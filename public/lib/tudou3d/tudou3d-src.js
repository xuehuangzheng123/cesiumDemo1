/*!
 * Tudou3D平台
 * 版本信息：v3.0.37, hash值: 34d827698ffa05d6594c
 * 编译日期：2022-12-26 14:25:59
 * 版权所有：Copyright by 土豆数据
 * 使用单位：土豆数据科技集团有限公司
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("tudou3d-cesium"), require("@turf/turf"));
	else if(typeof define === 'function' && define.amd)
		define("tudou3d", ["tudou3d-cesium", "@turf/turf"], factory);
	else if(typeof exports === 'object')
		exports["tudou3d"] = factory(require("tudou3d-cesium"), require("@turf/turf"));
	else
		root["tudou3d"] = factory(root["Cesium"], root["turf"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__19__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 108);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(17)["default"];

var assertThisInitialized = __webpack_require__(24);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(103);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return isBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSimpleType", function() { return isSimpleType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatNum", function() { return formatNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padLeft0", function() { return padLeft0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitWords", function() { return splitWords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trim", function() { return trim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrLength", function() { return getStrLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "template", function() { return template; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uuid", function() { return uuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTemplateHtml", function() { return getTemplateHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCesiumValue", function() { return getCesiumValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCesiumColor", function() { return getCesiumColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColorByStyle", function() { return getColorByStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAttrVal", function() { return getAttrVal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayRandomOne", function() { return getArrayRandomOne; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeArrayItem", function() { return removeArrayItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSymbolStyle", function() { return getSymbolStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geojsonToArcGIS", function() { return geojsonToArcGIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arcgisToGeoJSON", function() { return arcgisToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGeoJsonFeatures", function() { return getGeoJsonFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geoJsonToGraphics", function() { return geoJsonToGraphics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "featureToGraphic", function() { return featureToGraphic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "heightToZoom", function() { return heightToZoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlResource", function() { return getUrlResource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextImage", function() { return getTextImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCircleImage", function() { return getCircleImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadBase64Image", function() { return downloadBase64Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExplorerInfo", function() { return getExplorerInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webglreport", function() { return webglreport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webglerror", function() { return webglerror; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRequest", function() { return getRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRequestByName", function() { return getRequestByName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPCBroswer", function() { return isPCBroswer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alert", function() { return alert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "msg", function() { return msg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatDate", function() { return formatDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLangText", function() { return getLangText; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);
/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_turf_turf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _GraphicUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _terraformer_arcgis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);
/* harmony import */ var _map_core_addImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setImage", function() { return _map_core_addImage__WEBPACK_IMPORTED_MODULE_7__["b"]; });

/* harmony import */ var _PointTrans__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
/* harmony import */ var _const_Lang__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(28);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * 常用静态方法
 * @module Util
 */








/**
 * 判断对象是否为Number类型
 * @param {*} obj 对象
 * @returns {Boolean} 是否为Number类型
 */

function isNumber(obj) {
  return typeof obj == "number" && obj.constructor == Number;
}
/**
 * 判断对象是否为String类型
 * @param {*} obj 对象
 * @returns {Boolean} 是否为String类型
 */

function isString(obj) {
  return typeof obj == "string" && obj.constructor == String;
}
/**
 * 判断对象是否为Boolean类型
 * @param {*} obj 对象
 * @returns {Boolean} 是否为Boolean类型
 */

function isBoolean(obj) {
  return typeof obj == "boolean" && obj.constructor == Boolean;
}
/**
 * 判断对象是否为Object类型
 * @param {*} obj 对象
 * @returns {Boolean} 是否为Object类型
 */

function isObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
/**
 * 判断对象是否为简单类型（包括：String\Boolean\Number\Array）
 * @param {*} value 对象
 * @returns {Boolean} 是否为简单类型（包括：String\Boolean\Number\Array）
 */

function isSimpleType(value) {
  if (value == null || value == undefined) {
    return false;
  }

  if (isString(value) || isBoolean(value) || isNumber(value) || Array.isArray(value)) {
    return true;
  } else {
    return false;
  }
} //============字符串或值相关的处理============

/**
 * 格式化数字，返回指定小数位的数字
 *
 * @export
 * @param {Number} num 数字
 * @param {Int} [digits=0] 小数位数
 * @return {Number} 返回digits指定小数位的数字
 */

function formatNum(num) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var pow = Math.pow(10, digits);
  return Math.round(num * pow) / pow;
}
/**
 * 按指定长度,对数字进行补零，返回指定长度的字符串
 *
 * @export
 * @param {Number|String} numStr 数字对象,示例：1234
 * @param {Int} n 指定长度，示例：8
 * @return {String} 补零后的指定长度的字符串，示例：'00001234'
 */

function padLeft0(numStr, n) {
  numStr = String(numStr);
  var len = numStr.length;

  while (len < n) {
    numStr = "0" + numStr;
    len++;
  }

  return numStr;
}
/**
 * 根据空格分割字符串，并返回字符串数组（会自动去掉首位空格）
 *
 * @export
 * @param {String} str 字符串
 * @return {String[]} 分割后的字符串数组
 */

function splitWords(str) {
  return trim(str).split(/\s+/);
}
/**
 * 除去字符串首尾的空格
 *
 * @export
 * @param {String} str 字符串
 * @return {String} 除去首尾空格的字符串
 */

function trim(str) {
  if (!str) {
    return;
  }

  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
/**
 * 获取字符串长度，区分中文和英文
 *
 * @export
 * @param {String} str 字符串
 * @return {Number} 字符串长度
 */

function getStrLength(str) {
  if (!str) {
    return;
  }

  return str.replace(/[\u0391-\uFFE5]/g, "00").length;
} //popup的字符串模板

var templateRe = /\{ *([a-zA-Z0-9_\u4e00-\u9fa5]+) *\}/g;
/**
 * 根据数据和格式化字符串模板，返回字符串
 *
 * @export
 * @param {String} str 格式化字符串模版，属性字段为大括号，如 {name}
 * @param {Object} data 数据对象
 * @param {Boolean} toEmpty 是否将模板中未匹配项转为空值
 * @return {String} 返回字符串
 * @example
 *  var str = tudou3d.Util.template("<div>名称：{name}</div>", { name:"土豆数据", date:"2017-8-25"} );
 *  //str结果为 : "<div>名称：土豆数据</div>"
 */

function template(str, data, toEmpty) {
  if (str == null || !templateRe.test(str)) {
    return str;
  }

  return str.replace(templateRe, function (oldval, key, idx, all) {
    var value = data[key];

    if (!cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](value)) {
      return toEmpty ? "" : oldval;
    }

    if (typeof value == "function") {
      value = value(data);

      if (!cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](value)) {
        return toEmpty ? "" : oldval;
      }
    } else if (value.getValue && typeof value.getValue == "function") {
      value = value.getValue(cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());

      if (!cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](value)) {
        return toEmpty ? "" : oldval;
      }
    }

    return value;
  });
}
var CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
/**
 * 获取随机唯一uuid字符串,包含数字、大写字母、小写字母
 *
 * @export
 * @param {String} [prefix='M'] 前缀
 * @return {String} 字符串
 */

function uuid() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "M";
  var uuid = [];
  uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
  uuid[14] = "4";
  var r;

  for (var i = 0; i < 36; i++) {
    if (!uuid[i]) {
      r = 0 | Math.random() * 16;
      uuid[i] = CHARS[i == 19 ? r & 0x3 | 0x8 : r];
    }
  }

  return prefix + "-" + uuid.join("");
}
var callbackIndex = 0;
/**
 *获取Popup或Tooltip格式化Html字符串
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Object} options.attr 属性值
 * @param {String|Array|*} options.template 模版配置，支持：'all'、数组、字符串模板，当为数组时支持：
 * @param {String} options.template.field 字段名称
 * @param {String} options.template.name 显示的对应自定义名称 *
 * @param {String} [options.template.type] 默认为label文本，也可以支持：'button'按钮，'html' html内容。
 * @param {String} [options.template.callback] 当type为'button'按钮时，单击后触发的事件。
 * @param {String} [options.template.html] 当type为'html'时，对于拼接的html内容。 *
 * @param {String|Function} [options.template.format] 使用window上有效的格式化js方法名称或function回调方法，来格式化字符串值。
 * @param {String} [options.template.unit] 追加的计量单位值。
 *
 * @param {String} options.title 标题
 * @param {Boolean} [options.edit=false] 是否返回编辑输入框
 * @return {String}  Html字符串
 * @example
//template可以是'all' ，返回数据的全部属性信息
tiles3dLayer.bindPopup(function (event) {
  var attr = event.graphic.attr
  return tudou3d.Util.getTemplateHtml({ title: '桥梁', template: 'all', attr: attr })
})

//template可以是格式化字符串模板
var html = tudou3d.Util.getTemplateHtml({ title: '土豆项目', template:  "名称：{项目名称}<br />类型：{设施类型}<br />面积：{用地面积}亩<br />位置：{具体位置}", attr: item })

//可以是数组的template，按数组顺序构造，并转义字段名称
//
var html = tudou3d.Util.getTemplateHtml({
  title: '塔杆',
  template: [
    { field: 'roadName', name: '所属线路' },
    { field: 'towerId', name: '杆塔编号' },
    { field: '杆塔型号', name: '杆塔型号' },
    { field: '杆塔性质', name: '杆塔性质' },
    { field: '杆塔类型', name: '杆塔类型' },
    { field: '设计单位', name: '设计单位' },
    { field: 'height', name: '海拔高度' },
  ],
  attr: item,
})
 */

function getTemplateHtml(options) {
  var attr = options.attr;

  if (!attr) {
    return false;
  }

  var title = options.title;
  var isEdit = options.edit;
  var cfg = options.template;
  attr = getAttrVal(attr); //取值

  if (!cfg || cfg == "all") {
    //全部显示
    var countsok = 0;
    var inhtml = title ? '<div class="tudou-popup-titile">' + title + "</div>" : "";
    inhtml += '<div class="tudou-popup-content" >';

    for (var col in attr) {
      try {
        if (col == null || attr[col] == null) {
          continue;
        }

        if (col == "Shape" || col == "FID" || col == "OBJECTID" || col == "_definitionChanged" || col == "_propertyNames") {
          continue;
        } //不显示的字段


        if (col.substr(0, 1) == "_") {
          col = col.substring(1); //cesium 内部属性
        }

        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(attr[col]) == "object" && attr[col].hasOwnProperty && attr[col].hasOwnProperty("getValue")) {
          attr[col] = attr[col].getValue(cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());
        }

        if (typeof attr[col] == "function") {
          continue;
        }

        var showval = String.prototype.trim.call(String(attr[col] || ""));

        if (showval === "" || showval == "Null" || showval == "Unknown" || showval == "0") {
          continue;
        } //不显示空值，更美观友好


        inhtml += "<div><label>" + col + "</label>" + showval + "</div>";
        countsok++;
      } catch (e) {
        Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("getTemplateHtml:构造all时异常", e);
      }
    }

    inhtml += "</div>";

    if (countsok == 0) {
      return false;
    }

    return inhtml;
  } else if (Array.isArray(cfg)) {
    //数组
    var _countsok = 0;

    var _inhtml = title ? '<div class="tudou-popup-titile">' + title + "</div>" : '<div style="height: 10px;"></div>';

    _inhtml += '<div class="tudou-popup-content" >';

    for (var i = 0; i < cfg.length; i++) {
      var thisfield = cfg[i];

      if (thisfield == null) {
        continue;
      }

      var _col = thisfield.field;

      if (thisfield.type == "details" || thisfield.type == "button") {
        var _ret = function () {
          //详情等button按钮
          var onclickHtml = "";
          var callback = thisfield.callback;

          if (callback) {
            var funName = "_cache_getTemplateHtml_" + callbackIndex++;

            window[funName] = function () {
              eval(callback + "(" + JSON.stringify(attr) + ")");
            };

            onclickHtml = "onclick=\"".concat(funName, "();\"  ");
          }

          _inhtml += "<div style=\"text-align: center;padding: 2px 0;\">\n                            <button type=\"button\"  ".concat(onclickHtml, "\n                            data-type=\"").concat(_col, "\" class=\"btn btn-primary btn-sm tudou3d-popup-btn\" >").concat(thisfield.name || "查看详情", "</button>\n                        </div>");
          return "continue";
        }();

        if (_ret === "continue") continue;
      } else if (thisfield.type == "html") {
        _inhtml += "<div>" + thisfield.html + "</div>";
        continue;
      }

      if (!isEdit) {
        //非编辑状态隐藏空值
        if (_col == null || attr[_col] == null) {
          continue;
        }

        if (typeof attr[_col] == "function") {
          continue;
        }
      } //值


      var _showval = String.prototype.trim.call(attr[_col] || "");

      if (!isEdit) {
        //非编辑状态隐藏空值
        if (_showval == null || _showval === "" || _showval == "Null" || _showval == "Unknown" || _showval == "0" || _showval.length == 0) {
          continue;
        }
      }

      if (thisfield.format) {
        //使用外部 格式化js方法
        try {
          if (typeof thisfield.format == "function") {
            _showval = thisfield.format(_showval);
          } else {
            _showval = eval(thisfield.format + "(" + _showval + ")");
          }
        } catch (e) {
          Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("getTemplateHtml:格式化出错", thisfield);
        }
      }

      if (isEdit) {
        switch (thisfield.type) {
          default:
          case "string":
          case "number":
            _showval = "<input type=\"".concat(thisfield.type || "text", "\" class=\"tudou3d-popup-edititem\" style=\"width:").concat(options.width || 190, "px;\"\n                        data-type=\"").concat(_col, "\" value=\"").concat(_showval, "\" placeholder=\"\u8BF7\u8F93\u5165 ").concat(thisfield.name, "\"  />");
            break;

          case "textarea":
            _showval = "<textarea class=\"tudou3d-popup-edititem\" style=\"width:".concat(options.width || 190, "px;\"\n                        data-type=\"").concat(_col, "\"  placeholder=\"\u8BF7\u8F93\u5165 ").concat(thisfield.name, "\"  >").concat(_showval, "</textarea>");
            break;
        }
      }

      if (thisfield.unit) {
        _showval += thisfield.unit;
      }

      _inhtml += "<div><label>" + thisfield.name + "</label>" + _showval + "</div>";
      _countsok++;
    }

    _inhtml += "</div>";

    if (_countsok == 0) {
      return false;
    }

    return _inhtml;
  } else if (isObject(cfg)) {
    //对象,type区分逻辑
    switch (cfg.type) {
      default:
        break;

      case "iframe":
        {
          var _url = template(cfg.url, attr, true);

          var inhtml2 = '<iframe id="ifarm" src="' + _url + '"  style="width:' + (cfg.width || "300") + "px;height:" + (cfg.height || "300") + 'px;overflow:hidden;margin:0;" scrolling="no" frameborder="0" ></iframe>';
          return inhtml2;
        }

      case "javascript":
        {
          //回调方法
          var callbackFun = cfg.callback;
          return eval(callbackFun + "(" + JSON.stringify(attr) + ")");
        }
    }
  } else if (isString(cfg)) {
    //格式化字符串
    return template(cfg, attr, true);
  } else if (typeof cfg == "function") {
    return cfg(cfg, attr);
  }

  return false;
}
/**
 * 获取Cesium对象值的最终value值，
 * 因为cesium经常属性或绑定一层，通过本方法可以内部去判断是否有getValue或_value进行取最终value值。
 *
 * @export
 * @param {*} obj Cesium对象值
 * @param {Class} [ClasName=null] Cesium的类名，方便识别判断
 * @param {Class} [time= Cesium.JulianDate.now()] 如果具有时间属于时，取指定的时间的值
 * @return {*} 最终value值
 */

function getCesiumValue(obj, ClasName, time) {
  if (!obj) {
    return obj;
  }

  if (ClasName) {
    if (obj instanceof ClasName) {
      return obj;
    } else if (obj._value && obj._value instanceof ClasName) {
      return obj._value;
    }
  }

  if (typeof obj.getValue == "function") {
    return obj.getValue(time || cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());
  }

  return obj;
}
/**
 * 获取Cesium颜色对象
 * @param {String|Cesium.Color} color Cesium的类名，方便识别判断
 * @param {Cesium.Color} [defval] 默认值
 * @return {Cesium.Color} 颜色值
 */

function getCesiumColor(color, defval) {
  if (color) {
    if (isString(color)) {
      return cesium__WEBPACK_IMPORTED_MODULE_2__["Color"].fromCssColorString(color);
    } else {
      return color;
    }
  } else {
    return defval;
  }
}
/**
 * 根据配置信息获取Cesium颜色对象
 * @param {Object} style 配置信息
 * @param {String|Cesium.Color} style.color 颜色值
 * @param {Number} [style.opacity] 透明度
 * @param {Boolean} [style.randomColor] 是否随机色
 * @param {Cesium.Color} [defval=Cesium.Color.YELLOW] 默认值
 * @return {Cesium.Color} 颜色值
 */

function getColorByStyle(style) {
  var defval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cesium__WEBPACK_IMPORTED_MODULE_2__["Color"].YELLOW;
  var color;

  if (style.color) {
    if (isString(style.color)) {
      color = cesium__WEBPACK_IMPORTED_MODULE_2__["Color"].fromCssColorString(style.color);
    } else {
      color = style.color;
    }
  } else if (style.randomColor) {
    color = cesium__WEBPACK_IMPORTED_MODULE_2__["Color"].fromRandom({
      minimumRed: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.minimumRed, 0.0),
      maximumRed: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.maximumRed, 0.75),
      minimumGreen: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.minimumGreen, 0.0),
      maximumGreen: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.maximumGreen, 0.75),
      minimumBlue: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.minimumBlue, 0.0),
      maximumBlue: cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](style.maximumBlue, 0.75)
    });
  } else {
    color = defval;
  }

  if (!color) {
    return color;
  }

  if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](style.opacity)) {
    if (style.opacity < 0.0) {
      style.opacity = 0.0;
    } else if (style.opacity > 1.0) {
      style.opacity = 1.0;
    }

    color = color.withAlpha(Number(style.opacity));
  }

  return color;
}
/**
 * 取属性值，简化Cesium内的属性，去掉getValue等，取最简的键值对。
 * 方便popup、tooltip等构造方法使用
 *
 * @export
 * @param {*} attr Cesium内的属性对象
 * @param {Object} [options={}] 参数对象:
 * @param {Boolean} options.onlySimpleType 是否只获取简易类型的对象
 * @return {Object} 最简的键值对属性对象
 */

function getAttrVal(attr) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!attr) {
    return attr;
  }

  try {
    if (attr.getValue) {
      attr = attr.getValue(cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());
    }

    var newattr = {};

    if (attr._propertyNames && attr._propertyNames.length > 0) {
      var _iterator = _createForOfIteratorHelper(attr._propertyNames),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          var showval = getOneAttrValue(key, attr[key], options);

          if (showval == null) {
            continue;
          }

          newattr[key] = showval;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      for (var _key2 in attr) {
        var _showval2 = getOneAttrValue(_key2, attr[_key2], options);

        if (_showval2 == null) {
          continue;
        }

        newattr[_key2] = _showval2;
      }
    }

    return newattr;
  } catch (e) {
    Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("getAttrVal:出错了", e);
  }

  return attr;
} //内部方法

function getOneAttrValue(key, showval, options) {
  if (showval == null || showval === "" || showval === "Null" || showval === "Unknown") {
    return null;
  }

  if (showval.getValue && typeof showval.getValue == "function" && key != "material") {
    showval = showval.getValue(cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());
  }

  if (typeof showval == "function") {
    return null;
  }

  if (options.onlySimpleType) {
    if (showval instanceof cesium__WEBPACK_IMPORTED_MODULE_2__["Color"]) {
      return showval.toCssColorString();
    }

    if (!isSimpleType(showval)) {
      return null;
    }
  }

  return showval;
}
/**
 * 合并对象，对二级子属性为Object的对象也会进行融合。
 *
 * @export
 * @param {Object} [dest] 目标对象
 * @param {Object} sources 需要融入合并的对象
 * @return {Object} 融合后的对象
 */


function merge() {
  var dest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var i, j, len, src;

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }

  for (j = 0, len = sources.length; j < len; j++) {
    src = sources[j];

    for (i in src) {
      if (dest[i] && isObject(dest[i]) && !Array.isArray(dest[i])) {
        dest[i] = _objectSpread(_objectSpread({}, dest[i]), src[i]);
      } else {
        dest[i] = src[i];
      }
    }
  }

  return dest;
}
/**
 * 复制克隆对象
 *
 * @export
 * @param {Object} obj 原始对象
 * @param {String[]} [removeKeys = [] ] 不复制的属性名 数组
 * @param {Int} [level=5] 拷贝的层级最大深度,避免死循环
 * @return {Object} 克隆后的对象
 */

function clone(obj) {
  var removeKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;

  if (null == obj || "object" != _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(obj)) {
    return obj;
  } // Handle Date


  if (obj instanceof Date) {
    var copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  } // Handle Array


  if (Array.isArray(obj) && level >= 0) {
    var _copy = [];

    for (var i = 0, len = obj.length; i < len; ++i) {
      _copy[i] = clone(obj[i], removeKeys, level - 1);
    }

    return _copy;
  } // Handle Object


  if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(obj) == "object" && level >= 0) {
    try {
      var _copy2 = {};

      for (var attr in obj) {
        if (typeof attr == "function") {
          continue;
        }

        if (removeKeys.indexOf(attr) != -1) {
          continue;
        }

        if (obj.hasOwnProperty(attr)) {
          _copy2[attr] = clone(obj[attr], removeKeys, level - 1);
        }
      }

      return _copy2;
    } catch (e) {
      Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("clone:出错了", e);
    }
  }

  return obj;
}
/**
 * 随机获取数组中的一个元素
 *
 * @export
 * @param {Array} arr 数组
 * @return {*} 获取到的随机元素
 */

function getArrayRandomOne(arr) {
  var n = Math.floor(Math.random() * arr.length + 1) - 1;
  return arr[n];
}
/**
 * 移除数组中的指定对象
 *
 * @export
 * @param {Array} arr 数组
 * @param {*} val 需要移除的数组元素对象
 * @return {Boolean} 对象是否移除成功
 */

function removeArrayItem(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == val) {
      arr.splice(i, 1);
      return true;
    }
  }

  return false;
}
/**
 * 根据属性 和symbol配置 取style样式信息
 *
 * @param {Object} symbol symbol配置
 * @param {Object} symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {String} [symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 * @param {Object} [attr] 数据属性对象
 * @param {Object} [mergeStyle] 需要合并到styleOptions的默认Style样式
 * @return {Object} style样式
 *
 */

function getSymbolStyle(symbol, attr) {
  var mergeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!symbol) {
    return {};
  }

  var styleOpt = symbol.styleOptions ? _objectSpread(_objectSpread({}, mergeStyle), symbol.styleOptions) : _objectSpread({}, mergeStyle);

  if (symbol.styleField && attr) {
    //存在多个symbol，按styleField进行分类
    var styleFieldVal = attr[symbol.styleField];
    var styleOptField = symbol.styleFieldOptions[styleFieldVal];

    if (styleOptField != null) {
      styleOpt = _objectSpread(_objectSpread({}, styleOpt), styleOptField);
    }
  }

  if (attr) {
    for (var key in styleOpt) {
      styleOpt[key] = template(styleOpt[key], attr);
    }
  }

  if (typeof symbol.callback == "function") {
    //只是动态返回symbol的自定义的回调方法，返回style
    var _styleOptField = symbol.callback(attr, styleOpt);

    if (_styleOptField != null) {
      styleOpt = _objectSpread(_objectSpread({}, styleOpt), _styleOptField);
    }
  }

  return styleOpt;
}
/**
 * geojson格式 转 arcgis服务的json格式
 *
 * @param {Object} geojson geojson格式
 * @param {String} [idAttr='OBJECTID'] id字段名称
 * @return {Object} arcgis服务的json格式
 */

function geojsonToArcGIS(geojson, idAttr) {
  return Object(_terraformer_arcgis__WEBPACK_IMPORTED_MODULE_6__[/* geojsonToArcGIS */ "b"])(geojson, idAttr);
}
/**
 * arcgis服务的json格式 转 geojson格式
 *
 * @param {Object} arcgis arcgis服务的json格式
 * @param {String} [idAttr='OBJECTID'] id字段名称
 * @return {Object} geojson格式
 */

function arcgisToGeoJSON(arcgis, idAttr) {
  return Object(_terraformer_arcgis__WEBPACK_IMPORTED_MODULE_6__[/* arcgisToGeoJSON */ "a"])(arcgis, idAttr);
}
/**
 * 获取GeoJSON中的features数组集合（自动判断数据来源）
 *
 * @export
 * @param {Object} geojson geojson对象
 * @param {Object} [options={}] 控制参数
 * @param {Number} [options.buffer] 缓冲扩大的距离（单位：米）
 * @return {Object[]} features数组集合
 */

function getGeoJsonFeatures(geojson) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (geojson.geometryType && geojson.geometryType.indexOf("esri") != -1) {
    geojson = arcgisToGeoJSON(geojson);
  }

  var features;

  if (Array.isArray(geojson.features)) {
    features = geojson.features;
  } else if (Array.isArray(geojson)) {
    features = geojson;
  } else {
    features = [geojson];
  }

  if (options.buffer > 0) {
    var newFeatures = [];
    features.forEach(function (feature) {
      try {
        var _feature, _feature$geometry;

        if (((_feature = feature) === null || _feature === void 0 ? void 0 : (_feature$geometry = _feature.geometry) === null || _feature$geometry === void 0 ? void 0 : _feature$geometry.type) == "Polygon") {
          feature.geometry.coordinates[0].push(feature.geometry.coordinates[0][0]);
        }

        feature = Object(_turf_turf__WEBPACK_IMPORTED_MODULE_4__["buffer"])(feature, options.buffer, {
          units: "meters",
          steps: 64
        });
      } catch (e) {
        Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("getGeoJsonFeatures buffer:缓冲分析异常", e);
      }

      newFeatures.push(feature);
    });
    return newFeatures;
  }

  return features;
}
/**
 * GeoJSON 转为 Graphic构造参数数组（用于创建{@link BaseGraphic}）
 * style有3种方式控制: 1.传type及style参数；2.传symbol参数；3.数据本身的feature.properties.style；
 * 优先级为：1>2>3
 *
 * @export
 * @param {Object} geojson geojson对象
 * @param {Object} [options={}] 控制参数
 * @param {GraphicType} [option.type] 转为指定的类型
 * @param {Object} [options.style={}]  Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {Object} symbol symbol配置，与style二选一
 * @param {GraphicType} [symbol.type] 标识数据类型
 * @param {Boolean} [symbol.merge] 是否合并并覆盖json中已有的style，默认不合并，仅适用symbol配置。
 * @param {Object} symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {String} [symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 * @param {Number} [options.buffer] 缓冲扩大的距离（单位：米）
 * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857' （可以从 {@link http://epsg.io }查询）
 * @param {Boolean} [options.hasEdit] 当需要编辑时可以传true值,指定为Entity类型
 * @return {Object[]} Graphic构造参数数组（用于创建{@link BaseGraphic}）
 */

function geoJsonToGraphics(geojson) {
  var _geojson$crs, _geojson$crs$properti;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var features = getGeoJsonFeatures(geojson, options);

  if (geojson !== null && geojson !== void 0 && (_geojson$crs = geojson.crs) !== null && _geojson$crs !== void 0 && (_geojson$crs$properti = _geojson$crs.properties) !== null && _geojson$crs$properti !== void 0 && _geojson$crs$properti.name && !options.crs) {
    var crs = geojson.crs.properties.name;

    if (crs.indexOf("EPSG:") != -1) {
      options.crs = crs;
    }
  }

  var arrGraphis = [];

  for (var i = 0, len = features.length; i < len; i++) {
    var feature = features[i];
    var arr = featureToGraphic(feature, options);

    if (arr && arr.length > 0) {
      arrGraphis = arrGraphis.concat(arr);
    }
  }

  return arrGraphis;
}
/**
 * GeoJSON格式的Feature单个对象转为 Graphic构造参数（用于创建{@link BaseGraphic}）
 *
 * @export
 * @param {Object} feature geojson单个Feature对象
 * @param {Object} [options={}] 参数，包括：
 * @param {GraphicType} [options.type] 转为指定的类型
 * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857' （可以从 {@link http://epsg.io }查询）
 * @param {Object} [options.style={}]  Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {Boolean} [options.hasEdit] 当需要编辑时可以传true值,指定为Entity类型
 * @return {Object} Graphic构造参数（用于创建{@link BaseGraphic}）
 */

function featureToGraphic(feature) {
  var _feature$properties, _feature$properties2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var graphics = [];

  if (feature.type == "Topology") {
    for (var property in feature.objects) {
      if (feature.objects.hasOwnProperty(property)) {
        var featurenew = cesium__WEBPACK_IMPORTED_MODULE_2__["topojson"].feature(feature, feature.objects[property]);
        var layers = featureToGraphic(featurenew, options);

        if (layers && layers.length > 0) {
          graphics = graphics.concat(layers);
        }
      }
    }

    return graphics;
  }

  var geometry = feature.geometry,
      coords = geometry === null || geometry === void 0 ? void 0 : geometry.coordinates;

  if (!coords && !geometry) {
    return graphics;
  } //====== 类型 ======


  var graphicType;

  if (options.type) {
    graphicType = options.type;
  } else if (Object(_GraphicUtil__WEBPACK_IMPORTED_MODULE_5__["hasType"])(feature === null || feature === void 0 ? void 0 : (_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.type)) {
    graphicType = feature.properties.type;
  } //====== 处理属性 ======


  var attr = clone(feature === null || feature === void 0 ? void 0 : feature.properties, ["style"]) || {};

  if (attr && attr.type && attr.attr) {
    //兼容历史数据,V2内部标绘生产的geojson
    attr = attr.attr;
  } //====== 处理样式 ======


  var style = {};

  if (feature.properties) {
    //按geojson标准存储的一些样式转换处理
    //内置的 填充颜色等
    var marker = attr["marker-symbol"];

    if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](marker)) {
      style.image = marker;
      var outlineColor = attr["marker-color"];

      if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](outlineColor)) {
        style.outline = true;
        style.outlineColor = outlineColor;
      }
    } //内置的 填充颜色等


    var fill = attr.fill;

    if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](fill) && geometry.type != "LineString" && geometry.type != "MultiLineString") {
      style.color = fill;
      var opacity = attr["fill-opacity"];

      if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](opacity) && opacity !== 1.0) {
        style.opacity = opacity;
      } //内置的 线颜色等


      var stroke = attr.stroke;

      if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](stroke)) {
        style.outline = true;
        style.outlineColor = stroke;
        var width = attr["stroke-width"];

        if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](width)) {
          style.outlineWidth = width;
        }

        var _opacity = attr["stroke-opacity"];

        if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](_opacity) && _opacity !== 1.0) {
          style.outlineOpacity = _opacity;
        }
      }
    } else {
      //内置的 线颜色等
      var _stroke = attr.stroke;

      if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](_stroke)) {
        style.color = _stroke;
        var _width = attr["stroke-width"];

        if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](_width)) {
          style.width = _width;
        }

        var _opacity2 = attr["stroke-opacity"];

        if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](_opacity2) && _opacity2 !== 1.0) {
          style.opacity = _opacity2;
        }
      }
    }
  }

  if (options.style) {
    style = _objectSpread({}, options.style);
  } else if (isObject(feature === null || feature === void 0 ? void 0 : (_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.style)) {
    style = _objectSpread({}, feature.properties.style);
  } //图层有symbol配置时


  if (options.symbol) {
    if (typeof options.symbol == "function") {
      style = options.symbol(attr, style, feature) || style;

      if (style.type) {
        graphicType = style.type;
      }
    } else {
      graphicType = options.symbol.type || graphicType;
      style = getSymbolStyle(options.symbol, feature.properties || {}, options.symbol.merge ? style : {});
    }
  } //====== 按类型处理坐标和graphic ======


  var i, len;

  switch (geometry.type) {
    case "Point":
      {
        if (!graphicType || !Object(_GraphicUtil__WEBPACK_IMPORTED_MODULE_5__["isPointType"])(graphicType)) {
          graphicType = style.image ? "billboardP" : "pointP";

          if (options.hasEdit) {
            graphicType = style.image ? "billboard" : "point";
          }
        }

        var graphic = {
          type: graphicType,
          position: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4Trans"])(coords, options.crs),
          style: style,
          attr: attr
        };
        graphics.push(graphic);
        break;
      }

    case "MultiPoint":
      {
        if (!graphicType || !Object(_GraphicUtil__WEBPACK_IMPORTED_MODULE_5__["isPointType"])(graphicType)) {
          graphicType = style.image ? "billboardP" : "pointP";

          if (options.hasEdit) {
            graphicType = style.image ? "billboard" : "point";
          }
        }

        for (i = 0, len = coords.length; i < len; i++) {
          var _graphic = {
            type: graphicType,
            position: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4Trans"])(coords[i], options.crs),
            style: style,
            attr: attr
          };
          graphics.push(_graphic);
        }

        break;
      }

    case "LineString":
      {
        var _graphic2 = {
          type: graphicType || "polyline",
          positions: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4TransArr"])(coords, options.crs),
          style: style,
          attr: attr
        };
        graphics.push(_graphic2);
        break;
      }

    case "MultiLineString":
      {
        var maxPoly;
        var thisGraphics = [];

        for (i = 0, len = coords.length; i < len; i++) {
          var _graphic3 = {
            type: graphicType || "polyline",
            positions: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4TransArr"])(coords[i], options.crs),
            style: style,
            attr: attr
          };
          graphics.push(_graphic3);
          thisGraphics.push(_graphic3);

          if (!maxPoly || maxPoly.positions.length < _graphic3.positions.length) {
            maxPoly = _graphic3;
          }
        }

        if (maxPoly) {
          maxPoly.isMultiMax = true;

          if (style.label && !style.label.showAll) {
            for (i = 0, len = thisGraphics.length; i < len; i++) {
              var _graphic4 = thisGraphics[i];

              if (maxPoly == _graphic4) {
                continue;
              }

              _graphic4.style = _objectSpread({}, _graphic4.style); //clone

              delete _graphic4.style.label;
            }
          }
        }

        break;
      }

    case "Polygon":
      {
        if (!graphicType) {
          var _style$outlineStyle;

          graphicType = "polygonP";

          if (options.hasEdit) {
            graphicType = "polygon";
          } else if (style.outline && (style.outlineWidth > 1 || ((_style$outlineStyle = style.outlineStyle) === null || _style$outlineStyle === void 0 ? void 0 : _style$outlineStyle.width) > 1)) {
            graphicType = "polygon";
          }
        }

        var _graphic5 = {
          type: graphicType,
          positions: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4TransArr"])(coords.length == 1 ? coords[0] : coords, options.crs),
          style: style,
          attr: attr
        };
        graphics.push(_graphic5);
        break;
      }

    case "MultiPolygon":
      {
        if (!graphicType) {
          var _style$outlineStyle2;

          graphicType = "polygonP";

          if (options.hasEdit) {
            graphicType = "polygon";
          } else if (style.outline && (style.outlineWidth > 1 || ((_style$outlineStyle2 = style.outlineStyle) === null || _style$outlineStyle2 === void 0 ? void 0 : _style$outlineStyle2.width) > 1)) {
            graphicType = "polygon";
          }
        }

        var _maxPoly;

        var _thisGraphics = [];

        for (i = 0, len = coords.length; i < len; i++) {
          var thisCoor = coords[i];
          var _graphic6 = {
            type: graphicType,
            positions: Object(_PointTrans__WEBPACK_IMPORTED_MODULE_8__["proj4TransArr"])(thisCoor.length == 1 ? thisCoor[0] : thisCoor, options.crs),
            style: style,
            attr: attr
          };
          graphics.push(_graphic6);

          _thisGraphics.push(_graphic6);

          if (!_maxPoly || _maxPoly.positions.length < _graphic6.positions.length) {
            _maxPoly = _graphic6;
          }
        }

        if (_maxPoly) {
          _maxPoly.isMultiMax = true;

          if (style.label && !style.label.showAll) {
            for (i = 0, len = _thisGraphics.length; i < len; i++) {
              var _graphic7 = _thisGraphics[i];

              if (_maxPoly == _graphic7) {
                continue;
              }

              _graphic7.style = _objectSpread({}, _graphic7.style); //clone

              delete _graphic7.style.label;
            }
          }
        }

        break;
      }

    case "GeometryCollection":
      {
        for (var _i = 0, _len2 = geometry.geometries.length; _i < _len2; _i++) {
          var _layers = featureToGraphic({
            type: "Feature",
            geometry: geometry.geometries[_i],
            properties: feature.properties
          }, options);

          if (_layers && _layers.length > 0) {
            graphics = graphics.concat(_layers);
          }
        }

        break;
      }

    default:
      Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("Invalid GeoJSON object.", feature);
  }

  return graphics;
} //=======================

/**
 * 根据当前高度获取地图层级
 *
 * @export
 * @param {Number} altitude 高度值
 * @return {Int} 地图层级,通常为 0-21
 */

function heightToZoom(altitude) {
  var A = 40487.57;
  var B = 0.00007096758;
  var C = 91610.74;
  var D = -40467.74;
  return Math.round(D + (A - D) / (1 + Math.pow(altitude / C, B)));
}
/**
 * 根据图层的config的配置信息，自动加上代理等配置返回Resource对象
 *
 * @export
 * @param {Object} config 图层的配置信息
 * @param {String} config.url  url地址
 * @param {String} [config.proxy] 加载资源时要使用的代理服务url。
 * @param {Object} [config.templateValues] 一个对象，用于替换Url中的模板值的键/值对
 * @param {Object} [config.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
 * @param {Object} [config.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
 * @return {Cesium.Resource} Resource对象
 */

function getUrlResource(config) {
  var resource;

  if (config.url instanceof cesium__WEBPACK_IMPORTED_MODULE_2__["Resource"]) {
    var _resource = config.url;

    if (config.headers) {
      _resource.headers = config.headers;
    }

    if (config.proxy) {
      _resource.proxy = new cesium__WEBPACK_IMPORTED_MODULE_2__["DefaultProxy"](config.proxy);
    }

    if (config.templateValues) {
      _resource.setTemplateValues(config.templateValues);
    }

    if (config.queryParameters) {
      _resource.setQueryParameters(config.queryParameters);
    }

    return _resource;
  } else {
    if (config.templateValues) {
      config.url = template(config.url, config.templateValues);
    }

    resource = new cesium__WEBPACK_IMPORTED_MODULE_2__["Resource"]({
      url: config.url,
      queryParameters: config.queryParameters,
      templateValues: config.templateValues,
      headers: config.headers,
      proxy: config.proxy ? new cesium__WEBPACK_IMPORTED_MODULE_2__["DefaultProxy"](config.proxy) : null
    });
  }

  return resource;
}
/**
 * 文字转base64图片
 *
 * @export
 * @param {String} text 文字内容
 * @param {Object} [textStyle={}] 参数对象:
 * @param {String} [textStyle.font='10px sans-serif'] 使用的CSS字体。
 * @param {String} [textStyle.textBaseline='bottom'] 文本的基线。
 * @param {Boolean} [textStyle.fill=true] 是否填充文本。
 * @param {Boolean} [textStyle.stroke=false] 是否描边文本。
 * @param {Color} [textStyle.fillColor=Color.WHITE] 填充颜色。
 * @param {Color} [textStyle.strokeColor=Color.BLACK] 描边的颜色。
 * @param {Number} [textStyle.strokeWidth=1] 描边的宽度。
 * @param {Color} [textStyle.backgroundColor=Color.TRANSPARENT] 画布的背景色。
 * @param {Number} [textStyle.padding=0] 要在文本周围添加的填充的像素大小。
 * @returns {DOMString} base64图片对象，包含 data URI 的DOMString。
 */

function getTextImage(text, textStyle) {
  var canvas = cesium__WEBPACK_IMPORTED_MODULE_2__["writeTextToCanvas"](text, textStyle);
  return canvas ? canvas.toDataURL("image/png") : null;
}
var circleImage = {};
/**
 * 获取用于EntityCluster聚合的圆形图标对象
 *
 * @export
 * @param {Number} count 数字
 * @param {Object} [options={}] 参数对象:
 *
 * @param {Number} [options.radius=26] 圆形图标的整体半径大小（单位：像素）
 * @param {String} [options.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色
 * @param {Number} [options.opacity=0.5] 圆形图标的透明度
 *
 * @param {Number} [options.borderWidth=5] 圆形图标的边框宽度（单位：像素），0不显示
 * @param {String} [options.borderColor='rgba(110, 204, 57, 0.5)'] 圆形图标的边框背景颜色
 * @param {Number} [options.borderOpacity=0.6] 圆形图标边框的透明度
 *
 * @param {String} [options.fontColor='#ffffff'] 数字的颜色
 *
 * @returns {DOMString} base64图片对象，包含 data URI 的DOMString。
 */

function getCircleImage(count) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var inCircleRadius = cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](options.radius, 26);
  var outCircleRadius = inCircleRadius + cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](options.borderWidth, 5);
  var colorIn;
  var colorOut;

  if (options.color) {
    colorIn = options.color;
    colorOut = options.borderColor || colorIn;
  } else {
    var opacity = cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](options.opacity, 0.6);
    var borderOpacity = cesium__WEBPACK_IMPORTED_MODULE_2__["defaultValue"](options.borderOpacity, opacity * 0.8);

    if (count < 10) {
      colorIn = "rgba(110, 204, 57, " + opacity + ")";
      colorOut = "rgba(181, 226, 140, " + borderOpacity + ")";
    } else if (count < 100) {
      colorIn = "rgba(240, 194, 12,  " + opacity + ")";
      colorOut = "rgba(241, 211, 87, " + borderOpacity + ")";
    } else {
      colorIn = "rgba(241, 128, 23,  " + opacity + ")";
      colorOut = "rgba(253, 156, 115, " + borderOpacity + ")";
    }
  }

  var _key = "".concat(count, "_").concat(outCircleRadius, "_").concat(inCircleRadius, "_").concat(colorIn);

  if (!circleImage[_key]) {
    var thisSize = outCircleRadius * 2;
    var circleCanvas = document.createElement("canvas");
    circleCanvas.width = thisSize;
    circleCanvas.height = thisSize;
    var circleCtx = circleCanvas.getContext("2d");
    circleCtx.fillStyle = "#ffffff00";
    circleCtx.globalAlpha = 0.0;
    circleCtx.fillRect(0, 0, thisSize, thisSize); //圆形底色 (外圈)

    if (inCircleRadius != outCircleRadius) {
      circleCtx.globalAlpha = 1.0;
      circleCtx.beginPath();
      circleCtx.arc(outCircleRadius, outCircleRadius, outCircleRadius, 0, Math.PI * 2, true);
      circleCtx.closePath();
      circleCtx.fillStyle = colorOut;
      circleCtx.fill();
    } //圆形底色(内圈)


    circleCtx.globalAlpha = 1.0;
    circleCtx.beginPath();
    circleCtx.arc(outCircleRadius, outCircleRadius, inCircleRadius, 0, Math.PI * 2, true);
    circleCtx.closePath();
    circleCtx.fillStyle = colorIn;
    circleCtx.fill(); //数字文字

    circleCtx.font = options.font || inCircleRadius * 0.9 + "px bold normal"; // 设置字体

    circleCtx.fillStyle = options.fontColor || "#ffffff"; // 设置颜色

    circleCtx.textAlign = "center"; // 设置水平对齐方式

    circleCtx.textBaseline = "middle"; // 设置垂直对齐方式

    circleCtx.fillText(count, outCircleRadius, outCircleRadius); // 绘制文字（参数：要写的字，x坐标，y坐标）

    circleImage[_key] = circleCanvas.toDataURL("image/png");
  }

  return circleImage[_key];
}

function download(fileName, blob) {
  var aLink = document.createElement("a");
  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  document.body.appendChild(aLink);
  aLink.click();
  document.body.removeChild(aLink);
}

function base64Img2Blob(code) {
  var parts = code.split(";base64,");
  var contentType = parts[0].split(":")[1];
  var raw = window.atob(parts[1]);
  var rawLength = raw.length;
  var uInt8Array = new Uint8Array(rawLength);

  for (var i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }

  return new Blob([uInt8Array], {
    type: contentType
  });
}
/**
 *导出下载图片文件
 *
 * @export
 * @param {String} name 图片文件名称，不需要后缀名
 * @param {String} base64 图片内容，base64格式
 * @return {void}  无
 */


function downloadBase64Image(name, base64) {
  var blob = base64Img2Blob(base64);
  download(name + ".png", blob);
}
/**
 *导出下载文本文件
 *
 * @export
 * @param {String} fileName 文件完整名称，需要含后缀名
 * @param {String} string 文本内容
 * @return {void}  无
 */

function downloadFile(fileName, string) {
  var blob = new Blob([string]);
  download(fileName, blob);
}
/**
 * 获取浏览器类型及版本
 *
 * @export
 * @return {Object} 浏览器类型及版本,示例：{ type: 'Chrome', version: 71 }
 */

function getExplorerInfo() {
  var ver;
  var explorer = window.navigator.userAgent.toLowerCase(); //ie

  if (explorer.indexOf("msie") >= 0) {
    ver = Number(explorer.match(/msie ([\d]+)/)[1]);
    return {
      type: "IE",
      version: ver
    };
  } //firefox
  else if (explorer.indexOf("firefox") >= 0) {
    ver = Number(explorer.match(/firefox\/([\d]+)/)[1]);
    return {
      type: "Firefox",
      version: ver
    };
  } //Chrome
  else if (explorer.indexOf("chrome") >= 0) {
    ver = Number(explorer.match(/chrome\/([\d]+)/)[1]);
    return {
      type: "Chrome",
      version: ver
    };
  } //Opera
  else if (explorer.indexOf("opera") >= 0) {
    ver = Number(explorer.match(/opera.([\d]+)/)[1]);
    return {
      type: "Opera",
      version: ver
    };
  } //Safari
  else if (explorer.indexOf("Safari") >= 0) {
    ver = Number(explorer.match(/version\/([\d]+)/)[1]);
    return {
      type: "Safari",
      version: ver
    };
  }

  return {
    type: explorer,
    version: -1
  };
}
/**
 *检测当前浏览器是否支持WebGL
 *
 * @export
 * @return {Boolean} 是否支持WebGL
 */

function webglreport() {
  var exinfo = getExplorerInfo();

  if (exinfo.type == "IE" && exinfo.version < 11) {
    return false;
  }

  try {
    var glContext;
    var canvas = document.createElement("canvas");
    var requestWebgl2 = (typeof WebGL2RenderingContext === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(WebGL2RenderingContext)) != undefined;

    if (requestWebgl2) {
      glContext = canvas.getContext("webgl2") || canvas.getContext("experimental-webgl2") || undefined;
    }

    if (glContext == null) {
      glContext = canvas.getContext("webgl") || canvas.getContext("experimental-webgl") || undefined;
    }

    if (glContext == null) {
      return false;
    }
  } catch (e) {
    return false;
  }

  return true;
}
/**
 * 执行检测浏览器不支持webgl后的alert错误提示弹窗
 *
 * @export
 * @return {void}  无
 */

function webglerror() {
  var _window, _window$layer;

  if ((_window = window) !== null && _window !== void 0 && (_window$layer = _window.layer) !== null && _window$layer !== void 0 && _window$layer.open) {
    window.layer.open({
      type: 1,
      title: "当前浏览器不支持WebGL功能",
      closeBtn: 0,
      shadeClose: false,
      resize: false,
      area: ["530px", "170px"],
      //宽高
      content: '<div style="margin: 20px;color: #333;"><h3>系统检测到您使用的浏览器不支持WebGL功能！</h3>  <p>1、请您检查浏览器版本，安装使用最新版chrome、火狐或IE11以上浏览器！</p> <p>2、WebGL支持取决于GPU支持，请保证客户端电脑已安装显卡驱动程序！</p></div>'
    });
  } else {
    alert("系统检测到您使用的浏览器不支持WebGL功能");
  }
}
/**
 *获取当前页面的url中的?传入参数对象集合
 *
 * @export
 * @return {Object} 参数名与参数值的键值对
 */

function getRequest() {
  var url = location.search; //获取url中"?"符后的字串

  var theRequest = new Object();

  if (url.indexOf("?") != -1) {
    var str = url.substr(1);
    var strs = str.split("&");

    for (var i = 0; i < strs.length; i++) {
      theRequest[strs[i].split("=")[0]] = decodeURI(strs[i].split("=")[1]);
    }
  }

  return theRequest;
}
/**
 * 获取当前页面的url中的?传入的指定参数值
 *
 * @export
 * @param {String} name 指定参数名称
 * @return {String} 获取到的参数值
 */

function getRequestByName(name) {
  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
  var r = window.location.search.substr(1).match(reg);

  if (r != null) {
    return decodeURI(r[2]);
  }

  return null;
}
/**
 *当前是否是PC电脑浏览器。
 *
 * @export
 * @return {Boolean} 是否是PC电脑浏览器。
 */

function isPCBroswer() {
  var sUserAgent = navigator.userAgent.toLowerCase();
  var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
  var bIsIphoneOs = sUserAgent.match(/iphone/i) == "iphone";
  var bIsMidp = sUserAgent.match(/midp/i) == "midp";
  var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
  var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
  var bIsAndroid = sUserAgent.match(/android/i) == "android";
  var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
  var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";

  if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
    return false;
  } else {
    return true;
  }
}
/**
 * 执行alert弹窗
 *
 * @export
 * @param {String} msg 弹窗内的内容
 * @param {String} title 弹窗的标题
 * @return {void}  无
 */

function alert(msg, title) {
  if (window.haoutil && window.haoutil.alert) {
    //此方法需要引用haoutil
    window.haoutil.alert(msg, title);
  } else if (window.layer) {
    //此方法需要引用layer.js
    window.layer.alert(msg, {
      title: title || "提示",
      skin: "layui-layer-lan layer-tudou-dialog",
      closeBtn: 0,
      anim: 0
    });
  } else {
    window.alert(msg);
  }
}
/**
 * 执行msg提示窗
 *
 * @export
 * @param {String} msg 弹窗内的内容
 * @return {void}  无
 */

function msg(msg) {
  if (window.haoutil && window.haoutil.msg) {
    //此方法需要引用haoutil
    window.haoutil.msg(msg);
  } else if (window.toastr) {
    //此方法需要引用toastr
    window.toastr.info(msg);
  } else if (window.layer) {
    window.layer.msg(msg);
  } //此方法需要引用layer.js
  else {
    window.alert(msg);
  }
}
/**
 * 将 时间 转化为指定格式的字符串
 *
 * @export
 * @param {Date} date 时间
 * @param {String} fmt 格式模版，月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符; 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字).
 * @return {String} 指定格式的字符串
 * @example
 * tudou3d.Util.formatDate(date,"yyyy-MM-dd HH:mm:ss") ==> 2017-08-25 08:08:00
 * tudou3d.Util.formatDate(date,"yyyy-MM-dd HH:mm:ss.S") ==> 2017-08-25 08:08:00.423
 * tudou3d.Util.formatDate(date,"yyyy-M-d HH:mm:ss") ==> 2017-8-5 08:08:00
 */

function formatDate(date, fmt) {
  var o = {
    "M+": date.getMonth() + 1,
    //月份
    "d+": date.getDate(),
    //日
    "h+": date.getHours() % 12 == 0 ? 12 : date.getHours() % 12,
    //小时
    "H+": date.getHours(),
    //小时
    "m+": date.getMinutes(),
    //分
    "s+": date.getSeconds(),
    //秒
    "q+": Math.floor((date.getMonth() + 3) / 3),
    //季度
    S: date.getMilliseconds() //毫秒

  };

  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
  }

  for (var k in o) {
    if (new RegExp("(" + k + ")").test(fmt)) {
      fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    }
  }

  return fmt;
}
/**
 * 根据设置的lang参数，获取当前key对应语言的文本内容。
 * @param {String} key  文本key
 * @param {LangType} langType  使用的语言
 * @return {void}  lang参数指定的对应文本内容
 */

function getLangText(key) {
  var langType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var thisItem = _const_Lang__WEBPACK_IMPORTED_MODULE_9__[/* Lang */ "a"][key];

  if (!thisItem) {
    return key;
  }

  var langText = thisItem[langType] || key;
  return langText;
}

/***/ }),
/* 7 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransFun", function() { return getTransFun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionValue", function() { return getPositionValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxHeight", function() { return getMaxHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMinHeight", function() { return getMinHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPositionsHeight", function() { return addPositionsHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPositionsHeight", function() { return setPositionsHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurfaceHeight", function() { return getSurfaceHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurface3DTilesHeight", function() { return getSurface3DTilesHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurfaceTerrainHeight", function() { return getSurfaceTerrainHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurfacePosition", function() { return getSurfacePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentMousePosition", function() { return getCurrentMousePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMidpoint", function() { return getMidpoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRepeatPoint", function() { return isRepeatPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotateCenterPoint", function() { return getRotateCenterPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOnLinePointByLen", function() { return getOnLinePointByLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslationPosition", function() { return getTranslationPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionByHprAndOffset", function() { return getPositionByHprAndOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionByDirectionAndLen", function() { return getPositionByDirectionAndLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionByHprAndLen", function() { return getPositionByHprAndLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRayEarthPosition", function() { return getRayEarthPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRayEarthPositionByMatrix", function() { return getRayEarthPositionByMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend2Earth", function() { return extend2Earth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeadingPitchRollByOrientation", function() { return getHeadingPitchRollByOrientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeadingPitchRollByMatrix", function() { return getHeadingPitchRollByMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeadingPitchRollForLine", function() { return getHeadingPitchRollForLine; });
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _map_core_MapUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var _PointTrans__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);
/* harmony import */ var _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13);
/**
 * 单个坐标或位置矩阵相关的处理 静态方法
 * @module PointUtil
 */







/**
 * 获取PointTrans中对应的坐标转换方法
 * srcCoordType 转 dstCoordType 对应的方法名称
 *
 * @param {ChinaCRS} srcCoordType 原始的坐标系
 * @param {ChinaCRS} dstCoordType 转换后的坐标系
 * @return {Function} PointTrans中对应的坐标转换方法
 */

function getTransFun(srcCoordType, dstCoordType) {
  if (!srcCoordType || !dstCoordType) {
    return false;
  }

  srcCoordType = crsName2FunName(srcCoordType);
  dstCoordType = crsName2FunName(dstCoordType);

  if (dstCoordType == srcCoordType) {
    return false;
  }

  var funname = srcCoordType + "2" + dstCoordType;

  if (!_PointTrans__WEBPACK_IMPORTED_MODULE_5__[funname]) {
    return false;
  }

  return _PointTrans__WEBPACK_IMPORTED_MODULE_5__[funname];
}

function crsName2FunName(crsName) {
  switch (crsName) {
    default:
    case _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_4__[/* ChinaCRS */ "a"].WGS84:
      return "wgs";

    case _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_4__[/* ChinaCRS */ "a"].GCJ02:
      return "gcj";

    case _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_4__[/* ChinaCRS */ "a"].BAIDU:
      return "bd";
  }
}
/**
 * 获取position的最终value值，
 * 因为cesium经常属性或绑定一层，通过该方法可以内部去判断是否有getValue或_value进行取最终value值。
 *
 * @export
 * @param {Cesium.XXXPositionProperty|Cesium.Cartesian3|*} position 各种位置属性对象
 * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] 指定的时间值
 * @return {Cesium.Cartesian3} 具体的Cartesian3对象坐标值
 */


function getPositionValue(position, time) {
  if (!position) {
    return position;
  }

  var _position;

  if (position instanceof cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]) {
    _position = position;
  } else if (position._value && position._value instanceof cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]) {
    _position = position._value;
  } else if (typeof position.getValue == "function") {
    _position = position.getValue(time || cesium__WEBPACK_IMPORTED_MODULE_0__["JulianDate"].now());
  }

  return _position;
}
/**
 * 获取 坐标数组 中 最高高程值
 *
 * @export
 * @param {Cartesian3[]} positions 笛卡尔坐标数组
 * @param {Number} [defaultVal=0] 默认高程值
 * @return {Number} 最高高程值
 */

function getMaxHeight(positions) {
  var defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (positions == null || positions.length == 0) {
    return defaultVal;
  }

  var maxHeight = defaultVal;

  for (var i = 0; i < positions.length; i++) {
    var tempCarto = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions[i]);

    if (i == 0) {
      maxHeight = tempCarto.height;
    }

    if (tempCarto.height > maxHeight) {
      maxHeight = tempCarto.height;
    }
  }

  return Object(_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(maxHeight, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_6__[/* LatLngPoint */ "a"].FormatAltLength);
}
/**
 * 获取 坐标数组 中 最低高程值
 *
 * @export
 * @param {Cartesian3[]} positions 笛卡尔坐标数组
 * @param {Number} [defaultVal=0] 默认高程值
 * @return {Number} 最低高程值
 */

function getMinHeight(positions) {
  var defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (positions == null || positions.length == 0) {
    return defaultVal;
  }

  var minHeight = defaultVal;

  for (var i = 0; i < positions.length; i++) {
    var tempCarto = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions[i]);

    if (i == 0) {
      minHeight = tempCarto.height;
    }

    if (tempCarto.height < minHeight) {
      minHeight = tempCarto.height;
    }
  }

  return Object(_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(minHeight, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_6__[/* LatLngPoint */ "a"].FormatAltLength);
}
/**
 * 对坐标（或坐标数组）增加 指定的海拔高度值
 *
 * @export
 * @param {Cartesian3|Cartesian3[]} positions 笛卡尔坐标数组
 * @param {number} [addHeight=0] 增加的海拔高度值
 * @return {Cartesian3|Cartesian3[]} 增加高度后的坐标（或坐标数组）
 */

function addPositionsHeight(positions) {
  var addHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  addHeight = Number(addHeight);

  if (isNaN(addHeight) || addHeight == 0) {
    return positions;
  }

  if (Array.isArray(positions)) {
    var arr = [];

    for (var i = 0, len = positions.length; i < len; i++) {
      var car = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions[i]);
      var point = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(car.longitude, car.latitude, car.height + addHeight);
      arr.push(point);
    }

    return arr;
  } else {
    var _car = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions);

    return cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(_car.longitude, _car.latitude, _car.height + addHeight);
  }
}
/**
 * 对坐标（或坐标数组）赋值修改为 指定的海拔高度值
 *
 * @export
 * @param {Cartesian3|Cartesian3[]} positions 笛卡尔坐标数组
 * @param {number} [height=0] 增加的海拔高度值
 * @return {Cartesian3|Cartesian3[]} 增加高度后的坐标（或坐标数组）
 */

function setPositionsHeight(positions) {
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!positions) {
    return positions;
  }

  if (Array.isArray(positions)) {
    var arr = [];

    for (var i = 0, len = positions.length; i < len; i++) {
      var car = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions[i]);
      var point = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(car.longitude, car.latitude, height);
      arr.push(point);
    }

    return arr;
  } else {
    var _car2 = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(positions);

    return cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(_car2.longitude, _car2.latitude, height);
  }
}
/**
 * 异步计算贴地(或贴模型)高度完成 的回调方法
 * @callback getSurfaceHeight_callback
 * @param {Number|null} newHeight 计算完成的贴地(或贴模型)高度值
 * @param {Cesium.Cartographic} cartOld  原始点坐标对应的Cartographic经纬度值（弧度值）
 */

/**
 * 获取 坐标 的 贴地(或贴模型)高度
 *
 * @export
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} position 坐标
 * @param {Object} [options={}] 参数对象:
 * @param {Boolean} options.asyn  是否进行异步精确计算
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {getSurfaceHeight_callback} options.callback  异步计算高度完成后 的回调方法
 * @return {Number|void} 仅 asyn:false 时返回高度值
 *
 * @example
 * var position = graphic.position
 * position = tudou3d.PointUtil.getSurfaceHeight(map.scene, position, {
 *    asyn: true,     //是否异步求准确高度
 *    has3dtiles: true,   //是否先求贴模型上（无模型时改为false，提高效率）
 *    callback: function (newHeight, cartOld) {
 *       console.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))
 *       var positionNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
 *       graphic.position =positionNew
 *    }
 * });
 *
 */

function getSurfaceHeight(scene, position) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!position) {
    return position;
  }

  if (scene && scene.scene) {
    scene = scene.scene;
  } //是否在3ditiles上面


  var _has3dtiles = cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](options.has3dtiles, cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](Object(_map_core_MapUtil__WEBPACK_IMPORTED_MODULE_1__[/* pick3DTileset */ "e"])(scene, position)));

  if (_has3dtiles) {
    //求贴模型的高度
    return getSurface3DTilesHeight(scene, position, options);
  } else {
    //求贴地形高度
    return getSurfaceTerrainHeight(scene, position, options);
  }
}
/**
 * 获取 坐标 的 贴3dtiles模型高度
 *
 * @export
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} position 坐标
 * @param {Object} [options={}] 参数对象:
 * @param {Boolean} options.asyn  是否进行异步精确计算
 * @param {Object[]} [options.objectsToExclude=null]  排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {getSurfaceHeight_callback} options.callback  异步计算高度完成后 的回调方法
 * @return {Number|void} 仅 asyn:false 时返回高度值
 */

function getSurface3DTilesHeight(scene, position) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  //原始的Cartographic坐标
  options.cartographic = options.cartographic || cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(position);
  var carto = options.cartographic;
  var callback = options.callback; //是否异步求精确高度

  if (options.asyn) {
    scene.clampToHeightMostDetailed([position], options.objectsToExclude, 0.2).then(function (clampedPositions) {
      var clampedPt = clampedPositions[0];

      if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](clampedPt)) {
        var cartiles = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(clampedPt);
        var heightTiles = cartiles.height;

        if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](heightTiles) && heightTiles > -1000) {
          if (callback) {
            callback(heightTiles, cartiles);
          }

          return;
        }
      } //说明没在模型上，继续求地形上的高度


      getSurfaceTerrainHeight(scene, position, options);
    });
  } else {
    //取贴模型高度
    var heightTiles = scene.sampleHeight(carto, options.objectsToExclude, 0.2);

    if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](heightTiles) && heightTiles > -1000) {
      if (callback) {
        callback(heightTiles, carto);
      }

      return heightTiles;
    }
  }

  return 0; //表示取值失败
}
/**
 * 获取 坐标 的 贴地高度
 *
 * @export
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} position 坐标
 * @param {Object} [options={}] 参数对象:
 * @param {Boolean} options.asyn  是否进行异步精确计算
 * @param {getSurfaceHeight_callback} options.callback  异步计算高度完成后 的回调方法
 * @return {Number|void} 仅 asyn:false 时返回高度值
 *
 * @example
 * var position = entity.position.getValue();
 * position = tudou3d.PointUtil.getSurfaceTerrainHeight(map.scene, position, {
 *    asyn: true,     //是否异步求准确高度
 *    callback: function (newHeight, cartOld) {
 *       if (newHeight == null) return;
 *       console.log("地面海拔：" + newHeight.toFixed(2))
 *    }
 * });
 *
 */

function getSurfaceTerrainHeight(scene, position) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  //原始的Cartographic坐标
  var carto = options.cartographic || cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(position);
  var callback = options.callback;

  var _hasTerrain = Boolean(scene.terrainProvider._layers); //是否有地形


  if (!_hasTerrain) {
    //不存在地形，直接返回
    if (callback) {
      callback(carto.height, carto);
    }

    return carto.height;
  } //是否异步求精确高度


  if (options.asyn) {
    //赵西洋 Cesium.when切换为promise   20220805
    var promise = cesium__WEBPACK_IMPORTED_MODULE_0__["sampleTerrainMostDetailed"](scene.terrainProvider, [carto]);
    promise.then(function (samples) {
      // Cesium.when(Cesium.sampleTerrainMostDetailed(scene.terrainProvider, [carto]), function (samples) {
      var clampedCart = samples[0];
      var heightTerrain;

      if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](clampedCart) && cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](clampedCart.height)) {
        heightTerrain = clampedCart.height;
      } else {
        heightTerrain = scene.globe.getHeight(carto);
      }

      if (callback) {
        callback(heightTerrain, carto);
      }
    });
  } else {
    var heightTerrain = scene.globe.getHeight(carto);

    if (heightTerrain && heightTerrain > -1000) {
      if (callback) {
        callback(heightTerrain, carto);
      }

      return heightTerrain;
    } else {
      return carto.height;
    }
  }

  return 0; //表示取值失败
}
/**
 * 计算 贴地(或贴模型)高度 坐标
 * （非精确计算，根据当前加载的地形和模型数据情况有关）
 *
 * @export
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} position 坐标
 * @param {Object} [options={}] 参数对象，具有以下属性:
 * @param {Boolean} [options.relativeHeight=fasle]  是否在地形上侧的高度，在对象具备Cesium.HeightReference.RELATIVE_TO_GROUND时，可以设置为ture
 * @param {Number} [options.maxHeight] 可以限定最高高度，当计算的结果大于maxHeight时，原样返回，可以屏蔽计算误差的数据。
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，
 * @return {Cesium.Cartesian3} 贴地坐标
 */

function getSurfacePosition(scene, position) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!position) {
    return position;
  }

  var carto = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(position);
  var height = getSurfaceHeight(scene, position, options);

  if (height != 0 || cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](options.maxHeight) && height <= options.maxHeight) {
    if (options.relativeHeight) {
      //Cesium.HeightReference.RELATIVE_TO_GROUND时
      height += carto.height;
    }

    var positionNew = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(carto.longitude, carto.latitude, height);
    return positionNew;
  }

  return position;
}

function hasPickedModel(pickedObject, noPickEntity) {
  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject.id)) {
    //entity
    var entity = pickedObject.id;

    if (entity._noMousePick) {
      return entity;
    } //排除标识不拾取的对象


    if (noPickEntity && entity == noPickEntity) {
      return entity;
    }
  }

  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject.primitive)) {
    //primitive
    var primitive = pickedObject.primitive;

    if (primitive._noMousePick) {
      return primitive;
    } //排除标识不拾取的对象


    if (noPickEntity && primitive == noPickEntity) {
      return primitive;
    }
  }

  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject.tileset)) {
    //tileset
    var tileset = pickedObject.tileset;

    if (tileset._noMousePick) {
      return tileset;
    } //排除标识不拾取的对象


    if (noPickEntity && tileset == noPickEntity) {
      return tileset;
    }
  }

  return null;
}
/**
 * 获取 屏幕XY坐标 对应的 笛卡尔三维坐标
 *
 * @export
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian2} position 屏幕XY坐标（如鼠标所在位置)
 * @param {*} noPickEntity 排除的不拾取矢量对象，主要用于绘制中，排除对自己本身的拾取
 * @return {Cesium.Cartesian3}  笛卡尔三维坐标
 *
 *
 * @example
 *
 * //Cesium原生鼠标单击事件
 * var handler = new Cesium.ScreenSpaceEventHandler(map.scene.canvas);
 * handler.setInputAction(function (event) {
 *   var cartesian = tudou3d.PointUtil.getCurrentMousePosition(map.scene, event.position);
 *   //继续写其他代码
 * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
 */


function getCurrentMousePosition(scene, position, noPickEntity) {
  var cartesian; //在模型上提取坐标

  var pickedObject;

  try {
    pickedObject = scene.pick(position, 5, 5);
  } catch (e) {
    Object(_Log__WEBPACK_IMPORTED_MODULE_3__["logWarn"])("getCurrentMousePosition: scene.pick 拾取时异常", e);
  }

  if (scene.pickPositionSupported && cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject)) {
    //pickPositionSupported :判断是否支持深度拾取,不支持时无法进行鼠标交互绘制
    var pcEntity = hasPickedModel(pickedObject, noPickEntity);

    if (pcEntity) {
      if (pcEntity.billboard || pcEntity.point || pcEntity.label) {
        return getPositionValue(pcEntity.position);
      }

      if (pcEntity.show) {
        pcEntity.show = false; //先隐藏被排除的noPickEntity对象

        cartesian = getCurrentMousePosition(scene, position, noPickEntity);
        pcEntity.show = true; //还原被排除的noPickEntity对象

        if (cartesian) {
          return cartesian;
        } // else {
        //   logWarn("getCurrentMousePosition: 拾取到被排除的矢量对象", noPickEntity);
        // }

      }

      if (scene.onlyPickModelPosition) {
        //只取模型上的时候
        return scene.pickPosition(position);
      }
    } else {
      cartesian = scene.pickPosition(position);

      if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](cartesian)) {
        var cartographic = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(cartesian);

        if (cartographic.height >= 0) {
          return cartesian;
        } //不是entity时，支持3dtiles地下


        if (!cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject.id) && cartographic.height >= -5000) {
          return cartesian;
        } // logInfo('scene.pickPosition 拾取模型时 高度值异常：' + cartographic.height)

      }
    }
  } //超图s3m数据拾取


  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](cesium__WEBPACK_IMPORTED_MODULE_0__["S3MTilesLayer"])) {
    cartesian = scene.pickPosition(position);

    if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](cartesian)) {
      return cartesian;
    }
  } //onlyPickModelPosition是在 Map 中定义的对外属性
  //通过 map.onlyPickModelPosition 进行修改


  if (scene.onlyPickModelPosition) {
    //只取模型上的时候，不继续读取了
    return cartesian;
  } //1. globe.pick的结果相对稳定准确，不论地形深度检测开启与否，不论加载的是默认地形还是别的地形数据；
  //2. scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。
  //注意点： 1. globe.pick只能求交地形； 2. scene.pickPosition不仅可以求交地形，还可以求交除地形以外其他所有写深度的物体。
  //提取鼠标点的地理坐标


  if (scene.mode == cesium__WEBPACK_IMPORTED_MODULE_0__["SceneMode"].SCENE3D) {
    //三维模式下
    var pickRay = scene.camera.getPickRay(position);
    cartesian = scene.globe.pick(pickRay, scene);
  } else {
    //二维模式下
    cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
  }

  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](cartesian) && scene.camera.positionCartographic.height < 10000) {
    var _cartographic = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(cartesian);

    if (_cartographic.height < -5000) {
      return null; //屏蔽无效值
    }
  }

  return cartesian;
}
/**
 * 求2点的中间点（贴地表）
 *
 * @export
 * @param {Cesium.Cartesian3} mpt1 点1坐标
 * @param {Cesium.Cartesian3} mpt2 点2坐标
 * @return {Cesium.Cartesian3} 2个点是否为重复的点
 */

function getMidpoint(mpt1, mpt2) {
  if (!mpt2 || !mpt1) {
    return undefined;
  }

  var startPosition = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(mpt1);
  var endPosition = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(mpt2);
  var height = (startPosition.height + endPosition.height) / 2;
  var mc = new cesium__WEBPACK_IMPORTED_MODULE_0__["EllipsoidGeodesic"](startPosition, endPosition).interpolateUsingFraction(0.5);
  return cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromRadians(mc.longitude, mc.latitude, height);
}
/**
 * 判断2个点是否为重复的点，比如标绘中的双击会偶尔产生2个重复点
 *
 * @export
 * @param {Cesium.Cartesian3} mpt1 点1坐标
 * @param {Cesium.Cartesian3} mpt2 点2坐标
 * @return {Boolean} 2个点是否为重复的点
 */

function isRepeatPoint(mpt1, mpt2) {
  if (!mpt2 || !mpt1) {
    return false;
  }

  if (Math.abs(mpt1.x - mpt2.x) < 0.1 && Math.abs(mpt1.y - mpt2.y) < 0.1 && Math.abs(mpt1.z - mpt2.z) < 0.1) {
    return true;
  } else {
    return false;
  }
}
/**
 * 获取 点point1 绕 点center 的地面法向量 旋转顺时针angle角度 后的 新坐标
 *
 * @export
 * @param {Cesium.Cartesian3} center 中心点坐标
 * @param {Cesium.Cartesian3} point1 点坐标
 * @param {Number} angle 旋转角度,顺时针方向 0-360度
 * @return {Cesium.Cartesian3} 计算得到的新坐标
 */

function getRotateCenterPoint(center, point1, angle) {
  // 计算center的地面法向量
  var chicB = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(center);
  chicB.height = 0;
  var dB = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].toCartesian(chicB);
  var normaB = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].subtract(dB, center, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  normaB = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].normalize(normaB, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]()); // 构造基于center的法向量旋转90度的矩阵

  var Q = cesium__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].fromAxisAngle(normaB, cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toRadians(angle));
  var m3 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(Q);
  var m4 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(m3); // 计算point1点相对center点的坐标A1

  var A1 = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].subtract(point1, center, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]()); //对A1应用旋转矩阵

  var p = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(m4, A1, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]()); // 新点的坐标

  var pointNew = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].add(p, center, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  return pointNew;
}
/**
 * 求 p1指向p2方向线上，距离p1或p2指定长度的 新的点
 *
 * @export
 * @param {Cesium.Cartesian3} p1 起点坐标
 * @param {Cesium.Cartesian3} p2 终点坐标
 * @param {Number} len  指定的距离，addBS为false时：len为距离起点p1的距离，addBS为true时：len为距离终点p2的距离
 * @param {Boolean} [addBS=false]  标识len的参考目标
 * @return {Cesium.Cartesian3}  计算得到的新坐标
 */

function getOnLinePointByLen(p1, p2, len, addBS) {
  var mtx4 = cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].eastNorthUpToFixedFrame(p1);
  var mtx4_inverser = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].inverse(mtx4, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]());
  p1 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(mtx4_inverser, p1, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  p2 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(mtx4_inverser, p2, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  var substrct = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].subtract(p2, p1, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  var dis = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].distance(p1, p2);
  var scale = len / dis; //求比例

  if (addBS) {
    scale += 1;
  }

  var newP = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].multiplyByScalar(substrct, scale, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  newP = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(mtx4, newP, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  return newP;
}
/**
 * 获取点的offest平移矩阵后点,
 * 已经弃用，建议用 getPositionByHprAndOffset 方法
 *
 * @export
 * @param {Cesium.Cartesian3} position  中心点坐标
 * @param {Cesium.Cartesian3|Object} offest 偏移值
 * @param {Number} offest.x X轴方向偏移值,单位：米
 * @param {Number} offest.y Y轴方向偏移值,单位：米
 * @param {Number} offest.z Z轴方向偏移值,单位：米
 * @param {Number} degree 方向，0-360度
 * @param {String} [type='z'] 轴方向，可选值：'x' 、 'y' 、 'z'
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @return {Cesium.Cartesian3} 计算得到的新坐标
 */

function getTranslationPosition(position, offest, degree, type, fixedFrameTransform) {
  fixedFrameTransform = fixedFrameTransform || cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].eastNorthUpToFixedFrame;
  var rotate = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toRadians(-cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](degree, 0)); //转成弧度

  type = (type || "z").toUpperCase();
  var _normal = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]["UNIT_" + type];
  var quaternion = cesium__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].fromAxisAngle(_normal, rotate); //quaternion为围绕这个z轴旋转d度的四元数

  var rotateMatrix3 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(quaternion); //rotateMatrix3为根据四元数求得的旋转矩阵

  var pointCartesian3 = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"](cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](offest.x, 0), cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](offest.y, 0), cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](offest.z, 0)); //point的局部坐标

  var rotateTranslationMatrix4 = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(rotateMatrix3, cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].ZERO); //rotateTranslationMatrix4为旋转加平移的4x4变换矩阵，这里平移为(0,0,0)，故填个Cesium.Cartesian3.ZERO

  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByTranslation(rotateTranslationMatrix4, pointCartesian3, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4  X  pointCartesian3

  var originPositionCartesian3 = cesium__WEBPACK_IMPORTED_MODULE_0__["Ellipsoid"].WGS84.cartographicToCartesian(cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(position)); //得到局部坐标原点的全局坐标

  var originPositionTransform = fixedFrameTransform(originPositionCartesian3); //m1为局部坐标的z轴垂直于地表，局部坐标的y轴指向正北的4x4变换矩阵

  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyTransformation(originPositionTransform, rotateTranslationMatrix4, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4 X originPositionTransform

  var pointCartesian = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]();
  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].getTranslation(rotateTranslationMatrix4, pointCartesian); //根据最终变换矩阵m得到p2

  return pointCartesian;
}
/**
 * 根据 坐标位置、hpr方向、偏移距离，计算目标点坐标
 *
 * @export
 * @param {Cesium.Cartesian3} position 坐标位置
 * @param {Cesium.Cartesian3} offest 偏移距离值, xyz值的单位：米
 * @param {Cesium.HeadingPitchRoll} hpr 方向值
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @return {Cesium.Cartesian3} 目标点坐标
 */

function getPositionByHprAndOffset(position, offest, hpr, ellipsoid, fixedFrameTransform) {
  if (!hpr) {
    hpr = new cesium__WEBPACK_IMPORTED_MODULE_0__["HeadingPitchRoll"]();
  }

  var orientation = cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].headingPitchRollQuaternion(position, hpr, ellipsoid, fixedFrameTransform);
  var matrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(orientation, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]()), position, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]());
  var result = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(matrix, offest, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  return result;
}
/**
 * 根据观察点的方向角度和距离，计算目标点坐标
 *
 * @export
 * @param {Cesium.Cartesian3} position 观察点坐标
 * @param {Number} angle 方向角度 (正东方向为0,顺时针到360度)
 * @param {Number} radius 半径距离
 * @return {Cesium.Cartesian3} 目标点坐标
 */

function getPositionByDirectionAndLen(position, angle, radius) {
  var matrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].eastNorthUpToFixedFrame(position); //旋转

  var mz = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromRotationZ(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toRadians(360 - (angle || 0)));
  var rotationZ = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(mz);
  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiply(matrix, rotationZ, matrix);
  var result = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(matrix, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"](radius, 0, 0), new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  return result;
}
/**
 * 根据观察点的hpr方向和距离，计算目标点坐标
 *
 * @export
 * @param {Cesium.Cartesian3} position 观察点坐标
 * @param {Cesium.HeadingPitchRoll} hpr 方向值
 * @param {Number} radiusZ 半径距离
 * @return {Cesium.Cartesian3} 目标点坐标
 */

function getPositionByHprAndLen(position, hpr, radiusZ) {
  var orientation = cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].headingPitchRollQuaternion(position, hpr);
  var matrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(orientation, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]()), position, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]());
  var result = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(matrix, new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"](0, 0, -radiusZ), new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]());
  return result;
}
/**
 *  按观察点坐标和orientation方向，求观察点射向地球与地球的交点
 *
 * @export
 * @param {Cesium.Cartesian3} position 观察点坐标
 * @param {Cesium.HeadingPitchRoll|Cesium.Quaternion} orientation HeadingPitchRoll方向 或 四元数实例
 * @param {Boolean} reverse 是否翻转射线方向
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @return {Cesium.Cartesian3} 射线与地球的交点
 */

function getRayEarthPosition(position, orientation, reverse, ellipsoid) {
  if (orientation instanceof cesium__WEBPACK_IMPORTED_MODULE_0__["HeadingPitchRoll"]) {
    orientation = cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].headingPitchRollQuaternion(position, orientation);
  }

  var matrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(orientation, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]()), position, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]());
  return getRayEarthPositionByMatrix(matrix, reverse, ellipsoid);
}
/**
 *  按转换矩阵，求观察点射向地球与地球的交点
 *
 * @export
 * @param {Cesium.Matrix4} matrix 转换矩阵
 * @param {Boolean} reverse 是否翻转射线方向
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @return {Cesium.Cartesian3} 射线与地球的交点
 */

function getRayEarthPositionByMatrix(matrix, reverse, ellipsoid) {
  var scratchWC = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]();
  var scratchRay = new cesium__WEBPACK_IMPORTED_MODULE_0__["Ray"]();
  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(matrix, cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].ZERO, scratchWC);
  scratchWC.clone(scratchRay.origin);
  var bottomCenter = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"](0, 0, reverse ? -100 : 100);
  var groundPosition = extend2Earth(bottomCenter, matrix, scratchRay, ellipsoid);
  return groundPosition;
} //求地球交点【内部】

function extend2Earth(positionLC, matrix, ray, ellipsoid) {
  ellipsoid = ellipsoid ? ellipsoid : cesium__WEBPACK_IMPORTED_MODULE_0__["Ellipsoid"].WGS84;
  var scratchWC = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]();
  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(matrix, positionLC, scratchWC); //取延长线与地球相交的点

  cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].subtract(scratchWC, ray.origin, ray.direction);
  cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].normalize(ray.direction, ray.direction); //Get the first intersection point of a ray and an ellipsoid.

  var intersection = cesium__WEBPACK_IMPORTED_MODULE_0__["IntersectionTests"].rayEllipsoid(ray, ellipsoid);
  var point = null;

  if (intersection) {
    point = cesium__WEBPACK_IMPORTED_MODULE_0__["Ray"].getPoint(ray, intersection.start);
  }

  if (point) {
    try {
      var scratchCartographic2 = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"]();
      cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(point, null, scratchCartographic2);
    } catch (e) {
      return null;
    }
  }

  return point;
}
/**
 * 根据 position位置 和 orientation四元数实例 求 Heading Pitch Roll方向
 *
 * @export
 * @param {Cesium.Cartesian3} position 位置坐标
 * @param {Cesium.Quaternion} orientation 四元数实例
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
 */

function getHeadingPitchRollByOrientation(position, orientation, ellipsoid, fixedFrameTransform) {
  if (!cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](orientation) || !cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](position)) {
    return new cesium__WEBPACK_IMPORTED_MODULE_0__["HeadingPitchRoll"]();
  }

  var matrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].fromQuaternion(orientation, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]()), position, new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]());
  var hpr = getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform);
  return hpr;
}
/**
 * 根据matrix转换矩阵 求 Heading Pitch Roll角度
 *
 * @export
 * @param {Cesium.Matrix4} matrix 转换矩阵
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @param {Cesium.HeadingPitchRoll} [result] 可以先实例化返回的 Heading Pitch Roll角度对象
 * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll角度
 */

function getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform, result) {
  return cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].fixedFrameToHeadingPitchRoll(matrix, ellipsoid, fixedFrameTransform, result);
}
/**
 * 求 localStart点 到 localEnd点的 Heading Pitch Roll方向
 *
 * @export
 * @param {Cesium.Cartesian3} localStart 起点坐标
 * @param {Cesium.Cartesian3} localEnd 终点坐标
 * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
 */

function getHeadingPitchRollForLine(localStart, localEnd, ellipsoid, fixedFrameTransform) {
  ellipsoid = ellipsoid || cesium__WEBPACK_IMPORTED_MODULE_0__["Ellipsoid"].WGS84;
  var cartesian3 = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]();
  var matrix4Scratch2 = new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
  var rotationScratch = new cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
  var velocity = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].normalize(cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].subtract(localEnd, localStart, cartesian3), cartesian3);
  cesium__WEBPACK_IMPORTED_MODULE_0__["Transforms"].rotationMatrixFromPositionVelocity(localStart, velocity, ellipsoid, rotationScratch);
  var modelMatrix = cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].fromRotationTranslation(rotationScratch, localStart, matrix4Scratch2);
  cesium__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyTransformation(modelMatrix, cesium__WEBPACK_IMPORTED_MODULE_0__["Axis"].Z_UP_TO_X_UP, modelMatrix);
  var hpr = getHeadingPitchRollByMatrix(modelMatrix, ellipsoid, fixedFrameTransform);
  return hpr;
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasInfo", function() { return hasInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasWarn", function() { return hasWarn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasError", function() { return hasError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logInfo", function() { return logInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logWarn", function() { return logWarn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logError", function() { return logError; });
/**
 * SDK内部统一调用console.* 打印日志的控制类，在外部可以按需开启和关闭。
 * @module Log
 */
var _hasInfo = true;
var _hasWarn = true;
var _hasError = true;
/**
 * 是否 console.log 打印普通日志信息，可以按需关闭或开启
 *
 * @export
 * @param {Boolean} val 是否打印
 * @return {void}  无
 */

function hasInfo(val) {
  _hasInfo = val;
}
/**
 * 是否 console.warn 打印警告日志信息，可以按需关闭或开启，但不建议关闭
 *
 * @export
 * @param {Boolean} val 是否打印
 * @return {void}  无
 */

function hasWarn(val) {
  _hasInfo = val;
}
/**
 * 是否 console.error 打印错误日志信息，可以按需关闭或开启，但不建议关闭
 *
 * @export
 * @param {Boolean} val 是否打印
 * @return {void}  无
 */

function hasError(val) {
  _hasError = val;
}
/**
 * console.log 打印普通日志信息,方便开发调试
 *
 * @export
 * @param {String|Object} sources 打印的日志内容
 * @return {void}  无
 */

function logInfo() {
  var _console;

  if (!_hasInfo) {
    return;
  } // eslint-disable-next-line no-console


  (_console = console).log.apply(_console, arguments);
}
/**
 * console.warn 打印警告日志信息,方便开发调试
 *
 * @export
 * @param {String|Object} sources 打印的警告日志内容
 * @return {void}  无
 */

function logWarn() {
  var _console2;

  if (!_hasWarn) {
    return;
  } // eslint-disable-next-line no-console


  (_console2 = console).warn.apply(_console2, arguments);
}
/**
 * console.warn 打印错误日志信息,方便开发调试定位问题
 *
 * @export
 * @param {String|Object} sources 打印的错误日志内容
 * @return {void}  无
 */

function logError() {
  var _console3;

  if (!_hasError) {
    return;
  } // eslint-disable-next-line no-console


  (_console3 = console).error.apply(_console3, arguments);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(35);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasType", function() { return hasType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPointType", function() { return isPointType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClass", function() { return getClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromDraw", function() { return fromDraw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEntity", function() { return fromEntity; });
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _const_GraphicType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/**
 * 矢量数据 相关静态方法
 * @module GraphicUtil
 */


 //矢量数据集合（按类型）

var GraphicClass = {};
/**
 * 是否有指定类型矢量对象
 * @param {String} type 矢量数据类型
 * @returns {Boolean} 是否有指定类型
 */

function hasType(type) {
  if (GraphicClass[type]) {
    return true;
  } else {
    return false;
  }
}
/**
 * 判断该类型是否点状对象
 * @param {String} type 矢量数据类型
 * @returns {Boolean} 是否点状对象类型
 */

function isPointType(type) {
  if (GraphicClass[type] && GraphicClass[type].isPoint) {
    return true;
  } else {
    return false;
  }
}
/**
 * 注册矢量数据类
 *
 * @export
 * @param {String} type 矢量数据类型
 * @param {BaseGraphic} graphicClass 矢量数据类
 * @return {void}  无
 */

function register(type, graphicClass) {
  if (GraphicClass[type]) {
    Object(_util_Log__WEBPACK_IMPORTED_MODULE_1__["logError"])("register Graphic: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"), graphicClass);
  }

  _const_GraphicType__WEBPACK_IMPORTED_MODULE_2__[/* GraphicType */ "a"][type] = type;
  GraphicClass[type] = graphicClass; // console.log(`${type}，{@link ${graphicClass.name} }`)

  graphicClass.type = type; //静态属性

  graphicClass.prototype._type = type; //对象属性
}
/**
 * 根据 矢量数据类型 获取 矢量数据类
 * @param {String} type 矢量数据类型
 * @returns {BaseGraphic|undefined} 矢量数据类
 */

function getClass(type) {
  if (GraphicClass[type]) {
    return GraphicClass[type];
  } else {
    Object(_util_Log__WEBPACK_IMPORTED_MODULE_1__["logWarn"])("getClass:未找到该类型对应的处理类", type);
    return null;
  }
}
/**
 * 根据类型和参数 创建Graphic工厂方法
 *
 * @export
 * @param {Object} type 数据类型
 * @param {Object} options 构造参数， 按type支持{@link GraphicType}类的构造方法参数
 * @return {BaseGraphic} 创建完成的矢量数据对象
 */

function create(type, options) {
  var ThisGraphic = getClass(type);

  if (!ThisGraphic) {
    return;
  }

  var graphic = new ThisGraphic(options);
  return graphic;
}
/**
 * 通过标绘  创建Graphic工厂方法
 *
 * @export
 * @param {GraphicLayer} layer 图层对象
 * @param {Object} options Graphic构造参数,包含：
 * @param {GraphicType} options.type 类型
 * @param {Object} [options.其他] 按type支持{@link GraphicType}类的构造方法参数
 * @return {BaseGraphic} 创建完成的矢量数据对象
 */

function fromDraw(layer, options) {
  if (!options.type) {
    Object(_util_Log__WEBPACK_IMPORTED_MODULE_1__["logError"])("fromDraw:需要传入指定绘制的type类型！");
    return;
  }

  var ThisGraphic = getClass(options.type);

  if (!ThisGraphic || !ThisGraphic.fromDraw) {
    Object(_util_Log__WEBPACK_IMPORTED_MODULE_1__["logInfo"])("对象不支持标绘", ThisGraphic);
    return;
  }

  var graphic = ThisGraphic.fromDraw(layer, options);
  return graphic;
}
/**
 * 根据cesium的entity生成Graphic的工厂方法
 *
 * @export
 * @param {Cesium.Entity} entity cesium的entity对象
 * @param {Object} options Graphic构造参数,包含：
 * @param {GraphicType} options.type 类型
 * @param {Object} options.style 样式,按{@link GraphicType}对应的类的style配置
 * @param {Object} [options.attr=null] 属性
 * @return {BaseEntity} 创建完成的矢量数据对象
 */

function fromEntity(entity, options) {
  var type = getEntityTypeName(entity);
  options.type = type;
  var ThisGraphic = getClass(type);

  if (!ThisGraphic || !ThisGraphic.fromEntity) {
    Object(_util_Log__WEBPACK_IMPORTED_MODULE_1__["logInfo"])("对象不支持entity转换", ThisGraphic);
    return;
  }

  var graphic = ThisGraphic.fromEntity(entity, options);
  return graphic;
}

function getEntityTypeName(entity) {
  if (entity.type) {
    return entity.type;
  }

  if (entity.polygon) {
    return "polygon";
  }

  if (entity.rectangle) {
    return "rectangle";
  }

  if (entity.ellipse) {
    return "circle";
  }

  if (entity.polylineVolume) {
    return "polylineVolume";
  }

  if (entity.corridor) {
    return "corridor";
  }

  if (entity.wall) {
    return "wall";
  }

  if (entity.polyline) {
    return "polyline";
  }

  if (entity.ellipsoid) {
    return "ellipsoid";
  }

  if (entity.cylinder) {
    return "cylinder";
  }

  if (entity.plane) {
    return "plane";
  }

  if (entity.box) {
    return "box";
  }

  if (entity.billboard) {
    return "billboard";
  }

  if (entity.point) {
    return "point";
  }

  if (entity.model) {
    return "model";
  }

  if (entity.label) {
    return "label";
  }

  return null;
}

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClass", function() { return getClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "converOptions", function() { return converOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerImageryProvider", function() { return registerImageryProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getProviderClass", function() { return getProviderClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createImageryProvider", function() { return createImageryProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageryProviderViewModels", function() { return getImageryProviderViewModels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNoTerrainProvider", function() { return getNoTerrainProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerTerrainProvider", function() { return registerTerrainProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTerrainProviderClass", function() { return getTerrainProviderClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTerrainProvider", function() { return createTerrainProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTerrainProviderViewModels", function() { return getTerrainProviderViewModels; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _const_LayerType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _const_CRS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _layer_tileLayer_crs_GCJMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39);
/* harmony import */ var _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18);


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * 图层相关 静态方法
 * @module LayerUtil
 */







 //图层集合（按类型）

var LayerClass = {};
/**
 * 注册图层类
 *
 * @export
 * @param {String} type 图层类型
 * @param {BaseLayer} layerClass 图层类
 * @return {void}  无
 */

function register(type, layerClass) {
  if (LayerClass[type]) {
    Object(_Log__WEBPACK_IMPORTED_MODULE_5__["logError"])("register: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"), layerClass);
  }

  _const_LayerType__WEBPACK_IMPORTED_MODULE_2__[/* LayerType */ "a"][type] = type;
  LayerClass[type] = layerClass;
  layerClass.type = type; //静态属性

  layerClass.prototype._type = type; //对象属性
}
/**
 * 根据 图层类型 获取 图层类
 * @param {LayerType} type 图层类型
 * @returns {BaseLayer|undefined} 图层类
 */

function getClass(type) {
  return LayerClass[type];
}
/**
 * 创建图层工厂方法
 *
 * @export
 * @param {Object} options 图层参数，包括：
 * @param {LayerType} options.type 图层类型
 * @param {Object} options.其他 具体见各{@link LayerType}对应的图层类的构造方法参数
 * @param {Object} [templateValues={}] url模版
 * @return {BaseLayer} 创建完成的图层对象
 */

function create(options, templateValues) {
  var ThisLayer = getClass(options.type);

  if (ThisLayer) {
    if (templateValues) {
      options.templateValues = templateValues;
    }

    var layer = new ThisLayer(options);
    return layer;
  } else {
    Object(_Log__WEBPACK_IMPORTED_MODULE_5__["logWarn"])("配置中的图层未处理", options);
  }
} //转换图层配置参数

function converOptions(options) {
  var optionsNew = {}; //预处理参数

  for (var key in options) {
    var value = options[key];

    if (value == null) {
      continue;
    }

    switch (key) {
      default:
        //直接赋值
        optionsNew[key] = value;
        break;

      case "crs":
        value = (value + "").toUpperCase();

        if (value == _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG4326 || value == "4326" || value == "EPSG4326") {
          optionsNew.crs = _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG4326;
          optionsNew.tilingScheme = new cesium__WEBPACK_IMPORTED_MODULE_1__["GeographicTilingScheme"]({
            numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 2,
            numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
          });
        } else if (value == _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG4490 || value == "4490" || value == "EPSG4490") {
          optionsNew.crs = _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG4490;
          optionsNew.tilingScheme = new cesium__WEBPACK_IMPORTED_MODULE_1__["GeographicTilingScheme"]({
            numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 2,
            numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
          });
        } else {
          optionsNew.crs = _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG3857;
          optionsNew.tilingScheme = new cesium__WEBPACK_IMPORTED_MODULE_1__["WebMercatorTilingScheme"]({
            numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 1,
            numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
          });
        }

        break;

      case "chinaCRS":
        {
          if (options.mapChinaCRS != options.chinaCRS) {
            optionsNew.tilingScheme = new _layer_tileLayer_crs_GCJMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_7__[/* GCJMercatorTilingScheme */ "a"]({
              mapChinaCRS: options.mapChinaCRS || _const_ChinaCRS__WEBPACK_IMPORTED_MODULE_8__[/* ChinaCRS */ "a"].WGS84,
              chinaCRS: options.chinaCRS,
              numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 1,
              numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
            });
          }
        }
        break;

      case "rectangle":
        if (cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](value) && cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](value.xmin) && cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](value.xmax) && cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](value.ymin) && cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](value.ymax)) {
          optionsNew.rectangle = cesium__WEBPACK_IMPORTED_MODULE_1__["Rectangle"].fromDegrees(value.xmin, value.ymin, value.xmax, value.ymax);
        } else {
          optionsNew.rectangle = value;
        }

        break;

      case "bbox":
        optionsNew.rectangle = cesium__WEBPACK_IMPORTED_MODULE_1__["Rectangle"].fromDegrees(value[0], value[1], value[2], value[3]); //[xmin,ymin,xmax,ymax]

        break;
    }
  }

  optionsNew.crs = cesium__WEBPACK_IMPORTED_MODULE_1__["defaultValue"](optionsNew.crs, _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG3857); //4490坐标系z值是+1的

  if (optionsNew.crs == _const_CRS__WEBPACK_IMPORTED_MODULE_4__[/* CRS */ "a"].EPSG4490 && optionsNew.url) {
    optionsNew.url = optionsNew.url.replace(new RegExp("{z}", "gm"), "{z4490}");
    optionsNew.url = optionsNew.url.replace(new RegExp("{arc_z}", "gm"), "{arc_z4490}");
    optionsNew.url = optionsNew.url.replace(new RegExp("{arc_Z}", "gm"), "{arc_Z4490}");
  }

  if (optionsNew.url) {
    optionsNew.url = Object(_Util__WEBPACK_IMPORTED_MODULE_6__["getUrlResource"])(optionsNew);
  }

  return optionsNew;
} //瓦片图层ImageryProvider（按类型）

var ImageryProviderClass = {};
/**
 * 注册ImageryProvider类
 *
 * @export
 * @param {String} type Provider类型
 * @param {*} layerClass  ImageryProvider类
 * @return {void}  无
 *
 * @function
 */

function registerImageryProvider(type, layerClass) {
  if (ImageryProviderClass[type]) {
    Object(_Log__WEBPACK_IMPORTED_MODULE_5__["logError"])("registerImageryProvider: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"));
  }

  ImageryProviderClass[type] = layerClass;
}
function getProviderClass(type) {
  return ImageryProviderClass[type];
}
/**
 * 创建地图底图ImageryProvider的工厂方法
 *
 * @param {Object} options Provider参数，具体见各Provider类的构造方法参数说明
 * @return {*} ImageryProvider类
 *
 * @function
 */

function createImageryProvider(options) {
  var ThisLayerProvider = getProviderClass(options.type);

  if (ThisLayerProvider) {
    var layer = new ThisLayerProvider(options);
    layer.options = options; //绑定记录下

    return layer;
  } else {
    Object(_Log__WEBPACK_IMPORTED_MODULE_5__["logWarn"])("createLayer：存在未识别的图层", options);
  }
}
/**
 * 获取baseLayerPicker使用的绑定图层列表配置，
 * 用于将config.json的配置basemaps数据转换为imageryProviderViewModels
 *
 * @export
 * @param {Object[]} arrLayer basemaps配置
 * @return {Object} 转换后的 imageryProviderViewModels数组 和 显示图层的index(selectedIndex)
 */

function getImageryProviderViewModels(arrLayer) {
  var providerViewModels = [];
  var selectedIndex = -1;
  window._temp_createImageryProvider = createImageryProvider;

  for (var i = 0; i < arrLayer.length; i++) {
    var item = arrLayer[i];

    if (item.type == "group" && item.layers == null) {
      continue;
    }

    if (item.show) {
      selectedIndex = providerViewModels.length;
    }

    var funstr = "\n    window._temp_tudou_basemaps".concat(i, " = function () {\n        var item = ").concat(JSON.stringify(item), ";\n        if (item.type == \"group\") {\n            var arrVec = [];\n            for (var index = 0; index < item.layers.length; index++) {\n                var temp = window._temp_createImageryProvider(item.layers[index]);\n                if (temp == null) continue;\n                arrVec.push(temp);\n            }\n            return arrVec;\n        }\n        else {\n            return window._temp_createImageryProvider(item);\n        }\n    }");
    eval(funstr);
    var imgModel = new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: item.name || "未命名",
      tooltip: item.name || "未命名",
      iconUrl: item.icon || "",
      category: item.category || "",
      creationFunction: eval("window._temp_tudou_basemaps" + i)
    });
    providerViewModels.push(imgModel);
  }

  return {
    imageryProviderViewModels: providerViewModels,
    selectedIndex: selectedIndex
  };
}

var _ellipsoid = new cesium__WEBPACK_IMPORTED_MODULE_1__["EllipsoidTerrainProvider"]({
  ellipsoid: cesium__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84
});
/**
 * 创建 无地形的 标准椭球体对象
 *
 * @export
 * @return {Cesium.EllipsoidTerrainProvider} 无地形 标准椭球体对象
 */


function getNoTerrainProvider() {
  return _ellipsoid;
} //地形图层Provider（按类型）

var TerrainProviderClass = {};
/**
 * 注册TerrainProvider类
 *
 * @export
 * @param {String} type Provider类型
 * @param {*} layerClass  TerrainProvider类
 * @return {void}  无
 *
 * @function
 */

function registerTerrainProvider(type, layerClass) {
  if (TerrainProviderClass[type]) {
    Object(_Log__WEBPACK_IMPORTED_MODULE_5__["logError"])("registerTerrainProvider: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"));
  }

  TerrainProviderClass[type] = layerClass;
}
function getTerrainProviderClass(type) {
  return TerrainProviderClass[type];
}
/**
 * 创建地形对象的工厂方法
 *
 * @export
 * @param {Object} options 地形参数
 * @param {TerrainType} options.type 地形类型
 * @param {String|Cesium.Resource} options.url 地形服务地址
 * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
 * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
 * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
 * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
 *
 * @param {Boolean} [options.requestVertexNormals=true] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
 * @param {Boolean} [options.requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
 * @param {Boolean} [options.requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
 * @param {Object} [templateValues={}] url模版
 * @return {Cesium.CesiumTerrainProvider} 地形对象
 */

function createTerrainProvider(options, templateValues) {
  options = options || {
    type: _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].ION
  };
  options.type = options.type || _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].XYZ; //坡度需要为true

  options.requestVertexNormals = cesium__WEBPACK_IMPORTED_MODULE_1__["defaultValue"](options.requestVertexNormals, true);

  if (templateValues) {
    options.templateValues = templateValues;
  }

  var terrainProvider;

  switch (options.type) {
    default:
      {
        var ThisLayerProvider = getTerrainProviderClass(options.type);
        terrainProvider = new ThisLayerProvider(options);
      }
      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].XYZ:
      //默认是自定义的
      if (cesium__WEBPACK_IMPORTED_MODULE_1__["defined"](cesium__WEBPACK_IMPORTED_MODULE_1__["S3MTilesLayer"])) {
        terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["CesiumTerrainProvider"](options); //超图库不能传Resource参数
      } else {
        terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["CesiumTerrainProvider"](_objectSpread(_objectSpread({}, options), {}, {
          url: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["getUrlResource"])(options)
        }));
      }

      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].NONE:
    case "ellipsoid":
      //别名
      terrainProvider = _ellipsoid;
      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].ION:
      //cesium官方在线的
      terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["CesiumTerrainProvider"]({
        url: cesium__WEBPACK_IMPORTED_MODULE_1__["IonResource"].fromAssetId(1),
        requestWaterMask: options.requestWaterMask,
        requestVertexNormals: options.requestVertexNormals
      });
      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].GEE: //谷歌地球企业服务

    case "google":
      //别名
      terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["GoogleEarthEnterpriseTerrainProvider"](_objectSpread(_objectSpread({}, options), {}, {
        metadata: new cesium__WEBPACK_IMPORTED_MODULE_1__["GoogleEarthEnterpriseMetadata"](_objectSpread(_objectSpread({}, options), {}, {
          url: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["getUrlResource"])(options)
        }))
      }));
      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].ARCGIS:
      //ArcGIS地形服务
      terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["ArcGISTiledElevationTerrainProvider"](_objectSpread(_objectSpread({}, options), {}, {
        url: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["getUrlResource"])(options)
      }));
      break;

    case _const_TerrainType__WEBPACK_IMPORTED_MODULE_3__[/* TerrainType */ "a"].VR:
      terrainProvider = new cesium__WEBPACK_IMPORTED_MODULE_1__["VRTheWorldTerrainProvider"](_objectSpread(_objectSpread({}, options), {}, {
        url: Object(_Util__WEBPACK_IMPORTED_MODULE_6__["getUrlResource"])(options)
      }));
      break;
  }

  return terrainProvider;
}
/**
 * 获取baseLayerPicker使用的绑定地形列表
 * @param {Object} options 地形参数,同{@link createTerrainProvider}方法参数
 * @export
 * @return {Cesium.ProviderViewModel[]} 地形列表
 */

function getTerrainProviderViewModels(options) {
  if (options) {
    return [new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: "无地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/Ellipsoid.png"),
      tooltip: "WGS84标准椭球，即 EPSG:4326",
      category: "",
      creationFunction: function creationFunction() {
        return getNoTerrainProvider();
      }
    }), new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: options.name || "有地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
      tooltip: options.tooltip || "提供的高精度的DEM地形服务",
      category: "",
      creationFunction: function creationFunction() {
        return createTerrainProvider(options);
      }
    })];
  } else {
    return [new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: "无地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/Ellipsoid.png"),
      tooltip: "WGS84标准椭球，即 EPSG:4326",
      category: "",
      creationFunction: function creationFunction() {
        return getNoTerrainProvider();
      }
    }), new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: "Mar3D 中国地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
      tooltip: "Mar3D提供的12.5米精度的中国地形",
      category: "",
      creationFunction: function creationFunction() {
        return createTerrainProvider({
          url: "//data.mars3d.cn/terrain"
        });
      }
    }), new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: "Ion 全球地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
      tooltip: "Cesium官方Ion提供的高分辨率全球地形",
      category: "",
      creationFunction: function creationFunction() {
        return createTerrainProvider({
          type: "ion"
        });
      }
    }), new cesium__WEBPACK_IMPORTED_MODULE_1__["ProviderViewModel"]({
      name: "ArcGIS 全球地形",
      iconUrl: cesium__WEBPACK_IMPORTED_MODULE_1__["buildModuleUrl"]("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
      tooltip: "arcgis官方提供的高分辨率全球地形",
      category: "",
      creationFunction: function creationFunction() {
        return createTerrainProvider({
          type: "arcgis",
          url: "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer"
        });
      }
    })];
  }
}

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LatLngPoint; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _util_Util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);





/**
 * 坐标点类（含经度、纬度、高度）
 *
 * @param {Number} lng 经度值, -180 至 180
 * @param {Number} lat 纬度值, -90 至 90
 * @param {Number} alt 高度（单位：米）
 * @export
 * @class LatLngPoint
 */

var LatLngPoint = /*#__PURE__*/function () {
  function LatLngPoint(lng, lat, alt) {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, LatLngPoint);

    this._lng = Number(lng || 0);
    this._lat = Number(lat || 0);
    this._alt = Number(alt || 0);
  }
  /**
   * 经度值, -180 至 180
   * @type {Number}
   */


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(LatLngPoint, [{
    key: "lng",
    get: function get() {
      return this._lng;
    },
    set: function set(lng) {
      this._lng = +lng;
      this._position = null;
    }
    /**
     * 纬度值, -180 至 180
     * @type {Number}
     */

  }, {
    key: "lat",
    get: function get() {
      return this._lat;
    },
    set: function set(lat) {
      this._lat = +lat;
      this._position = null;
    }
    /**
     * 高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "alt",
    get: function get() {
      return this._alt || 0;
    },
    set: function set(alt) {
      this._alt = +alt;
      this._position = null;
    }
    /**
     * 复制一份对象
     * @return {void}  无
     */

  }, {
    key: "clone",
    value: function clone() {
      var position = new LatLngPoint();
      position.lng = this.lng || 0;
      position.lat = this.lat || 0;
      position.alt = this.alt || 0;
      return position;
    }
    /**
     * 格式化对象内的经纬度的小数位为6位，高度小数位为1位。
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "format",
    value: function format() {
      this.lng = Object(_util_Util__WEBPACK_IMPORTED_MODULE_4__["formatNum"])(this.lng, LatLngPoint.FormatLength);
      this.lat = Object(_util_Util__WEBPACK_IMPORTED_MODULE_4__["formatNum"])(this.lat, LatLngPoint.FormatLength);
      this.alt = Object(_util_Util__WEBPACK_IMPORTED_MODULE_4__["formatNum"])(this.alt, LatLngPoint.FormatAltLength);
      return this;
    }
    /**
     * 转换为数组对象
     * @param {Boolean} noAlt 是否包含高度值
     * @returns {Array} 数组对象，示例[113.123456,31.123456,30.1]
     */

  }, {
    key: "toArray",
    value: function toArray(noAlt) {
      this.format();

      if (noAlt) {
        return [this.lng, this.lat];
      } else {
        return [this.lng, this.lat, this.alt];
      }
    }
    /**
     * 转换为字符串对象
     * @returns {String} 符串，示例 "113.123456,31.123456,30.1"
     */

  }, {
    key: "toString",
    value: function toString() {
      this.format();
      return "".concat(this.lng, ",").concat(this.lat, ",").concat(this.alt);
    }
    /**
     * 转换为笛卡尔坐标
     * @param {Boolean} clone 是否复制
     * @returns {Cesium.Cartesian3} 笛卡尔坐标
     */

  }, {
    key: "toCartesian",
    value: function toCartesian() {
      var clone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!clone && this._position) {
        return this._position;
      } else {
        return cesium__WEBPACK_IMPORTED_MODULE_2__["Cartesian3"].fromDegrees(this.lng, this.lat, this.alt);
      }
    }
    /**
     * 转换为 地理坐标(弧度制)
     * @returns {Cesium.Cartographic} 地理坐标(弧度制)
     */

  }, {
    key: "toCartographic",
    value: function toCartographic() {
      return cesium__WEBPACK_IMPORTED_MODULE_2__["Cartographic"].fromDegrees(this.lng, this.lat, this.alt);
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param {LatLngPoint} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof LatLngPoint && this._alt == other._alt && this._lat == other._lat && this._lng == other._lng;
    }
    /**
     * 根据传入的各种对象数据，转换返回LatLngPoint对象
     *
     * @static
     * @param {String|Array|Object|Cesium.Cartesian3|*} position 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {LatLngPoint}  转换返回的LatLngPoint对象
     */

  }], [{
    key: "parse",
    value: function parse(position, time) {
      if (!position) {
        return new LatLngPoint();
      }

      var result;

      if (typeof position == "string") {
        result = LatLngPoint.fromString(position);
      } else if (Array.isArray(position)) {
        result = LatLngPoint.fromArray(position);
      } else if (position instanceof LatLngPoint) {
        result = position.clone();
      } else if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](position.lat) && cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](position.lng)) {
        result = new LatLngPoint(position.lng, position.lat, position.alt);

        for (var key in position) {
          result[key] = position[key];
        }
      } else if (position instanceof cesium__WEBPACK_IMPORTED_MODULE_2__["Cartesian3"] || position._value || position.getValue) {
        result = LatLngPoint.fromCartesian(position, time);
        result._position = position;
      } else if (cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](position.x) && cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](position.y) && cesium__WEBPACK_IMPORTED_MODULE_2__["defined"](position.z)) {
        position = new cesium__WEBPACK_IMPORTED_MODULE_2__["Cartesian3"](position.x, position.y, position.z);
        result = LatLngPoint.fromCartesian(position, time);
        result._position = position;
      } else {
        result = new LatLngPoint();
        Object(_util_Log__WEBPACK_IMPORTED_MODULE_3__["logError"])("坐标解析失败，请确认参数是否无误", position);
      }

      return result;
    }
    /**
     * 根据传入的各种对象数据，转换返回Cartesian3对象
     *
     * @static
     * @param {String|Array|Object|Cesium.Cartesian3|*} position 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {Cartesian3}  转换返回的Cartesian3对象
     */

  }, {
    key: "parseCartesian3",
    value: function parseCartesian3(position, time) {
      return LatLngPoint.parse(position, time).toCartesian();
    }
    /**
     * 根据数组数据，转换返回LatLngPoint对象
     * 示例：[113.123456,31.123456,30.1]
     *
     * @static
     * @param {Array} arr 坐标位置
     * @return {LatLngPoint}  转换返回的LatLngPoint对象
     */

  }, {
    key: "fromArray",
    value: function fromArray(arr) {
      var position = new LatLngPoint();

      if (Array.isArray(arr)) {
        position.lng = arr[0] || 0;
        position.lat = arr[1] || 0;
        position.alt = arr[2] || 0;
      }

      return position;
    }
    /**
     * 根据传入字符串，转换返回LatLngPoint对象
     * 示例："113.123456,31.123456,30.1"
     * @static
     * @param {String} str 坐标位置字符串，逗号分割。
     * @return {LatLngPoint}  转换返回的LatLngPoint对象
     */

  }, {
    key: "fromString",
    value: function fromString(str) {
      var position = new LatLngPoint();

      if (str && typeof str == "string") {
        var arr = str.split(",");
        position = this.fromArray(arr);
      }

      return position;
    }
    /**
     * 根据传入的笛卡尔坐标，转换返回LatLngPoint对象
     *
     * @static
     * @param {Cesium.Cartesian3|*} cartesian 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {LatLngPoint}  转换返回的LatLngPoint对象
     */

  }, {
    key: "fromCartesian",
    value: function fromCartesian(cartesian, time) {
      var result = new LatLngPoint();

      var _position;

      if (cartesian) {
        if (cartesian instanceof cesium__WEBPACK_IMPORTED_MODULE_2__["Cartesian3"]) {
          _position = cartesian;
        } else if (cartesian._value && cartesian._value instanceof cesium__WEBPACK_IMPORTED_MODULE_2__["Cartesian3"]) {
          _position = cartesian._value;
        } else if (typeof cartesian.getValue == "function") {
          _position = cartesian.getValue(time || cesium__WEBPACK_IMPORTED_MODULE_2__["JulianDate"].now());
        }
      }

      if (_position) {
        var carto = cesium__WEBPACK_IMPORTED_MODULE_2__["Cartographic"].fromCartesian(_position);

        if (carto) {
          result.lat = cesium__WEBPACK_IMPORTED_MODULE_2__["Math"].toDegrees(carto.latitude);
          result.lng = cesium__WEBPACK_IMPORTED_MODULE_2__["Math"].toDegrees(carto.longitude);
          result.alt = carto.height;
          result.format();
        }
      }

      result._position = cartesian;
      return result;
    }
    /**
     * 根据传入的地理坐标(弧度制)，转换返回LatLngPoint对象
     *
     * @static
     * @param {Cesium.Cartographic} cartographic 地理坐标(弧度制)
     * @return {LatLngPoint}  转换返回的LatLngPoint对象
     */

  }, {
    key: "fromCartographic",
    value: function fromCartographic(cartographic) {
      var result = new LatLngPoint();
      result.lat = cesium__WEBPACK_IMPORTED_MODULE_2__["Math"].toDegrees(cartographic.latitude);
      result.lng = cesium__WEBPACK_IMPORTED_MODULE_2__["Math"].toDegrees(cartographic.longitude);
      result.alt = cartographic.height;
      return result;
    }
  }]);

  return LatLngPoint;
}();
/**
 * 经度纬度的格式化时的长度，默认为6
 * @type {Number}
 */

LatLngPoint.FormatLength = 6;
/**
 * 高度的格式化时的长度，默认为1
 * @type {Number}
 */

LatLngPoint.FormatAltLength = 1;

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degree2dms", function() { return degree2dms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dms2degree", function() { return dms2degree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCGCS2000EPSGByLng", function() { return getCGCS2000EPSGByLng; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCGCS2000EPSGByX", function() { return getCGCS2000EPSGByX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proj4Trans", function() { return proj4Trans; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proj4TransArr", function() { return proj4TransArr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian2lonlat", function() { return cartesian2lonlat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesians2lonlats", function() { return cartesians2lonlats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian2mercator", function() { return cartesian2mercator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesians2mercators", function() { return cartesians2mercators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lonlat2cartesian", function() { return lonlat2cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lonlats2cartesians", function() { return lonlats2cartesians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lonlat2mercator", function() { return lonlat2mercator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lonlats2mercators", function() { return lonlats2mercators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercator2cartesian", function() { return mercator2cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercators2cartesians", function() { return mercators2cartesians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercator2lonlat", function() { return mercator2lonlat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercators2lonlats", function() { return mercators2lonlats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bd2gcj", function() { return bd2gcj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gcj2bd", function() { return gcj2bd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wgs2gcj", function() { return wgs2gcj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gcj2wgs", function() { return gcj2wgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bd2wgs", function() { return bd2wgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wgs2bd", function() { return wgs2bd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jwd2mct", function() { return jwd2mct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mct2jwd", function() { return mct2jwd; });
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _const_CRS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
/* harmony import */ var _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/**
 * 坐标点的转换 相关静态方法。
 *  提供了cesium内部不同坐标系之间的坐标转换、提供了国内偏移坐标系与标准坐标的转换。
 * @module PointTrans
 */




/**
 * 经度/纬度 十进制 转为 度分秒格式
 * @param {Number} value 经度或纬度值
 * @return {Object} 度分秒对象，如： { degree:113, minute:24, second:40 }
 */

function degree2dms(value) {
  value = Math.abs(value);
  var degree = Math.floor(value); //度

  var minute = Math.floor((value - degree) * 60); //分

  var second = Math.round((value - degree) * 3600 % 60); //秒

  return {
    degree: degree,
    minute: minute,
    second: second,
    str: degree + "° " + minute + "'  " + second + '"'
  };
}
/**
 * 经度/纬度  度分秒 转为 十进制
 * @param {Number} degree 度
 * @param {Number} minute 分
 * @param {Number} second 秒
 * @return {Number} 十进制
 */

function dms2degree(degree, minute, second) {
  var ten = Math.abs(degree) + minute / 60 + second / 3600;
  return ten;
}
/**
 * 根据经度值 获取CGCS2000投影坐标对应的 EPSG值
 *
 * @param {Number} lng 经度值
 * @param {Boolean} [fd6=false]  是否为6度分带， true:6度分带,false:3度分带
 * @param {Boolean} [hasAddDH=true] 横坐标前是否加带号
 * @return {String|undefined}  EPSG值
 */

function getCGCS2000EPSGByLng(lng, fd6) {
  var hasAddDH = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var epsgID;

  if (fd6) {
    var n6 = parseInt(lng / 6) + 1; //13到23

    if (n6 < 13 || n6 > 23) {
      return undefined;
    }

    if (hasAddDH) {
      //EPSG:4491 到 EPSG:4501
      epsgID = n6 + 4478;
    } else {
      //EPSG:4502 到 EPSG:4512
      epsgID = n6 + 4489;
    }
  } else {
    var n3 = parseInt((lng - 1.5) / 3) + 1; //25到45

    if (n3 < 25 || n3 > 45) {
      return undefined;
    }

    if (hasAddDH) {
      //EPSG:4513 到 EPSG:4533
      epsgID = n3 + 4488;
    } else {
      //EPSG:4534 到 EPSG:4554
      epsgID = n3 + 4509;
    }
  }

  return "EPSG:" + epsgID;
}
/**
 * 根据加带号的横坐标值 获取CGCS2000投影坐标对应的EPSG值
 * @param {Number} x 根据加带号的横坐标值
 * @return {String|undefined}  EPSG值
 */

function getCGCS2000EPSGByX(x) {
  var dh = parseInt(x.toString().slice(0, 2));

  if (dh >= 13 && dh <= 23) {
    //13到23,   EPSG:4491 到 EPSG:4501
    return "EPSG:" + (dh + 4478);
  } else if (dh >= 25 && dh <= 45) {
    //25到45,   EPSG:4513 到 EPSG:4533
    return "EPSG:" + (dh + 4488);
  } else {
    return undefined;
  }
}
/**
 * 使用proj4转换坐标（支持任意坐标系），
 * 坐标系 可以在 {@link http://epsg.io }进行查询，已经内置支持 EPSG:4326、EPSG:3857、EPSG:4490、EPSG:4491至4554
 *
 * @param {Number[]} arrdata 原始坐标,示例：[39396641,3882123]
 * @param {String|CRS} fromProjParams 原始坐标的坐标系，如'EPSG:4527'
 * @param {String|CRS} [toProjParams='EPSG:4326'] 转为返回的结果坐标系
 * @return {Number[]} 返回结果坐标系的对应坐标,示例：[115.866936, 35.062583]
 */

function proj4Trans(arrdata, fromProjParams) {
  var toProjParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "EPSG:4326";

  if (!fromProjParams || !toProjParams || fromProjParams == toProjParams) {
    return arrdata;
  }

  try {
    if (fromProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_Zone_3 || fromProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_Zone_6) {
      fromProjParams = getCGCS2000EPSGByX(arrdata[0]);
    }

    if (toProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_Zone_3) {
      toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, true);
    } else if (toProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_Zone_6) {
      toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, true);
    } else if (toProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_CM_3) {
      toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, false);
    } else if (toProjParams == _const_CRS__WEBPACK_IMPORTED_MODULE_2__[/* CRS */ "a"].CGCS2000_GK_CM_6) {
      toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, false);
    }

    if (!fromProjParams || !toProjParams || fromProjParams == toProjParams) {
      return arrdata;
    }

    var arr = Object(proj4__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(fromProjParams, toProjParams, arrdata);

    if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](arr) && arr.length > 1 && !isNaN(arr[0]) && arr[0] != Infinity) {
      return arr;
    }
  } catch (e) {//console.log(e)
  }

  return arrdata;
}
/**
 * 使用proj4转换坐标数组（支持任意坐标系），
 * 坐标系 可以在 {@link http://epsg.io }进行查询，已经内置支持 EPSG:4326、EPSG:3857、EPSG:4490、EPSG:4491至4554
 *
 * @param {Number[]} coords 原始坐标数组,示例：[[39396641,3882123],[39396623,3882134]]
 * @param {String} fromProjParams 原始坐标的坐标系，如'EPSG:4527'
 * @param {String} [toProjParams='EPSG:4326'] 转为返回的结果坐标系
 * @return {Number[]} 返回结果坐标系的对应坐标数组,示例：[[115.866936, 35.062583],[115.866923, 35.062565]]
 */

function proj4TransArr(coords, fromProjParams) {
  var toProjParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "EPSG:4326";

  if (!fromProjParams || fromProjParams == toProjParams) {
    return coords;
  }

  var arr = [];

  for (var i = 0, len = coords.length; i < len; i++) {
    var item = coords[i];

    if (Array.isArray(item[0])) {
      var arr2 = proj4TransArr(item, fromProjParams, toProjParams);

      if (arr2 && arr2.length > 0) {
        arr.push(arr2);
      }
    } else {
      var _arr = proj4Trans(item, fromProjParams, toProjParams);

      if (_arr) {
        arr.push(_arr);
      }
    }
  }

  return arr;
}
/**
 * Cesium笛卡尔空间坐标 转 经纬度坐标
 * 常用于转换geojson
 *
 * @param {Cesium.Cartesian3} cartesian Cesium笛卡尔空间xyz坐标
 * @param {Boolean} noAlt 是否包含高度值
 * @return {Number[]} 经纬度坐标,示例：[123.123456,32.654321,198.7]
 */

function cartesian2lonlat(cartesian, noAlt) {
  var carto = cesium__WEBPACK_IMPORTED_MODULE_0__["Cartographic"].fromCartesian(cartesian);

  if (carto == null) {
    return null;
  }

  var x = formatNum(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto.longitude), _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_3__[/* LatLngPoint */ "a"].FormatLength);
  var y = formatNum(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto.latitude), _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_3__[/* LatLngPoint */ "a"].FormatLength);

  if (noAlt) {
    return [x, y];
  } else {
    var z = formatNum(carto.height, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_3__[/* LatLngPoint */ "a"].FormatAltLength);
    return [x, y, z];
  }
}
/**
 * Cesium笛卡尔空间坐标数组 转 经纬度坐标数组
 * 常用于转换geojson
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions Cesium笛卡尔空间xyz坐标数组
 * @param {Boolean} noAlt 是否包含高度值
 * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
 */

function cartesians2lonlats(positions, noAlt) {
  var coordinates = [];

  for (var i = 0, len = positions.length; i < len; i++) {
    var point = cartesian2lonlat(positions[i], noAlt);

    if (point) {
      coordinates.push(point);
    }
  }

  return coordinates;
}
/**
 * Cesium笛卡尔空间坐标 转 WebMercator投影平面坐标
 *
 * @export
 * @param {Cesium.Cartesian3} position Cesium笛卡尔空间xyz坐标
 * @return {Number[]} 墨卡托投影平面坐标,示例：[13048882,3741659,20.1]
 */

function cartesian2mercator(position) {
  if (!position) {
    return null;
  }

  var lonlat = cartesian2lonlat(position);
  return lonlat2mercator(lonlat);
}
/**
 * Cesium笛卡尔空间坐标数组 转 WebMercator投影平面坐标数组
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions Cesium笛卡尔空间xyz坐标数组
 * @return {Array[]} WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
 */

function cartesians2mercators(positions) {
  var arrNew = [];

  for (var i = 0, len = positions.length; i < len; i++) {
    var point = cartesian2mercator(positions[i]);

    if (point) {
      arrNew.push(point);
    }
  }

  return arrNew;
}
/**
 * 经纬度坐标 转 Cesium笛卡尔空间xyz坐标
 *
 * @export
 * @param {Array[]} coord 经纬度坐标,示例：[123.123456,32.654321,198.7]
 * @param {Number} [defHeight=0] 默认高度
 * @return {Cesium.Cartesian3} Cesium笛卡尔空间xyz坐标
 */

function lonlat2cartesian(coord) {
  var defHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!coord || coord.length < 2) {
    return null;
  }

  return cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"].fromDegrees(coord[0], coord[1], coord[2] || defHeight);
}
/**
 * 经纬度坐标数组 转 Cesium笛卡尔空间xyz坐标数组
 *
 * @export
 * @param {Array[]} coords 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
 * @param {Number} [defHeight=0] 默认高度
 * @return {Cesium.Cartesian3[]} Cesium笛卡尔空间xyz坐标数组
 */

function lonlats2cartesians(coords, defHeight) {
  var arr = [];

  for (var i = 0, len = coords.length; i < len; i++) {
    var item = coords[i];

    if (Array.isArray(item[0])) {
      var arr2 = lonlats2cartesians(item, defHeight);

      if (arr2 && arr2.length > 0) {
        arr.push(arr2);
      }
    } else {
      var cartesian = lonlat2cartesian(item, defHeight);

      if (cartesian) {
        arr.push(cartesian);
      }
    }
  }

  return arr;
}
/**
 * 经纬度地理坐标 转 投影平面坐标
 *
 * @export
 * @param {Number[]} lnglat 经纬度坐标,示例：[123.123456,32.654321,20.1]
 * @return {Number[]} WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
 */

function lonlat2mercator(lnglat) {
  return jwd2mct(lnglat);
}
/**
 * 经纬度地理坐标数组 转 投影平面坐标数组
 *
 * @export
 * @param {Array[]} arr 经纬度坐标数组,示例：[ [123.123456,32.654321,20.1], [111.123456,22.654321,21.2] ]
 * @return {Array[]} WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
 */

function lonlats2mercators(arr) {
  var arrNew = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    var point = lonlat2mercator(arr[i]);
    arrNew.push(point);
  }

  return arrNew;
}
/**
 * 投影平面坐标 转 Cesium笛卡尔空间xyz坐标
 *
 * @export
 * @param {Number[]} point WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
 * @param {Number} [height] 赋值高度
 * @return  {Cesium.Cartesian3}  Cesium笛卡尔空间xyz坐标
 */

function mercator2cartesian(point, height) {
  if (isNaN(point[0]) || isNaN(point[1])) {
    return null;
  }

  var lonlat = mercator2lonlat(point);

  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](height)) {
    lonlat[2] = height;
  }

  return lonlat2cartesian(lonlat);
}
/**
 * 投影平面坐标数组 转 Cesium笛卡尔空间xyz坐标数组
 *
 * @export
 * @param {Number[]} arr WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
 * @param {Number} [height] 赋值高度
 * @return  {Cesium.Cartesian3}  Cesium笛卡尔空间xyz坐标数组
 */

function mercators2cartesians(arr, height) {
  var arrNew = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    var point = mercator2cartesian(arr[i], height);

    if (point) {
      arrNew.push(point);
    }
  }

  return arrNew;
}
/**
 * 投影平面坐标 转 经纬度地理坐标
 *
 * @export
 * @param {Number[]} point WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
 * @return {Number[]} 经纬度坐标,示例：[123.123456,32.654321,20.1]
 */

function mercator2lonlat(point) {
  return mct2jwd(point);
}
/**
 * 投影平面坐标数组 转 经纬度地理坐标数组
 *
 * @export
 * @param {Array[]} arr WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
 * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,20.1], [111.123456,22.654321,21.2] ]
 */

function mercators2lonlats(arr) {
  var arrNew = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    var point = mercator2lonlat(arr[i]);
    arrNew.push(point);
  }

  return arrNew;
} //格式化 数字 小数位数

function formatNum(num, digits) {
  return Number(num.toFixed(digits || 0));
} //========提供了百度（BD09）、国测局（GCJ02）、WGS84、Web墨卡托 4类坐标之间的转换=======
//传入参数 和 返回结果 均是数组：[经度,纬度]
//定义一些常量


var x_PI = 3.14159265358979324 * 3000.0 / 180.0;
var PI = 3.1415926535897932384626;
var a = 6378245.0;
var ee = 0.00669342162296594323;

function transformlat(lng, lat) {
  var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
  ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
  return ret;
}

function transformlng(lng, lat) {
  var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
  ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
  return ret;
} //判断是否在国内，不在国内则不做偏移


function out_of_china(lng, lat) {
  return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false;
}
/**
 * 经纬度坐标转换，
 * 百度坐标 (BD09) 转换为 国测局坐标 (GCJ02)
 *
 * @export
 * @param {Number[]} arrdata 百度坐标 (BD09)坐标数据，示例：[117.225590,31.832916]
 * @return {Number[]} 国测局坐标 (GCJ02)坐标数据，示例：[:117.22559,31.832917]
 */


function bd2gcj(arrdata) {
  var bd_lon = Number(arrdata[0]);
  var bd_lat = Number(arrdata[1]);
  var x_pi = 3.14159265358979324 * 3000.0 / 180.0;
  var x = bd_lon - 0.0065;
  var y = bd_lat - 0.006;
  var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
  var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
  var gg_lng = z * Math.cos(theta);
  var gg_lat = z * Math.sin(theta);
  gg_lng = Number(gg_lng.toFixed(6));
  gg_lat = Number(gg_lat.toFixed(6));
  return [gg_lng, gg_lat];
}
/**
 * 经纬度坐标转换，
 * 国测局坐标 (GCJ02) 转换为 百度坐标 (BD09)
 *
 * @export
 * @param {Number[]} arrdata 高德谷歌等国测局坐标 (GCJ02) 坐标数据，示例：[117.225590,31.832916]
 * @return {Number[]} 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
 */

function gcj2bd(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);
  var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
  var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
  var bd_lng = z * Math.cos(theta) + 0.0065;
  var bd_lat = z * Math.sin(theta) + 0.006;
  bd_lng = Number(bd_lng.toFixed(6));
  bd_lat = Number(bd_lat.toFixed(6));
  return [bd_lng, bd_lat];
}
/**
 * 经纬度坐标转换，
 * 标准无偏坐标（WGS84） 转为 国测局坐标 (GCJ02)
 *
 * @export
 * @param {Number[]} arrdata 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
 * @return {Number[]} 国测局坐标 (GCJ02)坐标数据，示例：[117.225590,31.832916]
 */

function wgs2gcj(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  if (out_of_china(lng, lat)) {
    return [lng, lat];
  } else {
    var dlat = transformlat(lng - 105.0, lat - 35.0);
    var dlng = transformlng(lng - 105.0, lat - 35.0);
    var radlat = lat / 180.0 * PI;
    var magic = Math.sin(radlat);
    magic = 1 - ee * magic * magic;
    var sqrtmagic = Math.sqrt(magic);
    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);
    var mglat = lat + dlat;
    var mglng = lng + dlng;
    mglng = Number(mglng.toFixed(6));
    mglat = Number(mglat.toFixed(6));
    return [mglng, mglat];
  }
}
/**
 * 经纬度坐标转换，
 * 国测局坐标 (GCJ02)  转换为 标准无偏坐标（WGS84）
 *
 * @export
 * @param {Number[]} arrdata 国测局坐标 (GCJ02)坐标数据，示例：[117.225590,31.832916]
 * @return {Number[]} 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
 */

function gcj2wgs(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  if (out_of_china(lng, lat)) {
    return [lng, lat];
  } else {
    var dlat = transformlat(lng - 105.0, lat - 35.0);
    var dlng = transformlng(lng - 105.0, lat - 35.0);
    var radlat = lat / 180.0 * PI;
    var magic = Math.sin(radlat);
    magic = 1 - ee * magic * magic;
    var sqrtmagic = Math.sqrt(magic);
    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);
    var mglat = lat + dlat;
    var mglng = lng + dlng;
    var jd = lng * 2 - mglng;
    var wd = lat * 2 - mglat;
    jd = Number(jd.toFixed(6));
    wd = Number(wd.toFixed(6));
    return [jd, wd];
  }
}
/**
 * 经纬度坐标转换，
 * 百度坐标 (BD09) 转 标准无偏坐标（WGS84）
 *
 * @export
 * @param {Number[]} arrdata 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
 * @return {Number[]} 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
 */

function bd2wgs(arrdata) {
  return gcj2wgs(bd2gcj(arrdata));
}
/**
 * 标准无偏坐标（WGS84）  转 百度坐标 (BD09)
 *
 * @export
 * @param {Number[]} arrdata 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
 * @return {Number[]} 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
 */

function wgs2bd(arrdata) {
  return gcj2bd(wgs2gcj(arrdata));
}
/**
 * 【方式2】经纬度地理坐标 转 投影平面坐标
 *
 * @export
 * @param {Number[]} arrdata 经纬度坐标,示例：[117.220101,31.834907]
 * @return {Number[]} WebMercator投影平面坐标,示例：[13048882.06,3741659.72]
 */

function jwd2mct(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);
  var x = lng * 20037508.34 / 180;
  var y = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
  y = y * 20037508.34 / 180; //+ 7.081154553416204e-10;

  x = Number(x.toFixed(2));
  y = Number(y.toFixed(2));
  return [x, y, arrdata[2] || 0];
}
/**
 * 【方式2】投影平面坐标 转 经纬度地理坐标
 *
 * @export
 * @param {Number[]} arrdata WebMercator投影平面坐标，示例：[13048882.06,3741659.72]
 * @return {Number[]} 经纬度坐标数据，示例：[117.220101,31.834907]
 */

function mct2jwd(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);
  var x = lng / 20037508.34 * 180;
  var y = lat / 20037508.34 * 180;
  y = 180 / PI * (2 * Math.atan(Math.exp(y * PI / 180)) - PI / 2);
  x = Number(x.toFixed(6));
  y = Number(y.toFixed(6));
  return [x, y, arrdata[2] || 0];
}

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js
/* harmony default export */ var global = (function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10;
// you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js
var PrimeMeridian_exports = {};


PrimeMeridian_exports.greenwich = 0.0; //"0dE",
PrimeMeridian_exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
PrimeMeridian_exports.paris = 2.337229166667; //"2d20'14.025\"E",
PrimeMeridian_exports.bogota = -74.080916666667; //"74d04'51.3\"W",
PrimeMeridian_exports.madrid = -3.687938888889; //"3d41'16.58\"W",
PrimeMeridian_exports.rome = 12.452333333333; //"12d27'8.4\"E",
PrimeMeridian_exports.bern = 7.439583333333; //"7d26'22.5\"E",
PrimeMeridian_exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
PrimeMeridian_exports.ferro = -17.666666666667; //"17d40'W",
PrimeMeridian_exports.brussels = 4.367975; //"4d22'4.71\"E",
PrimeMeridian_exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
PrimeMeridian_exports.athens = 23.7163375; //"23d42'58.815\"E",
PrimeMeridian_exports.oslo = 10.722916666667; //"10d43'22.5\"E"

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js
/* harmony default export */ var units = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js





/* harmony default export */ var projString = (function(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    gamma: function(v) {
      self.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = match(units, v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      var pm = match(PrimeMeridian_exports, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    },
    approx: function() {
      self.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
});

// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js
/* harmony default export */ var parser = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}

// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js
var wkt_parser_D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * wkt_parser_D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_1', 'Latitude of 1st standard parallel'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
    ['false_easting', 'False_Easting'],
    ['false_easting', 'False easting'],
    ['false-easting', 'Easting at false origin'],
    ['false_northing', 'False_Northing'],
    ['false_northing', 'False northing'],
    ['false_northing', 'Northing at false origin'],
    ['central_meridian', 'Central_Meridian'],
    ['central_meridian', 'Longitude of natural origin'],
    ['central_meridian', 'Longitude of false origin'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['latitude_of_origin', 'Latitude of natural origin'],
    ['latitude_of_origin', 'Latitude of false origin'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_Of_Center'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longitude_of_center', 'Longitude_of_center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['azimuth', 'Azimuth'],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
/* harmony default export */ var wkt_parser = (function(wkt) {
  var lisp = parser(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = projString(arguments[1]);
      }
      else {
        defs[name] = wkt_parser(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
global(defs);
/* harmony default export */ var lib_defs = (defs);

// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js




function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in lib_defs;
}
var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ['3857', '900913', '3785', '102113'];
function checkMercator(item) {
  var auth = match(item, 'authority');
  if (!auth) {
    return;
  }
  var code = match(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, 'extension');
  if (!ext) {
    return;
  }
  return match(ext, 'proj4');
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return lib_defs[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser(code);
      // test of spetial case, due to this being a very common and often malformed
      if (checkMercator(out)) {
        return lib_defs['EPSG:3857'];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ var parseCode = (parse);

// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js
/* harmony default export */ var extend = (function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js
/* harmony default export */ var msfnz = (function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js
/* harmony default export */ var sign = (function(x) {
  return x<0 ? -1 : 1;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js




/* harmony default export */ var adjust_lon = (function(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js


/* harmony default export */ var tsfnz = (function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js


/* harmony default export */ var phi2z = (function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function merc_inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ var merc = ({
  init: init,
  forward: forward,
  inverse: merc_inverse,
  names: names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js
function longlat_init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var longlat_names = ["longlat", "identity"];
/* harmony default export */ var longlat = ({
  init: longlat_init,
  forward: identity,
  inverse: identity,
  names: longlat_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js


var projs = [merc, longlat];
var projections_names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    projections_names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof projections_names[n] !== 'undefined' && projStore[projections_names[n]]) {
    return projStore[projections_names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ var projections = ({
  start: start,
  add: add,
  get: get
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js
var Ellipsoid_exports = {};

Ellipsoid_exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

Ellipsoid_exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

Ellipsoid_exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

Ellipsoid_exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

Ellipsoid_exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

Ellipsoid_exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

Ellipsoid_exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

Ellipsoid_exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

Ellipsoid_exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

Ellipsoid_exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

Ellipsoid_exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

Ellipsoid_exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

Ellipsoid_exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

Ellipsoid_exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

Ellipsoid_exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

Ellipsoid_exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

Ellipsoid_exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

Ellipsoid_exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

Ellipsoid_exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

Ellipsoid_exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

Ellipsoid_exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

Ellipsoid_exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

Ellipsoid_exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

Ellipsoid_exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

Ellipsoid_exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

Ellipsoid_exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

Ellipsoid_exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

Ellipsoid_exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

Ellipsoid_exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

Ellipsoid_exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

Ellipsoid_exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

Ellipsoid_exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

Ellipsoid_exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

Ellipsoid_exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

Ellipsoid_exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

Ellipsoid_exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

Ellipsoid_exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

Ellipsoid_exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

Ellipsoid_exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

Ellipsoid_exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

Ellipsoid_exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = Ellipsoid_exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

Ellipsoid_exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function deriveConstants_sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = match(Ellipsoid_exports, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js
var Datum_exports = {};

Datum_exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

Datum_exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

Datum_exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

Datum_exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

Datum_exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

Datum_exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

Datum_exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

Datum_exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

Datum_exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};

Datum_exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

Datum_exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

Datum_exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

Datum_exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

Datum_exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

Datum_exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

Datum_exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

Datum_exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js


function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ var lib_datum = (datum);

// CONCATENATED MODULE: ./node_modules/proj4/lib/nadgrid.js
/**
 * Resources for details of NTv2 file formats:
 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
 */

var loadedNadgrids = {};

/**
 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
 * as an ArrayBuffer.
 */
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid = {header: header, subgrids: subgrids};
  loadedNadgrids[key] = nadgrid;
  return nadgrid;
}

/**
 * Given a proj4 value for nadgrids, return an array of loaded grids
 */
function getNadgrids(nadgrids) {
  // Format details: http://proj.maptools.org/gen_parms.html
  if (nadgrids === undefined) { return null; }
  var grids = nadgrids.split(',');
  return grids.map(parseNadgridString);
}

function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === '@';
  if (optional) {
    value = value.slice(1);
  }
  if (value === 'null') {
    return {name: 'null', mandatory: !optional, grid: null, isNull: true};
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}

function secondsToRadians(seconds) {
  return (seconds / 3600) * Math.PI / 180;
}

function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
  }
  return true;
}

function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
  };
}

function decodeString(view, start, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
}

function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}

function mapNodes(nodes) {
  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
}

function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}

function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js









function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = match(Datum_exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

  var sphere_ = deriveConstants_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
    nadgrids);

  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
  extend(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calulated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Projection.projections = projections;
Projection.projections.start();
/* harmony default export */ var Proj = (Projection);

// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === PJD_7PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    /* Latitude out of range */
    return { x: Infinity, y: Infinity, z: p.z };
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js




function checkParams(type) {
  return (type === PJD_3PARAM || type === PJD_7PARAM);
}

/* harmony default export */ var datum_transform = (function(source, dest, point) {
  // Short cut if the datums are identical.
  if (compareDatums(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return undefined;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }

  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }

  // Do we need to go through geocentric coordinates?
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = geodeticToGeocentric(point, source_es, source_a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return undefined;
    }
  }

  return point;
});

function applyGridShift(source, inverse, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log('Grid shift grids not found');
    return -1;
  }
  var input = {x: -point.x, y: point.y};
  var output = {x: Number.NaN, y: Number.NaN};
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    onlyMandatoryGrids = grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    // skip tables that don't match our point at all
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
      continue;
    }
    output = applySubgridShift(input, inverse, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '"+
      -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}

function applySubgridShift(pin, inverse, ct) {
  var val = {x: Number.NaN, y: Number.NaN};
  if (isNaN(pin.x)) { return val; }
  var tb = {x: pin.x, y: pin.y};
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}

function nadInterpolate(pin, ct) {
  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
  var val= {x: Number.NaN, y: Number.NaN};
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = (indx.y * ct.lim[0]) + indx.x;
  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx++;
  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx += ct.lim[0];
  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx--;
  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
  return val;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ var adjust_axis = (function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }

    }
    else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      out[t] = v;
      break;
    case 'w':
      out[t] = -v;
      break;
    case 'n':
      out[t] = v;
      break;
    case 's':
      out[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js
/* harmony default export */ var toPoint = (function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js
/* harmony default export */ var checkSanity = (function (point) {
  checkCoord(point.x);
  checkCoord(point.y);
});
function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError('coordinates must be finite numbers');
  }
  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js







function checkNotWGS(source, dest) {
  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
}

function transform(source, dest, point, enforceAxis) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  }
  checkSanity(point);
  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj('WGS84');
    point = transform(source, wgs84, point, enforceAxis);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (enforceAxis && source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point); // Convert Cartesian to longlat
    if (!point) {
      return;
    }
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else { // else project
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }

  // DGR, 2010/11/12
  if (enforceAxis && dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }

  return point;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js


var core_wgs84 = Proj('WGS84');

function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
    if (coords.length > 2) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function (key) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof Proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Proj(item);
}

function core_proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function (coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function (coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ var core = (core_proj4);
// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var mgrs_A = 65; // A
var I = 73; // I
var O = 79; // O
var mgrs_V = 86; // V
var mgrs_Z = 90; // Z
/* harmony default export */ var mgrs = ({
  forward: mgrs_forward,
  inverse: mgrs_inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function mgrs_forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function mgrs_inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > mgrs_Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = mgrs_A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > mgrs_V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = mgrs_A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}

// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js


function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(mgrs_toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return mgrs_forward([this.x, this.y], accuracy);
};
/* harmony default export */ var lib_Point = (Point);

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ var pj_enfn = (function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js
/* harmony default export */ var pj_mlfn = (function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js



var MAX_ITER = 20;

/* harmony default export */ var pj_inv_mlfn = (function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function tmerc_init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function tmerc_forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > EPSLN) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function tmerc_inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);

    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = adjust_lon(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = HALF_PI * sign(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
/* harmony default export */ var tmerc = ({
  init: tmerc_init,
  forward: tmerc_forward,
  inverse: tmerc_inverse,
  names: tmerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js
/* harmony default export */ var sinh = (function(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js
/* harmony default export */ var hypot = (function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js
/* harmony default export */ var log1py = (function(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js



/* harmony default export */ var asinhy = (function(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

  return x < 0 ? -y : y;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js
/* harmony default export */ var gatg = (function(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js
/* harmony default export */ var clens = (function(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js
/* harmony default export */ var cosh = (function(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js



/* harmony default export */ var clens_cmplx = (function(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js










function etmerc_init() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    // When '+approx' is set, use tmerc instead
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}

function etmerc_forward(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;

  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));

  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function etmerc_inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ var etmerc = ({
  init: etmerc_init,
  forward: etmerc_forward,
  inverse: etmerc_inverse,
  names: etmerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js


/* harmony default export */ var adjust_zone = (function(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';



function utm_init() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}

var utm_names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ var utm = ({
  init: utm_init,
  names: utm_names,
  dependsOn: dependsOn
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js
/* harmony default export */ var srat = (function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js

var gauss_MAX_ITER = 20;


function gauss_init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}

function gauss_forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}

function gauss_inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = gauss_MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var gauss_names = ["gauss"];
/* harmony default export */ var gauss = ({
  init: gauss_init,
  forward: gauss_forward,
  inverse: gauss_inverse,
  names: gauss_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js



function sterea_init() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function sterea_forward(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function sterea_inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}

var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
/* harmony default export */ var sterea = ({
  init: sterea_init,
  forward: sterea_forward,
  inverse: sterea_inverse,
  names: sterea_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function stere_init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function stere_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function stere_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ var stere = ({
  init: stere_init,
  forward: stere_forward,
  inverse: stere_inverse,
  names: stere_names,
  ssfn_: ssfn_
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function somerc_init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function somerc_forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function somerc_inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var somerc_names = ["somerc"];
/* harmony default export */ var somerc = ({
  init: somerc_init,
  forward: somerc_forward,
  inverse: somerc_inverse,
  names: somerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js





var TOL = 1e-7;

function isTypeA(P) {
  var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  
  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
}


/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function omerc_init() {  
  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
    gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
  
  // only Type A uses the no_off or no_uoff property
  // https://github.com/OSGeo/proj.4/issues/104
  this.no_off = isTypeA(this);
  this.no_rot = 'no_rot' in this;
  
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }

  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }

  if (alp) {
    alpha_c = this.alpha;
  }
  
  if (gam) {
    gamma = (this.rectified_grid_angle * D2R);
  }
  
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
        Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
        Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  
  var one_es = 1.0 - this.es;
  com = Math.sqrt(one_es);
  
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D -1;
    
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    
    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    
    if (con < -Math.pi) {
      lam2 -=TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;
  
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    
    if (this.lat0 < 0) {
      this.u_0 = - this.u_0;
    }  
  }
    
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function omerc_forward(p) {
  var coords = {};
  var S, T, U, V, W, temp, u, v;
  p.x = p.x - this.lam0;
  
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
    
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V = Math.sin(this.B * p.x);
    U = (S * this.singam - V * this.cosgam) / T;
        
    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
      throw new Error();
    }
    
    v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
    temp = Math.cos(this.B * p.x);
    
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
    }    
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
     
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  
  coords.x = (this.a * coords.x + this.x0);
  coords.y = (this.a * coords.y + this.y0);
  
  return coords;
}

function omerc_inverse(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  
  p.x = (p.x - this.x0) * (1.0 / this.a);
  p.y = (p.y - this.y0) * (1.0 / this.a);

  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    
    if (coords.y === Infinity) {
      throw new Error();
    }
        
    coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
  }
  
  coords.x += this.lam0;
  
  return coords;
}

var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
/* harmony default export */ var omerc = ({
  init: omerc_init,
  forward: omerc_forward,
  inverse: omerc_inverse,
  names: omerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js






function lcc_init() {
  
  //double lat0;                    /* the reference latitude               */
  //double long0;                   /* the reference longitude              */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  
  //the above value can be set with proj4.defs
  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function lcc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function lcc_inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var lcc_names = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc"
];

/* harmony default export */ var lcc = ({
  init: lcc_init,
  forward: lcc_forward,
  inverse: lcc_inverse,
  names: lcc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js


function krovak_init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function krovak_forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function krovak_inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var krovak_names = ["Krovak", "krovak"];
/* harmony default export */ var krovak = ({
  init: krovak_init,
  forward: krovak_forward,
  inverse: krovak_inverse,
  names: krovak_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js
/* harmony default export */ var mlfn = (function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js
/* harmony default export */ var e0fn = (function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js
/* harmony default export */ var e1fn = (function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js
/* harmony default export */ var e2fn = (function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js
/* harmony default export */ var e3fn = (function(x) {
  return (x * x * x * (35 / 3072));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js
/* harmony default export */ var gN = (function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js



/* harmony default export */ var adjust_lat = (function(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js
/* harmony default export */ var imlfn = (function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js











function cass_init() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function cass_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function cass_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

}

var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ var cass = ({
  init: cass_init,
  forward: cass_forward,
  inverse: cass_inverse,
  names: cass_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js
/* harmony default export */ var qsfnz = (function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function laea_init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function laea_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function laea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ var laea = ({
  init: laea_init,
  forward: laea_forward,
  inverse: laea_inverse,
  names: laea_names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js
/* harmony default export */ var asinz = (function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js






function aea_init() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function aea_forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function aea_inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ var aea = ({
  init: aea_init,
  forward: aea_forward,
  inverse: aea_inverse,
  names: aea_names,
  phi1z: phi1z
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function gnom_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function gnom_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function gnom_inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var gnom_names = ["gnom"];
/* harmony default export */ var gnom = ({
  init: gnom_init,
  forward: gnom_forward,
  inverse: gnom_inverse,
  names: gnom_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js


/* harmony default export */ var iqsfnz = (function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function cea_init() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function cea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function cea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var cea_names = ["cea"];
/* harmony default export */ var cea = ({
  init: cea_init,
  forward: cea_forward,
  inverse: cea_inverse,
  names: cea_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js



function eqc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function eqc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function eqc_inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ var eqc = ({
  init: eqc_init,
  forward: eqc_forward,
  inverse: eqc_inverse,
  names: eqc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js










var poly_MAX_ITER = 20;

function poly_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function poly_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function poly_inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = poly_MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = poly_MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var poly_names = ["Polyconic", "poly"];
/* harmony default export */ var poly = ({
  init: poly_init,
  forward: poly_forward,
  inverse: poly_inverse,
  names: poly_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function nzmg_init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function nzmg_forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function nzmg_inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ var nzmg = ({
  init: nzmg_init,
  forward: nzmg_forward,
  inverse: nzmg_inverse,
  names: nzmg_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function mill_init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function mill_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function mill_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var mill_names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ var mill = ({
  init: mill_init,
  forward: mill_forward,
  inverse: mill_inverse,
  names: mill_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js



var sinu_MAX_ITER = 20;







function sinu_init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function sinu_forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = sinu_MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function sinu_inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var sinu_names = ["Sinusoidal", "sinu"];
/* harmony default export */ var sinu = ({
  init: sinu_init,
  forward: sinu_forward,
  inverse: sinu_inverse,
  names: sinu_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js

function moll_init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function moll_forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function moll_inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var moll_names = ["Mollweide", "moll"];
/* harmony default export */ var moll = ({
  init: moll_init,
  forward: moll_forward,
  inverse: moll_inverse,
  names: moll_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js











function eqdc_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function eqdc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function eqdc_inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var eqdc_names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ var eqdc = ({
  init: eqdc_init,
  forward: eqdc_forward,
  inverse: eqdc_inverse,
  names: eqdc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function vandg_init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function vandg_forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function vandg_inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ var vandg = ({
  init: vandg_init,
  forward: vandg_forward,
  inverse: vandg_inverse,
  names: vandg_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js














function aeqd_init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function aeqd_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function aeqd_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ var aeqd = ({
  init: aeqd_init,
  forward: aeqd_forward,
  inverse: aeqd_inverse,
  names: aeqd_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js




function ortho_init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function ortho_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function ortho_inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var ortho_names = ["ortho"];
/* harmony default export */ var ortho = ({
  init: ortho_init,
  forward: ortho_forward,
  inverse: ortho_inverse,
  names: ortho_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function qsc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function qsc_forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function qsc_inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (SPI / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}

var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ var qsc = ({
  init: qsc_init,
  forward: qsc_forward,
  inverse: qsc_inverse,
  names: qsc_names
});


// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039




var COEFS_X = [
    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
];

var COEFS_Y = [
    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
];

var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D/5; // rad to 5-degree interval
var RC1 = 1/C1;
var NODES = 18;

var poly3_val = function(coefs, x) {
    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function(coefs, x) {
    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
    var x = start;
    for (; iters; --iters) {
        var upd = f_df(x);
        x -= upd;
        if (Math.abs(upd) < max_err) {
            break;
        }
    }
    return x;
}

function robin_init() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
}

function robin_forward(ll) {
    var lon = adjust_lon(ll.x - this.long0);

    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
        i = 0;
    } else if (i >= NODES) {
        i = NODES - 1;
    }
    dphi = R2D * (dphi - RC1 * i);
    var xy = {
        x: poly3_val(COEFS_X[i], dphi) * lon,
        y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
        xy.y = -xy.y;
    }

    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
}

function robin_inverse(xy) {
    var ll = {
        x: (xy.x - this.x0) / (this.a * FXC),
        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };

    if (ll.y >= 1) { // pathologic case
        ll.x /= COEFS_X[NODES][0];
        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
    } else {
        // find table interval
        var i = Math.floor(ll.y * NODES);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        for (;;) {
            if (COEFS_Y[i][0] > ll.y) {
                --i;
            } else if (COEFS_Y[i+1][0] <= ll.y) {
                ++i;
            } else {
                break;
            }
        }
        // linear interpolation in 5 degree interval
        var coefs = COEFS_Y[i];
        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
        // find t so that poly3_val(coefs, t) = ll.y
        t = newton_rapshon(function(x) {
            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
        }, t, EPSLN, 100);

        ll.x /= poly3_val(COEFS_X[i], t);
        ll.y = (5 * i + t) * D2R;
        if (xy.y < 0) {
            ll.y = -ll.y;
        }
    }

    ll.x = adjust_lon(ll.x + this.long0);
    return ll;
}

var robin_names = ["Robinson", "robin"];
/* harmony default export */ var robin = ({
  init: robin_init,
  forward: robin_forward,
  inverse: robin_inverse,
  names: robin_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js


function geocent_init() {
    this.name = 'geocent';

}

function geocent_forward(p) {
    var point = geodeticToGeocentric(p, this.es, this.a);
    return point;
}

function geocent_inverse(p) {
    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
    return point;
}

var geocent_names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ var geocent = ({
    init: geocent_init,
    forward: geocent_forward,
    inverse: geocent_inverse,
    names: geocent_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js

var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};




var tpers_params = {
  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
  azi:   { def: 0, num: true, degrees: true }, // default is North
  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
};

function tpers_init() {
  Object.keys(tpers_params).forEach(function (p) {
    if (typeof this[p] === "undefined") {
      this[p] = tpers_params[p].def;
    } else if (tpers_params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (tpers_params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (tpers_params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));

  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }

  this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;

  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}

function tpers_forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);

  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }

  // Tilt 
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;

  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}

function tpers_inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };

  // Un-Tilt
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;

  var rh = hypot(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }

  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}

var tpers_names = ["Tilted_Perspective", "tpers"];
/* harmony default export */ var tpers = ({
  init: tpers_init,
  forward: tpers_forward,
  inverse: tpers_inverse,
  names: tpers_names
});

// CONCATENATED MODULE: ./node_modules/proj4/projs.js




























/* harmony default export */ var proj4_projs = (function(proj4){
  proj4.Proj.projections.add(tmerc);
  proj4.Proj.projections.add(etmerc);
  proj4.Proj.projections.add(utm);
  proj4.Proj.projections.add(sterea);
  proj4.Proj.projections.add(stere);
  proj4.Proj.projections.add(somerc);
  proj4.Proj.projections.add(omerc);
  proj4.Proj.projections.add(lcc);
  proj4.Proj.projections.add(krovak);
  proj4.Proj.projections.add(cass);
  proj4.Proj.projections.add(laea);
  proj4.Proj.projections.add(aea);
  proj4.Proj.projections.add(gnom);
  proj4.Proj.projections.add(cea);
  proj4.Proj.projections.add(eqc);
  proj4.Proj.projections.add(poly);
  proj4.Proj.projections.add(nzmg);
  proj4.Proj.projections.add(mill);
  proj4.Proj.projections.add(sinu);
  proj4.Proj.projections.add(moll);
  proj4.Proj.projections.add(eqdc);
  proj4.Proj.projections.add(vandg);
  proj4.Proj.projections.add(aeqd);
  proj4.Proj.projections.add(ortho);
  proj4.Proj.projections.add(qsc);
  proj4.Proj.projections.add(robin);
  proj4.Proj.projections.add(geocent);
  proj4.Proj.projections.add(tpers);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js










core.defaultDatum = 'WGS84'; //default datum
core.Proj = Proj;
core.WGS84 = new core.Proj('WGS84');
core.Point = lib_Point;
core.toPoint = toPoint;
core.defs = lib_defs;
core.nadgrid = nadgrid;
core.transform = transform;
core.mgrs = mgrs;
core.version = '__VERSION__';
proj4_projs(core);
/* harmony default export */ var lib = __webpack_exports__["a"] = (core);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CRS; });
/**
 * 坐标系 枚举
 *  @enum {String}
 */
var CRS = {
  /**
   * Web墨卡托投影坐标系
   */
  EPSG3857: "EPSG:3857",

  /**
   * WGS84地理坐标系
   */
  EPSG4326: "EPSG:4326",

  /**
   * 中国大地2000 （CGCS2000）地理坐标系
   */
  EPSG4490: "EPSG:4490",

  /**
   * CGCS2000 Gauss-Kruger Zone 平面投影，3度分带，横坐标前加带号。
   * 范围：EPSG:4513 到 EPSG:4533
   */
  CGCS2000_GK_Zone_3: "CGCS2000_GK_Zone_3",

  /**
   * CGCS2000 Gauss-Kruger Zone 平面投影，6度分带，横坐标前加带号。
   * 范围：EPSG:4491 到 EPSG:4501
   */
  CGCS2000_GK_Zone_6: "CGCS2000_GK_Zone_6",

  /**
   * CGCS2000 Gauss-Kruger CM 平面投影，3度分带，横坐标前不加带号。
   * 范围：EPSG:4534 到 EPSG:4554
   */
  CGCS2000_GK_CM_3: "CGCS2000_GK_CM_3",

  /**
   * CGCS2000 Gauss-Kruger CM 平面投影，6度分带，横坐标前不加带号。
   * 范围：EPSG:4502 到 EPSG:4512
   */
  CGCS2000_GK_CM_6: "CGCS2000_GK_CM_6"
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChinaCRS; });
/**
 * 国内偏移坐标系 枚举
 *  @enum {String}
 */
var ChinaCRS = {
  /**
   * 标准无偏坐标系
   */
  WGS84: "WGS84",

  /**
   * 国测局(GCJ02)偏移坐标系
   */
  GCJ02: "GCJ02",

  /**
   * 百度(BD09) 偏移坐标系
   */
  BAIDU: "BD09"
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__19__;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(104);

var iterableToArray = __webpack_require__(105);

var unsupportedIterableToArray = __webpack_require__(106);

var nonIterableSpread = __webpack_require__(107);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arcgisToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return geojsonToArcGIS; });
/* @preserve
* @terraformer/arcgis - v2.0.7 - MIT
* Copyright (c) 2012-2021 Environmental Systems Research Institute, Inc.
* Thu Jul 22 2021 13:58:30 GMT-0700 (Pacific Daylight Time)
*/
/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */

var edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }

  return false;
};
var coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {
  var contains = false;

  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }

  return contains;
};
var pointsEqual = function pointsEqual(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
};
var arrayIntersectsArray = function arrayIntersectsArray(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }

  return false;
};

/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */

var closeRing = function closeRing(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }

  return coordinates;
}; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
// points-are-in-clockwise-order

var ringIsClockwise = function ringIsClockwise(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;

  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }

  return total >= 0;
}; // This function ensures that rings are oriented in the right directions
// from http://jsperf.com/cloning-an-object/2

var shallowClone = function shallowClone(obj) {
  var target = {};

  for (var i in obj) {
    // both arcgis attributes and geojson props are just hardcoded keys
    if (obj.hasOwnProperty(i)) {
      // eslint-disable-line no-prototype-builtins
      target[i] = obj[i];
    }
  }

  return target;
};

/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */

var coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);

  if (!intersects && contains) {
    return true;
  }

  return false;
}; // do any polygons in this array contain any other polygons in this array?
// used for checking for holes in arcgis rings


var convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {
  var outerRings = [];
  var holes = [];
  var x; // iterator

  var outerRing; // current outer ring being evaluated

  var hole; // current hole being evaluated
  // for each ring

  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));

    if (ring.length < 4) {
      continue;
    } // is this ring an outer ring? is it clockwise?


    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance

      outerRings.push(polygon); // push to outer rings
    } else {
      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance
    }
  }

  var uncontainedHoles = []; // while there are holes left...

  while (holes.length) {
    // pop a hole off out stack
    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.

    var contained = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (coordinatesContainCoordinates(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    } // ring is not contained in any outer ring
    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320


    if (!contained) {
      uncontainedHoles.push(hole);
    }
  } // if we couldn't match any holes using contains we can try intersects...


  while (uncontainedHoles.length) {
    // pop a hole off out stack
    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.

    var intersects = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (arrayIntersectsArray(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }

    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }

  if (outerRings.length === 1) {
    return {
      type: 'Polygon',
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: 'MultiPolygon',
      coordinates: outerRings
    };
  }
};

var getId = function getId(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {
      return attributes[key];
    }
  }

  throw Error('No valid id attribute found');
};

var arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {
  var geojson = {};

  if (arcgis.features) {
    geojson.type = 'FeatureCollection';
    geojson.features = [];

    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));
    }
  }

  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {
    geojson.type = 'Point';
    geojson.coordinates = [arcgis.x, arcgis.y];

    if (typeof arcgis.z === 'number') {
      geojson.coordinates.push(arcgis.z);
    }
  }

  if (arcgis.points) {
    geojson.type = 'MultiPoint';
    geojson.coordinates = arcgis.points.slice(0);
  }

  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = 'LineString';
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = 'MultiLineString';
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }

  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }

  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {
    geojson.type = 'Polygon';
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }

  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = 'Feature';
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;

    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {// don't set an id
      }
    }
  } // if no valid geometry was encountered


  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }

  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));
  }

  return geojson;
};

/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
// outer rings are clockwise, holes are counterclockwise
// used for converting GeoJSON Polygons to ArcGIS Polygons

var orientRings = function orientRings(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));

  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }

    output.push(outerRing);

    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));

      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }

        output.push(hole);
      }
    }
  }

  return output;
}; // This function flattens holes in multipolygons to one array of polygons
// used for converting GeoJSON Polygons to ArcGIS Polygons


var flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {
  var output = [];

  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);

    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }

  return output;
};

var geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {
  idAttribute = idAttribute || 'OBJECTID';
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;

  switch (geojson.type) {
    case 'Point':
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];

      if (geojson.coordinates[2]) {
        result.z = geojson.coordinates[2];
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiPoint':
      result.points = geojson.coordinates.slice(0);

      if (geojson.coordinates[0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'LineString':
      result.paths = [geojson.coordinates.slice(0)];

      if (geojson.coordinates[0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiLineString':
      result.paths = geojson.coordinates.slice(0);

      if (geojson.coordinates[0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'Polygon':
      result.rings = orientRings(geojson.coordinates.slice(0));

      if (geojson.coordinates[0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiPolygon':
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));

      if (geojson.coordinates[0][0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'Feature':
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);
      }

      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};

      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }

      break;

    case 'FeatureCollection':
      result = [];

      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));
      }

      break;

    case 'GeometryCollection':
      result = [];

      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));
      }

      break;
  }

  return result;
};

/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */




/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getCameraView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return expImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return pick3DTileset; });
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);


 //取屏幕中心点坐标

function getCenter(scene) {
  var canvas = scene.canvas;
  var center = new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian2"](canvas.clientWidth / 2, canvas.clientHeight / 2);
  var ray = scene.camera.getPickRay(center);
  var target = scene.globe.pick(ray, scene);

  if (!target) {
    target = scene.camera.pickEllipsoid(center);
  }

  var point = _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].fromCartesian(target);
  return point;
} //提取地球视域边界

function getExtent(map) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // 范围对象
  var extent; // var rectangle = map.camera.computeViewRectangle(); //不支持二维模式
  // if (rectangle == null) return null;
  // var extent = formatRectangle(rectangle);  // 范围对象
  //默认值：中国区域

  extent = {
    xmin: 70,
    xmax: 140,
    ymin: 0,
    ymax: 55,
    height: 0
  }; // 得到当前三维场景

  var scene = map.scene; // 得到当前三维场景的椭球体

  var ellipsoid = scene.globe.ellipsoid;
  var canvas = scene.canvas; // canvas左上角

  var car3_lt = map.camera.pickEllipsoid(new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian2"](0, 0), ellipsoid);

  if (car3_lt) {
    // 在椭球体上
    var carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
    extent.xmin = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto_lt.longitude);
    extent.ymax = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto_lt.latitude);
    extent.height = Math.max(extent.height, carto_lt.height);
  } else {
    // 不在椭球体上
    var xMax = canvas.width / 2;
    var yMax = canvas.height / 2;
    var car3_lt2; // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率

    for (var yIdx = 0; yIdx <= yMax; yIdx += 10) {
      var xIdx = yIdx <= xMax ? yIdx : xMax;
      car3_lt2 = map.camera.pickEllipsoid(new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian2"](xIdx, yIdx), ellipsoid);

      if (car3_lt2) {
        break;
      }
    }

    if (car3_lt2) {
      var _carto_lt = ellipsoid.cartesianToCartographic(car3_lt2);

      extent.xmin = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(_carto_lt.longitude);
      extent.ymax = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(_carto_lt.latitude);
      extent.height = Math.max(extent.height, _carto_lt.height);
    }
  } // canvas右下角


  var car3_rb = map.camera.pickEllipsoid(new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian2"](canvas.width, canvas.height), ellipsoid);

  if (car3_rb) {
    // 在椭球体上
    var carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
    extent.xmax = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto_rb.longitude);
    extent.ymin = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(carto_rb.latitude);
    extent.height = Math.max(extent.height, carto_rb.height);
  } else {
    // 不在椭球体上
    var _xMax = canvas.width / 2;

    var _yMax = canvas.height / 2;

    var car3_rb2; // 这里每次10像素递减，一是10像素相差不大，二是为了提高程序运行效率

    for (var _yIdx = canvas.height; _yIdx >= _yMax; _yIdx -= 10) {
      var _xIdx = _yIdx >= _xMax ? _yIdx : _xMax;

      car3_rb2 = map.camera.pickEllipsoid(new cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian2"](_xIdx, _yIdx), ellipsoid);

      if (car3_rb2) {
        break;
      }
    }

    if (car3_rb2) {
      var _carto_rb = ellipsoid.cartesianToCartographic(car3_rb2);

      extent.xmax = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(_carto_rb.longitude);
      extent.ymin = cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(_carto_rb.latitude);
      extent.height = Math.max(extent.height, _carto_rb.height);
    }
  }

  if (!extent) {
    return;
  } //交换


  if (extent.xmax < extent.xmin) {
    var temp = extent.xmax;
    extent.xmax = extent.xmin;
    extent.xmin = temp;
  }

  if (extent.ymax < extent.ymin) {
    var _temp = extent.ymax;
    extent.ymax = extent.ymin;
    extent.ymin = _temp;
  } //截取长度


  if (options.formatNum) {
    extent.xmin = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(extent.xmin, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);
    extent.xmax = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(extent.xmax, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);
    extent.ymin = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(extent.ymin, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);
    extent.ymax = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(extent.ymax, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);
  }

  return extent;
} //提取相机视角范围参数

function getCameraView(camera, options) {
  var _options$simplify;

  var position = camera.positionCartographic;
  var bookmark = {};
  bookmark.lat = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(position.latitude), _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);
  bookmark.lng = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(position.longitude), _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatLength);

  if ((_options$simplify = options === null || options === void 0 ? void 0 : options.simplify) !== null && _options$simplify !== void 0 ? _options$simplify : true) {
    bookmark.alt = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(position.height, 0);
    bookmark.heading = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(camera.heading || 0) % 360, 0);
    bookmark.pitch = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(camera.pitch || 0) % 360, 0);
  } else {
    bookmark.alt = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(position.height, _core_LatLngPoint__WEBPACK_IMPORTED_MODULE_1__[/* LatLngPoint */ "a"].FormatAltLength);
    bookmark.heading = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(camera.heading || 0) % 360, 1);
    bookmark.pitch = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(camera.pitch || 0) % 360, 1);
    bookmark.roll = Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["formatNum"])(cesium__WEBPACK_IMPORTED_MODULE_0__["Math"].toDegrees(camera.roll || 0) % 360, 1);
  }

  return bookmark;
} //截图，导出地图场景图片

function expImage(viewer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.download = cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](options.download, true);
  options.type = cesium__WEBPACK_IMPORTED_MODULE_0__["defaultValue"](options.type, "image/jpeg");
  var width, height;
  var callback = options.callback;
  viewer.render();
  var imgdata = viewer.canvas.toDataURL(options.type, options.encoderOptions);

  if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](options.width) || cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](options.height)) {
    //指定了高或宽度后，图片压缩处理
    var image = new Image();

    image.onload = function () {
      //图片压缩处理
      if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](options.width)) {
        width = options.width;
        height = options.height || Math.round(width * viewer.canvas.height / viewer.canvas.width);
      } else {
        height = options.height;
        width = Math.round(height * viewer.canvas.width / viewer.canvas.height);
      }

      var canvas, ctx;
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0, width, height);
      var imgdataNew = canvas.toDataURL(options.type, options.encoderOptions);

      if (!options.filename) {
        options.filename = "场景出图_" + width + "x" + height;
      }

      if (options.download) {
        Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["downloadBase64Image"])(options.filename, imgdataNew);
      }

      if (callback) {
        callback(imgdataNew, {
          width: width,
          height: height
        });
      }
    };

    image.src = imgdata;
  } else {
    //高清原图
    height = viewer.canvas.height;
    width = viewer.canvas.width;

    if (!options.filename) {
      options.filename = "场景出图_" + width + "x" + height;
    }

    if (options.download) {
      Object(_util_Util__WEBPACK_IMPORTED_MODULE_2__["downloadBase64Image"])(options.filename, imgdata);
    }

    if (callback) {
      callback(imgdata, {
        width: width,
        height: height
      });
    }
  }
} //获取坐标点处的3dtiles模型，用于计算贴地时进行判断（和视角有关系，不一定精确）

function pick3DTileset(scene, positions) {
  if (!positions) {
    return null;
  }

  if (positions instanceof cesium__WEBPACK_IMPORTED_MODULE_0__["Cartesian3"]) {
    positions = [positions];
  }

  for (var i = 0, len = positions.length; i < len; ++i) {
    var position = positions[i];
    var coorPX = cesium__WEBPACK_IMPORTED_MODULE_0__["SceneTransforms"].wgs84ToWindowCoordinates(scene, position);

    if (!cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](coorPX)) {
      continue;
    }

    var pickedObject = scene.pick(coorPX, 10, 10);

    if (cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject) && cesium__WEBPACK_IMPORTED_MODULE_0__["defined"](pickedObject.primitive) && pickedObject.primitive instanceof cesium__WEBPACK_IMPORTED_MODULE_0__["Cesium3DTileset"]) {
      // Cesium.defined(pickedObject.primitive.isCesium3DTileset)
      return pickedObject.primitive;
    }
  }

  return null;
}

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TerrainType; });
/**
 * 地形类型
 * @enum {String}
 */
var TerrainType = {
  /**
   * 无地形
   */
  NONE: "none",

  /**
   * 标准xyz瓦片地形
   */
  XYZ: "xyz",

  /**
   * arcgis地形
   */
  ARCGIS: "arcgis",

  /**
   * ION在线地形(cesium官方服务)
   */
  ION: "ion",

  /**
   * GoogleEarth Enterprise 地形服务
   */
  GEE: "gee",

  /**
   * VR 地形
   */
  VR: "vr"
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return image; });
//当前版本  2021-5-20 - 至今
var version = '3.0.37'; //编译时间

var update = '2022-12-26 14:25:59';
var image = null; //打印信息

eval("var msg = `%c\uD83C\uDF12%c Tudou3D\u4E09\u7EF4\u5730\u7403\u5E73\u53F0\u8F6F\u4EF6 %c\n\n  \u7248 \u672C \u53F7\uFF1A3.0.37    ${window.Cesium && window.Cesium.VERSION?'Cesium\u7248\u672C\uFF1A'+window.Cesium.VERSION:''}\n  \u7F16\u8BD1\u65E5\u671F\uFF1A2022-12-26 14:25:59\n  \u6388\u6743\u4FE1\u606F\uFF1A\u6388\u6743\"\u571F\u8C46\u6570\u636E\u79D1\u6280\u96C6\u56E2\u6709\u9650\u516C\u53F8\"\u6C38\u4E45\u4F7F\u7528\u6B64\u8F6F\u4EF6\u5F53\u524D\u7248\u672C\u3002\n  \u7248\u6743\u58F0\u660E\uFF1A\n  1. Tudou3D\u7248\u6743\u5B8C\u5168\u5C5E\u4E8E \"\u571F\u8C46\u6570\u636E\u79D1\u6280\u6709\u9650\u516C\u53F8\".\n  2.\u5F53\u524D\u57FA\u4E8ETudou3D\u4E8C\u6B21\u5F00\u53D1\u7684\u9879\u76EE\u6240\u6709\u6743\u76CA\u5C5E\u4E8E\"\u571F\u8C46\u6570\u636E\u79D1\u6280\u96C6\u56E2\u6709\u9650\u516C\u53F8\"\u72EC\u81EA\u6240\u6709.\n  `;\nconsole.log(msg,\n   'font-size: 19px;padding-left: 10px;\tcolor: rgb(240, 133, 25);',\n   'font-size: 15px;\tline-height: 1.5;\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";color: rgb(240, 133, 25);\tpadding-bottom: 5px;',\n   'font-size: 12px;\tline-height: 1.5;\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";color: rgb(0, 138, 255);'  );");

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphicType; });
/**
 * 矢量数据类型
 * @enum {String}
 *
 * @property {String} 	label 文本点,对应类为：{@link LabelEntity }
 * @property {String} 	labelP 文本点（图元）,对应类为：{@link LabelPrimitive }
 * @property {String} 	point 像素点,，对应类为：{@link PointEntity }
 * @property {String} 	pointP 像素点（图元），对应类为：{@link PointPrimitive }
 * @property {String} 	billboard 图标点，对应类为：{@link BillboardEntity }
 * @property {String} 	divBillboard HTML转图片后的图标点，对应类为：{@link DivBillboardEntity }
 * @property {String} 	fontBillboard Font CSS字体点转图片后的图标点，对应类为：{@link FontBillboardEntity }
 * @property {String} 	billboardP 图标点（图元），对应类为：{@link BillboardPrimitive }
 * @property {String} 	model gltf小模型，对应类为：{@link ModelEntity }
 * @property {String} 	modelP gltf小模型（图元）对应类为：{@link ModelPrimitive }
 * @property {String} 	modelCombine gltf小模型（数据集），对应类为：{@link ModelCombine }
 * @property {String} 	plane 平面，对应类为：{@link PlaneEntity }
 * @property {String} 	planeP 平面（图元），对应类为：{@link PlanePrimitive }
 * @property {String} 	box 盒子，对应类为：{@link BoxEntity }
 * @property {String} 	boxP 盒子（图元），对应类为：{@link BoxPrimitive }
 * @property {String} 	circle 圆、圆柱，对应类为：{@link CircleEntity }
 * @property {String} 	circleP 圆、圆柱（图元）对应类为：{@link CirclePrimitive }
 * @property {String} 	ellipse 椭圆、椭圆柱，对应类为：{@link EllipseEntity }
 * @property {String} 	cylinder 圆锥，对应类为：{@link CylinderEntity }
 * @property {String} 	cylinderP 圆锥（图元），对应类为：{@link CylinderPrimitive }
 * @property {String} 	coneTrack 圆锥追踪体，对应类为：{@link ConeTrack }
 * @property {String} 	ellipsoid 球体，对应类为：{@link EllipsoidEntity }
 * @property {String} 	ellipsoidP 球体（图元），对应类为：{@link EllipsoidPrimitive }
 * @property {String} 	polyline 线，对应类为：{@link PolylineEntity }
 * @property {String} 	curve 曲线，对应类为：{@link CurveEntity }
 * @property {String} 	polylineP 线（图元），对应类为：{@link PolylinePrimitive }
 * @property {String} 	polylineCombine 大数据线（数据集）对应类为：{@link PolylineCombine }
 * @property {String} 	polylineVolume 管道线，对应类为：{@link PolylineVolumeEntity }
 * @property {String} 	polylineVolumeP 管道线（图元），对应类为：{@link PolylineVolumePrimitive }
 * @property {String} 	path 路径，对应类为：{@link PathEntity }
 * @property {String} 	corridor 走廊，对应类为：{@link CorridorEntity }
 * @property {String} 	corridorP 走廊（图元），对应类为：{@link CorridorPrimitive }
 * @property {String} 	wall 墙，对应类为：{@link WallEntity }
 * @property {String} 	wallP 墙（图元），对应类为：{@link WallPrimitive }
 * @property {String} 	polygon 面，对应类为：{@link PolygonEntity }
 * @property {String} 	polygonP 面（图元）对应类为：{@link PolygonPrimitive }
 * @property {String} 	polygonCombine 大数据面（数据集）对应类为：{@link PolygonCombine }
 * @property {String} 	rectangle 矩形，对应类为：{@link RectangleEntity }
 * @property {String} 	rectangleP 矩形（图元），对应类为：{@link RectanglePrimitive }
 * @property {String} 	frustum 四棱锥体（图元），对应类为：{@link FrustumPrimitive }
 *
 * @property {String} 	water 水域面，对应类为：{@link Water }
 * @property {String} 	div DIV点，对应类为：{@link DivGraphic }
 * @property {String} 	divLightPoint 动画的扩散div点，对应类为：{@link DivLightPoint }
 * @property {String} 	divUpLabel 竖立的文本DIV点，对应类为：{@link DivUpLabel }
 * @property {String} 	divBoderLabel 动态边框文本DIV点，对应类为：{@link DivBoderLabel }
 *
 * @property {String} 	particleSystem 粒子效果，对应类为：{@link ParticleSystem }
 * @property {String} 	video2D 视频融合（投射2D平面），对应类为：{@link Video2D }
 * @property {String} 	video3D 视频融合（投射3D，贴物体表面）对应类为：{@link Video3D }
 * @property {String} 	flatBillboard 平放的图标（数据集），对应类为：{@link FlatBillboard }
 * @property {String} 	lightCone 光锥体，对应类为：{@link LightCone }
 * @property {String} 	scrollWall 走马灯围墙效果，对应类为：{@link ScrollWall }
 * @property {String} 	diffuseWall 立体面(或圆)散射效果，对应类为：{@link DiffuseWall }
 * @property {String} 	dynamicRiver 动态河流，对应类为：{@link DynamicRiver }
 * @property {String} 	road 道路，对应类为：{@link Road }
 * @property {String} 	rectangularSensor 相控阵雷达，对应类为：{@link RectangularSensor }
 * @property {String} 	pit 井，对应类为：{@link Pit }
 *
 * @property {String} 	attackArrow 攻击箭头，对应类为：{@link AttackArrow }
 * @property {String} 	attackArrowPW 攻击箭头(平尾)，对应类为：{@link AttackArrowPW }
 * @property {String} 	attackArrowYW 攻击箭头（燕尾），对应类为：{@link AttackArrowYW }
 * @property {String} 	doubleArrow 双箭头（钳击），对应类为：{@link DoubleArrow }
 * @property {String} 	fineArrow 直箭头(2个点)，对应类为：{@link FineArrow }
 * @property {String} 	fineArrowYW 燕尾直箭头(2个点)，对应类为：{@link FineArrowYW }
 * @property {String} 	straightArrow 直箭头(3个点)，对应类为：{@link StraightArrow }
 * @property {String} 	lune 弓形面(3个点)，对应类为：{@link Lune }
 * @property {String} 	sector 扇形(3个点)，对应类为：{@link Sector }
 * @property {String} 	regular 正多边形，对应类为：{@link Regular }
 * @property {String} 	isosTriangle 等腰三角形(3个点)，对应类为：{@link IsosTriangle }
 * @property {String} 	closeVurve 闭合曲面(3个点)，对应类为：{@link CloseVurve }
 * @property {String} 	gatheringPlace 集结地(3个点)，对应类为：{@link GatheringPlace }
 *
 * @property {String} 	camberRadar 双曲面拱形雷达【tudou3d-space插件】，对应类为：{@link CamberRadar }
 * @property {String} 	conicSensor 圆锥体（单目标雷达）【tudou3d-space插件】，对应类为：{@link ConicSensor }
 * @property {String} 	rectSensor 四棱锥体【tudou3d-space插件】，对应类为：{@link RectSensor }
 * @property {String} 	satelliteSensor 卫星视锥综合体（圆锥或四凌锥）【tudou3d-space插件】，对应类为：{@link SatelliteSensor }
 * @property {String} 	satellite 卫星综合体【tudou3d-space插件】，对应类为：{@link Satellite }
 */
var GraphicType = {};


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addImage; });
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _const_Version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);


var customImage;
function setImage(custom) {
  customImage = custom;
}
function addImage(viewer, noTime) {
  var thisImg = _const_Version__WEBPACK_IMPORTED_MODULE_1__[/* image */ "a"] || customImage;

  if (!thisImg) {
    return;
  }

  var re = thisImg.rectangle || [10, 5, 88, 20];
  var viewportQuad = new cesium__WEBPACK_IMPORTED_MODULE_0__["ViewportQuad"]();
  viewportQuad.rectangle = new cesium__WEBPACK_IMPORTED_MODULE_0__["BoundingRectangle"](re[0], re[1], re[2], re[3]);
  viewportQuad.material = new cesium__WEBPACK_IMPORTED_MODULE_0__["Material"]({
    fabric: {
      type: "Image",
      uniforms: {
        color: new cesium__WEBPACK_IMPORTED_MODULE_0__["Color"](1.0, 1.0, 1.0, 1.0),
        image: thisImg.url
      }
    }
  });
  viewportQuad._muyao = true;
  viewer.scene.primitives.add(viewportQuad); //随机10分钟-20分钟内再次校验

  if (!noTime) {
    setInterval(function () {
      if (!checkHasImage(viewer)) {
        addImage(viewer, true);
      }
    }, 600000 + Math.random() * 600000);
  }

  return viewportQuad;
} //校验 图是否存在

function checkHasImage(viewer) {
  if (!viewer.scene || viewer.scene.primitives.length == 0) {
    return false;
  }

  for (var i = 0, len = viewer.scene.primitives.length; i < len; ++i) {
    var p = viewer.scene.primitives.get(i);

    if (p._muyao) {
      return true;
    }
  }

  return false;
}

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Lang; });
/**
 * 多语种文本配置，
 * 值为数组，对应{@link LangType}按照固定顺序排列,如：[中文简体,中文繁體,English]
 * @type {String}
 * @example
 *  tudou3d.Lang["_单击开始绘制"][tudou3d.LangType.ZH] ="新的中文提示语句";
 */
var Lang = {
  _放大: ["放大", "放大", "Zoom In"],
  _缩小: ["缩小", "縮小", "Zoom Out"],
  _查看此处坐标: ["查看此处坐标", "查看此處坐標", "Location info"],
  _位置信息: ["位置信息", "位置信息", "The location information"],
  _经度: ["经度", "經度", "Lon"],
  _纬度: ["纬度", "緯度", "Lat"],
  _海拔: ["高程", "高程", "Alt"],
  _横坐标: ["横坐标", "橫坐標", "X"],
  _纵坐标: ["纵坐标：", "縱坐標", "Y"],
  _查看当前视角: ["查看当前视角", "查看當前視角", "Camera info"],
  _当前视角信息: ["当前视角信息", "當前視角信息", "Current Camera Information"],
  _视角切换: ["视角切换", "視角切換", "Camera"],
  _禁止进入地下: ["禁止进入地下", "禁止進入地下", "Do not go underground"],
  _允许进入地下: ["允许进入地下", "允許進入地下", "Access to the ground"],
  _绕此处环绕飞行: ["绕此处环绕飞行", "繞此處環繞飛行", "Fly around here"],
  _关闭环绕飞行: ["关闭环绕飞行", "關閉環繞飛行", "Close off circling"],
  _移动到此处: ["移动到此处", "移動到此處", "Move it over here"],
  _第一视角站到此处: ["第一视角站到此处", "第一視角站到此處", "First view is here"],
  _开启键盘漫游: ["开启键盘漫游", "開啓鍵盤漫遊", "Enable keyboard roaming"],
  _关闭键盘漫游: ["关闭键盘漫游", "關閉鍵盤漫遊", "Turn off keyboard roaming"],
  _取消锁定: ["取消锁定", "取消鎖定", "Unlocked"],
  _三维模型: ["三维模型", "三維模型", "3DTiles"],
  _显示三角网: ["显示三角网", "顯示三角網", "Display Wireframe"],
  _关闭三角网: ["关闭三角网", "關閉三角網", "Close Wireframe"],
  _显示包围盒: ["显示包围盒", "顯示包圍盒", "Display BoundingVolume"],
  _关闭包围盒: ["关闭包围盒", "關閉包圍盒", "Close BoundingVolume"],
  _地形服务: ["地形服务", "地形服務", "Terrain"],
  _显示地形: ["显示地形", "顯示地形", "Open terrain"],
  _关闭地形: ["关闭地形", "關閉地形", "Close terrain"],
  _图上标记: ["图上标记", "圖上標記", "Drawing"],
  _标记点: ["标记点", "標記點", "Mark points"],
  _标记线: ["标记线", "標記線", "Tag line"],
  _标记面: ["标记面", "標記面", "Mark surface"],
  _标记圆: ["标记圆", "標記圓", "Mark round"],
  _标记矩形: ["标记矩形", "標記矩形", "Mark rectangular"],
  _允许编辑: ["允许编辑", "允許編輯", "Allowed to edit"],
  _禁止编辑: ["禁止编辑", "禁止編輯", "Prohibit to edit"],
  _导出GeoJSON: ["导出GeoJSON", "導出GeoJSON", "Export GeoJSON"],
  _清除所有标记: ["清除所有标记", "清除所有標記", "Clear"],
  _特效效果: ["特效效果", "特效效果", "Effects"],
  _开启下雨: ["开启下雨", "開啓下雨", "Enable rain"],
  _关闭下雨: ["关闭下雨", "關閉下雨", "Close rain"],
  _开启下雪: ["开启下雪", "開啓下雪", "Enable snow"],
  _关闭下雪: ["关闭下雪", "關閉下雪", "Close snow"],
  _开启雾天气: ["开启雾天气", "開啓霧天氣", "Enable fog"],
  _关闭雾天气: ["关闭雾天气", "關閉霧天氣", "Close fog"],
  _开启泛光: ["开启泛光", "開啓泛光", "Enable bloom"],
  _关闭泛光: ["关闭泛光", "關閉泛光", "Close bloom"],
  _开启亮度: ["开启亮度", "開啓亮度", "Enable brightness"],
  _关闭亮度: ["关闭亮度", "關閉亮度", "Close brightness"],
  _开启夜视: ["开启夜视", "開啓夜視", "Enable night vision"],
  _关闭夜视: ["关闭夜视", "關閉夜視", "Close night vision"],
  _开启黑白: ["开启黑白", "開啓黑白", "Enable black and white"],
  _关闭黑白: ["关闭黑白", "關閉黑白", "Close black and white"],
  _场景设置: ["场景设置", "場景設置", "Scene"],
  _开启深度监测: ["开启深度监测", "開啓深度監測", "Enable depth test against terrain"],
  _关闭深度监测: ["关闭深度监测", "關閉深度監測", "Close depth test against terrain"],
  _显示星空背景: ["显示星空背景", "顯示星空背景", "Enable skyBox"],
  _关闭星空背景: ["关闭星空背景", "關閉星空背景", "Close skyBox"],
  _开启日照阴影: ["开启日照阴影", "開啓日照陰影", "Enable shadow"],
  _关闭日照阴影: ["关闭日照阴影", "關閉日照陰影", "Close shadow"],
  _开启大气渲染: ["开启大气渲染", "開啓大氣渲染", "Enable sky atmosphere"],
  _关闭大气渲染: ["关闭大气渲染", "關閉大氣渲染", "Close sky atmosphere"],
  _场景出图: ["场景出图", "場景出圖", "Export image"],
  _删除测量: ["删除测量", "刪除測量", "Delete"],
  _角度: ["角度", "角度", "Angle"],
  _距离: ["距离", "距離", "Distance"],
  _面积: ["面积", "面積", "Area"],
  _总长: ["总长", "總長", "Total distance"],
  _起点: ["起点", "起點", "Start"],
  _高度差: ["高度差", "高度差", "Height difference"],
  _空间距离: ["空间距离", "空間距離", "Space distance"],
  _水平距离: ["水平距离", "水平距離", "Horizontal distance"],
  _正在计算体积: ["正在计算体积", "正在計算體積", "Calculating volume"],
  _填方体积: ["填方体积", "填方體積", "The volume of fill"],
  _挖方体积: ["挖方体积", "挖方體積", "Excavation volume"],
  _横切面积: ["横切面积", "橫切面積", "Crosscutting area"],
  _面上: ["面上", "面上", "Up"],
  _面下: ["面下", "面下", "Down"],
  _米: ["米", "米", "m"],
  _公里: ["公里", "公裏", "km"],
  _海里: ["海里", "海裏", "mile"],
  _丈: ["丈", "丈", "zhang"],
  _平方米: ["平方米", "平方米", "m²"],
  _平方公里: ["平方公里", "平方公裏", "km²"],
  _亩: ["亩", "畝", "mu"],
  _公顷: ["公顷", "公頃", "ha"],
  _立方米: ["方", "方", "m³"],
  _万立方米: ["万方", "万方", "wm³"],
  _单击开始绘制: ["单击开始绘制", "單擊開始繪制", "Click to start drawing"],
  _单击完成绘制: ["单击完成绘制", "單擊完成繪制", "Click to finish drawing"],
  _双击完成绘制: ["双击完成绘制", "雙擊完成繪制", "Double click to finish drawing"],
  _单击增加点右击删除点: ["单击增加点，右击删除点", "單擊增加點，右擊刪除點", "left click add point, right click delete point"],
  _激活编辑提示: ["单击后 激活编辑<br/>右击菜单删除", "單擊後 激活編輯<br/>右擊菜單刪除", "Click to activate editing <br/> Right click menu to delete"],
  _释放后完成修改: ["释放后完成修改", "釋放後完成修改", "Complete the modification after release"],
  _该对象不允许编辑: ["该对象不允许编辑", "該對象不允許編輯", "This object does not allow editing"],
  _拖动该点后: ["拖动该点后", "拖動該點後", "Drag that point"],
  _修改位置: ["修改位置", "修改位置", "Modify the position"],
  _整体平移: ["整体平移", "整體平移", "The overall translation"],
  _增加点: ["增加点", "增加點", "Add point"],
  _修改高度: ["修改高度", "修改高度", "Modify the height"],
  _修改半径: ["修改半径", "修改半徑", "Modify the radius"],
  _修改长度: ["修改长度(X方向)", "修改長度(X方向)", "Modify the length(X direction )"],
  _修改宽度: ["修改宽度(Y方向)", "修改寬度(Y方向)", "Change the width(Y direction)"],
  _修改方向: ["修改方向", "修改方向", "Change direction"],
  _修改缩放比例: ["修改缩放比例", "修改縮放比例", "Modify the Scale"],
  _右击删除该点: ["右击删除该点", "右擊刪除該點", "Right click to delete the point"],
  _无法删除不能少于最小点数: ["无法删除，点数量不能少于", "無法刪除，點數量不能少于", "Cannot delete, the number of dots cannot be less than"],
  _删除: ["删除", "刪除", "Delete"]
};


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LayerType; });
/**
 * 图层类型
 * @enum {String}
 *
 * @property {String} tdt 天地图在线地图,对应类为：{@link TdtLayer }
 * @property {String} baidu 百度在线地图,对应类为：{@link BaiduLayer }
 * @property {String} gaode 高德在线地图,对应类为：{@link GaodeLayer }
 * @property {String} tencent 腾讯在线地图,对应类为：{@link TencentLayer}
 * @property {String} osm OSM在线地图,对应类为：{@link OsmLayer}
 * @property {String} google 谷歌在线地图,对应类为：{@link GoogleLayer }
 * @property {String} bing 微软Bing地图,对应类为：{@link BingLayer}
 * @property {String} mapbox Mapbox在线地图,对应类为：{@link MapboxLayer }
 * @property {String} ion Cesium Ion在线地图,对应类为：{@link IonLayer }
 *
 * @property {String} image  单张图片,对应类为：{@link ImageLayer}
 * @property {String} xyz 标准XYZ金字塔,对应类为：{@link XyzLayer }
 * @property {String} arcgis ArcGIS服务,对应类为：{@link ArcGisLayer}
 * @property {String} arcgis_cache  AraGIS生成的金字塔瓦片数据 ,对应类为：{@link ArcGisCacheLayer}
 * @property {String} wms OGC标准的WMS服务,对应类为：{@link WmsLayer }
 * @property {String} wmts OGC标准的WMTS服务,对应类为：{@link WmtsLayer }
 * @property {String} tms 由MapTiler、GDAL2Tiles等生成的瓦片数据图层,对应类为：{@link TmsLayer }
 * @property {String} gee GoogleEarth Enterprise 地图服务,对应类为：{@link GeeLayer}
 *
 * @property {String} tileinfo 瓦片信息（一般用于测试）,对应类为：{@link TileInfoLayer}
 * @property {String} grid 网格线（一般用于无地图模式）,对应类为：{@link  GridLayer}
 *
 * @property {String} terrain 地形服务,对应类为：{@link TerrainLayer}
 * @property {String} group 图层组,对应类为：{@link GroupLayer}
 *
 * @property {String} graphic 矢量数据图层,对应类为：{@link GraphicLayer}
 * @property {String} graphicGroup 矢量数据图层组,对应类为：{@link GraphicGroupLayer }
 * @property {String} div DIV图层,对应类为：{@link DivLayer }
 * @property {String} geojson GeoJson格式数据（使用Graphic渲染）,对应类为：{@link GeoJsonLayer }
 *
 * @property {String} lodGraphic LOD分层分块加载矢量数据,对应类为：{@link LodGraphicLayer }
 * @property {String} wfs OGC标准的WFS服务,对应类为：{@link WfsLayer }
 * @property {String} arcgis_wfs ArcGIS Feature Server服务（分块分层加载）,对应类为：{@link ArcGisWfsLayer }
 * @property {String} arcgis_wfs_single  ArcGIS Feature Server服务（一次性加载，适合小数据）,对应类为：{@link ArcGisWfsSingleLayer}
 *
 * @property {String} model gltf小模型图层,对应类为：{@link ModelLayer }
 * @property {String} tileset或3dtiles  3dtiles三维模型图层,对应类为：{@link TilesetLayer }
 *
 * @property {String} czmGeojson GeoJson数据图层(Cesium原生加载渲染),对应类为：{@link CzmGeoJsonLayer }
 * @property {String} kml  kml数据图层(Cesium原生加载渲染),对应类为：{@link KmlLayer }
 * @property {String} czml czml数据图层(Cesium原生加载渲染),对应类为：{@link CzmlLayer }
 *
 * @property {String} graticule 经纬网,对应类为：{@link GraticuleLayer }
 * @property {String} gaodePOI 高德POI服务,对应类为：{@link GeodePoiLayer }
 * @property {String} osmBuildings OSM在线三维白膜服务,对应类为：{@link OsmBuildingsLayer }
 * @property {String} tdt_dm 天地图三维地名【tudou3d-tdt插件】,对应类为：{@link TdtDmLayer }
 *
 * @property {String} supermap_s3m 超图S3M图层【tudou3d-supermap插件】,对应类为：{@link SmMvtLayer }
 * @property {String} supermap_img 超图影像切片图层【tudou3d-supermap插件】,对应类为：{@link SmImgLayer }
 * @property {String} supermap_mvt 超图MVT矢量瓦片图层【tudou3d-supermap插件】,对应类为：{@link SmMvtLayer }
 *
 * @property {String} mapv MapV图层【tudou3d-mapv插件】,对应类为：{@link MapVLayer}
 * @property {String} echarts Echarts图层【tudou3d-echarts插件】,对应类为：{@link EchartsLayer }
 * @property {String} heat 热力图图层【tudou3d-heat插件】,对应类为：{@link HeatLayer }
 * @property {String} canvasWind canvas风场图层【tudou3d-wind插件】,对应类为：{@link CanvasWindLayer }
 * @property {String} wind 风场图层【tudou3d-wind插件】,对应类为：{@link WindLayer }
 *
 *
 */
var LayerType = {};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)\n{\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n    vec3 D = czm_ellipsoidInverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n    vec3 q = D * coneVertexWC;\n    float qMagnitudeSquared = dot(q, q);\n    float test = qMagnitudeSquared - 1.0;\n    \n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n    vec3 temp = D * pointWC - q;\n    float d = dot(temp, q);\n    \n    // Behind silhouette plane and inside silhouette cone\n    return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvec4 getLineColor()\n{\n    return u_lineColor;\n}\n\nvec4 getIntersectionColor()\n{\n    return u_intersectionColor;\n}\n\nfloat getIntersectionWidth()\n{\n    return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\n    // (s, t) both in the range [0, 1]\n    float t = pointMC.z / sensorRadius;\n    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n    s = s - floor(s);\n    \n    return vec2(s, t);\n}\n"

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = "attribute vec4 position;\nattribute vec3 normal;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    gl_Position = czm_modelViewProjection * position;\n    v_position = vec3(position);\n    v_positionWC = (czm_model * position).xyz;\n    v_positionEC = (czm_modelView * position).xyz;\n    v_normalEC = czm_normal * normal;\n}"

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform float u_type;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC)\n{\n    czm_materialInput materialInput;\n\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n    materialInput.str = pointMC / sensorRadius;\n\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n    materialInput.normalEC = u_normalDirection * normalEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n    // czm_lightDirectionEC在cesium1.66开始加入的\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon)\n{\n    float width = getIntersectionWidth();\n    float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n    float pixels = width * delta;\n    float temp = abs(value);\n    // There are a couple things going on here.\n    // First we test the value at the current fragment to see if it is within the tolerance.\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\n    // but we don't want to admit points that are obviously not on the surface.\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\n    // the points is close to zero.\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n    return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary)\n{\n    if (u_showIntersection && isOnBoundary)\n    {\n        return getIntersectionColor();\n    }\n    if(u_type == 1.0){\n        return getLineColor();\n    }\n    return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point)\n{\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\n    return dot(scaled, scaled) - 1.0;\n}\n\nvoid main()\n{\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\n\n    //vec3 pixDir = normalize(v_position);\n    float positionX = v_position.x;\n    float positionY = v_position.y;\n    float positionZ = v_position.z;\n\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\n    vec3 lineY = vec3(0, positionY, positionZ);\n    float resX = dot(normalize(lineX), zDir);\n    if(resX < cos(u_xHalfAngle)-0.00001){\n        discard;\n    }\n    float resY = dot(normalize(lineY), zDir);\n    if(resY < cos(u_yHalfAngle)-0.00001){\n        discard;\n    }\n\n\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n\n    // Occluded by the ellipsoid?\n\tif (!u_showThroughEllipsoid)\n\t{\n\t    // Discard if in the ellipsoid\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\n\t    if (ellipsoidValue < 0.0)\n\t    {\n            discard;\n\t    }\n\n\t    // Discard if in the sensor's shadow\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\n\t    {\n\t        discard;\n\t    }\n    }\n\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n    //isOnEllipsoid = false;\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\n    /*if(false){\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n        gl_FragColor = shade(isOnEllipsoid);\n    }\n*/\n    gl_FragColor = shade(isOnEllipsoid);\n\n}"

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec2 u_distanceDisplayCondition;\nuniform vec3 u_eyePos;\nvarying vec3 v_worldPos;\nuniform sampler2D billImg;\nvarying vec2 v_st;\nvoid main() {\n    float dis = distance(u_eyePos, v_worldPos);\n    if (dis < u_distanceDisplayCondition.x || dis > u_distanceDisplayCondition.y) {\n        discard;\n    } else {\n        gl_FragColor = texture2D(billImg,v_st);\n    }\n}"

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 color;\nattribute vec2 st;\nattribute float batchId;\nuniform mat4 mm;\nuniform mat4 vv;\nuniform vec2 resolution;\nuniform float billWidth;\nvarying vec2 v_st;\nvarying vec3 v_worldPos;\nvec4 transform(mat4 m,mat4 v,vec3 coord) {\n    return m * v * vec4(coord, 1.0);\n}\nvec2 project(vec4 device) {\n    vec3 device_normal = device.xyz / device.w;\n    vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;\n    return clip_pos * resolution;\n}\nvec4 unproject(vec2 screen, float z, float w) {\n    vec2 clip_pos = screen / resolution;\n    vec2 device_normal = clip_pos * 2.0 - 1.0;\n    return vec4(device_normal * w, z, w);\n}\nvoid main() { \n    v_st = st;\n    vec3 currP = position3DHigh.xyz + position3DLow.xyz;\n    v_worldPos = currP;\n    vec4 eyeCurrP = transform(mm,vv,currP);\n    vec2 winCurrP = project(eyeCurrP);\n    vec3 dirEye = czm_viewRotation * color;\n    dirEye = normalize(dirEye);\n    vec2 newWinCurrP = winCurrP + dirEye.xy * billWidth;\n    gl_Position = unproject(newWinCurrP, eyeCurrP.z, eyeCurrP.w);\n    gl_PointSize = billWidth;\n}"

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(1);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = "uniform samplerCube u_cubeMap;\n\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\n    gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n}\n"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position;\nuniform mat3 u_rotateMatrix; //【土豆数据tudougis.cn】 Hao 2019-9-18   天空盒\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));//【土豆数据tudougis.cn】 Hao 2019-9-18   天空盒\n    gl_Position = czm_projection * vec4(p, 1.0);\n    v_texCoord = position.xyz;\n}\n"

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GCJMercatorTilingScheme; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var cesium__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(cesium__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _util_PointUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


 //用于国测局坐标系下的相关瓦片纠偏处理

var GCJMercatorTilingScheme = /*#__PURE__*/function (_Cesium$WebMercatorTi) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(GCJMercatorTilingScheme, _Cesium$WebMercatorTi);

  var _super = _createSuper(GCJMercatorTilingScheme);

  function GCJMercatorTilingScheme(options) {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, GCJMercatorTilingScheme);

    _this = _super.call(this, options);
    var dstCoordType = options.mapChinaCRS; //map地图的坐标系

    var srcCoordType = options.chinaCRS; //layer图层的坐标系（默认与地图一致）

    var Map2CrsLayerCrs = Object(_util_PointUtil__WEBPACK_IMPORTED_MODULE_5__["getTransFun"])(dstCoordType, srcCoordType);
    var LayerCrs2MapCrs = Object(_util_PointUtil__WEBPACK_IMPORTED_MODULE_5__["getTransFun"])(srcCoordType, dstCoordType);

    if (Map2CrsLayerCrs) {
      var projection = new cesium__WEBPACK_IMPORTED_MODULE_4__["WebMercatorProjection"]();

      _this._projection.project = function (cartographic, result) {
        result = Map2CrsLayerCrs([cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toDegrees(cartographic.longitude), cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toDegrees(cartographic.latitude)]);
        result = projection.project(new cesium__WEBPACK_IMPORTED_MODULE_4__["Cartographic"](cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toRadians(result[0]), cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toRadians(result[1])));
        return new cesium__WEBPACK_IMPORTED_MODULE_4__["Cartesian2"](result.x, result.y);
      };

      _this._projection.unproject = function (cartesian, result) {
        var cartographic = projection.unproject(cartesian);
        result = LayerCrs2MapCrs([cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toDegrees(cartographic.longitude), cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toDegrees(cartographic.latitude)]);
        return new cesium__WEBPACK_IMPORTED_MODULE_4__["Cartographic"](cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toRadians(result[0]), cesium__WEBPACK_IMPORTED_MODULE_4__["Math"].toRadians(result[1]));
      };
    }

    return _this;
  }

  return GCJMercatorTilingScheme;
}(cesium__WEBPACK_IMPORTED_MODULE_4__["WebMercatorTilingScheme"]);

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = "/**\n * @license\n * Cellular noise (\"Worley noise\") in 2D in GLSL.\n * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n * This code is released under the conditions of the MIT license.\n * See LICENSE file for details.\n */\n\n//#ifdef GL_OES_standard_derivatives\n//    #extension GL_OES_standard_derivatives : enable\n//#endif\n//\n//float aastep (float threshold , float value)\n//{\n//    float afwidth = 0.7 * length ( vec2 ( dFdx ( value ), dFdy ( value )));\n//    return smoothstep ( threshold - afwidth , threshold + afwidth , value );\n//}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 _czm_permute289(vec3 x)\n{\n    return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n/**\n * DOC_TBA\n *\n * Implemented by Stefan Gustavson, and distributed under the MIT License.  {@link http://openglinsights.git.sourceforge.net/git/gitweb.cgi?p=openglinsights/openglinsights;a=tree;f=proceduraltextures}\n *\n * @name czm_cellular\n * @glslFunction\n *\n * @see Stefan Gustavson's chapter, <i>Procedural Textures in GLSL</i>, in <a href=\"http://www.openglinsights.com/\">OpenGL Insights</a>.\n */\nvec2 czm_cellular(vec2 P)\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\n{\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n    vec2 Pi = mod(floor(P), 289.0);\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = _czm_permute289(Pi.x + oi);\n    vec3 p = _czm_permute289(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p*K) - Ko;\n    vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter*ox;\n    vec3 dy = Pf.y - of + jitter*oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = _czm_permute289(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p*K) - Ko;\n    oy = mod(floor(p*K),7.0)*K - Ko;\n    dx = Pf.x - 0.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = _czm_permute289(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p*K) - Ko;\n    oy = mod(floor(p*K),7.0)*K - Ko;\n    dx = Pf.x - 1.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n"

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = "/**\n * @license\n * Description : Array and textureless GLSL 2D/3D/4D simplex\n *               noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _czm_mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 _czm_mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 _czm_mod289(vec2 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat _czm_mod289(float x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 _czm_permute(vec4 x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 _czm_permute(vec3 x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nfloat _czm_permute(float x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 _czm_taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat _czm_taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 _czm_grad4(float j, vec4 ip)\n{\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n\n/**\n * DOC_TBA\n *\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n *\n * @name czm_snoise\n * @glslFunction\n *\n * @see <a href=\"https://github.com/ashima/webgl-noise\">https://github.com/ashima/webgl-noise</a>\n * @see Stefan Gustavson's paper <a href=\"http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\">Simplex noise demystified</a>\n */\nfloat czm_snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = _czm_mod289(i); // Avoid truncation effects in permutation\n    vec3 p = _czm_permute( _czm_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat czm_snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = _czm_mod289(i);\n    vec4 p = _czm_permute( _czm_permute( _czm_permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat czm_snoise(vec4 v)\n{\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // (sqrt(5) - 1)/4 = F4, used once below\n    #define F4 0.309016994374947451\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = _czm_mod289(i);\n    float j0 = _czm_permute( _czm_permute( _czm_permute( _czm_permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = _czm_permute( _czm_permute( _czm_permute( _czm_permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = _czm_grad4(j0,   ip);\n    vec4 p1 = _czm_grad4(j1.x, ip);\n    vec4 p2 = _czm_grad4(j1.y, ip);\n    vec4 p3 = _czm_grad4(j1.z, ip);\n    vec4 p4 = _czm_grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= _czm_taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n"

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = repeat * materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - speed*czm_frameNumber/1000.0), st.t));\n    if(color.a == 0.0) {\n       if(colorImage.rgb == vec3(1.0)){\n          discard;\n        }\n        material.alpha = colorImage.a;\n        material.diffuse = colorImage.rgb;\n    }\n    else {\n        material.alpha = colorImage.a * color.a;\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb);\n    }\n\n    if(hasImage2)  {\n        vec4 colorBG = texture2D(image2,materialInput.st);\n        if(colorBG.a>0.5){\n            material.diffuse = color2.rgb;\n        }\n    }\n    return material;\n}\n"

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\nuniform float startTime;\nuniform float percent;\nuniform float alpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float t =fract(startTime +czm_frameNumber * speed / 1000.0);\n  t *= (1.0 + percent);\n  float alpha1 = smoothstep(t- percent, t, st.s) * step(-t, -st.s);\n  alpha1 += alpha;\n  material.diffuse = color.rgb;\n  material.alpha = alpha1;\n  return material;\n}\n"

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform vec4 bgColor;\nuniform float speed;\nuniform float startTime;\nuniform float bidirectional;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t = fract(startTime + czm_frameNumber * speed / 1000.0);\n\n    t *= 1.03;\n    float alpha0 = smoothstep(t - 0.03, t, st.s) * step(st.s, t);\n    float mt = 1. - t;\n    float alpha1 = smoothstep(mt + 0.03, mt, st.s) * step(mt, st.s);\n\n    float a0 = step(abs(bidirectional - 0.0) - 0.001, 0.);\n    float a1 = step(abs(bidirectional - 1.0) - 0.001, 0.);\n    float db = step(abs(bidirectional - 2.0) - 0.001, 0.);\n    float alpha = alpha0 * (a0 + db) + alpha1 * (a1 + db);\n    alpha = clamp(alpha, 0., 1.);\n\n    material.diffuse = color.rgb * alpha + bgColor.rgb * (1. - alpha);\n    material.alpha = color.a * alpha + bgColor.a * (1. - alpha);\n\n    // if (useImageAndRepeat.x != 0.) {\n    //     float repeat = useImageAndRepeat.y;\n    //     vec4 tudouImageColor = texture2D(image, fract(vec2(fract((st.s-t)*repeat), st.t)));\n    //     material.diffuse = tudouImageColor.rgb;\n    //     material.alpha = tudouImageColor.a;\n    // }\n\n    return material;\n}\n"

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  float time = fract( czm_frameNumber  *  speed / 1000.0);\n  vec2 st = materialInput.st;\n  float scalar = smoothstep(0.0,1.0,time);\n  material.diffuse = color.rgb * scalar;\n  material.alpha = color.a * scalar ;\n  return material;\n}\n"

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D image;\nuniform vec4 color;\nuniform float speed;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber * speed / 1000.0);\n  vec4 colorImage = texture2D(image,st);\n  vec3 fragColor = color.rgb;\n  if(st.t > 0.45 && st.t < 0.55 ) {\n    fragColor = vec3(1.0);\n  }\n  if(color.a == 0.0){\n    if(colorImage.rgb == vec3(1.0)){\n      discard;\n    }\n    material.alpha = colorImage.a * 1.5 * fract(st.s - time);\n    material.diffuse = colorImage.rgb;\n  }else{\n    material.alpha = colorImage.a * color.a * 1.5 * smoothstep(.0,1., fract(st.s - time));\n    material.diffuse = max(fragColor.rgb * material.alpha , fragColor.rgb);\n  }\n  return material;\n}\n"

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D image;\nuniform float speed;\nuniform vec4 color;\nuniform float count;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  float perDis = 1.0 / count / 3.0  ;\n  vec2 st = materialInput.st * vec2(1.0,count);\n  float time = fract(czm_frameNumber * speed / 1000.0);\n  vec4 colorImage = texture2D(image, vec2(fract(st.t - time),st.t));\n  material.alpha =  colorImage.a * smoothstep(.2 ,1. ,distance(st.t * perDis ,1. + perDis ));\n  material.diffuse = max(color.rgb * material.alpha * 1.5, color.rgb);\n  material.emission = max(color.rgb * material.alpha * 1.5, color.rgb);\n  return material;\n}\n"

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = "float circle(vec2 uv, float r, float blur) {\n    float d = length(uv) * 2.0;\n    float c = smoothstep(r+blur, r, d);\n    return c;\n}\n\nuniform vec4 color;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st - .5;\n    material.diffuse = color.rgb;\n    material.emission = vec3(0);\n\n    float t =fract(czm_frameNumber * speed / 1000.0);\n    float s = 0.3;\n    float radius1 = smoothstep(.0, s, t) * 0.5;\n    float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n    float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n    float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n    float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n\n    material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2*0.1 + alpha3*0.1);\n    material.alpha *= color.a;\n\n    return material;\n}\n"

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec4 imgC = texture2D(image,st);\n    if(imgC.a>.0){\n        material.diffuse = color.rgb;\n    }\n    material.alpha = imgC.a * color.a;\n    return material;\n}\n"

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = 1.5 * color.rgb;\n    vec2 st = materialInput.st;\n\n    float dis = distance(st, vec2(0.5, 0.5));\n    float per = fract(speed*czm_frameNumber/1000.0);\n    if(count==1.0){\n        if(dis > per * 0.5){ \n            discard;\n        }else {\n            material.alpha = color.a  * dis / per / 2.0;\n        }\n    }\n    else{\n        vec3 str = materialInput.str;\n        if(abs(str.z)>0.001){\n            discard;\n        }\n        if(dis >0.5){\n            discard;\n        }\n        else {\n            float perDis = 0.5/count;\n            float disNum;\n            float bl = 0.0;\n            for(int i=0;i<=999;i++){\n                if(float(i)<=count){\n                    disNum = perDis*float(i) - dis + per/count;\n                    if(disNum>0.0){\n                        if(disNum<perDis){\n                            bl = 1.0-disNum/perDis;\n                        }\n                        else if(disNum-perDis<perDis){\n                            bl = 1.0 - abs(1.0-disNum/perDis);\n                        }\n                        material.alpha = pow(bl,(1.0 + 10.0 * (1.0 - gradient)));\n                    }\n                }\n            }\n        }\n    } \n    return material;\n}"

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st * 2.0 - 1.0;\n  float t = czm_frameNumber * speed / 1000.0 ;\n  vec3 col = vec3(0.0);\n  vec2 p = vec2(sin(t), cos(t));\n  float d = length(st - dot(p, st) * p);\n  if (dot(st, p) < 0.) {\n    d = length(st);\n  }\n\n  col = .006 / d * color.rgb;\n\n  if(distance(st,vec2(0)) >  0.99 ){\n    col =color.rgb;\n  }\n\n  material.alpha  = pow(length(col),2.0);\n  material.diffuse = col * 3.0 ;\n  return material;\n}\n"

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\n\n#define PI 3.14159265359\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec2 pos = st - vec2(0.5);\n  float time = czm_frameNumber * speed / 1000.0 ;\n  float r = length(pos);\n  float t = atan(pos.y, pos.x) - time * 2.5;\n  float a = (atan(sin(t), cos(t)) + PI)/(2.0*PI);\n  float ta = 0.5;\n  float v = smoothstep(ta-0.05,ta+0.05,a) * smoothstep(ta+0.05,ta-0.05,a);\n  vec3 flagColor = color.rgb * v;\n  float blink = pow(sin(time*1.5)*0.5+0.5, 0.8);\n  flagColor = color.rgb *  pow(a, 8.0*(.2+blink))*(sin(r*500.0)*.5+.5) ;\n  flagColor = flagColor * pow(r, 0.4);\n  material.alpha = length(flagColor) * 1.3;\n  material.diffuse = flagColor * 3.0;\n  return material;\n}\n"

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.s + czm_frameNumber * speed / 1000.0),fract(st.t)));\n\n    material.alpha = colorImage.a * color.a;\n    if(pure) {\n        material.diffuse = diffusePower * color.rgb;\n    }\n    else {\n        material.diffuse = colorImage.rgb;\n    }\n    return material;\n }\n"

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\n\n#define pi 3.1415926535\n#define PI2RAD 0.01745329252\n#define TWO_PI (2. * PI)\n\nfloat rands(float p){\n  return fract(sin(p) * 10000.0);\n}\n\nfloat noise(vec2 p){\n  float time = fract( czm_frameNumber * speed / 1000.0);\n  float t = time / 20000.0;\n  if(t > 1.0) t -= floor(t);\n  return rands(p.x * 14. + p.y * sin(t) * 0.5);\n}\n\nvec2 sw(vec2 p){\n  return vec2(floor(p.x), floor(p.y));\n}\n\nvec2 se(vec2 p){\n  return vec2(ceil(p.x), floor(p.y));\n}\n\nvec2 nw(vec2 p){\n  return vec2(floor(p.x), ceil(p.y));\n}\n\nvec2 ne(vec2 p){\n  return vec2(ceil(p.x), ceil(p.y));\n}\n\nfloat smoothNoise(vec2 p){\n  vec2 inter = smoothstep(0.0, 1.0, fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n}\n\nfloat fbm(vec2 p){\n  float z = 2.0;\n  float rz = 0.0;\n  vec2 bp = p;\n  for(float i = 1.0; i < 6.0; i++){\n    rz += abs((smoothNoise(p) - 0.5)* 2.0) / z;\n    z *= 2.0;\n    p *= 2.0;\n  }\n  return rz;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec2 st2 = materialInput.st;\n  float time = fract( czm_frameNumber * speed / 1000.0);\n  if (st.t < 0.5) {\n    discard;\n  }\n  st *= 4.;\n  float rz = fbm(st);\n  st /= exp(mod( time * 2.0, pi));\n  rz *= pow(15., 0.9);\n  vec4 temp = vec4(0);\n  temp = mix( color / rz, vec4(color.rgb, 0.1), 0.2);\n  if (st2.s < 0.05) {\n    temp = mix(vec4(color.rgb, 0.1), temp, st2.s / 0.05);\n  }\n  if (st2.s > 0.95){\n    temp = mix(temp, vec4(color.rgb, 0.1), (st2.s - 0.95) / 0.05);\n  }\n  material.diffuse = temp.rgb;\n  material.alpha = temp.a * 2.0;\n  return material;\n}\n"

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber * speed / 1000.0);\n  float alpha = abs(smoothstep(0.5,1.,fract( -st.t - time)));\n  alpha += .1;\n  material.alpha = alpha;\n  material.diffuse = color.rgb;\n  return material;\n}\n"

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float diffusePower;\nuniform float alphaPower;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float alpha = distance(st,vec2(0.5, 0.5));\n  material.alpha = color.a  * alpha  * alphaPower;\n  material.diffuse = color.rgb * diffusePower;\n  return material;\n}\n"

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 asphaltColor;\nuniform float bumpSize;\nuniform float roughness;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  //Main cellular pattern\n  vec4 color = asphaltColor;\n  vec2 st = materialInput.st;\n  vec2 F = czm_cellular(st / bumpSize);\n  color.rgb -= (F.x / F.y) * 0.1;\n\n  //Extra bumps for roughness\n  float noise = czm_snoise(st / bumpSize);\n  noise = pow(noise, 5.0) * roughness;\n  color.rgb += noise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 1.0 - F.x * F.x;\n\n  vec4 color = mix(lightColor, darkColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 0.1 + (F.y - F.x);\n\n  vec4 color = mix(lightColor, darkColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 grassColor;\nuniform vec4 dirtColor;\nuniform float patchiness;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  vec2 st = materialInput.st;\n  float noise1 = (czm_snoise(st * patchiness * 1.0)) * 1.0;\n  float noise2 = (czm_snoise(st * patchiness * 2.0)) * 0.5;\n  float noise3 = (czm_snoise(st * patchiness * 4.0)) * 0.25;\n  float noise = sin(noise1 + noise2 + noise3) * 0.1;\n\n  vec4 color = mix(grassColor, dirtColor, noise);\n\n  //Make thatch patterns\n  float verticalNoise = czm_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\n  float horizontalNoise = czm_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\n  float stripeNoise = min(verticalNoise, horizontalNoise);\n\n  color.rgb += stripeNoise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightWoodColor;\nuniform vec4 darkWoodColor;\nuniform float ringFrequency;\nuniform vec2 noiseScale;\nuniform float grainFrequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  //Based on wood shader from OpenGL Shading Language (3rd edition) pg. 455\n  vec2 st = materialInput.st;\n\n  vec2 noisevec;\n  noisevec.x = czm_snoise(st * noiseScale.x);\n  noisevec.y = czm_snoise(st * noiseScale.y);\n\n  vec2 location = st + noisevec;\n  float dist = sqrt(location.x * location.x + location.y * location.y);\n  dist *= ringFrequency;\n\n  float r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\n  if(r > 1.0)\n      r = 2.0 - r;\n\n  vec4 color = mix(lightWoodColor, darkWoodColor, r);\n\n  //streaks\n  r = abs(czm_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\n  color.rgb += lightWoodColor.rgb * r;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform vec4 u_color;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC)\n{\n    czm_materialInput materialInput;\n\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n    materialInput.str = pointMC / sensorRadius;\n\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n    materialInput.normalEC = u_normalDirection * normalEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    material.diffuse = u_color.rgb;\n    material.alpha = u_color.a;\n    // czm_lightDirectionEC在cesium1.66开始加入的\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon)\n{\n    float width = getIntersectionWidth();\n    float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n    float pixels = width * delta;\n    float temp = abs(value);\n    // There are a couple things going on here.\n    // First we test the value at the current fragment to see if it is within the tolerance.\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\n    // but we don't want to admit points that are obviously not on the surface.\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\n    // the points is close to zero.\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n    return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary)\n{\n    if (u_showIntersection && isOnBoundary)\n    {\n        return getIntersectionColor();\n    }\n    return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point)\n{\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\n    return dot(scaled, scaled) - 1.0;\n}\n\nvoid main()\n{\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\n\n    //vec3 pixDir = normalize(v_position);\n    float positionX = v_position.x;\n    float positionY = v_position.y;\n    float positionZ = v_position.z;\n\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\n    vec3 lineY = vec3(0, positionY, positionZ);\n    float resX = dot(normalize(lineX), zDir);\n    if(resX < cos(u_xHalfAngle) - 0.0001){\n        discard;\n    }\n    float resY = dot(normalize(lineY), zDir);\n    if(resY < cos(u_yHalfAngle)- 0.0001){\n        discard;\n    }\n\n\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n\n    // Occluded by the ellipsoid?\n\tif (!u_showThroughEllipsoid)\n\t{\n\t    // Discard if in the ellipsoid\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\n\t    if (ellipsoidValue < 0.0)\n\t    {\n            discard;\n\t    }\n\n\t    // Discard if in the sensor's shadow\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\n\t    {\n\t        discard;\n\t    }\n    }\n\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n    gl_FragColor = shade(isOnEllipsoid);\n\n}"

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(35);

var defineProperty = __webpack_require__(7);

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

module.exports = _set;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}"

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float powerRatio = 1./(fract(czm_frameNumber / 30.0) +  1.) ;\n    float alpha = pow(1. - st.t,powerRatio);\n    vec4 color = vec4(u_color.rgb, alpha*u_color.a);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}"

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n    float param = 1. - step(length, 0.6);//大于0.6模糊，rate = 0.6\n    float scale = param * length;// 0.6< length 返回0，反之返回1.\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length 返回0，反之返回1.\n\n    float param1 = step(length, 0.7);//小于0.5模糊\n    float scale1 = param1 * length;// 0.6< length 返回0，反之返回1.\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length 返回0，反之返回1.\n\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}"

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;//扫描速度1度\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);//color.r = 0 或1\n    return material;\n}"

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main(){\n    gl_FragColor = xh_getMaterial(v_st);\n}"

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}"

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}"

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n    czm_material material = czm_getDefaultMaterial(cmi);\n    vec2 st = cmi.st;\n    float t = fract(speed*czm_frameNumber/1000.0) * direction;\n    vec2 st1 = vec2(st.s,fract(st.t - t));\n    vec4 color = vec4(0.,0.,0.,0.);\n    float tt = 0.5 - abs(0.5 - st1.t);\n    float ss = st1.s ;\n    float alpha = tt * 2.;\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n"

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n    czm_material material = czm_getDefaultMaterial(cmi);\n    vec2 st = cmi.st;\n    float t = fract(speed*czm_frameNumber/1000.0) * direction;\n    vec2 st1 = vec2(fract(st.s - t),st.t);\n    vec4 color = vec4(0.,0.,0.,0.);\n    float alpha = 1.-st.t;\n    float value = fract(st1.s/0.25);\n    alpha *= sin(value * 3.1415926);\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n"

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput) {\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    if(move){\n        float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n        float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n        float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        st += sqrt(z*z+z2*z2);\n        st.s += reflux * czm_frameNumber/1000.0 * speed;\n        st.s = mod(st.s,1.0);\n    }\n    if(flipY){\n        st = vec2(st.t,st.s);\n    }\n    vec4 colorImage = texture2D(image, st);\n    material.alpha = alpha;\n    material.diffuse = colorImage.rgb;\n    return material;\n}\n"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "\n\n\n\nuniform float mixNum;\nuniform sampler2D colorTexture;\nuniform sampler2D tudouShadow;\nuniform sampler2D videoTexture;\nuniform sampler2D depthTexture;\nuniform mat4 _shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\nuniform vec4 disViewColor;\nuniform bool clearBlack;\nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility =\n    (\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0)\n    ;\n    return visibility;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n    vec3 v01 = point -planeOrigin;\n    float d = dot(planeNormal, v01) ;\n    return (point - planeNormal * d);\n}\nfloat ptm(vec3 pt){\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\n}\nvoid main()\n{\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n    vec4 shadowPosition = _shadowMap_matrix * positionEC;\n    shadowPosition /= shadowPosition.w;\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    shadowParameters.texCoords = shadowPosition.xy;\n    shadowParameters.depth = shadowPosition.z;\n    shadowParameters.nDotL = nDotL;\n    float visibility = _czm_shadowVisibility(tudouShadow, shadowParameters);\n\n    vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);\n    if(clearBlack){\n        if(videoColor.r + videoColor.g + videoColor.b <0.01){\n            gl_FragColor = color;\n            return;\n        }\n    }\n    if(visibility==1.0){\n        gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);\n    }else{\n        if(abs(shadowPosition.z-0.0)<0.01){\n            return;\n        }\n        if(clearBlack){\n            gl_FragColor = color;\n            return;\n        }\n        gl_FragColor = vec4(mix(color.rgb,disViewColor.rgb,disViewColor.a),disViewColor.a);\n    }\n}\n"

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "uniform float czzj;\nuniform float dis;\nuniform float spzj;\nuniform vec3 visibleColor;\nuniform vec3 disVisibleColor;\nuniform float mixNum;\nuniform sampler2D colorTexture;\nuniform sampler2D tudouShadow;\nuniform sampler2D depthTexture;\nuniform mat4 _shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightPositionWC;\nuniform vec4 shadowMap_lightDirectionEC;\nuniform vec3 shadowMap_lightUp;\nuniform vec3 shadowMap_lightDir;\nuniform vec3 shadowMap_lightRight;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility =\n    (\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0)\n    ;\n    return visibility;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n    vec3 v01 = point -planeOrigin;\n    float d = dot(planeNormal, v01) ;\n    return (point - planeNormal * d);\n}\nfloat ptm(vec3 pt){\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\n}\nvoid main()\n{\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n\n    // vec4 stcc = texture2D(tudouShadow, v_textureCoordinates);\n    // gl_FragColor = currD;\n    // return;\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    float depth = getDepth(currD);\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\n    // return;\n    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n    vec4 shadowPosition = _shadowMap_matrix * positionEC;\n    shadowPosition /= shadowPosition.w;\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    //坐标与视点位置距离，大于最大距离则舍弃阴影效果\n    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\n    if(distance(lw.xyz,vw.xyz)>dis){\n        gl_FragColor = color;\n        return;\n    }\n\n\n    //水平夹角限制\n    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);\n    directionEC = ptOnSP - lw.xyz;\n    float directionECMO = ptm(directionEC.xyz);\n    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\n    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);\n    float degJJ = acos(cosJJ)*(180.0 / PI);\n    degJJ = abs(degJJ);\n    if(degJJ>spzj/2.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    //垂直夹角限制\n    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);\n    vec3 dirOnCZ = ptOnCZ - lw.xyz;\n    float dirOnCZMO = ptm(dirOnCZ);\n    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);\n    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);\n    degJJCZ = abs(degJJCZ);\n    if(degJJCZ>czzj/2.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    shadowParameters.texCoords = shadowPosition.xy;\n    shadowParameters.depth = shadowPosition.z;\n    shadowParameters.nDotL = nDotL;\n    float visibility = _czm_shadowVisibility(tudouShadow, shadowParameters);\n    if(visibility==1.0){\n        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);\n    }else{\n        // if(abs(shadowPosition.z-0.0)<0.01){\n        //     return;\n        // }\n        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);\n    }\n}\n"

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float lineWidth;\nuniform float height;\nuniform bvec3 strokeType;\nuniform vec3 tjxColor;\nuniform vec3 bjColor;\nuniform vec3 cameraPos;\nuniform float mbDis;\nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nbool isTJX(vec2 uv,float lw){\n    vec2 pixelSize = lw / czm_viewport.zw;\n    float dx0 = -pixelSize.x;\n    float dy0 = -pixelSize.y;\n    float dx1 = pixelSize.x;\n    float dy1 = pixelSize.y;\n\n    vec2 currUV = uv + vec2(dx0, dy0);\n    vec4 currDepth = texture2D(depthTexture, currUV);\n    float depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(0.0, dy0);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(dx1, dy0);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(dx0, 0.0);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(dx1, 0.0);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(dx0, dy1);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(0.0, dy1);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    currUV = uv + vec2(dx1, dy1);\n    currDepth = texture2D(depthTexture, currUV);\n    depth = getDepth(currDepth);\n    if(depth>=1.0)return true;\n\n    return false;\n}\nvoid main(){\n\n\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    if(height>14102.0){\n        gl_FragColor = color;\n        return;\n    }\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 dx = dFdx(positionEC.xyz);\n    vec3 dy = dFdy(positionEC.xyz);\n    vec3 normal = normalize(cross(dx,dy));\n\n    if(strokeType.y||strokeType.z){\n        vec4 wp = czm_inverseView * positionEC;\n        if(distance(wp.xyz,cameraPos)>mbDis){\n            gl_FragColor = color;\n        }else{\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\n            if(dotNum<0.05){\n                gl_FragColor = vec4(bjColor,1.0);\n                return;\n            }\n        }\n    }\n    if(strokeType.x||strokeType.z){\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\n        if(tjx){\n            gl_FragColor = vec4(tjxColor,1.0);\n            return;\n        }\n    }\n    gl_FragColor = color;\n}"

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position;\nvoid main()\n{\n    vec4 pos = vec4(position.xyz,1.0);\n    gl_Position = czm_projection*pos;\n}\n"

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nvoid main()\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "uniform mat4 myPorjection;\nattribute vec3 position;\nvarying vec2 depth;\nvoid main()\n{\n    vec4 pos = vec4(position.xyz,1.0);\n    depth = pos.zw;\n    pos.z = 0.0;\n    gl_Position = czm_projection*pos;\n}"

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\n\n#define OES_texture_float_linear\n\nvarying vec2 depth;\n\nvec4 packDepth(float depth)\n{\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n\nvoid main()\n{\n    float fDepth = (depth.x / 5000.0)/2.0 + 0.5;\n    // gl_FragColor = packDepth(fDepth);\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}\n"

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "float getDistance(sampler2D depthTexture, vec2 texCoords) \n{ \n    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \n    if (depth == 0.0) { \n        return czm_infinity; \n    } \n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \n    return -eyeCoordinate.z / eyeCoordinate.w; \n} \nfloat interpolateByDistance(vec4 nearFarScalar, float distance) \n{ \n    float startDistance = nearFarScalar.x; \n    float startValue = nearFarScalar.y; \n    float endDistance = nearFarScalar.z; \n    float endValue = nearFarScalar.w; \n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \n    return mix(startValue, endValue, t); \n} \nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \n{ \n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \n} \nuniform sampler2D colorTexture; \nuniform sampler2D depthTexture; \nuniform vec4 fogByDistance; \nuniform vec4 fogColor; \nvarying vec2 v_textureCoordinates; \nvoid main(void) \n{ \n    float distance = getDistance(depthTexture, v_textureCoordinates); \n    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \n    float blendAmount = interpolateByDistance(fogByDistance, distance); \n    vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \n    gl_FragColor = alphaBlend(finalFogColor, sceneColor); \n} "

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;//下雨前输入的场景渲染照片\nvarying vec2 v_textureCoordinates;\nuniform float speed;\nuniform float size;\nuniform float direction;\n\n\nfloat hash(float x){\n    return fract(sin(x*23.3)*13.13);\n}\n\nvoid main(void){\n\n    float time = czm_frameNumber * speed/ 1000.0;\n    vec2 resolution = czm_viewport.zw;\n\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n    vec3 finalColor=vec3(0.1,0.2,0.3);//粒子的颜色\n\n    float si=sin(direction),co=cos(direction);\n    uv*=mat2(co,-si,si,co);\n    uv*=length(uv+vec2(0,4.9))*0.3+1.0;\n\n    float v=1.-sin(hash(floor(uv.x*100.0))*2.0);\n    float b=clamp(abs(sin(20.0*time*v+uv.y*(5./(2.0+v))))-.95,0.0,1.0)*size;\n    finalColor*=v*b; //屏幕上雨的颜色\n\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1.0), 0.5); //将雨和三维场景融合\n}\n"

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture; //输入的场景渲染照片\nvarying vec2 v_textureCoordinates;\nuniform float speed;\n\nfloat snow(vec2 uv,float scale){\n    float time = czm_frameNumber * speed / 1000.0 ;\n    float w=smoothstep(1.0,0.0,-uv.y*(scale/10.0));\n    if(w<0.1)return 0.0;\n    uv+=time/scale;\n    uv.y+=time*2.0/scale;\n    uv.x+=sin(uv.y+time*0.5)/scale;\n    uv*=scale;\n\n    vec2 s=floor(uv),f=fract(uv),p;\n    float k=3.0,d;\n    p=0.5+0.35*sin(11.0*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.0))-f;\n    d=length(p);k=min(d,k);\n    k=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n    return k*w;\n}\n\nvoid main(void){\n    vec2 resolution = czm_viewport.zw;\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\n    float c = 0.0;\n    c+=snow(uv,15.);\n    c+=snow(uv,10.);\n    c+=snow(uv,9.);\n    c+=snow(uv,8.);\n    c+=snow(uv,7.);\n    c+=snow(uv,6.);\n    c+=snow(uv,5.);\n    c+=snow(uv,4.);\n\n    vec3 finalColor=(vec3(c)); //屏幕上雪的颜色\n\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1.0), 0.5);  //将雪和三维场景融合\n\n}\n"

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float alpha;\nvarying vec2 v_textureCoordinates;\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nvoid main(){\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 dx = dFdx(positionEC.xyz);\n    vec3 dy = dFdy(positionEC.xyz);\n    vec3 nor = normalize(cross(dx,dy));\n\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\n    float dotNumWC = dot(positionWC.xyz,normalWC);\n    if(dotNumWC<=0.3){\n        gl_FragColor = mix(color,vec4(1.0),alpha*0.3);\n        return;\n    }\n    gl_FragColor = mix(color,vec4(1.0),dotNumWC*alpha);\n}"

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nvec3 guussColor(vec2 uv){\n    vec2 pixelSize = 1.0 / czm_viewport.zw;\n    float dx0 = -pixelSize.x;\n    float dy0 = -pixelSize.y;\n    float dx1 = pixelSize.x;\n    float dy1 = pixelSize.y;\n    vec4 gc = (\n        texture2D(colorTexture, uv)+\n        texture2D(colorTexture, uv + vec2(dx0, dy0)) +\n        texture2D(colorTexture, uv + vec2(0.0, dy0)) +\n        texture2D(colorTexture, uv + vec2(dx1, dy0)) +\n        texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\n        texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\n        texture2D(colorTexture, uv + vec2(dx0, dy1)) +\n        texture2D(colorTexture, uv + vec2(0.0, dy1)) +\n        texture2D(colorTexture, uv + vec2(dx1, dy1))\n    ) * (1.0 / 9.0);\n    return gc.rgb;\n}\nvoid main(){\n    // mat4 dither = mat4(\n    //     0,       0.5,    0.125,  0.625,\n    //     0.75,    0.25,   0.875,  0.375,\n    //     0.1875,  0.6875, 0.0625, 0.5625,\n    //     0.9375,  0.4375, 0.8125, 0.3125\n    // );\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\n    float offset = 0.0;\n\n\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n    // gl_FragColor = currD;\n    // return;\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n    float depth = getDepth(currD);\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\n    // return;\n\n    \n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 dx = dFdx(positionEC.xyz);\n    vec3 dy = dFdy(positionEC.xyz);\n    vec3 normal = normalize(cross(dx,dy));\n\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\n    vec3 normalWC = normalize(czm_inverseViewRotation * normal);\n    float fotNumWC = dot(positionWC.xyz,normalWC);\n    if(fotNumWC<=0.5){\n        gl_FragColor = color;\n        return;\n    }\n    \n\n\n\n\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\n    // return;\n\n    vec3 viewDir = normalize(positionEC.xyz);\n    vec3 reflectDir = reflect(viewDir, normal);\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\n    vec3 viewReflectDir = reflectDir;\n\n    \n    float step = 0.05;\n    int stepNum = int(20.0 / step);\n    vec3 pos;\n    vec3 albedo;\n    bool jd = false;\n    for(int i = 1;i <= 400;i++)\n    {\n        float delta = step * float(i) + offset;\n        pos = positionEC.xyz + viewReflectDir * delta;\n        float d = -pos.z;\n\n        vec4 tmp = czm_projection * vec4(pos,1.0);\n        vec3 screenPos = tmp.xyz / tmp.w;\n        vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\n        \n        if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\n            float dd = getDepth(texture2D(depthTexture, uv));\n            vec4 jzc = toEye(uv, dd);\n            dd = -jzc.z;\n            if(d>dd){\n                if(abs(abs(d) - abs(dd)) <=step){\n                    jd = true;\n                    // albedo = texture2D(colorTexture, uv).rgb;\n                    albedo = guussColor(uv);\n                }\n                break;\n            }\n        }\n    }\n    if(jd){\n        gl_FragColor = vec4(mix(color.xyz,albedo,0.5),1.0);\n    }else{\n        gl_FragColor = color;\n    }\n}"

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\nconst int KERNEL_WIDTH=16;\nvoid main(void)\n{\n    vec2 step = 1.0 / czm_viewport.zw;\n    vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step);\n    vec3 averageValue = vec3(0.0);\n    for (int i = 0; i < KERNEL_WIDTH; i++)\n    {\n        for (int j = 0; j < KERNEL_WIDTH; j++)\n        {\n            averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb;\n        }\n    }\n    averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH);\n    gl_FragColor = vec4(averageValue, 1.0);\n}\n"

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 103 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(36);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(36);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "version", function() { return /* reexport */ Version["c" /* version */]; });
__webpack_require__.d(__webpack_exports__, "update", function() { return /* reexport */ Version["b" /* update */]; });
__webpack_require__.d(__webpack_exports__, "name", function() { return /* binding */ src_name; });
__webpack_require__.d(__webpack_exports__, "author", function() { return /* binding */ author; });
__webpack_require__.d(__webpack_exports__, "Cesium", function() { return /* reexport */ external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_; });
__webpack_require__.d(__webpack_exports__, "Resource", function() { return /* reexport */ external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"]; });
__webpack_require__.d(__webpack_exports__, "proj4", function() { return /* reexport */ lib["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "BaseClass", function() { return /* reexport */ BaseClass_BaseClass; });
__webpack_require__.d(__webpack_exports__, "BaseThing", function() { return /* reexport */ BaseThing_BaseThing; });
__webpack_require__.d(__webpack_exports__, "LatLngPoint", function() { return /* reexport */ LatLngPoint["a" /* LatLngPoint */]; });
__webpack_require__.d(__webpack_exports__, "LatLngArray", function() { return /* reexport */ LatLngArray_LatLngArray; });
__webpack_require__.d(__webpack_exports__, "GroundSkyBox", function() { return /* reexport */ GroundSkyBox_GroundSkyBox; });
__webpack_require__.d(__webpack_exports__, "CRS", function() { return /* reexport */ CRS["a" /* CRS */]; });
__webpack_require__.d(__webpack_exports__, "ChinaCRS", function() { return /* reexport */ ChinaCRS["a" /* ChinaCRS */]; });
__webpack_require__.d(__webpack_exports__, "EventType", function() { return /* reexport */ EventType; });
__webpack_require__.d(__webpack_exports__, "State", function() { return /* reexport */ State; });
__webpack_require__.d(__webpack_exports__, "Token", function() { return /* reexport */ Token_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "MaterialType", function() { return /* reexport */ MaterialType_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "GraphicType", function() { return /* reexport */ GraphicType["a" /* GraphicType */]; });
__webpack_require__.d(__webpack_exports__, "LayerType", function() { return /* reexport */ LayerType["a" /* LayerType */]; });
__webpack_require__.d(__webpack_exports__, "Lang", function() { return /* reexport */ Lang["a" /* Lang */]; });
__webpack_require__.d(__webpack_exports__, "LangType", function() { return /* reexport */ LangType; });
__webpack_require__.d(__webpack_exports__, "DomUtil", function() { return /* reexport */ DomUtil_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "MeasureUtil", function() { return /* reexport */ MeasureUtil_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "PointUtil", function() { return /* reexport */ PointUtil; });
__webpack_require__.d(__webpack_exports__, "PolyUtil", function() { return /* reexport */ PolyUtil_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "PointTrans", function() { return /* reexport */ PointTrans; });
__webpack_require__.d(__webpack_exports__, "Util", function() { return /* reexport */ Util; });
__webpack_require__.d(__webpack_exports__, "Log", function() { return /* reexport */ Log; });
__webpack_require__.d(__webpack_exports__, "MaterialUtil", function() { return /* reexport */ MaterialUtil_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "GraphicUtil", function() { return /* reexport */ GraphicUtil; });
__webpack_require__.d(__webpack_exports__, "DrawUtil", function() { return /* reexport */ DrawUtil_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "LayerUtil", function() { return /* reexport */ LayerUtil; });
__webpack_require__.d(__webpack_exports__, "BaseMaterialConver", function() { return /* reexport */ BaseMaterialConver_BaseMaterialConver; });
__webpack_require__.d(__webpack_exports__, "BaseStyleConver", function() { return /* reexport */ BaseStyleConver_BaseStyleConver; });
__webpack_require__.d(__webpack_exports__, "BillboardStyleConver", function() { return /* reexport */ BillboardStyleConver_BillboardStyleConver; });
__webpack_require__.d(__webpack_exports__, "BoxStyleConver", function() { return /* reexport */ BoxStyleConver_BoxStyleConver; });
__webpack_require__.d(__webpack_exports__, "CircleStyleConver", function() { return /* reexport */ CircleStyleConver_CircleStyleConver; });
__webpack_require__.d(__webpack_exports__, "CorridorStyleConver", function() { return /* reexport */ CorridorStyleConver_CorridorStyleConver; });
__webpack_require__.d(__webpack_exports__, "CylinderStyleConver", function() { return /* reexport */ CylinderStyleConver_CylinderStyleConver; });
__webpack_require__.d(__webpack_exports__, "DivGraphicStyleConver", function() { return /* reexport */ DivGraphicStyleConver_DivGraphicStyleConver; });
__webpack_require__.d(__webpack_exports__, "EllipsoidStyleConver", function() { return /* reexport */ EllipsoidStyleConver_EllipsoidStyleConver; });
__webpack_require__.d(__webpack_exports__, "LabelStyleConver", function() { return /* reexport */ LabelStyleConver_LabelStyleConver; });
__webpack_require__.d(__webpack_exports__, "ModelStyleConver", function() { return /* reexport */ ModelStyleConver_ModelStyleConver; });
__webpack_require__.d(__webpack_exports__, "PathStyleConver", function() { return /* reexport */ PathStyleConver_PathStyleConver; });
__webpack_require__.d(__webpack_exports__, "PlaneStyleConver", function() { return /* reexport */ PlaneStyleConver_PlaneStyleConver; });
__webpack_require__.d(__webpack_exports__, "PointStyleConver", function() { return /* reexport */ PointStyleConver_PointStyleConver; });
__webpack_require__.d(__webpack_exports__, "PolygonStyleConver", function() { return /* reexport */ PolygonStyleConver_PolygonStyleConver; });
__webpack_require__.d(__webpack_exports__, "PolylineStyleConver", function() { return /* reexport */ PolylineStyleConver_PolylineStyleConver; });
__webpack_require__.d(__webpack_exports__, "PolylineVolumeStyleConver", function() { return /* reexport */ PolylineVolumeStyleConver_PolylineVolumeStyleConver; });
__webpack_require__.d(__webpack_exports__, "RectangleStyleConver", function() { return /* reexport */ RectangleStyleConver_RectangleStyleConver; });
__webpack_require__.d(__webpack_exports__, "RectangularSensorStyleConver", function() { return /* reexport */ RectangularSensorStyleConver_RectangularSensorStyleConver; });
__webpack_require__.d(__webpack_exports__, "WallStyleConver", function() { return /* reexport */ WallStyleConver_WallStyleConver; });
__webpack_require__.d(__webpack_exports__, "material", function() { return /* reexport */ material_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "graphic", function() { return /* reexport */ graphic_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "provider", function() { return /* reexport */ provider_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "layer", function() { return /* reexport */ layer_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "thing", function() { return /* reexport */ thing_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "effect", function() { return /* reexport */ effect_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "control", function() { return /* reexport */ control_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "query", function() { return /* reexport */ query_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "Map", function() { return /* reexport */ Map_Map; });

// NAMESPACE OBJECT: ./src/const/Token.js
var Token_namespaceObject = {};
__webpack_require__.r(Token_namespaceObject);
__webpack_require__.d(Token_namespaceObject, "ion", function() { return ion; });
__webpack_require__.d(Token_namespaceObject, "mapbox", function() { return mapbox; });
__webpack_require__.d(Token_namespaceObject, "bing", function() { return bing; });
__webpack_require__.d(Token_namespaceObject, "tiandituArr", function() { return tiandituArr; });
__webpack_require__.d(Token_namespaceObject, "tianditu", function() { return tianditu; });
__webpack_require__.d(Token_namespaceObject, "gaodeArr", function() { return gaodeArr; });
__webpack_require__.d(Token_namespaceObject, "gaode", function() { return gaode; });
__webpack_require__.d(Token_namespaceObject, "baiduArr", function() { return baiduArr; });
__webpack_require__.d(Token_namespaceObject, "baidu", function() { return baidu; });

// NAMESPACE OBJECT: ./src/const/MaterialType.js
var MaterialType_namespaceObject = {};
__webpack_require__.r(MaterialType_namespaceObject);
__webpack_require__.d(MaterialType_namespaceObject, "Color", function() { return Color; });
__webpack_require__.d(MaterialType_namespaceObject, "Image", function() { return MaterialType_Image; });
__webpack_require__.d(MaterialType_namespaceObject, "Grid", function() { return Grid; });
__webpack_require__.d(MaterialType_namespaceObject, "Checkerboard", function() { return Checkerboard; });
__webpack_require__.d(MaterialType_namespaceObject, "Stripe", function() { return Stripe; });
__webpack_require__.d(MaterialType_namespaceObject, "Water", function() { return MaterialType_Water; });
__webpack_require__.d(MaterialType_namespaceObject, "PolylineDash", function() { return PolylineDash; });
__webpack_require__.d(MaterialType_namespaceObject, "PolylineOutline", function() { return PolylineOutline; });
__webpack_require__.d(MaterialType_namespaceObject, "PolylineArrow", function() { return PolylineArrow; });
__webpack_require__.d(MaterialType_namespaceObject, "PolylineGlow", function() { return PolylineGlow; });
__webpack_require__.d(MaterialType_namespaceObject, "LineFlow", function() { return LineFlow; });
__webpack_require__.d(MaterialType_namespaceObject, "LineFlowColor", function() { return LineFlowColor; });
__webpack_require__.d(MaterialType_namespaceObject, "ODLine", function() { return ODLine; });
__webpack_require__.d(MaterialType_namespaceObject, "LineFlicker", function() { return LineFlicker; });
__webpack_require__.d(MaterialType_namespaceObject, "LineTrail", function() { return LineTrail; });
__webpack_require__.d(MaterialType_namespaceObject, "WallScroll", function() { return WallScroll; });
__webpack_require__.d(MaterialType_namespaceObject, "ScanLine", function() { return ScanLine; });
__webpack_require__.d(MaterialType_namespaceObject, "CircleScan", function() { return CircleScan; });
__webpack_require__.d(MaterialType_namespaceObject, "CircleWave", function() { return CircleWave; });
__webpack_require__.d(MaterialType_namespaceObject, "RadarLine", function() { return RadarLine; });
__webpack_require__.d(MaterialType_namespaceObject, "RadarWave", function() { return RadarWave; });
__webpack_require__.d(MaterialType_namespaceObject, "Text", function() { return Text; });
__webpack_require__.d(MaterialType_namespaceObject, "RectSlide", function() { return RectSlide; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyGradient", function() { return PolyGradient; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyAsphalt", function() { return PolyAsphalt; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyBlob", function() { return PolyBlob; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyFacet", function() { return PolyFacet; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyGrass", function() { return PolyGrass; });
__webpack_require__.d(MaterialType_namespaceObject, "PolyWood", function() { return PolyWood; });
__webpack_require__.d(MaterialType_namespaceObject, "EllipsoidElectric", function() { return EllipsoidElectric; });
__webpack_require__.d(MaterialType_namespaceObject, "EllipsoidWave", function() { return EllipsoidWave; });
__webpack_require__.d(MaterialType_namespaceObject, "CylinderWave", function() { return CylinderWave; });

// NAMESPACE OBJECT: ./src/util/DomUtil.js
var DomUtil_namespaceObject = {};
__webpack_require__.r(DomUtil_namespaceObject);
__webpack_require__.d(DomUtil_namespaceObject, "create", function() { return create; });
__webpack_require__.d(DomUtil_namespaceObject, "createSvg", function() { return createSvg; });
__webpack_require__.d(DomUtil_namespaceObject, "createVideo", function() { return createVideo; });
__webpack_require__.d(DomUtil_namespaceObject, "get", function() { return DomUtil_get; });
__webpack_require__.d(DomUtil_namespaceObject, "parseDom", function() { return parseDom; });
__webpack_require__.d(DomUtil_namespaceObject, "remove", function() { return remove; });
__webpack_require__.d(DomUtil_namespaceObject, "empty", function() { return empty; });
__webpack_require__.d(DomUtil_namespaceObject, "getStyle", function() { return getStyle; });
__webpack_require__.d(DomUtil_namespaceObject, "hasClass", function() { return hasClass; });
__webpack_require__.d(DomUtil_namespaceObject, "addClass", function() { return addClass; });
__webpack_require__.d(DomUtil_namespaceObject, "removeClass", function() { return removeClass; });
__webpack_require__.d(DomUtil_namespaceObject, "setClass", function() { return setClass; });
__webpack_require__.d(DomUtil_namespaceObject, "getClass", function() { return getClass; });
__webpack_require__.d(DomUtil_namespaceObject, "enterFullscreen", function() { return enterFullscreen; });
__webpack_require__.d(DomUtil_namespaceObject, "exitFullscreen", function() { return exitFullscreen; });

// NAMESPACE OBJECT: ./src/util/PolyUtil.js
var PolyUtil_namespaceObject = {};
__webpack_require__.r(PolyUtil_namespaceObject);
__webpack_require__.d(PolyUtil_namespaceObject, "centerOfMass", function() { return centerOfMass; });
__webpack_require__.d(PolyUtil_namespaceObject, "buffer", function() { return buffer; });
__webpack_require__.d(PolyUtil_namespaceObject, "bufferPoints", function() { return bufferPoints; });
__webpack_require__.d(PolyUtil_namespaceObject, "getGranularity", function() { return getGranularity; });
__webpack_require__.d(PolyUtil_namespaceObject, "interPolygon", function() { return interPolygon; });
__webpack_require__.d(PolyUtil_namespaceObject, "getHeightRange", function() { return getHeightRange; });
__webpack_require__.d(PolyUtil_namespaceObject, "computeVolume", function() { return computeVolume; });
__webpack_require__.d(PolyUtil_namespaceObject, "updateVolumeByMinHeight", function() { return updateVolumeByMinHeight; });
__webpack_require__.d(PolyUtil_namespaceObject, "updateVolume", function() { return updateVolume; });
__webpack_require__.d(PolyUtil_namespaceObject, "getEllipseOuterPositions", function() { return getEllipseOuterPositions; });
__webpack_require__.d(PolyUtil_namespaceObject, "formatRectangle", function() { return formatRectangle; });
__webpack_require__.d(PolyUtil_namespaceObject, "getRectangle", function() { return getRectangle; });
__webpack_require__.d(PolyUtil_namespaceObject, "getPositionsRectVertex", function() { return getPositionsRectVertex; });
__webpack_require__.d(PolyUtil_namespaceObject, "getRectangleOuterPositions", function() { return getRectangleOuterPositions; });
__webpack_require__.d(PolyUtil_namespaceObject, "getRectPositionsByCenter", function() { return getRectPositionsByCenter; });
__webpack_require__.d(PolyUtil_namespaceObject, "isInPoly", function() { return PolyUtil_isInPoly; });
__webpack_require__.d(PolyUtil_namespaceObject, "getBezierCurve", function() { return getBezierCurve; });
__webpack_require__.d(PolyUtil_namespaceObject, "interPolyline", function() { return interPolyline; });
__webpack_require__.d(PolyUtil_namespaceObject, "interLine", function() { return interLine; });
__webpack_require__.d(PolyUtil_namespaceObject, "computeSurfaceLine", function() { return computeSurfaceLine; });
__webpack_require__.d(PolyUtil_namespaceObject, "computeSurfacePoints", function() { return computeSurfacePoints; });
__webpack_require__.d(PolyUtil_namespaceObject, "computeStepSurfaceLine", function() { return computeStepSurfaceLine; });
__webpack_require__.d(PolyUtil_namespaceObject, "getLinkedPointList", function() { return getLinkedPointList; });
__webpack_require__.d(PolyUtil_namespaceObject, "getOffsetLine", function() { return getOffsetLine; });
__webpack_require__.d(PolyUtil_namespaceObject, "sliceByMaxDistance", function() { return sliceByMaxDistance; });
__webpack_require__.d(PolyUtil_namespaceObject, "convex", function() { return convex; });

// NAMESPACE OBJECT: ./src/util/MeasureUtil.js
var MeasureUtil_namespaceObject = {};
__webpack_require__.r(MeasureUtil_namespaceObject);
__webpack_require__.d(MeasureUtil_namespaceObject, "getDistance", function() { return getDistance; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getSurfaceDistance", function() { return getSurfaceDistance; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getClampDistance", function() { return getClampDistance; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getArea", function() { return getArea; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getTriangleArea", function() { return MeasureUtil_getTriangleArea; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getClampArea", function() { return getClampArea; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getAngle", function() { return getAngle; });
__webpack_require__.d(MeasureUtil_namespaceObject, "getSlope", function() { return MeasureUtil_getSlope; });
__webpack_require__.d(MeasureUtil_namespaceObject, "formatDistance", function() { return formatDistance; });
__webpack_require__.d(MeasureUtil_namespaceObject, "formatArea", function() { return formatArea; });
__webpack_require__.d(MeasureUtil_namespaceObject, "formatVolume", function() { return formatVolume; });

// NAMESPACE OBJECT: ./src/util/MaterialUtil.js
var MaterialUtil_namespaceObject = {};
__webpack_require__.r(MaterialUtil_namespaceObject);
__webpack_require__.d(MaterialUtil_namespaceObject, "registerOptsConver", function() { return registerOptsConver; });
__webpack_require__.d(MaterialUtil_namespaceObject, "register", function() { return register; });
__webpack_require__.d(MaterialUtil_namespaceObject, "registerProperty", function() { return registerProperty; });
__webpack_require__.d(MaterialUtil_namespaceObject, "createMaterialProperty", function() { return createMaterialProperty; });
__webpack_require__.d(MaterialUtil_namespaceObject, "createMaterial", function() { return createMaterial; });
__webpack_require__.d(MaterialUtil_namespaceObject, "toJSON", function() { return MaterialUtil_toJSON; });

// NAMESPACE OBJECT: ./src/util/DrawUtil.js
var DrawUtil_namespaceObject = {};
__webpack_require__.r(DrawUtil_namespaceObject);
__webpack_require__.d(DrawUtil_namespaceObject, "PointType", function() { return PointType; });
__webpack_require__.d(DrawUtil_namespaceObject, "PointColor", function() { return PointColor; });
__webpack_require__.d(DrawUtil_namespaceObject, "setPointStyle", function() { return setPointStyle; });
__webpack_require__.d(DrawUtil_namespaceObject, "getEditPointStyle", function() { return getEditPointStyle; });

// NAMESPACE OBJECT: ./src/material/index.js
var material_namespaceObject = {};
__webpack_require__.r(material_namespaceObject);
__webpack_require__.d(material_namespaceObject, "TextMaterial", function() { return TextMaterial_TextMaterial; });
__webpack_require__.d(material_namespaceObject, "CylinderWaveMaterial", function() { return CylinderWaveMaterial_CylinderWaveMaterial; });
__webpack_require__.d(material_namespaceObject, "BaseMaterialProperty", function() { return BaseMaterialProperty_BaseMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "CircleScanMaterialProperty", function() { return CircleScanMaterialProperty_CircleScanMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "CircleWaveMaterialProperty", function() { return CircleWaveMaterialProperty_CircleWaveMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "EllipsoidElectricMaterialProperty", function() { return EllipsoidElectricMaterialProperty_EllipsoidElectricMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "EllipsoidWaveMaterialProperty", function() { return EllipsoidWaveMaterialProperty_EllipsoidWaveMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "LineFlickerMaterialProperty", function() { return LineFlickerMaterialProperty_LineFlickerMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "LineFlowColorMaterialProperty", function() { return LineFlowColorMaterialProperty_LineFlowColorMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "LineFlowMaterialProperty", function() { return LineFlowMaterialProperty_LineFlowMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "LineTrailMaterialProperty", function() { return LineTrailMaterialProperty_LineTrailMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "ODLineMaterialProperty", function() { return ODLineMaterialProperty_ODLineMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "RadarLineMaterialProperty", function() { return RadarLineMaterialProperty_RadarLineMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "RadarWaveMaterialProperty", function() { return RadarWaveMaterialProperty_RadarWaveMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "ScanLineMaterialProperty", function() { return ScanLineMaterialProperty_ScanLineMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "TextMaterialProperty", function() { return TextMaterialProperty_TextMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "WallScrollMaterialProperty", function() { return WallScrollMaterialProperty_WallScrollMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "WaterMaterialProperty", function() { return WaterMaterialProperty_WaterMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "PolyGradientMaterialProperty", function() { return PolyGradientMaterialProperty_PolyGradientMaterialProperty; });
__webpack_require__.d(material_namespaceObject, "RectSlideMaterialProperty", function() { return RectSlideMaterialProperty_RectSlideMaterialProperty; });

// NAMESPACE OBJECT: ./src/graphic/index.js
var graphic_namespaceObject = {};
__webpack_require__.r(graphic_namespaceObject);
__webpack_require__.d(graphic_namespaceObject, "BaseGraphic", function() { return BaseGraphic_BaseGraphic; });
__webpack_require__.d(graphic_namespaceObject, "BaseEntity", function() { return BaseEntity_BaseEntity; });
__webpack_require__.d(graphic_namespaceObject, "BasePointEntity", function() { return BasePointEntity_BasePointEntity; });
__webpack_require__.d(graphic_namespaceObject, "BasePolyEntity", function() { return BasePolyEntity_BasePolyEntity; });
__webpack_require__.d(graphic_namespaceObject, "BasePrimitive", function() { return BasePrimitive_BasePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "BasePointPrimitive", function() { return BasePointPrimitive_BasePointPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "BasePolyPrimitive", function() { return BasePolyPrimitive_BasePolyPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "PointEntity", function() { return PointEntity_PointEntity; });
__webpack_require__.d(graphic_namespaceObject, "BillboardEntity", function() { return BillboardEntity_BillboardEntity; });
__webpack_require__.d(graphic_namespaceObject, "LabelEntity", function() { return LabelEntity_LabelEntity; });
__webpack_require__.d(graphic_namespaceObject, "ModelEntity", function() { return ModelEntity_ModelEntity; });
__webpack_require__.d(graphic_namespaceObject, "BoxEntity", function() { return BoxEntity_BoxEntity; });
__webpack_require__.d(graphic_namespaceObject, "PlaneEntity", function() { return PlaneEntity_PlaneEntity; });
__webpack_require__.d(graphic_namespaceObject, "CircleEntity", function() { return CircleEntity_CircleEntity; });
__webpack_require__.d(graphic_namespaceObject, "CylinderEntity", function() { return CylinderEntity_CylinderEntity; });
__webpack_require__.d(graphic_namespaceObject, "EllipsoidEntity", function() { return EllipsoidEntity_EllipsoidEntity; });
__webpack_require__.d(graphic_namespaceObject, "PolylineEntity", function() { return PolylineEntity_PolylineEntity; });
__webpack_require__.d(graphic_namespaceObject, "PolylineVolumeEntity", function() { return PolylineVolumeEntity_PolylineVolumeEntity; });
__webpack_require__.d(graphic_namespaceObject, "PathEntity", function() { return PathEntity_PathEntity; });
__webpack_require__.d(graphic_namespaceObject, "CorridorEntity", function() { return CorridorEntity_CorridorEntity; });
__webpack_require__.d(graphic_namespaceObject, "WallEntity", function() { return WallEntity_WallEntity; });
__webpack_require__.d(graphic_namespaceObject, "RectangleEntity", function() { return RectangleEntity_RectangleEntity; });
__webpack_require__.d(graphic_namespaceObject, "PolygonEntity", function() { return PolygonEntity_PolygonEntity; });
__webpack_require__.d(graphic_namespaceObject, "FontBillboardEntity", function() { return FontBillboardEntity_FontBillboardEntity; });
__webpack_require__.d(graphic_namespaceObject, "DivBillboardEntity", function() { return DivBillboardEntity_DivBillboardEntity; });
__webpack_require__.d(graphic_namespaceObject, "EllipseEntity", function() { return EllipseEntity_EllipseEntity; });
__webpack_require__.d(graphic_namespaceObject, "CurveEntity", function() { return CurveEntity_CurveEntity; });
__webpack_require__.d(graphic_namespaceObject, "ConeTrack", function() { return ConeTrack_ConeTrack; });
__webpack_require__.d(graphic_namespaceObject, "RectangularSensor", function() { return RectangularSensor_RectangularSensor; });
__webpack_require__.d(graphic_namespaceObject, "Video2D", function() { return Video2D_Video2D; });
__webpack_require__.d(graphic_namespaceObject, "AttackArrow", function() { return AttackArrow_AttackArrow; });
__webpack_require__.d(graphic_namespaceObject, "AttackArrowPW", function() { return AttackArrowPW_AttackArrowPW; });
__webpack_require__.d(graphic_namespaceObject, "AttackArrowYW", function() { return AttackArrowYW_AttackArrowYW; });
__webpack_require__.d(graphic_namespaceObject, "CloseVurve", function() { return CloseVurve_CloseVurve; });
__webpack_require__.d(graphic_namespaceObject, "DoubleArrow", function() { return DoubleArrow_DoubleArrow; });
__webpack_require__.d(graphic_namespaceObject, "FineArrow", function() { return FineArrow_FineArrow; });
__webpack_require__.d(graphic_namespaceObject, "FineArrowYW", function() { return FineArrowYW_FineArrowYW; });
__webpack_require__.d(graphic_namespaceObject, "GatheringPlace", function() { return GatheringPlace_GatheringPlace; });
__webpack_require__.d(graphic_namespaceObject, "IsosTriangle", function() { return IsosTriangle_IsosTriangle; });
__webpack_require__.d(graphic_namespaceObject, "Lune", function() { return Lune_Lune; });
__webpack_require__.d(graphic_namespaceObject, "Regular", function() { return Regular_Regular; });
__webpack_require__.d(graphic_namespaceObject, "Sector", function() { return Sector_Sector; });
__webpack_require__.d(graphic_namespaceObject, "StraightArrow", function() { return StraightArrow_StraightArrow; });
__webpack_require__.d(graphic_namespaceObject, "PointPrimitive", function() { return PointPrimitive_PointPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "BillboardPrimitive", function() { return BillboardPrimitive_BillboardPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "LabelPrimitive", function() { return LabelPrimitive_LabelPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "ModelPrimitive", function() { return ModelPrimitive_ModelPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "CirclePrimitive", function() { return CirclePrimitive_CirclePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "PlanePrimitive", function() { return PlanePrimitive_PlanePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "BoxPrimitive", function() { return BoxPrimitive_BoxPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "CylinderPrimitive", function() { return CylinderPrimitive_CylinderPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "EllipsoidPrimitive", function() { return EllipsoidPrimitive_EllipsoidPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "PolylinePrimitive", function() { return PolylinePrimitive_PolylinePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "WallPrimitive", function() { return WallPrimitive_WallPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "CorridorPrimitive", function() { return CorridorPrimitive_CorridorPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "PolylineVolumePrimitive", function() { return PolylineVolumePrimitive_PolylineVolumePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "RectanglePrimitive", function() { return RectanglePrimitive_RectanglePrimitive; });
__webpack_require__.d(graphic_namespaceObject, "PolygonPrimitive", function() { return PolygonPrimitive_PolygonPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "FrustumPrimitive", function() { return FrustumPrimitive_FrustumPrimitive; });
__webpack_require__.d(graphic_namespaceObject, "BaseCombine", function() { return BaseCombine_BaseCombine; });
__webpack_require__.d(graphic_namespaceObject, "ModelCombine", function() { return ModelCombine_ModelCombine; });
__webpack_require__.d(graphic_namespaceObject, "PolygonCombine", function() { return PolygonCombine_PolygonCombine; });
__webpack_require__.d(graphic_namespaceObject, "PolylineCombine", function() { return PolylineCombine_PolylineCombine; });
__webpack_require__.d(graphic_namespaceObject, "FlatBillboard", function() { return FlatBillboard_FlatBillboard; });
__webpack_require__.d(graphic_namespaceObject, "LightCone", function() { return LightCone_LightCone; });
__webpack_require__.d(graphic_namespaceObject, "Water", function() { return Water_Water; });
__webpack_require__.d(graphic_namespaceObject, "DiffuseWall", function() { return DiffuseWall_DiffuseWall; });
__webpack_require__.d(graphic_namespaceObject, "ScrollWall", function() { return ScrollWall_ScrollWall; });
__webpack_require__.d(graphic_namespaceObject, "DynamicRiver", function() { return DynamicRiver_DynamicRiver; });
__webpack_require__.d(graphic_namespaceObject, "Road", function() { return Road_Road; });
__webpack_require__.d(graphic_namespaceObject, "Pit", function() { return Pit_Pit; });
__webpack_require__.d(graphic_namespaceObject, "DivGraphic", function() { return DivGraphic_DivGraphic; });
__webpack_require__.d(graphic_namespaceObject, "DivBoderLabel", function() { return DivBoderLabel_DivBoderLabel; });
__webpack_require__.d(graphic_namespaceObject, "DivLightPoint", function() { return DivLightPoint_DivLightPoint; });
__webpack_require__.d(graphic_namespaceObject, "DivUpLabel", function() { return DivUpLabel_DivUpLabel; });
__webpack_require__.d(graphic_namespaceObject, "ParticleSystem", function() { return ParticleSystem_ParticleSystem; });
__webpack_require__.d(graphic_namespaceObject, "Video3D", function() { return Video3D_Video3D; });
__webpack_require__.d(graphic_namespaceObject, "DynamicRoamLine", function() { return DynamicRoamLine_DynamicRoamLine; });
__webpack_require__.d(graphic_namespaceObject, "RoamLine", function() { return RoamLine_RoamLine; });

// NAMESPACE OBJECT: ./src/layer/tileLayer/provider/index.js
var provider_namespaceObject = {};
__webpack_require__.r(provider_namespaceObject);
__webpack_require__.d(provider_namespaceObject, "XyzImageryProvider", function() { return XyzImageryProvider_XyzImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "TdtImageryProvider", function() { return TdtImageryProvider_TdtImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "GaodeImageryProvider", function() { return GaodeImageryProvider_GaodeImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "BaiduImageryProvider", function() { return BaiduImageryProvider_BaiduImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "TencentImageryProvider", function() { return TencentImageryProvider_TencentImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "GoogleImageryProvider", function() { return GoogleImageryProvider_GoogleImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "OsmImageryProvider", function() { return OsmImageryProvider_OsmImageryProvider; });
__webpack_require__.d(provider_namespaceObject, "EmptyImageryProvider", function() { return EmptyImageryProvider_EmptyImageryProvider; });

// NAMESPACE OBJECT: ./src/layer/index.js
var layer_namespaceObject = {};
__webpack_require__.r(layer_namespaceObject);
__webpack_require__.d(layer_namespaceObject, "BaseLayer", function() { return BaseLayer_BaseLayer; });
__webpack_require__.d(layer_namespaceObject, "GroupLayer", function() { return GroupLayer_GroupLayer; });
__webpack_require__.d(layer_namespaceObject, "BaseTileLayer", function() { return BaseTileLayer_BaseTileLayer; });
__webpack_require__.d(layer_namespaceObject, "BaseGraphicLayer", function() { return BaseGraphicLayer_BaseGraphicLayer; });
__webpack_require__.d(layer_namespaceObject, "TerrainLayer", function() { return TerrainLayer_TerrainLayer; });
__webpack_require__.d(layer_namespaceObject, "ArcGisCacheLayer", function() { return ArcGisCacheLayer_ArcGisCacheLayer; });
__webpack_require__.d(layer_namespaceObject, "ArcGisLayer", function() { return ArcGisLayer_ArcGisLayer; });
__webpack_require__.d(layer_namespaceObject, "BaiduLayer", function() { return BaiduLayer_BaiduLayer; });
__webpack_require__.d(layer_namespaceObject, "BingLayer", function() { return BingLayer_BingLayer; });
__webpack_require__.d(layer_namespaceObject, "GaodeLayer", function() { return GaodeLayer_GaodeLayer; });
__webpack_require__.d(layer_namespaceObject, "GeeLayer", function() { return GeeLayer_GeeLayer; });
__webpack_require__.d(layer_namespaceObject, "GoogleLayer", function() { return GoogleLayer_GoogleLayer; });
__webpack_require__.d(layer_namespaceObject, "ImageLayer", function() { return ImageLayer_ImageLayer; });
__webpack_require__.d(layer_namespaceObject, "IonLayer", function() { return IonLayer_IonLayer; });
__webpack_require__.d(layer_namespaceObject, "MapboxLayer", function() { return MapboxLayer_MapboxLayer; });
__webpack_require__.d(layer_namespaceObject, "OsmLayer", function() { return OsmLayer_OsmLayer; });
__webpack_require__.d(layer_namespaceObject, "TdtLayer", function() { return TdtLayer_TdtLayer; });
__webpack_require__.d(layer_namespaceObject, "TencentLayer", function() { return TencentLayer_TencentLayer; });
__webpack_require__.d(layer_namespaceObject, "TmsLayer", function() { return TmsLayer_TmsLayer; });
__webpack_require__.d(layer_namespaceObject, "WmsLayer", function() { return WmsLayer_WmsLayer; });
__webpack_require__.d(layer_namespaceObject, "WmtsLayer", function() { return WmtsLayer_WmtsLayer; });
__webpack_require__.d(layer_namespaceObject, "XyzLayer", function() { return XyzLayer_XyzLayer; });
__webpack_require__.d(layer_namespaceObject, "GridLayer", function() { return GridLayer_GridLayer; });
__webpack_require__.d(layer_namespaceObject, "TileInfoLayer", function() { return TileInfoLayer_TileInfoLayer; });
__webpack_require__.d(layer_namespaceObject, "EmptyTileLayer", function() { return EmptyTileLayer_EmptyTileLayer; });
__webpack_require__.d(layer_namespaceObject, "CzmGeoJsonLayer", function() { return CzmGeoJsonLayer_CzmGeoJsonLayer; });
__webpack_require__.d(layer_namespaceObject, "KmlLayer", function() { return KmlLayer_KmlLayer; });
__webpack_require__.d(layer_namespaceObject, "CzmlLayer", function() { return CzmlLayer_CzmlLayer; });
__webpack_require__.d(layer_namespaceObject, "GraphicLayer", function() { return GraphicLayer_GraphicLayer; });
__webpack_require__.d(layer_namespaceObject, "GraphicGroupLayer", function() { return GraphicGroupLayer_GraphicGroupLayer; });
__webpack_require__.d(layer_namespaceObject, "DivLayer", function() { return DivLayer_DivLayer; });
__webpack_require__.d(layer_namespaceObject, "GeoJsonLayer", function() { return GeoJsonLayer_GeoJsonLayer; });
__webpack_require__.d(layer_namespaceObject, "ModelLayer", function() { return ModelLayer_ModelLayer; });
__webpack_require__.d(layer_namespaceObject, "TilesetLayer", function() { return TilesetLayer_TilesetLayer; });
__webpack_require__.d(layer_namespaceObject, "OsmBuildingsLayer", function() { return OsmBuildingsLayer_OsmBuildingsLayer; });
__webpack_require__.d(layer_namespaceObject, "GraticuleLayer", function() { return GraticuleLayer_GraticuleLayer; });
__webpack_require__.d(layer_namespaceObject, "LodGraphicLayer", function() { return LodGraphicLayer_LodGraphicLayer; });
__webpack_require__.d(layer_namespaceObject, "GeodePoiLayer", function() { return GeodePoiLayer_GeodePoiLayer; });
__webpack_require__.d(layer_namespaceObject, "WfsLayer", function() { return WfsLayer_WfsLayer; });
__webpack_require__.d(layer_namespaceObject, "ArcGisWfsLayer", function() { return ArcGisWfsLayer_ArcGisWfsLayer; });
__webpack_require__.d(layer_namespaceObject, "ArcGisWfsSingleLayer", function() { return ArcGisWfsSingleLayer_ArcGisWfsSingleLayer; });
__webpack_require__.d(layer_namespaceObject, "register", function() { return LayerUtil["register"]; });
__webpack_require__.d(layer_namespaceObject, "create", function() { return LayerUtil["create"]; });
__webpack_require__.d(layer_namespaceObject, "createTerrainProvider", function() { return LayerUtil["createTerrainProvider"]; });
__webpack_require__.d(layer_namespaceObject, "createImageryProvider", function() { return LayerUtil["createImageryProvider"]; });

// NAMESPACE OBJECT: ./src/thing/index.js
var thing_namespaceObject = {};
__webpack_require__.r(thing_namespaceObject);
__webpack_require__.d(thing_namespaceObject, "Underground", function() { return Underground_Underground; });
__webpack_require__.d(thing_namespaceObject, "ViewShed3D", function() { return ViewShed3D_ViewShed3D; });
__webpack_require__.d(thing_namespaceObject, "Sightline", function() { return Sightline_Sightline; });
__webpack_require__.d(thing_namespaceObject, "Skyline", function() { return Skyline_Skyline; });
__webpack_require__.d(thing_namespaceObject, "Shadows", function() { return Shadows_Shadows; });
__webpack_require__.d(thing_namespaceObject, "Measure", function() { return Measure_Measure; });
__webpack_require__.d(thing_namespaceObject, "MeasureVolume", function() { return MeasureVolume_MeasureVolume; });
__webpack_require__.d(thing_namespaceObject, "FloodByGraphic", function() { return FloodByGraphic_FloodByGraphic; });
__webpack_require__.d(thing_namespaceObject, "Slope", function() { return Slope_Slope; });
__webpack_require__.d(thing_namespaceObject, "TerrainPlanClip", function() { return TerrainPlanClip_TerrainPlanClip; });
__webpack_require__.d(thing_namespaceObject, "FloodByMaterial", function() { return FloodByMaterial_FloodByMaterial; });
__webpack_require__.d(thing_namespaceObject, "TerrainClip", function() { return TerrainClip_TerrainClip; });
__webpack_require__.d(thing_namespaceObject, "ContourLine", function() { return ContourLine_ContourLine; });
__webpack_require__.d(thing_namespaceObject, "LimitHeight", function() { return LimitHeight_LimitHeight; });
__webpack_require__.d(thing_namespaceObject, "TilesetPlanClip", function() { return TilesetPlanClip_TilesetPlanClip; });
__webpack_require__.d(thing_namespaceObject, "ModelPlanClip", function() { return ModelPlanClip_ModelPlanClip; });
__webpack_require__.d(thing_namespaceObject, "TilesetClip", function() { return TilesetClip_TilesetClip; });
__webpack_require__.d(thing_namespaceObject, "TilesetFlat", function() { return TilesetFlat_TilesetFlat; });
__webpack_require__.d(thing_namespaceObject, "TilesetFlood", function() { return TilesetFlood_TilesetFlood; });
__webpack_require__.d(thing_namespaceObject, "FirstPersonRoam", function() { return FirstPersonRoam_FirstPersonRoam; });
__webpack_require__.d(thing_namespaceObject, "StreetView", function() { return StreetView_StreetView; });
__webpack_require__.d(thing_namespaceObject, "CameraHistory", function() { return CameraHistory_CameraHistory; });
__webpack_require__.d(thing_namespaceObject, "RotatePoint", function() { return RotatePoint_RotatePoint; });
__webpack_require__.d(thing_namespaceObject, "RotateOut", function() { return RotateOut_RotateOut; });

// NAMESPACE OBJECT: ./src/effect/index.js
var effect_namespaceObject = {};
__webpack_require__.r(effect_namespaceObject);
__webpack_require__.d(effect_namespaceObject, "BaseEffect", function() { return BaseEffect_BaseEffect; });
__webpack_require__.d(effect_namespaceObject, "FogEffect", function() { return FogEffect_FogEffect; });
__webpack_require__.d(effect_namespaceObject, "RainEffect", function() { return RainEffect_RainEffect; });
__webpack_require__.d(effect_namespaceObject, "SnowEffect", function() { return SnowEffect_SnowEffect; });
__webpack_require__.d(effect_namespaceObject, "SnowCoverEffect", function() { return SnowCoverEffect_SnowCoverEffect; });
__webpack_require__.d(effect_namespaceObject, "InvertedEffect", function() { return InvertedEffect_InvertedEffect; });
__webpack_require__.d(effect_namespaceObject, "NightVisionEffect", function() { return NightVisionEffect_NightVisionEffect; });
__webpack_require__.d(effect_namespaceObject, "BloomEffect", function() { return BloomEffect_BloomEffect; });
__webpack_require__.d(effect_namespaceObject, "BrightnessEffect", function() { return BrightnessEffect_BrightnessEffect; });
__webpack_require__.d(effect_namespaceObject, "BlackAndWhiteEffect", function() { return BlackAndWhiteEffect_BlackAndWhiteEffect; });
__webpack_require__.d(effect_namespaceObject, "MosaicEffect", function() { return MosaicEffect_MosaicEffect; });
__webpack_require__.d(effect_namespaceObject, "DepthOfFieldEffect", function() { return DepthOfFieldEffect_DepthOfFieldEffect; });

// NAMESPACE OBJECT: ./src/control/index.js
var control_namespaceObject = {};
__webpack_require__.r(control_namespaceObject);
__webpack_require__.d(control_namespaceObject, "BaseControl", function() { return BaseControl_BaseControl; });
__webpack_require__.d(control_namespaceObject, "LocationBar", function() { return LocationBar_LocationBar; });
__webpack_require__.d(control_namespaceObject, "MouseDownView", function() { return MouseDownView_MouseDownView; });
__webpack_require__.d(control_namespaceObject, "Zoom", function() { return Zoom_Zoom; });
__webpack_require__.d(control_namespaceObject, "ToolButton", function() { return ToolButton_ToolButton; });
__webpack_require__.d(control_namespaceObject, "Compass", function() { return Compass_Compass; });
__webpack_require__.d(control_namespaceObject, "DistanceLegend", function() { return DistanceLegend_DistanceLegend; });
__webpack_require__.d(control_namespaceObject, "MapSplit", function() { return MapSplit_MapSplit; });

// NAMESPACE OBJECT: ./src/query/index.js
var query_namespaceObject = {};
__webpack_require__.r(query_namespaceObject);
__webpack_require__.d(query_namespaceObject, "BaiduPOI", function() { return BaiduPOI_BaiduPOI; });
__webpack_require__.d(query_namespaceObject, "GaodePOI", function() { return GaodePOI_GaodePOI; });
__webpack_require__.d(query_namespaceObject, "GaodeRoute", function() { return GaodeRoute_GaodeRoute; });
__webpack_require__.d(query_namespaceObject, "QueryGeoServer", function() { return QueryGeoServer_QueryGeoServer; });
__webpack_require__.d(query_namespaceObject, "QueryArcServer", function() { return QueryArcServer_QueryArcServer; });

// EXTERNAL MODULE: ./src/theme/Map.scss
var theme_Map = __webpack_require__(90);

// EXTERNAL MODULE: ./src/theme/LocationBar.scss
var theme_LocationBar = __webpack_require__(91);

// EXTERNAL MODULE: ./src/theme/ContextMenu.scss
var theme_ContextMenu = __webpack_require__(92);

// EXTERNAL MODULE: ./src/theme/MouseDownView.scss
var theme_MouseDownView = __webpack_require__(93);

// EXTERNAL MODULE: ./src/theme/Popup.scss
var theme_Popup = __webpack_require__(94);

// EXTERNAL MODULE: ./src/theme/SmallTooltip.scss
var theme_SmallTooltip = __webpack_require__(95);

// EXTERNAL MODULE: ./src/theme/Compass.scss
var theme_Compass = __webpack_require__(96);

// EXTERNAL MODULE: ./src/theme/DistanceLegend.scss
var theme_DistanceLegend = __webpack_require__(97);

// EXTERNAL MODULE: ./src/theme/MapSplit.scss
var theme_MapSplit = __webpack_require__(98);

// EXTERNAL MODULE: ./src/theme/DivGraphic.scss
var theme_DivGraphic = __webpack_require__(99);

// EXTERNAL MODULE: ./src/theme/DivLightPoint.scss
var theme_DivLightPoint = __webpack_require__(100);

// EXTERNAL MODULE: ./src/theme/DivBoderLabel.scss
var theme_DivBoderLabel = __webpack_require__(101);

// EXTERNAL MODULE: ./src/theme/DivUpLabel.scss
var theme_DivUpLabel = __webpack_require__(102);

// CONCATENATED MODULE: ./src/theme/index.js
// import 'cesium/Widgets/widgets.css'













// EXTERNAL MODULE: ./src/const/Version.js
var Version = __webpack_require__(25);

// EXTERNAL MODULE: external {"commonjs2":"tudou3d-cesium","amd":"tudou3d-cesium","commonjs":"tudou3d-cesium","root":"Cesium"}
var external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_ = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/proj4/lib/index.js + 89 modules
var lib = __webpack_require__(15);

// CONCATENATED MODULE: ./src/core/proj4_defs.js
 //常用的坐标系内置下，proj4已经内置了EPSG:4326、EPSG:3857、EPSG:4269
//以下配置，可以从 http://epsg.io 查询
//China Geodetic Coordinate System 2000

lib["a" /* default */].defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs"); //Zone横坐标前加带号， 6度分带
//CGCS2000 / Gauss-Kruger zone 13, bounds : 73.62 35.42 78.01 41.07

lib["a" /* default */].defs("EPSG:4491", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=13500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 14, bounds : 77.98 29.16 84.0 47.23

lib["a" /* default */].defs("EPSG:4492", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=14500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 15, bounds :84.0 27.32 90.0 49.18

lib["a" /* default */].defs("EPSG:4493", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=15500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 16, bounds :90.0 27.71 96.01 47.9

lib["a" /* default */].defs("EPSG:4494", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=16500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 17

lib["a" /* default */].defs("EPSG:4495", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=17500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 18

lib["a" /* default */].defs("EPSG:4496", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=18500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 19

lib["a" /* default */].defs("EPSG:4497", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=19500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 20

lib["a" /* default */].defs("EPSG:4498", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=20500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 21

lib["a" /* default */].defs("EPSG:4499", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=21500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 22

lib["a" /* default */].defs("EPSG:4500", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=22500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger zone 23

lib["a" /* default */].defs("EPSG:4501", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=23500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //Zone 横坐标前加带号， 3度分带
//CGCS2000 / 3-degree Gauss-Kruger zone 25 , bounds:  73.62 35.81  76.5 40.65

lib["a" /* default */].defs("EPSG:4513", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=25500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 26 , bounds:  76.5 31.03  79.5 41.83

lib["a" /* default */].defs("EPSG:4514", "+proj=tmerc +lat_0=0 +lon_0=78 +k=1 +x_0=26500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 27 , bounds:  79.5 29.95 82.51 45.88

lib["a" /* default */].defs("EPSG:4515", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=27500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 28

lib["a" /* default */].defs("EPSG:4516", "+proj=tmerc +lat_0=0 +lon_0=84 +k=1 +x_0=28500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 29

lib["a" /* default */].defs("EPSG:4517", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=29500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 30

lib["a" /* default */].defs("EPSG:4518", "+proj=tmerc +lat_0=0 +lon_0=90 +k=1 +x_0=30500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 31

lib["a" /* default */].defs("EPSG:4519", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=31500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 32

lib["a" /* default */].defs("EPSG:4520", "+proj=tmerc +lat_0=0 +lon_0=96 +k=1 +x_0=32500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 33

lib["a" /* default */].defs("EPSG:4521", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=33500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 34

lib["a" /* default */].defs("EPSG:4522", "+proj=tmerc +lat_0=0 +lon_0=102 +k=1 +x_0=34500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 35

lib["a" /* default */].defs("EPSG:4523", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=35500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 36

lib["a" /* default */].defs("EPSG:4524", "+proj=tmerc +lat_0=0 +lon_0=108 +k=1 +x_0=36500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 37

lib["a" /* default */].defs("EPSG:4525", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=37500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 38

lib["a" /* default */].defs("EPSG:4526", "+proj=tmerc +lat_0=0 +lon_0=114 +k=1 +x_0=38500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 39

lib["a" /* default */].defs("EPSG:4527", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=39500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 40

lib["a" /* default */].defs("EPSG:4528", "+proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=40500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 41

lib["a" /* default */].defs("EPSG:4529", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=41500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 42

lib["a" /* default */].defs("EPSG:4530", "+proj=tmerc +lat_0=0 +lon_0=126 +k=1 +x_0=42500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 43

lib["a" /* default */].defs("EPSG:4531", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=43500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 44

lib["a" /* default */].defs("EPSG:4532", "+proj=tmerc +lat_0=0 +lon_0=132 +k=1 +x_0=44500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger zone 45

lib["a" /* default */].defs("EPSG:4533", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=45500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CM 横坐标前不加带号， 6度分带
//CGCS2000 / Gauss-Kruger CM 75E

lib["a" /* default */].defs("EPSG:4502", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 81E

lib["a" /* default */].defs("EPSG:4503", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 87E

lib["a" /* default */].defs("EPSG:4504", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 93E

lib["a" /* default */].defs("EPSG:4505", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 99E

lib["a" /* default */].defs("EPSG:4506", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 105E

lib["a" /* default */].defs("EPSG:4507", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 111E

lib["a" /* default */].defs("EPSG:4508", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 117E

lib["a" /* default */].defs("EPSG:4509", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 123E

lib["a" /* default */].defs("EPSG:4510", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 129E

lib["a" /* default */].defs("EPSG:4511", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / Gauss-Kruger CM 135E

lib["a" /* default */].defs("EPSG:4512", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CM 横坐标前不加带号， 3度分带
//CGCS2000 / 3-degree Gauss-Kruger CM 75E, bounds: 73.62 35.81 76.5 40.65

lib["a" /* default */].defs("EPSG:4534", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 78E, bounds: 76.5 31.03 79.5 41.83

lib["a" /* default */].defs("EPSG:4535", "+proj=tmerc +lat_0=0 +lon_0=78 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 81E, bounds: 79.5 29.95 82.51 45.88

lib["a" /* default */].defs("EPSG:4536", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 84E

lib["a" /* default */].defs("EPSG:4537", "+proj=tmerc +lat_0=0 +lon_0=84 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 87E

lib["a" /* default */].defs("EPSG:4538", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 90E

lib["a" /* default */].defs("EPSG:4539", "+proj=tmerc +lat_0=0 +lon_0=90 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 93E

lib["a" /* default */].defs("EPSG:4540", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 96E

lib["a" /* default */].defs("EPSG:4541", "+proj=tmerc +lat_0=0 +lon_0=96 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 99E

lib["a" /* default */].defs("EPSG:4542", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 102E

lib["a" /* default */].defs("EPSG:4543", "+proj=tmerc +lat_0=0 +lon_0=102 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 105E

lib["a" /* default */].defs("EPSG:4544", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 108E

lib["a" /* default */].defs("EPSG:4545", "+proj=tmerc +lat_0=0 +lon_0=108 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 111E

lib["a" /* default */].defs("EPSG:4546", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 114E

lib["a" /* default */].defs("EPSG:4547", "+proj=tmerc +lat_0=0 +lon_0=114 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 117E

lib["a" /* default */].defs("EPSG:4548", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 120E

lib["a" /* default */].defs("EPSG:4549", "+proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 123E

lib["a" /* default */].defs("EPSG:4550", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 126E

lib["a" /* default */].defs("EPSG:4551", "+proj=tmerc +lat_0=0 +lon_0=126 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 129E

lib["a" /* default */].defs("EPSG:4552", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 132E

lib["a" /* default */].defs("EPSG:4553", "+proj=tmerc +lat_0=0 +lon_0=132 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs"); //CGCS2000 / 3-degree Gauss-Kruger CM 135E

lib["a" /* default */].defs("EPSG:4554", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(7);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(2);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(3);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./src/util/Log.js
var Log = __webpack_require__(9);

// EXTERNAL MODULE: ./src/util/Util.js
var Util = __webpack_require__(6);

// CONCATENATED MODULE: ./src/core/BaseClass.js




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



/**
 * 基础类，SDK中几乎所有类的基类，都是继承该基类的。
 * @param {Object} options 参数名称
 *
 * @export
 * @class BaseClass
 */

var BaseClass_BaseClass = /*#__PURE__*/function () {
  function BaseClass(options) {
    classCallCheck_default()(this, BaseClass);

    this.options = options;
  }
  /**
   * 销毁当前对象
   *
   * @param {Boolean} [noDel=false] false:会自动delete释放所有属性，true：不delete绑定的变量
   * @return {void}  无
   *
   */


  createClass_default()(BaseClass, [{
    key: "destroy",
    value: function destroy(noDel) {
      if (!noDel) {
        //删除所有绑定的数据
        for (var i in this) {
          delete this[i];
        }
      }
    }
    /**
     * 绑定指定类型事件监听器
     *
     * @param {EventType|EventType[]} types 事件类型
     * @param {Function} fn 绑定的监听器回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "on",
    value: function on(types, fn, context) {
      if (!types) {
        Object(Log["logError"])("绑定事件时传入了空值", fn);
        return this;
      } // types can be a map of types/handlers


      if (Array.isArray(types)) {
        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      } else if (Object(Util["isObject"])(types)) {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = Object(Util["splitWords"])(types);

        for (var _i = 0, _len = types.length; _i < _len; _i++) {
          this._on(types[_i], fn, context);
        }
      }

      this._onEventHook && this._onEventHook(types);
      return this;
    }
    /**
     * 解除绑定指定类型事件监听器
     *
     * @param {EventType|EventType[]} types 事件类型
     * @param {Function} fn 绑定的监听器回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "off",
    value: function off(types, fn, context) {
      if (!types) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (Array.isArray(types)) {
        for (var i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      } else if (Object(Util["isObject"])(types)) {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = Object(Util["splitWords"])(types);

        for (var _i2 = 0, _len2 = types.length; _i2 < _len2; _i2++) {
          this._off(types[_i2], fn, context);
        }
      }

      return this;
    }
  }, {
    key: "_on",
    value: function _on(type, fn, context) {
      this._events = this._events || {};
      /* get/init listeners for type */

      var typeListeners = this._events[type];

      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context == this) {
        // Less memory footprint.
        context = undefined;
      }

      var newListener = {
        fn: fn,
        ctx: context
      },
          listeners = typeListeners; // check if fn already there

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn == fn && listeners[i].ctx == context) {
          return;
        }
      }

      listeners.push(newListener);
    }
  }, {
    key: "_off",
    value: function _off(type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];

      if (!listeners) {
        return;
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        } // clear all listeners for a type if function isn't specified


        delete this._events[type];
        return;
      }

      if (context == this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];

          if (l.ctx != context) {
            continue;
          }

          if (l.fn == fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }

            listeners.splice(i, 1);
            return;
          }
        }
      }
    }
    /**
     * 触发指定类型的事件。
     *
     * @param {EventType} type 事件类型
     * @param {Object} data 传输的数据或对象，可在事件回调方法中event对象中获取进行使用
     * @param {BaseClass} [propagate=null] 将事件传播给父类 (用addEventParent设置)
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "fire",
    value: function fire(type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = _objectSpread(_objectSpread({}, data), {}, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });

      if (this._events) {
        var listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;

          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    }
    /**
     * 是否有绑定指定的事件
     *
     * @param {EventType} type 事件类型
     * @param {BaseClass} [propagate=null] 是否判断指定的父类 (用addEventParent设置的)
     * @return {Boolean} 是否存在
     *
     */

  }, {
    key: "listens",
    value: function listens(type, propagate) {
      var listeners = this._events && this._events[type];

      if (listeners && listeners.length) {
        return true;
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * 绑定一次性执行的指定类型事件监听器
     * 与on类似，监听器只会被触发一次，然后被删除。
     *
     * @param {EventType|EventType[]} types 事件类型
     * @param {Function} fn 绑定的监听器回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "once",
    value: function once(types, fn, context) {
      var _this = this;

      if (Object(Util["isObject"])(types)) {
        for (var type in types) {
          this.once(type, types[type], fn);
        }

        return this;
      }

      var handler = bind(function () {
        _this.off(types, fn, context).off(types, handler, context);
      }, this); // add a listener that's executed once and removed after that

      return this.on(types, fn, context).on(types, handler, context);
    }
    /**
     * 添加抛出事件到父类，它将接收传播的事件
     *
     * @param {Object} obj 父类对象
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "addEventParent",
    value: function addEventParent(obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    }
    /**
     * 移除抛出事件到父类
     *
     * @param {Object} obj 父类对象
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "removeEventParent",
    value: function removeEventParent(obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }

      return this;
    }
    /**
     * 是否绑定了抛出事件到指定父类
     *
     * @param {Object} obj 父类对象
     * @return {this} 当前对象本身,可以链式调用
     *
     */

  }, {
    key: "hasEventParent",
    value: function hasEventParent(obj) {
      if (this._eventParents && this._eventParents[stamp(obj)]) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "_propagateEvent",
    value: function _propagateEvent(e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, _objectSpread({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  }]);

  return BaseClass;
}();

function falseFn() {
  return false;
}

function bind(fn, obj) {
  var slice = Array.prototype.slice;

  if (fn.bind) {
    return fn.bind.apply(fn, slice.call(arguments, 1));
  }

  var args = slice.call(arguments, 2);
  return function () {
    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  };
}

var lastId = 0; //返回一个对象的唯一ID，如果它没有ID，则为它赋值。

function stamp(obj) {
  if (!obj) {
    return 0;
  }

  obj._tudou3d_id = obj._tudou3d_id || ++lastId;
  return obj._tudou3d_id;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var helpers_get = __webpack_require__(10);
var get_default = /*#__PURE__*/__webpack_require__.n(helpers_get);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(5);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(4);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(1);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// CONCATENATED MODULE: ./src/const/State.js
/**
 * 状态 枚举
 *  @enum {String}
 */
var State = {
  /**
   * 初始化
   */
  INITIALIZED: "inited",

  /**
   * 已添加到地图上
   */
  ADDED: "added",

  /**
   * 已移除地图
   */
  REMOVED: "removed",

  /**
   * 已销毁对象
   */
  DESTROY: "destroy"
};

// CONCATENATED MODULE: ./src/const/EventType.js
/**
 * 事件类型 枚举（所有事件统一的入口）
 * @enum {String}
 */
var EventType = {
  /**
   * 添加对象
   */
  add: "add",

  /**
   * 移除对象
   */
  remove: "remove",

  /**
   *添加矢量数据时[图层上监听时使用]
   */
  addGraphic: "addGraphic",

  /**
   *移除矢量数据时[图层上监听时使用]
   */
  removeGraphic: "removeGraphic",

  /**
   * 添加图层[map上监听时使用]
   */
  addLayer: "addLayer",

  /**
   * 移除图层[map上监听时使用]
   */
  removeLayer: "removeLayer",

  /**
   *更新了对象
   */
  update: "update",

  /**
   *更新了style对象
   */
  updateStyle: "updateStyle",

  /**
   *更新了attr对象
   */
  updateAttr: "updateAttr",

  /**
   *显示了对象
   */
  show: "show",

  /**
   *隐藏了对象
   */
  hide: "hide",

  /**
   * 开始
   */
  start: "start",

  /**
   * 变化了
   */
  change: "change",

  /**
   *多个数据异步分析时，完成其中一个时的回调事件
   */
  endItem: "endItem",

  /**
   *多个数据异步分析时，完成所有的回调事件
   */
  end: "end",

  /**
   * 完成
   */
  stop: "stop",

  /**
   * 完成加载，但未做任何其他处理前
   */
  loadBefore: "loadBefore",

  /**
   * 完成加载，执行所有内部处理后
   */
  load: "load",

  /**
   * 出错了
   */
  error: "error",

  /**
   * 完成加载配置信息
   */
  loadConfig: "loadConfig",

  /**
   * popup弹窗打开后
   */
  popupOpen: "popupOpen",

  /**
   * popup弹窗关闭
   */
  popupClose: "popupClose",

  /**
   * 左键单击  鼠标事件
   */
  click: "click",

  /**
   * 左键单击到矢量或模型数据时 鼠标事件
   */
  clickGraphic: "clickGraphic",

  /**
   * 左键单击到wms或arcgis瓦片服务的对应矢量数据时
   */
  clickTileGraphic: "clickTileGraphic",

  /**
   * 左键单击地图空白（未单击到矢量或模型数据）时 鼠标事件
   */
  clickMap: "clickMap",

  /**
   * 左键双击  鼠标事件
   */
  dblClick: "dblClick",

  /**
   * 左键鼠标按下 鼠标事件
   */
  leftDown: "leftDown",

  /**
   * 左键鼠标按下后释放   鼠标事件
   */
  leftUp: "leftUp",

  /**
   * 鼠标移动   鼠标事件
   */
  mouseMove: "mouseMove",

  /**
   * 鼠标移动（拾取目标，并延迟处理） 鼠标事件
   */
  mouseMoveTarget: "mouseMoveTarget",

  /**
   * 鼠标滚轮滚动  鼠标事件
   */
  wheel: "wheel",

  /**
   * 右键单击 鼠标事件
   */
  rightClick: "rightClick",

  /**
   * 右键鼠标按下  鼠标事件
   */
  rightDown: "rightDown",

  /**
   * 右键鼠标按下后释放   鼠标事件
   */
  rightUp: "rightUp",

  /**
   * 中键单击 鼠标事件
   */
  middleClick: "middleClick",

  /**
   * 中键鼠标按下  鼠标事件
   */
  middleDown: "middleDown",

  /**
   * 中键鼠标按下后释放 鼠标事件
   */
  middleUp: "middleUp",

  /**
   * 在触摸屏上两指缩放开始 鼠标事件
   */
  pinchStart: "pinchStart",

  /**
   * 在触摸屏上两指缩放结束  鼠标事件
   */
  pinchEnd: "pinchEnd",

  /**
   * 在触摸屏上两指移动 鼠标事件
   */
  pinchMove: "pinchMove",

  /**
   * 鼠标按下 [左中右3键都触发] 鼠标事件
   */
  mouseDown: "mouseDown",

  /**
   * 鼠标按下后释放 [左中右3键都触发] 鼠标事件
   */
  mouseUp: "mouseUp",

  /**
   * 鼠标移入 鼠标事件
   */
  mouseOver: "mouseOver",

  /**
   * 鼠标移出 鼠标事件
   */
  mouseOut: "mouseOut",

  /**
   * 按键按下 键盘事件
   */
  keydown: "keydown",

  /**
   * 按键按下后释放 键盘事件
   */
  keyup: "keyup",

  /**
   * 开始绘制 标绘事件
   */
  drawStart: "drawStart",

  /**
   * 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
   */
  drawMouseMove: "drawMouseMove",

  /**
   * 绘制过程中增加了点 标绘事件
   */
  drawAddPoint: "drawAddPoint",

  /**
   * 绘制过程中删除了最后一个点 标绘事件
   */
  drawRemovePoint: "drawRemovePoint",

  /**
   * 创建完成 标绘事件
   */
  drawCreated: "drawCreated",

  /**
   * 开始编辑 标绘事件
   */
  editStart: "editStart",

  /**
   * 移动鼠标按下左键（LEFT_DOWN）标绘事件
   */
  editMouseDown: "editMouseDown",

  /**
   *正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
   */
  editMouseMove: "editMouseMove",

  /**
   *编辑修改了点（LEFT_UP）标绘事件
   */
  editMovePoint: "editMovePoint",

  /**
   * 编辑删除了点 标绘事件
   */
  editRemovePoint: "editRemovePoint",

  /**
   * 图上编辑修改了相关style属性 标绘事件
   */
  editStyle: "editStyle",

  /**
   * 停止编辑 标绘事件
   */
  editStop: "editStop",

  /**
   * 标绘事件
   */
  move: "move",

  /**
   * 3dtiles模型，模型瓦片初始化完成
   * 该回调只执行一次
   */
  initialTilesLoaded: "initialTilesLoaded",

  /**
   * 3dtiles模型,当前批次模型加载完成
   * 该回调会执行多次，视角变化后重新加载一次完成后都会回调
   */
  allTilesLoaded: "allTilesLoaded",

  /**
   * 栅格瓦片图层，添加单个瓦片，开始加载瓦片（请求前）
   */
  addTile: "addTile",

  /**
   * 栅格瓦片图层，添加单个瓦片 加载瓦片完成
   */
  addTileSuccess: "addTileSuccess",

  /**
   * 栅格瓦片图层，添加单个瓦片 加载瓦片出错了
   */
  addTileError: "addTileError",

  /**
   * 栅格瓦片图层，移除单个瓦片
   */
  removeTile: "removeTile",

  /**
   * 相机开启移动前 场景事件
   */
  cameraMoveStart: "cameraMoveStart",

  /**
   *相机移动完成后 场景事件
   */
  cameraMoveEnd: "cameraMoveEnd",

  /**
   * 相机位置完成 场景事件
   */
  cameraChanged: "cameraChanged",

  /**
   * 场景更新前 场景事件
   */
  preUpdate: "preUpdate",

  /**
   * 场景更新后 场景事件
   */
  postUpdate: "postUpdate",

  /**
   * 场景渲染前 场景事件
   */
  preRender: "preRender",

  /**
   * 场景渲染后 场景事件
   */
  postRender: "postRender",

  /**
   * 场景渲染失败（需要刷新页面）
   */
  renderError: "renderError",

  /**
   * 场景模式(2D/3D/哥伦布)变换前 场景事件
   */
  morphStart: "morphStart",

  /**
   * 完成场景模式(2D/3D/哥伦布)变换 场景事件
   */
  morphComplete: "morphComplete",

  /**
   * 时钟跳动 场景事件
   */
  clockTick: "clockTick"
};

// CONCATENATED MODULE: ./src/core/BaseThing.js







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * Thing对象(如特效、分析、管理类等) 的基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Boolean} [options.stopPropagation=false] 当前类中事件是否停止冒泡, false时：事件冒泡到map中。
 * @export
 * @class BaseThing
 * @extends {BaseClass}
 *
 * @see [支持的事件类型]{@link BaseThing.EventType}
 */

var BaseThing_BaseThing = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(BaseThing, _BaseClass);

  var _super = _createSuper(BaseThing);

  function BaseThing() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseThing);

    if (Object(Util["isBoolean"])(options)) {
      options = {
        enabled: options
      };
    } // options.stopPropagation = Cesium.defaultValue(options.stopPropagation, false)


    _this = _super.call(this, options);
    _this._uuid = Object(Util["uuid"])();
    _this._id = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.id, _this._uuid);
    _this._enabled = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.enabled, true);
    _this._state = State.INITIALIZED;
    _this.options = options;
    return _this;
  } //========== 对外属性 ==========

  /**
   *  内置唯一标识ID
   *
   * @type {String}
   * @readonly
   */


  createClass_default()(BaseThing, [{
    key: "uuid",
    get: function get() {
      return this._uuid;
    }
    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     *
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * 是否已添加到地图
     *
     * @type {Boolean}
     * @readonly
     *
     */

  }, {
    key: "isAdded",
    get: function get() {
      return this._state == State.ADDED;
    }
    /**
     * 对象的id标识
     * @type {String|Number}
     */

  }, {
    key: "id",
    get: function get() {
      return this._id;
    },
    set: function set(id) {
      this._id = id;
    }
    /**
     *  设置对象的启用和禁用状态。
     * @type {Boolean}
     *
     */

  }, {
    key: "enabled",
    get: function get() {
      return this._enabled;
    },
    set: function set(val) {
      if (this._enabled == val) {
        return;
      }

      this._enabled = val;
      this._enabledHook && this._enabledHook(val);
    }
    /**
     * 添加到地图上，同 map.addThing
     *
     * @param {Map} map 地图对象
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "addTo",
    value: function addTo(map) {
      if (map && map.addThing) {
        map.addThing(this);
      }

      return this;
    }
    /**
     * 从地图上移除，同map.removeThing
     *
     * @param {Boolean} destroy 是否调用destroy释放
     * @return {void}  无
     */

  }, {
    key: "remove",
    value: function remove(destroy) {
      if (this._map) {
        this._map.removeThing(this, destroy);
      }
    }
    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onAdd",
    value: function _onAdd(map) {
      if (this._state == State.ADDED) {
        return;
      }

      this._map = map;

      if (!this.options.stopPropagation) {
        this.addEventParent(map);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._mountedHook();

          this._createOK = true;
        }
      }

      this._addedBaseHook && this._addedBaseHook();
      this._addedHook && this._addedHook();
      this._state = State.ADDED;
      this.fire(EventType.add);
    }
    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onRemove",
    value: function _onRemove() {
      if (this._state == State.REMOVED) {
        return;
      }

      if (!this._map) {
        return;
      }

      this._removedBaseHook && this._removedBaseHook();
      this._removedHook && this._removedHook();
      this._state = State.REMOVED;
      this.fire(EventType.remove);

      if (this.options && !this.options.stopPropagation) {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {} //销毁

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      if (this._state != State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }

      get_default()(getPrototypeOf_default()(BaseThing.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return BaseThing;
}(BaseClass_BaseClass);
/**
 * @typedef {Object} BaseThing.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} add 添加对象
 * @property {String} remove 移除对象
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.add, function (event) {
 *   console.log('添加了对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */
// EXTERNAL MODULE: ./src/core/LatLngPoint.js
var LatLngPoint = __webpack_require__(13);

// CONCATENATED MODULE: ./src/core/LatLngArray.js




/**
 * 坐标数组处理类
 *
 * @export
 * @class LatLngArray
 */

var LatLngArray_LatLngArray = /*#__PURE__*/function () {
  function LatLngArray() {
    classCallCheck_default()(this, LatLngArray);
  }

  createClass_default()(LatLngArray, null, [{
    key: "toCartesians",
    value:
    /**
     * 根据传入的各种对象数据数组，转换返回Cartesian3数组
     *
     * @static
     * @param {String[]|Array[]|LatLngPoint[]} value 坐标位置数组
     * @return {Cesium.Cartesian3[]}  转换返回的Cartesian3数组
     */
    function toCartesians(value) {
      if (!Array.isArray(value)) {
        return value;
      }

      var _positions = [];
      value.forEach(function (item) {
        if (item instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]) {
          _positions.push(item);

          return;
        }

        var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

        if (!_point) {
          return;
        }

        _positions.push(_point.toCartesian(true));
      });
      return _positions;
    }
    /**
     * 根据传入的各种对象数据数组，转换返回LatLngPoint数组
     *
     * @static
     * @param {String[]|Array[]|Cesium.Cartesian3[]} value 坐标位置数组
     * @return {LatLngPoint[]}  转换返回的LatLngPoint数组
     */

  }, {
    key: "toPoints",
    value: function toPoints(value) {
      if (!Array.isArray(value)) {
        return value;
      }

      var _points = [];
      value.forEach(function (item) {
        if (item instanceof LatLngPoint["a" /* LatLngPoint */]) {
          _points.push(item);

          return;
        }

        var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

        if (!_point) {
          return;
        }

        _points.push(_point);
      });
      return _points;
    }
    /**
     * 根据传入的各种对象数据数组，转换返回经纬度坐标数组
     *
     * @static
     * @param {String[]|Array[]|Cesium.Cartesian3[]} value 坐标位置数组
     * @param {Boolean} noAlt 是否包含高度值
     * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     */

  }, {
    key: "toArray",
    value: function toArray(value, noAlt) {
      if (!Array.isArray(value)) {
        return value;
      }

      var _points = [];
      value.forEach(function (item) {
        if (Array.isArray(item)) {
          _points.push(item);

          return;
        }

        var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

        if (!_point) {
          return;
        }

        _points.push(_point.toArray(noAlt));
      });
      return _points;
    }
  }]);

  return LatLngArray;
}();
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(17);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/shaders/GroundSkyBoxFS.glsl
var GroundSkyBoxFS = __webpack_require__(37);
var GroundSkyBoxFS_default = /*#__PURE__*/__webpack_require__.n(GroundSkyBoxFS);

// EXTERNAL MODULE: ./src/shaders/GroundSkyBoxVS.glsl
var GroundSkyBoxVS = __webpack_require__(38);
var GroundSkyBoxVS_default = /*#__PURE__*/__webpack_require__.n(GroundSkyBoxVS);

// CONCATENATED MODULE: ./src/core/GroundSkyBox.js







function GroundSkyBox_createSuper(Derived) { var hasNativeReflectConstruct = GroundSkyBox_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GroundSkyBox_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 近地天空盒, 在场景周围绘制星星等太空背景。
 * 天空盒子是用真正的赤道平均春分点(TEME)轴定义的。仅在3D中支持。当转换为2D或哥伦布视图时，天空盒会淡出。
 * 天空盒子的大小不能超过{@link Cesium.Scene#maximumCubeMapSize}。
 *
 * @param {Object} options 对象，具有以下属性:
 * @param {Object} [options.sources] 天空盒的6个立方体映射面的图片url
 * @param {String} [options.sources.positiveX] 映射面的图片url
 * @param {String} [options.sources.negativeX] 映射面的图片url
 * @param {String} [options.sources.positiveY] 映射面的图片url
 * @param {String} [options.sources.negativeY] 映射面的图片url
 * @param {String} [options.sources.positiveZ] 映射面的图片url
 * @param {String} [options.sources.negativeZ] 映射面的图片url
 * @param {Boolean} [options.show=true] 是否显示
 *
 * @export
 * @class GroundSkyBox
 * @extends {Cesium.SkyBox}
 * @example
 * scene.skyBox = new tudou3d.GroundSkyBox({
 *   sources : {
 *     positiveX : 'skybox_px.png',
 *     negativeX : 'skybox_nx.png',
 *     positiveY : 'skybox_py.png',
 *     negativeY : 'skybox_ny.png',
 *     positiveZ : 'skybox_pz.png',
 *     negativeZ : 'skybox_nz.png'
 *   }
 * });
 */

var GroundSkyBox_GroundSkyBox = /*#__PURE__*/function (_Cesium$SkyBox) {
  inherits_default()(GroundSkyBox, _Cesium$SkyBox);

  var _super = GroundSkyBox_createSuper(GroundSkyBox);

  function GroundSkyBox() {
    classCallCheck_default()(this, GroundSkyBox);

    return _super.apply(this, arguments);
  }

  createClass_default()(GroundSkyBox, [{
    key: "update",
    value: //内部渲染的方法
    function update(frameState, useHdr) {
      var that = this;

      if (!this.show) {
        return undefined;
      }

      if (frameState.mode !== external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D && frameState.mode !== external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING) {
        return undefined;
      } // The sky box is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.


      if (!frameState.passes.render) {
        return undefined;
      }

      var context = frameState.context;

      if (this._sources !== this.sources) {
        this._sources = this.sources;
        var sources = this.sources; //>>includeStart('debug', pragmas.debug);

        if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.positiveX) || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.negativeX) || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.positiveY) || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.negativeY) || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.positiveZ) || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](sources.negativeZ)) {
          throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");
        }

        if (typeof_default()(sources.positiveX) !== typeof_default()(sources.negativeX) || typeof_default()(sources.positiveX) !== typeof_default()(sources.positiveY) || typeof_default()(sources.positiveX) !== typeof_default()(sources.negativeY) || typeof_default()(sources.positiveX) !== typeof_default()(sources.positiveZ) || typeof_default()(sources.positiveX) !== typeof_default()(sources.negativeZ)) {
          throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("this.sources properties must all be the same type.");
        } //>>includeEnd('debug');


        if (typeof sources.positiveX === "string") {
          // Given urls for cube-map images.  Load them.
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["loadCubeMap"](context, this._sources).then(function (cubeMap) {
            that._cubeMap = that._cubeMap && that._cubeMap.destroy();
            that._cubeMap = cubeMap;
          });
        } else {
          this._cubeMap = this._cubeMap && this._cubeMap.destroy();
          this._cubeMap = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CubeMap"]({
            context: context,
            source: sources
          });
        }
      }

      var command = this._command;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](command.vertexArray)) {
        command.uniformMap = {
          u_cubeMap: function u_cubeMap() {
            return that._cubeMap;
          },
          //【土豆数据tudougis.cn】 Hao 2019-9-18   近地天空盒
          u_rotateMatrix: function u_rotateMatrix() {
            command.modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(frameState.camera._positionWC);
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].getMatrix3(command.modelMatrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]());
          } //【土豆数据tudougis.cn】 Hao 2019-9-18   近地天空盒

        };
        var geometry = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoxGeometry"].createGeometry(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoxGeometry"].fromDimensions({
          dimensions: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](2.0, 2.0, 2.0),
          vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexFormat"].POSITION_ONLY
        }));
        var attributeLocations = this._attributeLocations = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryPipeline"].createAttributeLocations(geometry);
        command.vertexArray = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexArray"].fromGeometry({
          context: context,
          geometry: geometry,
          attributeLocations: attributeLocations,
          bufferUsage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW
        });
        command.renderState = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"].fromCache({
          blending: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BlendingState"].ALPHA_BLEND
        });
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](command.shaderProgram) || this._useHdr !== useHdr) {
        var fs = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderSource"]({
          defines: [useHdr ? "HDR" : ""],
          sources: [GroundSkyBoxFS_default.a]
        });
        command.shaderProgram = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"].fromCache({
          context: context,
          vertexShaderSource: GroundSkyBoxVS_default.a,
          fragmentShaderSource: fs,
          attributeLocations: this._attributeLocations
        });
        this._useHdr = useHdr;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cubeMap)) {
        return undefined;
      }

      return command;
    }
  }]);

  return GroundSkyBox;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SkyBox"]);
// EXTERNAL MODULE: ./src/const/CRS.js
var CRS = __webpack_require__(16);

// EXTERNAL MODULE: ./src/const/ChinaCRS.js
var ChinaCRS = __webpack_require__(18);

// CONCATENATED MODULE: ./src/const/Token.js
/**
 * SDK中涉及到的所有第3放地图服务的Token令牌key，
 * 【重要提示：为了避免后期失效，请全部重新赋值换成自己的key】
 * @module Token
 */

/**
 * Cesium官方的Ion服务key，
 * 官网： {@link https://cesium.com/ion/signin/}
 *  @enum {String}
 */
var ion = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlZDJjMTcwNS04ZDVmLTQzNWQtYWUyZC0yMTJkMDkyMzkyMjMiLCJpZCI6MTQ4MiwiaWF0IjoxNjQ4NDQ2OTIwfQ.7e1QUkx_k-mZBxKz9tV8a5TFEorrlLlkfcVNNPzfTQY";
/**
 * mapbox地图key，
 * 官网：{@link https://account.mapbox.com}
 *  @enum {String}
 */

var mapbox = "sk.eyJ1IjoibWFyc2dpcyIsImEiOiJjbDFhYXQ3a2EwaHF6M2NvdnhmdjR6ajZ2In0.-sahm9R0QuPP3pAihJHC4A";
/**
 * 微软Bing地图key，
 * 官网： {@link https://www.bingmapsportal.com/Application}
 *  @enum {String}
 */

var bing = "Am5SdKm6pNdkP1P5zuUOMZwleCHeA7GD5vuQgZ3xBUbEMBeQ5cQ1WN4B8xqqV1Vt"; //2020-11-19

/**
 * 天地图key数组，
 * 官网： {@link https://console.tianditu.gov.cn/api/key}
 *  @enum {String[]}
 */

var tiandituArr = ["9ae78c51a0a28f06444d541148496e36", //2020-10-10
"2a0e637a8772d92b123ee8866dee4a82"];
/**
 * 天地图key，
 *  @enum {String}
 */

var tianditu = tiandituArr[0];
/**
 * 高德key数组，
 * 官网： {@link https://console.amap.com/dev/key/app}
 *  @enum {String[]}
 */

var gaodeArr = ["ae29a37307840c7ae4a785ac905927e0", //2020-6-18
"888a52a74c55ca47abe6c55ab3661d11", "0bc2903efcb3b67ebf1452d2f664a238", "0df8f6f984adc49fca5b7b1108664da2", "72f75689dff38a781055e68843474751"];
/**
 * 高德key，
 *  @enum {String}
 */

var gaode = gaodeArr[0];
/**
 * 百度key数组，
 * 官网： {@link http://lbsyun.baidu.com/apiconsole/key#/home}
 *  @enum {String[]}
 */

var baiduArr = ["c3qarrKcqnB9HbCOPfKOHgneH6AGXCVU", //2020-6-6
"6g6evLsHT4M0DVZnRXRpXDDq1t95ESrg", "4j0HA8IeuvAPCl62ni8xCZkBhc2YGr67", "F4CZ3cvHf8vbL8rkuTNtx8w2eflpdzj5", "qObioeG8HeeQVrOVAGScPVhDzlmv6rL9"];
/**
 * 百度key，
 *  @enum {String}
 */

var baidu = baiduArr[0];
// CONCATENATED MODULE: ./src/const/MaterialType.js
/**
 * 材质 类型枚举
 * @module MaterialType
 * @example
//Entity矢量对象
let graphic = new tudou3d.graphic.PolylineEntity({
  positions: [
    [117.169646, 31.769171],
    [117.194579, 31.806466],
  ],
  style: {
    width: 5,
    material: tudou3d.MaterialUtil.createMaterialProperty(tudou3d.MaterialType.LineFlow, {
      color: '#00ff00',
      image: 'img/textures/LinkPulse.png',
      speed: 5,
    }),
  },
})
graphicLayer.addGraphic(graphic)

//Primitive矢量对象
var primitive = new tudou3d.graphic.PolylinePrimitive({
  positions: [
    [117.348938, 31.805369, 7.63],
    [117.429496, 31.786715, 8.41],
  ],
  style: {
    width: 5,
    material: tudou3d.MaterialUtil.createMaterial(tudou3d.MaterialType.LineFlow, {
      color: '#1a9850',
      image: 'img/textures/ArrowOpacity.png',
      speed: 10,
    }),
  },
})
graphicLayer.addGraphic(primitive)
 *
 */

/**
 * 通用：纯色颜色 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color}  [color=Cesium.Color.WHITE] 颜色
 *
 * @see Cesium.Material.ColorType
 * @see Cesium.ColorMaterialProperty
 */

var Color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ColorType;
/**
 * 通用：图片 材质
 * @type {String}
 * @readonly
 * @property {String|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image 图片对象或图片地址
 * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] The color applied to the image
 * @property {Boolean} [transparent=false] Set to true when the image has transparency (for example, when a png has transparent sections)
 *
 * @see Cesium.Material.ImageType
 * @see Cesium.ImageMaterialProperty
 */

var MaterialType_Image = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ImageType;
/**
 * 通用：网格 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] A Property specifying the grid {@link Color}.
 * @property {Number} [cellAlpha=0.1] A numeric Property specifying cell alpha values.
 * @property {Cesium.Cartesian2} [lineCount=new Cesium.Cartesian2(8, 8)] A {@link Cartesian2} Property specifying the number of grid lines along each axis.
 * @property {Cesium.Cartesian2} [lineThickness=new Cesium.Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
 * @property {Cesium.Cartesian2} [lineOffset=new Cesium.Cartesian2(0.0, 0.0)] A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
 *
 *
 * @see Cesium.Material.GridType
 * @see Cesium.GridMaterialProperty
 */

var Grid = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].GridType;
/**
 * 通用：棋盘 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color} [evenColor=Cesium.Color.WHITE] A Property specifying the first {@link Cesium.Color}.
 * @property {Cesium.Color} [oddColor=Cesium.Color.BLACK] A Property specifying the second {@link Cesium.Color}.
 * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(2.0, 2.0)] A {@link Cesium.Cartesian2} Property specifying how many times the tiles repeat in each direction.
 *
 *
 * @see Cesium.Material.CheckerboardType
 * @see Cesium.CheckerboardMaterialProperty
 */

var Checkerboard = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CheckerboardType;
/**
 * 通用：条纹 材质
 * @type {String}
 * @readonly
 * @property {Cesium.StripeOrientation} [orientation=Cesium.StripeOrientation.HORIZONTAL] 条纹方向
 * @property {Cesium.Color} [evenColor=Cesium.Color.WHITE] A Property specifying the first {@link Color}.
 * @property {Cesium.Color} [oddColor=Cesium.Color.BLACK] A Property specifying the second {@link Color}.
 * @property {Number} [offset=0] A numeric Property specifying how far into the pattern to start the material.
 * @property {Number} [repeat=1] A numeric Property specifying how many times the stripes repeat.
 *
 *
 * @see Cesium.Material.StripeType
 * @see Cesium.StripeMaterialProperty
 */

var Stripe = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].StripeType;
/**
 * 通用：水面 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color}  [baseWaterColor=new Cesium.Color(0.2, 0.3, 0.6, 1.0)] 基础颜色
 * @property {Cesium.Color}  [blendColor=new Cesium.Color(0.0, 1.0, 0.699, 1.0)] 从水中混合到非水域时使用的rgba颜色对象。
 * @property {String}  [specularMap] 单一通道纹理用来指示水域的面积。
 * @property {String}  [normalMap] 水正常扰动的法线图。
 * @property {Number}  [frequency=100] 控制波数的数字。
 * @property {Number}  [animationSpeed=0.01] 控制水的动画速度的数字。
 * @property {Number}  [amplitude=10] 控制水波振幅的数字。
 * @property {Number}  [specularIntensity=0.5] 控制镜面反射强度的数字。
 * @property {Number}  [fadeFactor=1.0] fadeFactor
 *
 * @see Cesium.Material.WaterType
 * @see WaterMaterialProperty
 */

var MaterialType_Water = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].WaterType;
/**
 * 线：虚线 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] A Property specifying the {@link Color} of the line.
 * @property {Cesium.Color} [gapColor=Cesium.Color.TRANSPARENT] A Property specifying the {@link Color} of the gaps in the line.
 * @property {Number} [dashLength=16.0] A numeric Property specifying the length of the dash pattern in pixels.
 * @property {Number} [dashPattern=255.0] A numeric Property specifying a 16 bit pattern for the dash
 *
 * @see Cesium.Material.PolylineDashType
 * @see Cesium.PolylineDashMaterialProperty
 */

var PolylineDash = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolylineDashType;
/**
 * 线：衬色线 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] A Property specifying the {@link Color} of the line.
 * @property {Cesium.Color} [outlineColor=Cesium.Color.BLACK] A Property specifying the {@link Color} of the outline.
 * @property {Number} [outlineWidth=1.0] A numeric Property specifying the width of the outline, in pixels.
 *
 *
 * @see Cesium.Material.PolylineOutlineType
 * @see Cesium.PolylineOutlineMaterialProperty
 */

var PolylineOutline = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolylineOutlineType;
/**
 * 线：箭头 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color}  [color=Cesium.Color.WHITE] 颜色
 *
 * @see Cesium.Material.PolylineArrowType
 * @see Cesium.PolylineArrowMaterialProperty
 */

var PolylineArrow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolylineArrowType;
/**
 * 线：高亮线 材质
 * @type {String}
 * @readonly
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] A Property specifying the {@link Color} of the line.
 * @property {Number} [glowPower=0.25] 高亮强度,占总线宽的百分比表示。
 * @property {Number} [taperPower=1.0] A numeric Property specifying the strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.
 *
 *
 * @see Cesium.Material.PolylineGlowType
 * @see Cesium.PolylineGlowMaterialProperty
 */

var PolylineGlow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolylineGlowType;
/**
 * 线状: 流动图片效果 材质（适用于线和墙）
 * @type {String}
 * @readonly
 *
 * @property {String} image 背景图片URL
 * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
 * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(1.0, 1.0)] 横纵方向重复次数
 * @property {Boolean} [axisY=false] 是否Y轴朝上
 * @property {Number} [speed=10] 速度，值越大越快
 * @property {Boolean} [hasImage2=false] 是否有2张图片的混合模式
 * @property {String} [image2] 第2张背景图片URL地址
 * @property {Cesium.Color} [color2=new Cesium.Color(1, 1, 1)] 第2张背景图片颜色
 *
 * @see tudou3d.MaterialType.LineFlow
 * @see LineFlowMaterialProperty
 */

var LineFlow = "LineFlow";
/**
 * 线状: 流动颜色效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @property {Number} [speed=2] 速度，值越大越快
 * @property {Number} [percent=0.04] 比例
 * @property {Number} [alpha=0.1] 透明程度 0.0-1.0
 * @property {Number} [startTime=0] 开始的时间
 *
 * @see tudou3d.MaterialType.LineFlowColor
 * @see LineFlowColorMaterialProperty
 */

var LineFlowColor = "LineFlowColor";
/**
 * 线状: OD线效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 运动对象的颜色
 * @property {Cesium.Color} [options.bgColor] 线的背景颜色
 * @property {Number} [startTime=0] 开始的时间
 * @property {Number} [speed=20] 速度，值越大越快
 * @property {Number} [options.bidirectional=0]  运行形式：0 正向运动 1 反向运动 2 双向运动
 *
 * @see tudou3d.MaterialType.ODLine
 * @see ODLineMaterialProperty
 */

var ODLine = "ODLine";
/**
 * 线状: 闪烁线 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 线颜色
 * @property {Number} [speed=10] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.LineFlicker
 * @see LineFlickerMaterialProperty
 */

var LineFlicker = "LineFlicker";
/**
 * 线状: 轨迹线 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 线颜色
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.LineTrail
 * @see LineTrailMaterialProperty
 */

var LineTrail = "LineTrail";
/**
 * 墙体:  走马灯围墙 材质
 * @type {String}
 * @readonly
 *
 * @property {String} [image] 背景图片URL
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 颜色
 * @property {Number} [count=1] 数量
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.WallScroll
 * @see WallScrollMaterialProperty
 */

var WallScroll = "WallScroll";
/**
 * 面状: 用于面状对象的 扫描线放大效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 扫描线颜色
 * @property {Number} [speed=10] 扫描速度，值越大越快
 *
 * @see tudou3d.MaterialType.ScanLine
 * @see ScanLineMaterialProperty
 */

var ScanLine = "ScanLine";
/**
 * 圆形: 扫描效果 材质
 * @type {String}
 * @readonly
 *
 * @property {String} image 扫描图片URL地址
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 1.0)] 颜色
 *
 * @see tudou3d.MaterialType.CircleScan
 * @see CircleScanMaterialProperty
 */

var CircleScan = "CircleScan";
/**
 * 圆形: 扩散波纹效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 颜色
 * @property {Number} [speed=10] 速度，值越大越快
 * @property {Number} [count=1] 圆圈个数
 * @property {Number} [gradient=0.1] 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
 *
 * @see tudou3d.MaterialType.CircleWave
 * @see CircleWaveMaterialProperty
 */

var CircleWave = "CircleWave";
/**
 * 圆形: 雷达线(圆+旋转半径线) 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.RadarLine
 * @see RadarLineMaterialProperty
 */

var RadarLine = "RadarLine";
/**
 * 圆形: 波纹雷达扫描效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.RadarWave
 * @see RadarWaveMaterialProperty
 */

var RadarWave = "RadarWave";
/**
 * 面状: 文字贴图 材质
 * @type {String}
 * @readonly
 *
 * @property {String} text 文本内容
 * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体,
 * @property {Number} [font_size = 30] 字体大小
 * @property {String} [font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
 * @property {String} [font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
 * @property {string} [font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
 *
 * @property {Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 填充颜色。
 * @property {Boolean} [stroke=true] 是否描边文本。
 * @property {Color} [strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
 * @property {Number} [strokeWidth=2] 描边的宽度。
 * @property {Color} [backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
 * @property {Number} [padding=10] 要在文本周围添加的填充的像素大小。
 * @property {String} [textBaseline='top'] 文本的基线。
 * @see TextMaterial
 * @see TextMaterialProperty
 */

var Text = "Text";
/**
 * 矩形面： 轮播图  材质
 * @type {String}
 * @readonly
 *
 * @property {String} image 图片URL
 * @property {Cesium.Color} [color=Cesium.Color.WHITE] 颜色和透明度
 * @property {Number} [speed=10] 速度，值越大越快
 * @property {Boolean} [pure=false] 是否纯色
 *
 * @see tudou3d.MaterialType.RectSlide
 * @see RectSlideMaterialProperty
 */

var RectSlide = "RectSlide";
/**
 * 面状： 渐变面  材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 0.5)] 颜色
 * @property {Number} [alphaPower=1.5] 透明度系数
 * @property {Number} [diffusePower=1.6] 漫射系数
 *
 * @see tudou3d.MaterialType.PolyGradient
 * @see PolyGradientMaterialProperty
 */

var PolyGradient = "PolyGradient";
/**
 * 面状： 柏油路面效果  材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [asphaltColor=new Cesium.Color(0.15, 0.15, 0.15, 1.0)] 沥青的颜色
 * @property {Number} [bumpSize=0.02] 块大小
 * @property {Number} [roughness=0.2] 粗糙度
 *
 * @see tudou3d.MaterialType.PolyAsphalt
 * @see 暂无属性材质
 */

var PolyAsphalt = "PolyAsphalt";
/**
 *  面状：混合效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [lightColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
 * @property {Cesium.Color} [darkColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
 * @property {Number} [frequency=10.0] 频率
 *
 * @see tudou3d.MaterialType.PolyBlob
 * @see 暂无属性材质
 */

var PolyBlob = "PolyBlob";
/**
 * 面状：碎石面效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [lightColor=new Cesium.Color(0.25, 0.25, 0.25, 0.75)] 浅色的颜色
 * @property {Cesium.Color} [darkColor= new Cesium.Color(0.75, 0.75, 0.75, 0.75)] 深色的颜色
 * @property {Number} [frequency=10.0] 频率
 *
 * @see tudou3d.MaterialType.PolyFacet
 * @see 暂无属性材质
 */

var PolyFacet = "PolyFacet";
/**
 * 面状：草地面效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [grassColor=new Cesium.Color(0.25, 0.4, 0.1, 1.0)] 草地的颜色
 * @property {Cesium.Color} [dirtColor= new Cesium.Color(0.1, 0.1, 0.1, 1.0)] 泥土的颜色
 * @property {Number} [patchiness=1.5] 斑块分布
 *
 * @see tudou3d.MaterialType.PolyGrass
 * @see 暂无属性材质
 */

var PolyGrass = "PolyGrass";
/**
 *  面状：木材面效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [lightWoodColor=new Cesium.Color(0.6, 0.3, 0.1, 1.0)] 浅色的颜色
 * @property {Cesium.Color} [darkWoodColor= new Cesium.Color(0.4, 0.2, 0.07, 1.0)] 深色的颜色
 * @property {Number} [ringFrequency=3.0] 环频率
 * @property {Cesium.Cartesian2} [noiseScale= new Cesium.Cartesian2(0.7, 0.5)] 噪波比例
 * @property {Number} [grainFrequency=27.0] 颗粒的频率
 *
 * @see tudou3d.MaterialType.PolyWood
 * @see 暂无属性材质
 */

var PolyWood = "PolyWood";
/**
 * 球体: 电弧球体效果  材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.EllipsoidElectric
 * @see EllipsoidElectricMaterialProperty
 */

var EllipsoidElectric = "EllipsoidElectric";
/**
 * 球体: 波纹球体效果 材质
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
 * @property {Number} [speed=5.0] 速度，值越大越快
 *
 * @see tudou3d.MaterialType.EllipsoidWave
 * @see EllipsoidWaveMaterialProperty
 */

var EllipsoidWave = "EllipsoidWave";
/**
 * 圆锥: 条纹波纹扩散效果
 * @type {String}
 * @readonly
 *
 * @property {Cesium.Color} [color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
 * @property {Number} [repeat=30] 圈数量
 * @property {Number} [frameRate=60] 每秒刷新次数
 *
 * @see CylinderWaveMaterial
 * @see 暂无属性材质
 */

var CylinderWave = "CylinderWave";
// EXTERNAL MODULE: ./src/const/GraphicType.js
var GraphicType = __webpack_require__(26);

// EXTERNAL MODULE: ./src/const/LayerType.js
var LayerType = __webpack_require__(29);

// EXTERNAL MODULE: ./src/const/Lang.js
var Lang = __webpack_require__(28);

// CONCATENATED MODULE: ./src/const/LangType.js
/**
 * 语言类型  枚举
 *  @enum {String}
 */
var LangType = {
  /**
   * 简体中文
   */
  ZH: 0,

  /**
   * 繁体中文(香港、台湾等地区)
   */
  ZHHK: 1,

  /**
   * English英文  en
   */
  EN: 2
};

// CONCATENATED MODULE: ./src/util/DomUtil.js
/**
 * DOM操作 相关静态方法类
 * @module DomUtil
 */

/**
 * 创建一个tagName的HTML元素，将其class设置为className，并可选择将其添加到container元素中
 *
 * @export
 * @param {String} tagName 元素类型，比如 div
 * @param {String} className 附加的class样式名
 * @param {HTMLElement} container 添加到指定的父节点(可选)
 * @return {HTMLElement} 创建好的DOM元素
 */

function create(tagName, className, container) {
  var el = document.createElement(tagName);
  el.className = className || "";

  if (container) {
    container.appendChild(el);
  }

  return el;
}
/**
 * 创建svg元素
 *
 * @export
 * @param {Number} width 宽度
 * @param {Number} height 高度
 * @param {String} path url路径
 * @param {HTMLElement} container 添加到指定的父节点(可选)
 * @return {SVGElement} 创建的svg元素
 */

function createSvg(width, height, path, container) {
  var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg:svg");
  svg.setAttribute("class", "svg-path");
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
  var pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
  pathEl.setAttribute("d", path);
  svg.appendChild(pathEl);

  if (container) {
    container.appendChild(svg);
  }

  return svg;
}
/**
 *  创建Video元素
 *
 * @export
 * @param {String} url url地址
 * @param {String} type 视频类型
 * @param {String} className 样式名称
 * @param {HTMLElement} container  添加到指定的父节点(可选)
 * @return {HTMLElement} 创建的Video元素
 */

function createVideo(url, type, className, container) {
  var videoEl = create("video", className, container);
  var source = create("source", "", videoEl);
  source.setAttribute("src", url);
  source.setAttribute("type", "video/".concat(type));
  return videoEl;
}
/**
 * 返回给定DOM id的元素，或者返回元素本身
 *
 * @export
 * @param {String} id  dom的id
 * @return {HTMLElement|*} DOM元素
 */

function DomUtil_get(id) {
  return typeof id == "string" ? document.getElementById(id) : id;
}
/**
 * 将HTML字符串解析为DOM
 * @param {String} domStr HTML字符串
 * @param {Boolean} withWrapper 是否返回DIV父节点
 * @param {String} className 指定加上的样式名称
 * @returns {HTMLDivElement|NodeListOf<ChildNode>} 解析后的DOM元素
 */

function parseDom(domStr) {
  var withWrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var el = document.createElement("div");
  el.className = className;
  el.innerHTML = domStr;
  return withWrapper ? el : el.childNodes;
}
/**
 * 从其父元素中移除元素
 *
 * @export
 * @param {HTMLElement|String} el DOM元素或元素ID
 * @return {void}  无
 */

function remove(el) {
  el = DomUtil_get(el);

  if (!el) {
    return;
  }

  var parent = el.parentNode;

  if (parent) {
    parent.removeChild(el);
  }
}
/**
 * 删除所有子元素
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @return {void}  无
 */

function empty(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
/**
 * 返回元素上某个样式属性的值
 *
 * @export
 * @param {HTMLElement} el 指定的DOM元素
 * @param {String} style 样式名称
 * @return {String|null} 样式的值
 */

function getStyle(el, style) {
  var value = el.style[style] || el.currentStyle && el.currentStyle[style];

  if ((!value || value == "auto") && document.defaultView) {
    var css = document.defaultView.getComputedStyle(el, null);
    value = css ? css[style] : null;
  }

  return value == "auto" ? null : value;
}
/**
 * 判断元素是否有指定class样式
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @param {String} name class样式名称
 * @return {Boolean}  包含返回`true`,不包含返回`false`
 */

function hasClass(el, name) {
  if (!el) {
    return false;
  }

  if (el.classList != undefined) {
    return el.classList.contains(name);
  }

  var className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
/**
 * 在元素上添加指定的name的calss样式
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @param {String} name class样式名称
 * @return {void}  无
 */

function addClass(el, name) {
  if (!el) {
    return;
  }

  if (el.classList != undefined) {
    var classes = Object(Util["splitWords"])(name);

    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    var className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
/**
 * 在元素上移除指定的name的calss样式
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @param {String} name class样式名称
 * @return {void}  无
 */

function removeClass(el, name) {
  if (!el) {
    return;
  }

  if (el.classList != undefined) {
    el.classList.remove(name);
  } else {
    setClass(el, Object(Util["trim"])((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
  }
}
/**
 * 在元素上赋值设置指定的name的calss样式
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @param {String} name class样式名称
 * @return {void}  无
 */

function setClass(el, name) {
  if (!el.className || !el.className.baseVal) {
    el.className = name;
  } else {
    // in case of SVG element
    el.className.baseVal = name;
  }
}
/**
 * 获取dom元素上的class样式名称
 *
 * @export
 * @param {HTMLElement} el DOM元素
 * @return {String} class样式名称
 */

function getClass(el) {
  var _el$className;

  // Check if the element is an SVGElementInstance and use the correspondingElement instead
  // (Required for linked SVG elements in IE11.)
  if (el.correspondingElement) {
    el = el.correspondingElement;
  }

  return (_el$className = el.className) !== null && _el$className !== void 0 && _el$className.baseVal ? el.className.baseVal : el.className;
}
/**
 * 进入全屏
 *
 * @export
 * @param {HTMLElement} el 指定DOM元素
 * @returns {Boolean} 是否执行
 */

function enterFullscreen(el) {
  if (!el) {
    return false;
  }

  if (el.requestFullscreen) {
    el.requestFullscreen();
    return true;
  } else if (el.msRequestFullscreen) {
    el.msRequestFullscreen();
    return true;
  } else if (el.mozRequestFullScreen) {
    el.mozRequestFullScreen();
    return true;
  } else if (el.webkitRequestFullscreen) {
    el.webkitRequestFullscreen();
    return true;
  }

  return false;
}
/**
 * 退出全屏
 *
 * @export
 * @returns {Boolean} 是否执行
 */

function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
    return true;
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
    return true;
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
    return true;
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
    return true;
  }

  return false;
}
// EXTERNAL MODULE: external {"commonjs2":"@turf/turf","amd":"@turf/turf","commonjs":"@turf/turf","root":"turf"}
var turf_root_turf_ = __webpack_require__(19);

// EXTERNAL MODULE: ./src/map/core/MapUtil.js
var MapUtil = __webpack_require__(22);

// EXTERNAL MODULE: ./src/util/PointUtil.js
var PointUtil = __webpack_require__(8);

// EXTERNAL MODULE: ./src/util/PointTrans.js
var PointTrans = __webpack_require__(14);

// CONCATENATED MODULE: ./src/util/PolyUtil.js


function PolyUtil_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolyUtil_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolyUtil_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolyUtil_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * 多个点 或 线面数据 相关处理 静态方法
 * @module PolyUtil
 */









/**
 * 求坐标数组的中心点
 *
 * @export
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} arr 坐标数组
 * @param {Number} height 指定中心点的高度值，默认为所有点的最高高度
 * @return {Cesium.Cartesian3} 中心点坐标
 */

function centerOfMass(arr, height) {
  if (!arr || arr.length == 0) {
    return;
  }

  var positions = LatLngArray_LatLngArray.toCartesians(arr);

  try {
    if (positions.length == 1) {
      return positions[0];
    } else if (positions.length == 2) {
      return Object(PointUtil["getMidpoint"])(positions[0], positions[1]);
    }

    if (height == null) {
      height = Object(PointUtil["getMaxHeight"])(positions);
    }

    var boundingSphere = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromPoints(positions);
    var ptcenter = Object(PointUtil["setPositionsHeight"])(boundingSphere.center, height);
    return ptcenter;
  } catch (e) {
    return positions[Math.floor(positions.length / 2)];
  }
}
/**
 * 缓冲分析，求指定 点线面geojson对象 按width半径的 缓冲面对象
 *
 * @export
 * @param {Object} geojson geojson格式对象
 * @param {Number} width 缓冲半径,单位：米
 * @param {Number} [steps=8] 缓冲步幅
 * @return {Object} 缓冲面对象，geojson格式
 */

function buffer(geojson, width, steps) {
  //判断tur库是否存在 start
  try {
    if (!turf_root_turf_["buffer"]) {
      throw new Error("turf不存在");
    }
  } catch (e) {
    Object(Log["logError"])("buffer：该方法依赖turf库，请引入该库。", e);
    return geojson;
  } //判断tur库是否存在 end


  try {
    var _geojson, _geojson$geometry;

    width = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](width, 1);

    if (((_geojson = geojson) === null || _geojson === void 0 ? void 0 : (_geojson$geometry = _geojson.geometry) === null || _geojson$geometry === void 0 ? void 0 : _geojson$geometry.type) == "Polygon") {
      geojson.geometry.coordinates[0].push(geojson.geometry.coordinates[0][0]);
    } //API: http://turfjs.org/docs/#buffer


    geojson = Object(turf_root_turf_["buffer"])(geojson, width, {
      units: "meters",
      steps: steps || 8
    });
  } catch (e) {
    Object(Log["logError"])("PolyUtil buffer:缓冲分析异常", e);
  }

  return geojson;
}
/**
 * 缓冲分析，坐标数组围合面，按width半径的 缓冲新的坐标
 *
 * @export
 * @param {LatLngPoint[]} points 坐标数组
 * @param {Number} width 缓冲半径,单位：米
 * @param {Number} [steps=8] 缓冲步幅
 * @return {LatLngPoint[]} 缓冲后的新坐标数组
 */

function bufferPoints(points, width, steps) {
  try {
    width = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](width, 1);
    var coordinates = LatLngArray_LatLngArray.toArray(points);

    if (coordinates[0][0] != coordinates[coordinates.length - 1][0] && coordinates[0][1] != coordinates[coordinates.length - 1][1]) {
      coordinates.push(coordinates[0]);
    } //API: http://turfjs.org/docs/#buffer


    var polygon = {
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [coordinates]
      }
    };
    var geojson = Object(turf_root_turf_["buffer"])(polygon, width, {
      units: "meters",
      steps: steps || 8
    });
    return LatLngArray_LatLngArray.toPoints(geojson.geometry.coordinates[0]);
  } catch (e) {
    Object(Log["logError"])("PolyUtil buffer:缓冲分析异常", e);
  }

  return points;
}
/**
 * 求坐标数组的矩形范围内 按 splitNum网格数插值的 granularity值
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 坐标数组
 * @param {Int} [splitNum=10] splitNum网格数
 * @return {Number} granularity值
 */

function getGranularity(positions) {
  var splitNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  var recta = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(positions);
  var granularity = Math.max(recta.height, recta.width);
  granularity /= splitNum;
  return granularity;
}
/**
 * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果 的回调方法
 * @callback interPolygon_callback
 * @param {Object} [options={}] 参数对象:
 * @param {Number} options.granularity 面内按splitNum网格数插值的granularity值
 * @param {Number} options.maxHeight 面内最大高度
 * @param {Number} options.minHeight 面内最小高度
 * @param {Object[]} options.list  三角网对象数组，每个对象包含三角形的3个顶点(point1\point2\point3)相关值
 */

/**
 * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3[]} options.positions 坐标数组
 * @param {interPolygon_callback} options.callback  异步计算高度完成后 的回调方法
 * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
 * @param {Boolean} [options.asyn=false]  是否进行异步精确计算
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {Boolean} [options.onlyPoint=false] truea时，返回结果中只返回点，不返回三角网
 * @return {Object|void} 仅 asyn:false 时返回计算结果值
 */

function interPolygon(options) {
  var scene = options.scene; //坐标数组

  var positions = [];
  var pos = options.positions;

  for (var i = 0; i < pos.length; i++) {
    positions.push(pos[i].clone());
  } //splitNum分割的个数


  var granularity = getGranularity(positions, options.splitNum); //插值求面的三角网

  var arrPoly = [];
  var polygonGeometry = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].fromPositions({
    positions: positions,
    vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"].FLAT_VERTEX_FORMAT,
    granularity: granularity
  });
  var geom = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].createGeometry(polygonGeometry);
  var i0, i1, i2;
  var cartesian1, cartesian2, cartesian3;

  for (var _i = 0; _i < geom.indices.length; _i += 3) {
    i0 = geom.indices[_i];
    i1 = geom.indices[_i + 1];
    i2 = geom.indices[_i + 2]; //三角形 点1

    cartesian1 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](geom.attributes.position.values[i0 * 3], geom.attributes.position.values[i0 * 3 + 1], geom.attributes.position.values[i0 * 3 + 2]);
    arrPoly.push(cartesian1); //三角形 点2

    cartesian2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](geom.attributes.position.values[i1 * 3], geom.attributes.position.values[i1 * 3 + 1], geom.attributes.position.values[i1 * 3 + 2]);
    arrPoly.push(cartesian2); //三角形 点3

    cartesian3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](geom.attributes.position.values[i2 * 3], geom.attributes.position.values[i2 * 3 + 1], geom.attributes.position.values[i2 * 3 + 2]);
    arrPoly.push(cartesian3);
  }

  var maxHeight = 0;
  var minHeight = 9999;
  var onlyPoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.onlyPoint, false); //只返回点，不需要三角网时
  //格式化每个点

  function onFormatPoint(position, noHeight) {
    var height;
    var point;
    var pointDM;
    var carto;

    if (noHeight) {
      delete options.callback;
      height = Object(PointUtil["getSurfaceHeight"])(scene, position, options);
      carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
      point = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, 0);
      pointDM = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, height);
    } else {
      carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
      height = carto.height;
      point = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, 0);
      pointDM = position;
    }

    if (maxHeight < height) {
      maxHeight = height;
    }

    if (minHeight > height) {
      minHeight = height;
    }

    return {
      height: height,
      point: point,
      pointDM: pointDM
    };
  }

  function interCallback(raisedPositions, noHeight) {
    var arrSJW = [];
    var obj1, obj2, obj3;

    for (var _i2 = 0; _i2 < raisedPositions.length; _i2 += 3) {
      //三角形 点1
      obj1 = onFormatPoint(raisedPositions[_i2], noHeight); //三角形 点2

      obj2 = onFormatPoint(raisedPositions[_i2 + 1], noHeight); //三角形 点3

      obj3 = onFormatPoint(raisedPositions[_i2 + 2], noHeight);

      if (onlyPoint) {
        //只返回点，不需要三角网
        addPointFoyArrOnly(arrSJW, obj1);
        addPointFoyArrOnly(arrSJW, obj2);
        addPointFoyArrOnly(arrSJW, obj3);
      } else {
        //常规返回，三角网
        arrSJW.push({
          point1: obj1,
          point2: obj2,
          point3: obj3
        });
      }
    }

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.minHeight)) {
      minHeight = Math.max(options.minHeight, minHeight);
      maxHeight = Math.max(maxHeight, minHeight);
    }

    var result = {
      granularity: granularity,
      maxHeight: maxHeight,
      minHeight: minHeight,
      list: arrSJW //三角网

    };
    var callback = options.callback;

    if (callback) {
      callback(result);
    }

    return result;
  } //是否异步求精确高度


  if (options.asyn) {
    //求高度
    return computeSurfacePoints({
      scene: scene,
      positions: arrPoly,
      has3dtiles: options.has3dtiles,
      callback: interCallback
    });
  } else {
    return interCallback(arrPoly, true);
  }
} //判断坐标点是否在数组内

function addPointFoyArrOnly(arr, newItem) {
  var isIn = false;
  var point = newItem.point;

  for (var z = 0; z < arr.length; z++) {
    var item = arr[z].point;

    if (point.x == item.x && point.y == item.y && point.z == item.z) {
      isIn = true;
      break;
    }
  }

  if (!isIn) {
    arr.push(newItem);
  }
}
/**
 * 计算面内最大、最小高度值
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 坐标数组
 * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Object} [options={}] 参数对象:
 * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @return {Object} 计算面内最大、最小高度值对象，结果示例：{ maxHeight: 100, minHeight: 21 }
 */


function getHeightRange(positions, scene, options) {
  var resultInter = interPolygon(PolyUtil_objectSpread({
    positions: positions,
    scene: scene
  }, options));
  return {
    has3dtiles: resultInter._has3dtiles,
    maxHeight: resultInter.maxHeight,
    minHeight: resultInter.minHeight
  };
}
/**
 * 计算三角形面积（空间平面）
 *
 * @export
 * @param {Cesium.Cartesian3} pos1 三角形顶点坐标1
 * @param {Cesium.Cartesian3} pos2 三角形顶点坐标2
 * @param {Cesium.Cartesian3} pos3 三角形顶点坐标3
 * @return {Number} 面积，单位：平方米
 * @private
 */

function getTriangleArea(pos1, pos2, pos3) {
  var a = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(pos1, pos2);
  var b = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(pos2, pos3);
  var c = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(pos3, pos1);
  var S = (a + b + c) / 2;
  return Math.sqrt(S * (S - a) * (S - b) * (S - c));
}
/**
 * 体积计算
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3[]} options.positions 坐标数组
 * @param {VolumeResult} options.callback  异步计算高度完成后 的回调方法
 * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
 * @param {Boolean} [options.asyn=false]  是否进行异步精确计算
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @return {VolumeResult|void} 仅 asyn:false 时返回计算结果值
 */


function computeVolume(options) {
  var resultInter = interPolygon(options);

  if (resultInter) {
    resultInter = updateVolumeByMinHeight(resultInter);
  }

  return resultInter;
}
/**
 * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果 的回调方法
 * @callback VolumeResult
 * @param {Object} [options={}] 参数对象:
 * @param {Number} options.granularity 面内按splitNum网格数插值的granularity值
 * @param {Number} options.maxHeight 面内最大高度
 * @param {Number} options.minHeight 面内最小高度
 * @param {Object[]} options.list  三角网对象数组，每个对象包含三角形的3个顶点(point1\point2\point3)相关值
 *
 * @param {Number} options.totalArea 总面积(横截面/投影底面)，执行updateVolumeByMinHeight后赋值
 * @param {Number} options.totalVolume  总体积，执行updateVolumeByMinHeight后赋值
 *
 * @param {Number} options.digVolume  挖方体积，执行updateVolume后赋值
 * @param {Number} options.fillVolume  填方体积，执行updateVolume后赋值
 */

/**
 * 根据 minHeight最低底面高度 计算（或重新计算）填挖方体积
 *
 * @export
 * @param {interPolygon_callback} resultInter 插值完的对象
 * @return {VolumeResult} 计算完成的填挖方体积
 */

function updateVolumeByMinHeight(resultInter) {
  var minHeight = resultInter.minHeight;
  var totalArea = 0; //总面积(横截面/投影底面)

  var totalVolume = 0; //总体积

  for (var i = 0, len = resultInter.list.length; i < len; i++) {
    var item = resultInter.list[i];
    var pt1 = item.point1;
    var pt2 = item.point2;
    var pt3 = item.point3; //横截面面积

    var bottomArea = getTriangleArea(pt1.point, pt2.point, pt3.point);
    item.area = bottomArea;
    totalArea += bottomArea;
    var height1 = pt1.height;
    var height2 = pt2.height;
    var height3 = pt3.height;

    if (height1 < minHeight) {
      height1 = minHeight;
    }

    if (height2 < minHeight) {
      height2 = minHeight;
    }

    if (height3 < minHeight) {
      height3 = minHeight;
    } //挖方体积 （横截面面积 * 3个点的平均高）


    var cutVolume = bottomArea * (height1 - minHeight + height2 - minHeight + height3 - minHeight) / 3;
    item.cutVolume = cutVolume;
    totalVolume = totalVolume + cutVolume;
  }

  resultInter.totalArea = totalArea; //总面积(横截面/投影底面)

  resultInter.totalVolume = totalVolume; //总体积

  return resultInter;
}
/**
 * 根据 基准面高度 重新计算填挖方体积
 *
 * @export
 * @param {VolumeResult} resultInter 插值完的对象
 * @param {Number} cutHeight 基准面高度
 * @return {VolumeResult} 重新计算填挖方体积后的对象
 */

function updateVolume(resultInter, cutHeight) {
  if (!resultInter) {
    return;
  }

  var minHeight = resultInter.minHeight;
  var totalVolume = resultInter.totalVolume; //总体积

  if (cutHeight <= minHeight) {
    resultInter.fillVolume = 0; //填方体积

    resultInter.digVolume = totalVolume; //挖方体积

    return resultInter;
  }

  var totalV = 0; //底部到基准面的总体积

  var totalBottomV = 0; //挖方体积

  for (var i = 0, len = resultInter.list.length; i < len; i++) {
    var item = resultInter.list[i]; //底部到基准面的总体积

    totalV += item.area * (cutHeight - minHeight);
    var pt1 = item.point1;
    var pt2 = item.point2;
    var pt3 = item.point3;
    var height1 = pt1.height;
    var height2 = pt2.height;
    var height3 = pt3.height;

    if (height1 < cutHeight) {
      height1 = cutHeight;
    }

    if (height2 < cutHeight) {
      height2 = cutHeight;
    }

    if (height3 < cutHeight) {
      height3 = cutHeight;
    } //挖方体积 （横截面面积 * 3个点的平均高）


    totalBottomV += item.area * (height1 - cutHeight + height2 - cutHeight + height3 - cutHeight) / 3;
  }

  resultInter.digVolume = totalBottomV; //挖方体积

  resultInter.fillVolume = totalV - (totalVolume - totalBottomV); //填方体积

  return resultInter;
}
/**
 * 获取 圆（或椭圆）边线上的坐标点数组
 *
 * @export
 * @param {Object} [options] 参数对象:
 * @param {Cesium.Cartesian3|LatLngPoint} options.position  圆的中心坐标
 * @param {Number} options.radius  如是圆时，半径（单位：米）
 * @param {Number} options.semiMajorAxis  椭圆时的 长半轴半径（单位：米）
 * @param {Number} options.semiMinorAxis   椭圆时的 短半轴半径（单位：米）
 * @param {Number} [options.count=1]  象限内点的数量，返回的总数为 count*4
 * @param {Number} [options.rotation=0]  旋转的角度
 * @return {Cesium.Cartesian3[]}  边线上的坐标点数组
 */

function getEllipseOuterPositions(options) {
  var position = options.position;

  if (!position) {
    return null;
  }

  position = LatLngPoint["a" /* LatLngPoint */].parseCartesian3(position);
  var count = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.count, 1); //点的数量，总数为count*4

  var semiMajorAxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.semiMajorAxis, options.radius);
  var semiMinorAxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.semiMinorAxis, options.radius);
  var rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.rotation, 0);

  if (!semiMajorAxis || !semiMinorAxis) {
    return [position, position, position];
  } //获取椭圆上的坐标点数组


  var cep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipseGeometryLibrary"].computeEllipsePositions({
    center: position,
    semiMajorAxis: semiMajorAxis,
    //长半轴
    semiMinorAxis: semiMinorAxis,
    //短半轴
    rotation: rotation,
    granularity: Math.PI / (16 * count)
  }, true, true);
  var arr = cep.outerPositions;
  var positions = [];

  for (var i = 0, len = arr.length; i < len; i += 3) {
    //长半轴上的坐标点
    var pt = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](arr[i], arr[i + 1], arr[i + 2]);
    positions.push(pt);
  }

  return positions;
}
/**
 * 格式化Rectangle矩形对象,返回经纬度值
 *
 * @export
 * @param {Cesium.Rectangle} rectangle 矩形对象
 * @param  {Int} [digits=6] 经纬度保留的小数位数
 * @return {Object} 返回经纬度值，示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
 */

function formatRectangle(rectangle) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LatLngPoint["a" /* LatLngPoint */].FormatLength;
  var west = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(rectangle.west), digits);
  var east = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(rectangle.east), digits);
  var north = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(rectangle.north), digits);
  var south = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(rectangle.south), digits);

  if (west > east) {
    var temp = west;
    west = east;
    east = temp;
  }

  if (south > north) {
    var _temp = south;
    south = north;
    north = _temp;
  }

  return {
    xmin: west,
    xmax: east,
    ymin: south,
    ymax: north
  };
}
/**
 * 获取 坐标数组 的 矩形边界值
 *
 * @export
 * @param {Cesium.Cartesian3[]|String[]|Array[]|LatLngPoint[]} positions 坐标数组
 * @param {Boolean} [isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
 * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
 */

function getRectangle(positions, isFormat) {
  if (!positions) {
    return null;
  } //剔除null值的数据


  for (var i = positions.length - 1; i >= 0; i--) {
    if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](positions[i])) {
      positions.splice(i, 1);
    }
  }

  positions = LatLngArray_LatLngArray.toCartesians(positions);
  var rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(positions);

  if (isFormat) {
    return formatRectangle(rectangle);
  } else {
    return rectangle;
  }
}
/**
 * 获取坐标点数组的外接矩形的 4个顶点坐标点（数组）
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions  坐标点数组
 * @param {Number} [rotation=0]  旋转的角度，弧度值
 * @return {Cesium.Cartesian3[]} 4个顶点坐标点
 */

function getPositionsRectVertex(positions) {
  var rotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(positions);
  var height = Object(PointUtil["getMaxHeight"])(positions);
  var arr = getRectangleOuterPositions({
    rectangle: rectangle,
    rotation: rotation,
    height: height
  });
  return arr;
}
/**
 * 获取矩形（含旋转角度）的边线上的4个顶点坐标点数组
 *
 * @export
 * @param {Object} [options] 参数对象:
 * @param {Cesium.Rectangle} options.rectangle  矩形对象
 * @param {Number} [options.rotation=0]  旋转的角度，弧度值
 * @param {Number} [options.height=0]  坐标的高度
 * @param {Number} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE]  granularity值
 * @param {Cesium.Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
 * @return {Cesium.Cartesian3[]} 边线上的4个顶点坐标点数组
 */

function getRectangleOuterPositions(options) {
  var rectangle = options.rectangle;
  var rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.rotation, 0.0);
  var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.height, 0.0);

  if (rotation == 0) {
    return [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(rectangle.west, rectangle.south, height), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(rectangle.east, rectangle.south, height), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(rectangle.east, rectangle.north, height), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(rectangle.west, rectangle.north, height)];
  }

  var granularity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.granularity, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].RADIANS_PER_DEGREE);
  var rectangleScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]();
  var nwScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();
  var computedOptions = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometryLibrary"].computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);
  var w_height = computedOptions.height;
  var w_width = computedOptions.width;
  var ellipsoid = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.ellipsoid, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ellipsoid"].WGS84);
  var scratchRectanglePoints = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()];
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometryLibrary"].computePosition(computedOptions, ellipsoid, false, 0, 0, scratchRectanglePoints[0]);
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometryLibrary"].computePosition(computedOptions, ellipsoid, false, 0, w_width - 1, scratchRectanglePoints[1]);
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometryLibrary"].computePosition(computedOptions, ellipsoid, false, w_height - 1, w_width - 1, scratchRectanglePoints[2]);
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometryLibrary"].computePosition(computedOptions, ellipsoid, false, w_height - 1, 0, scratchRectanglePoints[3]);

  if (height != 0) {
    scratchRectanglePoints = Object(PointUtil["setPositionsHeight"])(scratchRectanglePoints, height);
  }

  return scratchRectanglePoints;
}
/**
 * 根据传入中心点、高宽或角度，计算矩形面的顶点坐标。
 *
 * @export
 * @param {Object} [options] 参数对象:
 * @param {Cesium.Cartesian3} options.center  中心坐标
 * @param {Number} [options.width]  矩形的宽度，单位：米
 * @param {Number} [options.height]  矩形的高度，单位：米
 * @param {Number} [options.rotation=0]  旋转的角度
 * @param {Number} [options.originX=0.5]  中心点所在的位置x轴方向比例，取值范围：0.1-1.0
 * @param {Number} [options.originY=0.5]  中心点所在的位置y轴方向比例，取值范围：0.1-1.0
 * @return {Cesium.Cartesian3[]}  矩形面的顶点坐标数组
 */

function getRectPositionsByCenter(options) {
  var center = options.center;
  var width = options.width;
  var height = options.height;
  var rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.rotation, 0);
  var originX = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.originX, 0.5);
  var originY = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.originY, 0.5);
  var scratchEnuMatrix = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();
  var scratchRotationQuat = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"]();
  var scratchSrtMatrix = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();
  var localPositions = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(-originX, -originY, 0.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(1.0 - originX, -originY, 0.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(1.0 - originX, 1.0 - originY, 0.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(-originX, 1.0 - originY, 0.0)];
  var enuMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(center, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ellipsoid"].WGS84, scratchEnuMatrix);
  var rotationQuat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"].fromAxisAngle(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z, rotation, scratchRotationQuat);
  var cmftqrs = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromTranslationQuaternionRotationScale;
  var srtMatrix = cmftqrs(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO, rotationQuat, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(width, height), scratchSrtMatrix);
  var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(enuMatrix, srtMatrix, srtMatrix);
  var result = [];
  localPositions.forEach(function (lp, index) {
    if (typeof result[index] == "undefined") {
      result[index] = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
    }

    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(modelMatrix, lp, result[index]);
  });
  return result;
}
/**
 * 判断点是否 多边形内
 *
 * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} coordinates 多边形的边界点
 * @return {Boolean} 是否在多边形内
 */

function PolyUtil_isInPoly(position, coordinates) {
  //判断tur库是否存在 start
  try {
    if (!turf_root_turf_["booleanPointInPolygon"]) {
      throw new Error("turf不存在");
    }
  } catch (e) {
    Object(Log["logError"])("isInPoly：该方法依赖turf库，请引入该库。", e);
    return false;
  } //判断tur库是否存在 end


  var pt = {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: LatLngPoint["a" /* LatLngPoint */].parse(position).toArray()
    }
  };
  var poly = {
    type: "Polygon",
    coordinates: [LatLngArray_LatLngArray.toArray(coordinates)]
  };
  return Object(turf_root_turf_["booleanPointInPolygon"])(pt, poly); //turf插件计算的
}
/**
 * 求贝塞尔曲线坐标
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 坐标数组
 * @param {Boolean} [closure=fasle] 是否闭合曲线
 * @return {Cesium.Cartesian3[]} 坐标数组
 */

function getBezierCurve(positions, closure) {
  if (!positions || positions.length < 3) {
    return positions;
  }

  var coordinates = Object(PointTrans["cartesians2lonlats"])(positions);

  if (closure) {
    //闭合曲线
    coordinates.push(coordinates[0]);
  }

  var defHeight = coordinates[coordinates.length - 1][2]; //判断tur库是否存在 start

  try {
    if (!turf_root_turf_["bezierSpline"]) {
      throw new Error("turf不存在");
    }
  } catch (e) {
    Object(Log["logError"])("getBezierCurve：该方法依赖turf库，请引入该库。", e);
    return positions;
  } //判断tur库是否存在 end


  var curved = Object(turf_root_turf_["bezierSpline"])({
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  });
  var result = Object(PointTrans["lonlats2cartesians"])(curved.geometry.coordinates, defHeight);

  if (closure) {
    result.push(result[0]);
  }

  return result;
}
/**
 * 对路线进行平面等比插值，高度：指定的固定height值 或 按贴地高度。
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} options.positions 坐标数组
 * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
 * @param {Number} [options.minDistance=null] 插值最小间隔(单位：米)，优先级高于splitNum
 * @param {Number} [options.height=0] 坐标的高度
 * @param {Boolean} [options.surfaceHeight=true] 是否计算贴地高度 （非精确计算，根据当前加载的地形和模型数据情况有关）
 * @return {Cesium.Cartesian3[]} 插值后的路线坐标数组
 */

function interPolyline(options) {
  var positions = options.positions;
  var scene = options.scene;
  var granularity = getGranularity(positions, options.splitNum || 100);

  if (granularity <= 0) {
    granularity = null;
  }

  var flatPositions = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylinePipeline"].generateArc({
    positions: positions,
    height: options.height,
    //未传入时，内部默认为0
    minDistance: options.minDistance,
    //插值间隔(米)，优先级高于granularity
    granularity: granularity //splitNum分割的个数

  });
  var arr = [];

  for (var i = 0; i < flatPositions.length; i += 3) {
    var position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].unpack(flatPositions, i);

    if (scene && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.surfaceHeight, true)) {
      delete options.callback;
      var height = Object(PointUtil["getSurfaceHeight"])(scene, position, options);
      var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
      position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, height);
    }

    arr.push(position);
  }

  return arr;
}
/**
 * 对路线进行按空间等比插值，高度：高度值按各点的高度等比计算
 * 比如：用于航线的插值运算
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 坐标数组
 * @param {Object} [options={}] 参数对象:
 * @param {Number} [options.splitNum] 插值数，等比分割的个数，默认不插值
 * @param {Number} [options.minDistance] 插值时的最小间隔(单位：米)，优先级高于splitNum
 * @return {Cesium.Cartesian3[]} 插值后的坐标对象
 */

function interLine(positions) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!positions || positions.length < 2) {
    return positions;
  }

  var granularity;

  if (options.splitNum) {
    //splitNum分割的个数
    granularity = getGranularity(positions, options.splitNum);

    if (granularity <= 0) {
      granularity = null;
    }
  }

  var arr = [positions[0]];

  for (var index = 1, length = positions.length; index < length; index++) {
    var startP = positions[index - 1];
    var endP = positions[index];
    var interPositions = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylinePipeline"].generateArc({
      positions: [startP, endP],
      minDistance: options.minDistance,
      //插值间隔(米)，优先级高于granularity
      granularity: granularity //splitNum分割的个数

    }); //剖面的数据

    var h1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(startP).height;
    var h2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(endP).height;
    var hstep = (h2 - h1) / interPositions.length;

    for (var i = 3, len = interPositions.length; i < len; i += 3) {
      var position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].unpack(interPositions, i);
      var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
      var height = Number((h1 + hstep * i).toFixed(1));
      position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, height);
      arr.push(position);
    }
  }

  return arr;
}
/**
 * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果 的回调方法
 * @callback surfaceLineWork_callback
 * @param {Cesium.Cartesian3[]} raisedPositions  计算完成后得到的贴地点数组
 * @param {Boolean} noHeight  是否计算贴地高度失败，true时标识计算失败了
 * @param {Cesium.Cartesian3[]} positions 原始的坐标数组
 */

/**
 * 求路线的贴地线坐标（插值）
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} options.positions 坐标数组
 * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
 * @param {Number} [options.minDistance=null] 插值最小间隔(单位：米)，优先级高于splitNum
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
 * @param {surfaceLineWork_callback} options.callback  异步计算高度完成后 的回调方法
 * @return {void} 无
 */

function computeSurfaceLine(options) {
  return surfaceLineWork.start(options);
}
/**
 * 求 多个点 的的贴地新坐标（不插值）
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} options.positions 坐标数组
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
 * @param {surfaceLineWork_callback} options.callback  异步计算高度完成后 的回调方法
 * @return {void} 无
 */

function computeSurfacePoints(options) {
  options.split = false;
  return surfaceLineWork.start(options);
} // 计算贴地(或贴模型)路线（异步）

var surfaceLineWork = {
  start: function start(params) {
    this.params = params;
    this.scene = params.map ? params.map.scene : params.scene;

    if (!this.scene) {
      Object(Log["logError"])("surfaceLineWork: \u8BF7\u4F20\u5165scene\u53C2\u6570", params);
      return;
    }

    var positions = params.positions;

    if (positions == null || positions.length == 0) {
      // 无数据
      this.end(positions);
      return;
    }

    this.positions = positions; // 线中间插值

    var _split = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](params.split, true);

    if (_split) {
      positions = interPolyline(PolyUtil_objectSpread(PolyUtil_objectSpread({}, params), {}, {
        scene: this.scene,
        positions: positions,
        surfaceHeight: false // 不用重复计算高度

      }));
      var positionsClone = [];

      for (var i = 0, len = positions.length; i < len; ++i) {
        positionsClone.push(positions[i].clone());
      }

      this.positions = positionsClone;
    }

    var _has3dtiles = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](params.has3dtiles, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](Object(MapUtil["e" /* pick3DTileset */])(this.scene, positions))); // 是否在3ditiles上面


    var _hasTerrain = Boolean(this.scene.terrainProvider._layers); // 是否有地形


    this._has3dtiles = _has3dtiles;
    this._hasTerrain = _hasTerrain;

    if (!_hasTerrain && !_has3dtiles) {
      // 无地形和无模型时，直接返回
      this.end(positions);
      return;
    }

    if (params.exact) {
      // 精确异步计算
      if (_hasTerrain) {
        this.clampToTerrain(positions);
      } else {
        this.clampTo3DTileset(positions);
      }
    } else {
      // 同步快速概略的计算模式： 该方式计算精度较低，但计算速度快，仅能计算在当前视域内坐标的高度
      var _positionsClone = [];

      for (var _i3 = 0, _len = this.positions.length; _i3 < _len; ++_i3) {
        var _height;

        var carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this.positions[_i3]);
        var height = void 0;

        if (_has3dtiles) {
          var heightTiles = this.scene.sampleHeight(carto, this.params.objectsToExclude, this.params.width);

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](heightTiles) && heightTiles > -1000) {
            height = heightTiles; // 取贴模型高度
          }
        }

        if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](height)) {
          var heightTerrain = this.scene.globe.getHeight(carto);

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](heightTerrain) && heightTerrain > -1000) {
            height = heightTerrain;
          }
        }

        _positionsClone.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, (_height = height) !== null && _height !== void 0 ? _height : carto.height));
      }

      this.end(_positionsClone);
    }

    return this;
  },
  clampToTerrain: function clampToTerrain(positions) {
    var _this = this;

    var ellipsoid = this.scene.globe.ellipsoid;
    var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions); // 用于缺少地形数据时，赋值的高度

    var tempHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[0]).height;
    var that = this;
    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["when"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["sampleTerrainMostDetailed"](this.scene.terrainProvider, cartographicArray), function (samples) {
      samples = that.removeNullData(samples);
      var noHeight = false;
      var offset = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](that.params.offset, 0); // 增高高度，便于可视

      for (var i = 0; i < samples.length; ++i) {
        if (samples[i].height == null) {
          noHeight = true;
          samples[i].height = tempHeight;
        } else {
          var _this$scene$globe;

          samples[i].height = offset + samples[i].height * (((_this$scene$globe = _this.scene.globe) === null || _this$scene$globe === void 0 ? void 0 : _this$scene$globe.terrainExaggeration) || 1);
        }
      }

      var raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);

      if (that._has3dtiles) {
        that.clampTo3DTileset(raisedPositions);
      } else {
        that.end(raisedPositions, noHeight);
      }
    });
  },
  clampTo3DTileset: function clampTo3DTileset(positions) {
    var that = this;
    var positionsClone = [];

    for (var i = 0, len = positions.length; i < len; ++i) {
      positionsClone.push(positions[i].clone());
    }

    this.scene.clampToHeightMostDetailed(positionsClone, this.params.objectsToExclude, 0.2).then(function (clampedCartesians) {
      clampedCartesians = that.removeNullData(clampedCartesians);

      if (clampedCartesians.length == 0) {
        clampedCartesians = positions;
      }

      that.end(clampedCartesians);
    });
  },
  end: function end(raisedPositions, noHeight) {
    var callback = this.params.callback;

    if (callback) {
      callback(raisedPositions, noHeight, this.positions);
    }
  },
  removeNullData: function removeNullData(samples) {
    var arrNew = [];

    for (var i = 0; i < samples.length; ++i) {
      if (samples[i] != null) {
        arrNew.push(samples[i]);
      }
    }

    return arrNew;
  }
};
/**
 * 异步分段分步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
 * @callback computeStepSurfaceLine_endItem
 * @param {Cesium.Cartesian3[]} raisedPositions  当前2个点之间的 贴地坐标数组
 * @param {Boolean} noHeight  是否计算贴地高度失败，true时标识计算失败了
 * @param {Number} index  坐标数组的index顺序
 */

/**
 * 异步分段分步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
 * @callback computeStepSurfaceLine_end
 * @param {Array[]} arrStepPoints  二维数组坐标集合，各分段2点之间的贴地点数组的集合
 */

/**
 * 按2个坐标点分段分步来计算，求路线的贴地线坐标（插值）
 *
 * @export
 * @param {Object} [options={}] 参数对象:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Cesium.Cartesian3} options.positions 坐标数组
 * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
 * @param {Number} [options.minDistance=null] 插值最小间隔(单位：米)，优先级高于splitNum
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
 * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
 * @param {computeStepSurfaceLine_endItem} options.endItem  异步计算高度完成后 的回调方法
 * @param {computeStepSurfaceLine_end} options.end  异步计算高度完成后 的回调方法
 * @param {computeStepSurfaceLine_end} options.callback  异步计算高度完成后 的回调方法(别名，同end)
 * @return {void} 无
 */

function computeStepSurfaceLine(options) {
  var positions = options.positions;
  var arrStepPoints = [];
  var params = {};

  for (var key in options) {
    if (key == "positions" || key == "callback" || key == "end" || key == "endItem") {
      continue;
    }

    params[key] = options[key];
  }

  var index = 0;
  var allcount = positions.length - 1;

  function getLineFD() {
    if (index >= allcount) {
      if (options.callback) {
        options.callback(arrStepPoints);
      }

      if (options.end) {
        options.end(arrStepPoints);
      }

      return;
    }

    params.positions = [positions[index], positions[index + 1]];

    params.callback = function (raisedPositions, noHeight) {
      if (options.endItem) {
        options.endItem(raisedPositions, noHeight, index);
      }

      arrStepPoints.push(raisedPositions);
      index++;
      getLineFD();
    };

    surfaceLineWork.start(params);
  }

  getLineFD();
}
/**
 * 计算2点间的 曲线链路的点集（空中曲线）
 *
 * @export
 * @param {Cesium.Cartesian3} startPoint 开始节点
 * @param {Cesium.Cartesian3} endPoint 结束节点
 * @param {Number} angularityFactor 曲率
 * @param {Number} numOfSingleLine 点集数量
 * @return {Cesium.Cartesian3[]}  曲线坐标数组
 */

function getLinkedPointList(startPoint, endPoint, angularityFactor, numOfSingleLine) {
  var result = [];
  var startPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(startPoint);
  var endPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(endPoint);
  var startLon = startPosition.longitude * 180 / Math.PI;
  var startLat = startPosition.latitude * 180 / Math.PI;
  var endLon = endPosition.longitude * 180 / Math.PI;
  var endLat = endPosition.latitude * 180 / Math.PI;
  var dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat)); //var dist = Cesium.Cartesian3.distance(startPoint, endPoint);

  var angularity = dist * angularityFactor;
  var startVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(startPoint);
  var endVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(endPoint);
  var startLength = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(startVec, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO);
  var endLength = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(endVec, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO);
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(startVec, startVec);
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(endVec, endVec);

  if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(startVec, endVec) == 0) {
    return result;
  } //var cosOmega = Cesium.Cartesian3.dot(startVec, endVec);
  //var omega = Math.acos(cosOmega);


  var omega = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(startVec, endVec);
  result.push(startPoint);

  for (var i = 1; i < numOfSingleLine - 1; i++) {
    var t = i * 1.0 / (numOfSingleLine - 1);
    var invT = 1 - t;
    var startScalar = Math.sin(invT * omega) / Math.sin(omega);
    var endScalar = Math.sin(t * omega) / Math.sin(omega);
    var startScalarVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(startVec, startScalar, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var endScalarVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(endVec, endScalar, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var centerVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(startScalarVec, endScalarVec, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var ht = t * Math.PI;
    var centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
    centerVec = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(centerVec, centerLength, centerVec);
    result.push(centerVec);
  }

  result.push(endPoint);
  return result;
}
/**
 * 计算平行线
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 原始线的坐标数组
 * @param {Number} offset 偏移的距离（单位米），正负决定方向
 * @return {Cesium.Cartesian3[]}  平行线坐标数组
 */

function getOffsetLine(positions, offset) {
  var arrNew = [];

  for (var i = 1; i < positions.length; i++) {
    var point1 = positions[i - 1];
    var point2 = positions[i];
    var dir12 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(point1, point2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var dir21left = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(point1, dir12, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var p1offset = computedOffsetData(point1, dir21left, offset * 1000);
    var p2offset = computedOffsetData(point2, dir21left, offset * 1000);

    if (i == 1) {
      arrNew.push(p1offset);
    }

    arrNew.push(p2offset);
  }

  return arrNew;
}

function computedOffsetData(ori, dir, wid) {
  var currRay = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](ori, dir);
  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(currRay, wid, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
}
/**
 * 截取路线指定最大长度的新路线，
 * 在最后一个点往前截取maxDistance长度。
 * 应用场景： 航迹的 “尾巴线” 的运算
 *
 * @export
 * @param {Cesium.Cartesian3[]} positions 路线坐标
 * @param {Number} maxDistance  最大的截取长度
 * @param {Object} [options={}] 参数对象:
 * @param {Boolean} [options.point=false] 为true时 只返回计算的maxDistance处的坐标
 * @return {Cesium.Cartesian3[]|Cesium.Cartesian3}  指定长度的坐标数组 ，options.point为true时，只返回数组的第1个点。
 */


function sliceByMaxDistance(positions, maxDistance) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (positions.length < 2) {
    return positions;
  }

  for (var i = positions.length - 1; i >= 1; i--) {
    var pt1 = positions[i];
    var pt2 = positions[i - 1];
    var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(pt1, pt2);
    maxDistance -= distance;

    if (maxDistance == 0) {
      if (options.point) {
        return pt1;
      } else {
        return positions.slice(i);
      }
    } else if (maxDistance < 0) {
      maxDistance += distance; //求指定长度拼接上去

      var newpt = Object(PointUtil["getOnLinePointByLen"])(pt1, pt2, maxDistance);

      if (options.point) {
        return newpt;
      } else {
        return [newpt].concat(positions.slice(i));
      }
    }
  }

  return positions;
}
/**
 * 求 坐标点 的 外包围凸体面(简化只保留边界线坐标)
 *
 * @export
 * @param {Array[]} coordinates 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
 * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
 */

function convex(coordinates) {
  if (coordinates.length > 0) {
    //判断tur库是否存在 start
    try {
      if (!turf_root_turf_["convex"]) {
        throw new Error("turf不存在");
      }
    } catch (e) {
      Object(Log["logError"])("convex：该方法依赖turf库，请引入该库。", e);
      return coordinates;
    } //判断tur库是否存在 end


    var pts = [];

    for (var i = 0; i < coordinates.length; i++) {
      pts.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: coordinates[i]
        }
      });
    } //求外包围凸体


    var hull = Object(turf_root_turf_["convex"])({
      type: "FeatureCollection",
      features: pts
    });

    if (hull) {
      var _hull$geometry;

      var coords = hull === null || hull === void 0 ? void 0 : (_hull$geometry = hull.geometry) === null || _hull$geometry === void 0 ? void 0 : _hull$geometry.coordinates;

      if (coords && coords.length > 0) {
        coordinates = coords[0];
      }
    }
  }

  return coordinates;
}
// CONCATENATED MODULE: ./src/thing/terrain/Slope.js







function Slope_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Slope_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Slope_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Slope_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Slope_createSuper(Derived) { var hasNativeReflectConstruct = Slope_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Slope_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









/**
 * @typedef {Object} Slope.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} endItem 多个数据异步分析时，完成其中一个时的回调事件
 * @property {String} end 多个数据异步分析时，完成所有的回调事件
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('发送了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 坡度坡向分析
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 分析区域 坐标位置数组
 *
 * @param {Object} [options.arrow] 箭头线的样式，包括以下：
 * @param {Boolean} [options.arrow.show=true] 是否显示箭头线
 * @param {Number} [options.arrow.scale=0.3] 箭头长度的比例（网格大小），根据绘制区域的大小和插值数来计算实际长度值。
 * @param {Cesium.Color} [options.arrow.color=Cesium.Color.YELLOW] 颜色
 * @param {Number} [options.arrow.length=40] 分析单个点时，箭头长度值
 *
 * @param {Object} [options.point] 点的样式，包括以下：
 * @param {Boolean} [options.point.show=true] 是否显示点
 * @param {Number} [options.point.pixelSize=9]  像素大小
 * @param {Cesium.Color} [options.point.color=Cesium.Color.RED.withAlpha(0.5)] 颜色
 *
 * @param {Function} [options.tooltip] 可以指定绑定tooltip
 * @param {Function} [options.popup] 可以指定绑定popup
 *
 * @export
 * @class Slope
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link Slope.EventType}
 */

var Slope_Slope = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Slope, _BaseThing);

  var _super = Slope_createSuper(Slope);

  function Slope() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Slope);

    _this = _super.call(this, options); //箭头

    _this.options.arrow = _this.options.arrow || {};
    _this.options.arrow.show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.arrow.show, true);
    _this.options.arrow.scale = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.arrow.scale, 0.3); //箭头长度的比例

    _this.options.arrow.width = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.arrow.width, 15); //箭头宽度

    _this.options.arrow.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.arrow.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW);
    _this.arrowLength = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.arrow.length, 40); //point点

    _this.options.point = _this.options.point || {};
    _this.options.point.show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.point.show, true);
    _this.options.point.pixelSize = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.point.pixelSize, 9);
    _this.options.point.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.point.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].RED.withAlpha(0.5));
    _this.arrowPrimitives = [];
    /**
     * 赵西洋
     * 隐藏点功能
     * 20210909
     */

    _this.pointPrimitives = [];
    return _this;
  }
  /**
   * 对象添加到地图前创建一些对象的钩子方法，
   * 只会调用一次
   * @return {void}  无
   * @private
   */


  createClass_default()(Slope, [{
    key: "_mountedHook",
    value: function _mountedHook() {
      this.pointInterPrimitives = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PointPrimitiveCollection"]();

      this._map.scene.primitives.add(this.pointInterPrimitives);
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      if (this.options.positions && this.options.positions.length > 0) {
        this.add(this.options.positions, this.options);
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear();
    }
    /**
     * 添加计算的 位置
     *
     * @param {Array[]|LatLngPoint[]|Cesium.Cartesian3[]|LatLngPoint|Cesium.Cartesian3} positions 坐标数组 或 单个坐标
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.splitNum=8] 插值数，横纵等比分割的网格个数
     * @param {Number} [options.radius=2]  取样分析，点周边半径（单位：米）
     * @param {Number} [options.count=4] 取样分析，点周边象限内点的数量，共计算 count*4 个点
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @return {void}  无，计算结果在 end事件中返回
     */

  }, {
    key: "add",
    value: function add(positions) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!positions || positions.length < 1) {
        return;
      }

      positions = LatLngArray_LatLngArray.toCartesians(positions);
      this.eventResult = {
        positions: positions
      };
      var splitNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.splitNum, 8);

      if (positions.length > 2 && splitNum > 1) {
        //传入面边界时
        var resultInter = interPolygon({
          scene: this._map.scene,
          positions: positions,
          has3dtiles: false,
          onlyPoint: true,
          //true时只返回点，不返回三角网
          splitNum: splitNum //splitNum插值分割的个数

        });
        this.arrowLength = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].chordLength(resultInter.granularity, this._map.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;
        this.eventResult.maxHeight = resultInter.maxHeight;
        this.eventResult.minHeight = resultInter.minHeight;
        positions = [];

        for (var k = 0; k < resultInter.list.length; k++) {
          positions.push(resultInter.list[k].pointDM);
        }
      }

      this.stateAll = positions.length;
      this.stateOkIndex = 0;
      this.instances = [];
      this.arrData = [];

      for (var i = 0; i < this.stateAll; i++) {
        this._fxOnePoint(positions[i], options);
      }
    } //分析单个点的对应坡度

  }, {
    key: "_fxOnePoint",
    value: function _fxOnePoint(position, options) {
      var _this2 = this;

      if (!position) {
        return;
      } //返回该点的周边2米圆上的8个点


      var arcPoint = getEllipseOuterPositions({
        position: position,
        radius: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.radius, 2),
        //半径
        count: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.count, 4) //共返回 count*4 个点

      });
      arcPoint.push(position);
      var ellipsoid = this._map.scene.globe.ellipsoid; // 求出点的详细高度

      var that = this;
      computeSurfacePoints({
        scene: this._map.scene,
        positions: arcPoint,
        has3dtiles: options.has3dtiles,
        callback: function callback(raisedPositions, noHeight) {
          if (_this2.stateAll == 0) {
            return;
          }

          if (noHeight) {
            Object(Log["logWarn"])("未获取到高度值，贴地高度计算存在误差");
          }

          var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions); // 中心点

          var center = cartographicArray.pop(); // 其余圆上点

          var maxIndex = 0;
          var maxHeight = cartographicArray[0].height;
          var minIndex = 0;
          var minHeight = cartographicArray[0].height;

          for (var i = 1; i < cartographicArray.length - 1; i++) {
            var item = cartographicArray[i];

            if (item.height > maxHeight) {
              maxHeight = item.height;
              maxIndex = i;
            }

            if (item.height < minHeight) {
              minHeight = item.height;
              minIndex = i;
            }
          }

          var maxPoint = cartographicArray[maxIndex]; //周边最高点

          var minPoint = cartographicArray[minIndex]; //周边最低点

          var slopeVal1 = that.getSlope(center, maxPoint);
          var slopeVal2 = that.getSlope(center, minPoint);

          if (slopeVal1 > slopeVal2) {
            that._fxOnePointOk(position, center, maxPoint, slopeVal1);
          } else {
            that._fxOnePointOk(position, center, minPoint, slopeVal2);
          }
        }
      });
    } //分析单个点的对应坡度完成后添加显示的箭头等

  }, {
    key: "_fxOnePointOk",
    value: function _fxOnePointOk(position, center, maxPoint, slopeVal) {
      var centerCar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(center);
      var maxPointCar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(maxPoint);
      maxPointCar = Object(PointUtil["getOnLinePointByLen"])(centerCar, maxPointCar, this.arrowLength); // 计算圆上的最高点和中心点的高度 判断箭头方向

      var arrArrowPt;

      if (center.height > maxPoint.height) {
        //中心点高于四周情况下
        arrArrowPt = [centerCar, maxPointCar];
      } else {
        //边缘指向中心
        arrArrowPt = [maxPointCar, centerCar];
      } //求方位角


      var slopeAngle = getAngle(arrArrowPt[0], arrArrowPt[1], true);
      var slopeValDou = Math.atan(slopeVal) * 180 / Math.PI;
      slopeValDou = Number(slopeValDou.toFixed(2)); // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°

      var text1 = slopeValDou + "°"; // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%

      var text2 = (slopeVal * 100).toFixed(2) + "%";
      var itemData = {
        position: position,
        //坐标位置
        slope: slopeValDou,
        //度数法值【 α(坡度)=arc tan (高程差/水平距离)】
        slopeStr1: text1,
        //度数法值字符串
        slopeStr2: text2,
        //百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
        direction: slopeAngle //坡向值（0-360度）

      };

      if (!this.arrData) {
        this.arrData = [];
      }

      this.arrData.push(itemData);
      this.fire(EventType.endItem, {
        data: itemData,
        index: this.stateOkIndex
      }); // 构建箭头

      if (this.options.arrow.show) {
        var gs = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
          geometry: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineGeometry"](Slope_objectSpread({
            positions: arrArrowPt
          }, this.options.arrow)),
          vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineMaterialAppearance"].VERTEX_FORMAT,
          id: "polylinedashinstance"
        });
        this.instances.push(gs);
      } // 添加点 显示坡度


      if (this.options.point.show) {
        var primitive = this.pointInterPrimitives.add(Slope_objectSpread({
          position: centerCar
        }, this.options.point));
        primitive.attr = itemData;
        primitive.eventTarget = this;
        primitive.tooltip = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.tooltip, "\u5761\u5EA6: ".concat(text1, "  (").concat(text2, ")<br />\u5761\u5411: ").concat(slopeAngle, "\xB0")); // 显示结果

        primitive.popup = this.options.popup;
        /**
         * 赵西洋
         * 隐藏点功能
         * 20210909
         */

        this.pointPrimitives.push(primitive);
      } // 全部计算完成


      this.stateOkIndex++;

      if (this.stateOkIndex >= this.stateAll) {
        if (this.options.arrow.show && this.instances.length > 0) {
          var arrowPrimitive = this._map.scene.primitives.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
            geometryInstances: this.instances,
            appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineMaterialAppearance"]({
              material: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("PolylineArrow", {
                color: this.options.arrow.color
              })
            })
          }));

          this.arrowPrimitives.push(arrowPrimitive);
          this.instances = [];
        }

        this.fire(EventType.end, Slope_objectSpread(Slope_objectSpread({}, this.eventResult || {}), {}, {
          data: this.arrData
        }));
      }
    }
    /**
     * 计算两点之间的坡度
     *
     * @param { Cesium.Cartesian3} c1 点1
     * @param { Cesium.Cartesian3} c2 点2
     * @return {Number} 坡度值
     */

  }, {
    key: "getSlope",
    value: function getSlope(c1, c2) {
      if (!c1 || !c2) {
        return;
      }

      var differH = Math.abs(c1.height - c2.height); //高度差

      var differV = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(c1), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(c2.longitude, c2.latitude, c1.height)); // 水平距离

      var value = differH / differV;
      return value;
    }
    /**
     * 箭头显隐  赵西洋 隐藏箭头功能  20210909
     * @param {Boolean} show  动态设置箭头要素显隐，true为显示，false为隐藏
     */

  }, {
    key: "setArrowShow",
    value: function setArrowShow(show) {
      for (var i = 0, len = this.arrowPrimitives.length; i < len; i++) {
        var primitive = this.arrowPrimitives[i];
        primitive.show = show;
      }
    }
    /**
     * 设置点显隐 赵西洋 隐藏点功能 20210909
     * @param {Boolean} show  动态设置计算点要素显隐，true为显示，false为隐藏
     */

  }, {
    key: "setPointShow",
    value: function setPointShow(show) {
      for (var i = 0, len = this.pointPrimitives.length; i < len; i++) {
        var primitive = this.pointPrimitives[i];
        primitive.show = show;
      }
    }
    /**
     * 获取单点的坡度坡向值
     * @param {Object} options 参数
     * @param {Cesium.Cartesian3} options.position 需要检测的坡度坡向点位坐标
     * @param {function} options.callback  获取到点位的坡度坡向值
     */

  }, {
    key: "getSinglePoint",
    value: function getSinglePoint() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var position = options.position,
          _callback = options.callback; //返回该点的周边2米圆上的8个点

      var arcPoint = getEllipseOuterPositions({
        position: position,
        radius: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](2),
        //半径
        count: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](4) //共返回 count*4 个点

      });
      arcPoint.push(position);
      var ellipsoid = this._map.scene.globe.ellipsoid; // 求出点的详细高度

      var that = this;
      computeSurfacePoints({
        scene: this._map.scene,
        positions: arcPoint,
        has3dtiles: options.has3dtiles,
        callback: function callback(raisedPositions, noHeight) {
          if (_this3.stateAll == 0) {
            return;
          }

          if (noHeight) {
            Object(Log["logWarn"])("未获取到高度值，贴地高度计算存在误差");
          }

          var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions); // 中心点

          var center = cartographicArray.pop(); // 其余圆上点

          var maxIndex = 0;
          var maxHeight = cartographicArray[0].height;
          var minIndex = 0;
          var minHeight = cartographicArray[0].height;

          for (var i = 1; i < cartographicArray.length - 1; i++) {
            var item = cartographicArray[i];

            if (item.height > maxHeight) {
              maxHeight = item.height;
              maxIndex = i;
            }

            if (item.height < minHeight) {
              minHeight = item.height;
              minIndex = i;
            }
          }

          var maxPoint = cartographicArray[maxIndex]; //周边最高点

          var minPoint = cartographicArray[minIndex]; //周边最低点

          var slopeVal1 = that.getSlope(center, maxPoint);
          var slopeVal2 = that.getSlope(center, minPoint);

          if (slopeVal1 > slopeVal2) {
            that._fxSinglePoint(position, center, maxPoint, slopeVal1, _callback);
          } else {
            that._fxSinglePoint(position, center, minPoint, slopeVal2, _callback);
          }
        }
      });
    } //分析单个点的对应坡度
    //赵西洋添加
    //单点传入识别地形
    //20210909

  }, {
    key: "_fxSinglePoint",
    value: function _fxSinglePoint(position, center, maxPoint, slopeVal, callback) {
      var centerCar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(center);
      var maxPointCar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(maxPoint);
      maxPointCar = Object(PointUtil["getOnLinePointByLen"])(centerCar, maxPointCar, this.arrowLength); // 计算圆上的最高点和中心点的高度 判断箭头方向

      var arrArrowPt;

      if (center.height > maxPoint.height) {
        //中心点高于四周情况下
        arrArrowPt = [centerCar, maxPointCar];
      } else {
        //边缘指向中心
        arrArrowPt = [maxPointCar, centerCar];
      } //求方位角


      var slopeAngle = getAngle(arrArrowPt[0], arrArrowPt[1], true);
      var slopeValDou = Math.atan(slopeVal) * 180 / Math.PI;
      slopeValDou = Number(slopeValDou.toFixed(2)); // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°

      var text1 = slopeValDou + "°"; // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%

      var text2 = (slopeVal * 100).toFixed(2) + "%";
      var itemData = {
        position: position,
        //坐标位置
        slope: slopeValDou,
        //度数法值【 α(坡度)=arc tan (高程差/水平距离)】
        slopeStr1: text1,
        //度数法值字符串
        slopeStr2: text2,
        //百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
        direction: slopeAngle //坡向值（0-360度）

      };
      callback(itemData);
    }
    /**
     * 清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this.pointInterPrimitives) {
        this.pointInterPrimitives.removeAll();
      }

      for (var i = 0, len = this.arrowPrimitives.length; i < len; i++) {
        this._map.scene.primitives.remove(this.arrowPrimitives[i]);
      }

      this.arrowPrimitives = [];
      /**
       * 赵西洋
       * 隐藏点功能
       * 20210909
       */

      this.pointPrimitives = [];
      this.instances = [];
      this.arrData = [];
      this.stateAll = 0;
      this.stateOkIndex = 0;
    }
  }]);

  return Slope;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/util/MeasureUtil.js
/**
 * 图上量算 的 常用静态方法
 * @module MeasureUtil
 */







/**
 * 求坐标数组的空间距离
 *
 * @export
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} positions 坐标数组
 * @return {Number} 距离（单位：米）
 */

function getDistance(positions) {
  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](positions) || positions.length < 2) {
    return 0;
  }

  positions = LatLngArray_LatLngArray.toCartesians(positions);
  var distance = 0;

  for (var i = 1, len = positions.length; i < len; i++) {
    distance += external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[i - 1], positions[i]);
  }

  return distance;
}
/**
 * 求坐标数组的 距离（地球表面弧度的）,
 * 比如北京到纽约（不能穿过球心，是贴地表的线的距离）
 *
 * @export
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} positions 坐标数组
 * @return {Number} 距离（单位：米）
 */

function getSurfaceDistance(positions) {
  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](positions) || positions.length < 2) {
    return 0;
  }

  positions = LatLngArray_LatLngArray.toCartesians(positions);
  var distance = 0;

  for (var i = 1, len = positions.length; i < len; i++) {
    var c1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[i - 1]);
    var c2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[i]);
    var geodesic = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidGeodesic"]();
    geodesic.setEndPoints(c1, c2);
    var s = geodesic.surfaceDistance;
    s = Math.sqrt(Math.pow(s, 2) + Math.pow(c2.height - c1.height, 2));
    distance += s;
  }

  return distance;
}
/**
 * 异步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
 * @callback getClampDistance_endItem
 * @param {Object} options 参数对象，具有以下属性:
 * @param {Number} options.index  坐标数组的index顺序
 * @param {Cesium.Cartesian3[]} options.positions  当前2个点之间的 贴地坐标数组
 * @param {Number} options.distance  当前2个点之间的 贴地距离
 * @param {Number[]} options.arrDistance  已计算完成从第0点到index点的 每一段的长度数组
 * @param {Number} options.all_distance   已计算完成从第0点到index点的 贴地距离
 */

/**
 * 异步计算贴地距离完成 的回调方法
 * @callback getClampDistance_callback
 * @param {Number} all_distance 路线的全部距离，单位：米
 * @param {Array} arrDistance 每2个点间的 每一段的长度数组
 */

/**
 * 异步计算贴地(地表或模型表面)距离，单位：米
 *
 * @export
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} positions 坐标数组
 * @param {Object} options 参数对象，具有以下属性:
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Number} [options.splitNum=100]  插值数，将线段分割的个数
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {getClampDistance_endItem} options.endItem  异步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
 * @param {getClampDistance_callback} options.callback  异步计算贴地距离完成 的回调方法
 * @return {void}  无
 */

function getClampDistance(positions, options) {
  var all_distance = 0;
  var arrDistance = [];
  positions = LatLngArray_LatLngArray.toCartesians(positions);
  computeStepSurfaceLine({
    scene: options.scene,
    positions: positions,
    splitNum: options.splitNum,
    has3dtiles: options.has3dtiles,
    //计算每个分段后的回调方法
    endItem: function endItem(raisedPositions, noHeight, index) {
      var distance = getSurfaceDistance(raisedPositions);

      if (noHeight && options.disTerrainScale) {
        distance = distance * options.disTerrainScale; //求高度失败，概略估算值
      }

      all_distance += distance;
      arrDistance.push(distance);

      if (options.endItem) {
        options.endItem({
          index: index,
          positions: raisedPositions,
          distance: distance,
          arrDistance: arrDistance,
          all_distance: all_distance
        });
      }
    },
    //计算全部完成的回调方法
    end: function end() {
      if (options.callback) {
        options.callback(all_distance, arrDistance);
      }
    }
  });
}
/**
 * 计算面积（空间平面）
 *
 * @export
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} positions 坐标数组
 * @return {Number} 面积，单位：平方米
 */

function getArea(positions) {
  if (!positions || !Array.isArray(positions) || positions.length < 3) {
    return 0;
  }

  positions = LatLngArray_LatLngArray.toCartesians(positions);
  var geometry = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CoplanarPolygonGeometry"].createGeometry(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CoplanarPolygonGeometry"].fromPositions({
    positions: positions,
    vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexFormat"].POSITION_ONLY
  }));
  var result = 0;

  if (!geometry) {
    return result;
  }

  var flatPositions = geometry.attributes.position.values;
  var indices = geometry.indices;

  for (var i = 0; i < indices.length; i += 3) {
    var p0 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].unpack(flatPositions, indices[i] * 3, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var p1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].unpack(flatPositions, indices[i + 1] * 3, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var p2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].unpack(flatPositions, indices[i + 2] * 3, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    result += MeasureUtil_getTriangleArea(p0, p1, p2);
  }

  return result;
}
/**
 * 计算三角形面积（空间平面）
 *
 * @export
 * @param {Cesium.Cartesian3} pos1 三角形顶点坐标1
 * @param {Cesium.Cartesian3} pos2 三角形顶点坐标2
 * @param {Cesium.Cartesian3} pos3 三角形顶点坐标3
 * @return {Number} 面积，单位：平方米
 */

function MeasureUtil_getTriangleArea(pos1, pos2, pos3) {
  // let a = Cesium.Cartesian3.distance(pos1, pos2)
  // let b = Cesium.Cartesian3.distance(pos2, pos3)
  // let c = Cesium.Cartesian3.distance(pos3, pos1)
  // let S = (a + b + c) / 2
  // return Math.sqrt(S * (S - a) * (S - b) * (S - c))
  var v0 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(pos1, pos2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  var v1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(pos3, pos2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  var cross = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(v0, v1, v0);
  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].magnitude(cross) * 0.5;
}
/**
 * 异步精确计算贴地面积完成 的回调方法
 * @callback getClampArea_callback
 * @param {Number} area 贴地面积，单位：平方米
 * @param {Object} resultInter 面内进行贴地(或贴模型)插值对象
 */

/**
 * 计算贴地面积
 *
 * @export
 * @param {Cesium.Cartesian3[]|LatLngPoint[]} positions 坐标数组
 * @param {Object} options 参数对象，具有以下属性:
 * @param {Boolean} options.asyn  是否进行异步精确计算
 * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
 * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
 * @param {getClampArea_callback} options.callback  异步计算贴地距离完成 的回调方法
 * @return {Number|void} 仅 asyn:false 时返回面积，单位：平方米
 */

function getClampArea(positions, options) {
  function _restultArea(resultInter) {
    var area = 0; //总面积(贴地三角面)

    for (var i = 0, len = resultInter.list.length; i < len; i++) {
      var item = resultInter.list[i];
      var pt1 = item.point1;
      var pt2 = item.point2;
      var pt3 = item.point3; //求面积

      area += MeasureUtil_getTriangleArea(pt1.pointDM, pt2.pointDM, pt3.pointDM);
    }

    return area;
  }

  var _callback = options.callback;
  var resultInter = interPolygon({
    positions: LatLngArray_LatLngArray.toCartesians(positions),
    scene: options.scene,
    splitNum: options.splitNum,
    has3dtiles: options.has3dtiles,
    asyn: options.asyn,
    callback: function callback(resultInter) {
      var area = _restultArea(resultInter);

      if (_callback) {
        _callback(area, resultInter);
      }
    }
  });

  if (options.asyn) {
    return null;
  } else {
    var area = _restultArea(resultInter);

    if (_callback) {
      _callback(area, resultInter);
    }

    return area;
  }
}
/**
 * 计算2点的角度值，角度已正北为0度，顺时针为正方向
 *
 * @export
 * @param {Cesium.Cartesian3} startPosition 需要计算的点
 * @param {Cesium.Cartesian3} endPosition 目标点，以该点为参考中心。
 * @param {Boolean} [isNorthZero=false]  是否正东为0时的角度（如方位角）
 * @return {Number} 返回角度值，0-360度
 */

function getAngle(startPosition, endPosition, isNorthZero) {
  //获取该位置的默认矩阵
  var mat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(endPosition); //中心点 矩阵

  mat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].getMatrix3(mat, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]());
  var xaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(mat, 0, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  var yaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(mat, 1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  var zaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(mat, 2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); //计算该位置 和  position 的 角度值

  var dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(startPosition, endPosition, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); //z crosss (dirx cross z) 得到在 xy平面的向量

  dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(dir, zaxis, dir);
  dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(zaxis, dir, dir);
  dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(dir, dir);
  var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(xaxis, dir);
  var ay = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(yaxis, dir);

  if (ay > Math.PI * 0.5) {
    heading = 2 * Math.PI - heading;
  }

  var hDegrees = 360 - external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(heading) - 180; //转换为: 正东为0时，顺时针为正方向

  if (isNorthZero) {
    hDegrees += 90; //转换为：以北为0度
  }

  if (hDegrees < 0) {
    hDegrees = hDegrees + 360;
  } else if (hDegrees > 360) {
    hDegrees = hDegrees - 360;
  }

  return Object(Util["formatNum"])(hDegrees, 1);
}
/**
 * 异步计算中，每计算完成1个点的坡度坡向后 的回调方法
 * @callback getSlope_endItem
 * @param {Object} event 参数对象，具有以下属性:
 * @param {Number} event.index 数组点中的index顺序
 * @param {Object} event.data 数据对象，具有以下属性:
 * @param {Cesium.Cartesian3} event.data.position  坐标位置
 * @param {Number} event.data.slope 度数法值【 α(坡度)=arc tan (高程差/水平距离)】
 * @param {String} event.data.slopeStr1 度数法值字符串
 * @param {String} event.data.slopeStr2 百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
 * @param {Number} event.data.direction 坡向值（0-360度）
 */

/**
 * 异步计算完成所有点的坡度坡向后 的回调方法
 * @callback getSlope_callback
 * @param {Object} event 参数对象，具有以下属性:
 * @param {Object[]} event.data 数组对象，数组中每一个值，具有以下属性:
 * @param {Cesium.Cartesian3} event.data.position  坐标位置
 * @param {Number} event.data.slope 度数法值【 α(坡度)=arc tan (高程差/水平距离)】
 * @param {String} event.data.slopeStr1 度数法值字符串
 * @param {String} event.data.slopeStr2 百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
 * @param {Number} event.data.direction 坡向值（0-360度）
 */

/**
 * 异步计算点的坡度坡向
 *
 * @export
 * @param {Object} options 参数对象，具有以下属性:
 * @param {Map} options.map  Map地图对象
 * @param {Cesium.Cartesian3[]} options.positions 坐标数组
 * @param {Number} options.radius  缓冲半径（影响坡度坡向的精度）
 * @param {Number} options.count  缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
 * @param {Boolean} options.has3dtiles  是否在3dtiles模型上分析（模型分析较慢，按需开启）
 * @param {getSlope_endItem} options.endItem  异步计算中，每计算完成1个点的坡度坡向后 的回调方法
 * @param {getSlope_callback} options.callback  异步计算完成所有点的坡度坡向后 的回调方法
 * @return {Slope}  坡度坡向分析类对象,分析完成方法内部会自动释放
 */

function MeasureUtil_getSlope(options) {
  var slope = new Slope_Slope({
    positions: options.positions,
    splitNum: 1,
    radius: options.radius,
    //缓冲半径（影响坡度坡向的精度）
    count: options.count,
    //缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
    has3dtiles: options.has3dtiles,
    point: {
      show: false
    },
    arrow: {
      show: false
    }
  });
  slope.addTo(options.map);

  if (options.endItem) {
    slope.on(EventType.endItem, options.endItem);
  }

  slope.on(EventType.end, function (e) {
    if (options.callback) {
      options.callback(e);
    }

    slope.destroy();
  });
  return slope;
}
/**
 * 格式化显示距离值, 可指定单位
 *
 * @export
 * @param {Number} val  距离值，米
 * @param {String} [unit='auto'] 计量单位, 可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
 * @param {LangType} lang  使用的语言
 * @return {String} 带单位的格式化距离值字符串，如：20.17 米
 */

function formatDistance(val, unit, lang) {
  if (val == null) {
    return "";
  }

  if (unit == null || unit == "auto") {
    if (val < 1000) {
      unit = "m";
    } else {
      unit = "km";
    }
  }

  var valstr = "";

  switch (unit) {
    default:
    case "m":
      valstr = val.toFixed(2) + Object(Util["getLangText"])("_米", lang);
      break;

    case "km":
      valstr = (val * 0.001).toFixed(2) + Object(Util["getLangText"])("_公里", lang);
      break;

    case "mile":
      valstr = (val * 0.00054).toFixed(2) + Object(Util["getLangText"])("_海里", lang);
      break;

    case "zhang":
      valstr = (val * 0.3).toFixed(2) + Object(Util["getLangText"])("_丈", lang);
      break;
  }

  return valstr;
}
/**
 * 格式化显示面积值, 可指定单位
 *
 * @export
 * @param {Number} val 面积值，平方米
 * @param {String} [unit='auto'] 计量单位，可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用m或km
 * @param {LangType} lang  使用的语言
 * @return {String} 带单位的格式化面积值字符串，如：20.21 平方公里
 */

function formatArea(val, unit, lang) {
  if (val == null) {
    return "";
  }

  if (unit == null || unit == "auto") {
    if (val < 1000000) {
      unit = "m";
    } else {
      unit = "km";
    }
  }

  var valstr = "";

  switch (unit) {
    default:
    case "m":
      valstr = val.toFixed(2) + Object(Util["getLangText"])("_平方米", lang);
      break;

    case "km":
      valstr = (val / 1000000).toFixed(2) + Object(Util["getLangText"])("_平方公里", lang);
      break;

    case "mu":
      valstr = (val * 0.0015).toFixed(2) + Object(Util["getLangText"])("_亩", lang);
      break;

    case "ha":
      valstr = (val * 0.0001).toFixed(2) + Object(Util["getLangText"])("_公顷", lang);
      break;
  }

  return valstr;
}
/**
 * 格式化显示体积值, 可指定单位
 *
 * @export
 * @param {Number} val 体积值，立方米
 * @param {String} [unit='auto'] 计量单位，当前无用，备用参数
 * @param {LangType} lang  使用的语言
 * @return {String} 带单位的格式化体积值字符串，如：20.21 方
 */

function formatVolume(val, unit, lang) {
  if (val == null) {
    return "";
  }

  if (lang == LangType.EN) {
    return val.toFixed(2) + Object(Util["getLangText"])("_立方米", lang);
  }

  if (val < 10000) {
    return val.toFixed(2) + Object(Util["getLangText"])("_立方米", lang);
  } else {
    return (val / 10000).toFixed(2) + Object(Util["getLangText"])("_万立方米", lang);
  }
}
// CONCATENATED MODULE: ./src/util/MaterialUtil.js
/**
 * 矢量数据材质
 * @module MaterialUtil
 */
 // import { BaseMaterialConver } from '../material'


var OptsConverClass = {};
function registerOptsConver(type, mClass) {
  if (OptsConverClass[type]) {
    Object(Log["logError"])("MaterialUtil registerOptsConver: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"), mClass);
  }

  OptsConverClass[type] = mClass;
} //材质属性类集合（按类型）

var MaterialClass = {}; //注册 自定义的材质类

function register(type, mClass) {
  if (MaterialClass[type]) {
    Object(Log["logError"])("MaterialUtil register: ".concat(type, "\u7C7B\u578B\u5DF2\u5B58\u5728"), mClass);
  }

  MaterialClass[type] = mClass;
} //材质属性类集合（按类型）

var MaterialPropertyClass = {}; //注册 材质属性类

function registerProperty(type, propertyClass) {
  if (MaterialPropertyClass[type]) {
    Object(Log["logError"])("MaterialUtil registerProperty: ".concat(type, "\u5C5E\u6027\u7C7B\u578B\u5DF2\u5B58\u5728"), propertyClass);
  }

  MaterialPropertyClass[type] = propertyClass;
}
/**
 * 创建 材质属性（用于Entity）
 * @param {MaterialType} type 材质类型
 * @param {Object} options 创建参数,具体对照{@link MaterialType}的注释说明
 * @returns {BaseMaterialProperty} 材质属性对象
 */

function createMaterialProperty(type, options) {
  var ThisPropertyClass = MaterialPropertyClass[type];

  if (ThisPropertyClass) {
    var optsConver = OptsConverClass[type] || OptsConverClass["default"];

    if (optsConver) {
      options.materialType = type;
      options = optsConver.toCesiumVal(options, {}, true);
    }

    var material = new ThisPropertyClass(options);
    material._tudou_type = type;
    return material;
  } else {
    Object(Log["logWarn"])("createMaterialProperty:未找到该类型的对应材质属性", type);
  }
}
/**
 * 创建 材质（用于Primitive）
 * @param {MaterialType} type 材质类型
 * @param {Object} options 创建参数,具体对照{@link MaterialType}的注释说明
 * @returns {Cesium.Material} 材质对象
 */

function createMaterial(type, options) {
  if (!type) {
    Object(Log["logError"])("createMaterial：请指定tudou3d.MaterialType类型");
    return;
  }

  var optsConver = OptsConverClass[type] || OptsConverClass["default"];

  if (optsConver) {
    options.materialType = type;
    options = optsConver.toCesiumVal(options);
  }

  var material;
  var ThisClass = MaterialClass[type];

  if (ThisClass) {
    material = new ThisClass(options);
  } else {
    material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType(type, options);
  }

  material._tudou_type = type;
  return material;
}
/**
 * 将材质对象转为Josn简单对象，用于保存。
 *
 * @param {Cesium.Material|BaseMaterialProperty} material 材质对象
 * @param {Object} style 附加到的目标对象
 * @return {Object} json简单对象
 */

function MaterialUtil_toJSON(material) {
  var _material$_template;

  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type;

  if (material._tudou_type) {
    type = material._tudou_type;
  } else if (material !== null && material !== void 0 && (_material$_template = material._template) !== null && _material$_template !== void 0 && _material$_template.type) {
    type = material._template.type;
  } else if (material !== null && material !== void 0 && material.getType) {
    type = material.getType();
  }

  if (!type) {
    if (material instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]) {
      type = "Color";
    } else {
      Object(Log["logWarn"])("toJSON：未识别的材质类型", material);
    }
  }

  var optsConver = OptsConverClass[type] || OptsConverClass["default"];

  if (optsConver) {
    style.materialType = type;
    optsConver.toJSON(material, style);
  }

  return style;
}
// EXTERNAL MODULE: ./src/util/GraphicUtil.js
var GraphicUtil = __webpack_require__(11);

// CONCATENATED MODULE: ./src/util/DrawUtil.js


function DrawUtil_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DrawUtil_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DrawUtil_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DrawUtil_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * 矢量数据标绘编辑相关常量
 * @module DrawUtil
 */


/**
 * 拖拽点分类
 * @type {Number}
 */

var PointType = {
  Control: 1,
  //位置控制
  MoveAll: 2,
  //整体平移(如线面)
  AddMidPoint: 3,
  //辅助增加新点
  MoveHeight: 4,
  //上下移动高度
  EditAttr: 5,
  //辅助修改属性（如半径）
  EditRotation: 6 //旋转角度修改

};
/**
 * 拖拽点颜色
 * @type {Cesium.Color}
 * @example
tudou3d.DrawUtil.PointColor.Control = '#1c197d' //位置控制拖拽点
tudou3d.DrawUtil.PointColor.MoveAll = '#8c003a' //整体平移(如线面)拖拽点
tudou3d.DrawUtil.PointColor.MoveHeight = '#9500eb' //上下移动高度的拖拽点
tudou3d.DrawUtil.PointColor.EditAttr = '#f73163' //辅助修改属性（如半径）的拖拽点
tudou3d.DrawUtil.PointColor.AddMidPoint = 'rgba(4,194,201,0.3)' //增加新点，辅助拖拽点
 */

var PointColor = {
  Control: "#1c197d",
  //位置控制拖拽点
  MoveAll: "#8c003a",
  //整体平移(如线面)拖拽点
  MoveHeight: "#9500eb",
  //上下移动高度的拖拽点
  EditAttr: "#f531e8",
  //辅助修改属性（如半径）的拖拽点
  AddMidPoint: "rgba(4,194,201,0.3)" //增加新点，辅助拖拽点

}; //编辑点的公共样式

var defaultEditStyle = {
  pixelSize: 12,
  outline: true,
  outlineColor: "rgba(255,255,255,0.5)",
  outlineWidth: 2,
  scaleByDistance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["NearFarScalar"](1000, 1, 1000000, 0.5),
  disableDepthTestDistance: Number.POSITIVE_INFINITY //不被遮挡

};
/**
 * 设置编辑点的样式（color颜色除外）
 * @param {PointPrimitive.StyleOptions} value 像素
 * @returns {void} 无
 */

function setPointStyle(value) {
  defaultEditStyle = Object(Util["merge"])(defaultEditStyle, value);
}
function getEditPointStyle(type) {
  var attr = DrawUtil_objectSpread({}, defaultEditStyle);

  switch (type) {
    case PointType.AddMidPoint:
      attr.color = PointColor.AddMidPoint;
      attr.outlineColor = "rgba(255,255,255,0.4)";
      break;

    case PointType.MoveAll:
      attr.color = PointColor.MoveAll;
      break;

    case PointType.MoveHeight:
      attr.color = PointColor.MoveHeight;
      break;

    case PointType.EditAttr:
      attr.color = PointColor.EditAttr;
      break;

    case PointType.Control:
    default:
      attr.color = PointColor.Control;
      break;
  }

  return attr;
}
// EXTERNAL MODULE: ./src/util/LayerUtil.js
var LayerUtil = __webpack_require__(12);

// CONCATENATED MODULE: ./src/core/BaseOptsConver.js



 //转换options

var BaseOptsConver_BaseOptsConver = /*#__PURE__*/function () {
  function BaseOptsConver() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseOptsConver);

    this.options = options;
  } // /**
  //  * 排除的不用处理的属性
  //  * @type {String[]}
  //  * @readonly
  //  */
  // get excluded() {
  //   return null
  // }
  //====================
  //转换为cesium所需的数据对象


  createClass_default()(BaseOptsConver, [{
    key: "toCesiumVal",
    value: function toCesiumVal(style) {
      var czmVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._toCesiumValBefore(style, czmVal);

      for (var key in style) {
        var value = style[key]; //非简单类型，无需处理 直接赋值。

        if (!Object(Util["isSimpleType"])(value)) {
          czmVal[key] = value;
          continue;
        }

        if (this.excluded && this.excluded.indexOf(key) != -1) {
          continue;
        }

        var showval = this._toOneCesiumVal(key, value, style, czmVal);

        if (showval == null) {
          continue;
        }

        czmVal[key] = showval;
      }

      this._toCesiumValEnd(style, czmVal);

      return czmVal;
    }
  }, {
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {}
  }, {
    key: "_toCesiumValEnd",
    value: function _toCesiumValEnd(style, czmVal) {}
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          czmVal[key] = value;
          break;
        // case 'repeat_x': {
        //   let repeatX = Cesium.defaultValue(style.repeat_x, 1)
        //   let repeatY = Cesium.defaultValue(style.repeat_y, 1)
        //   czmVal.repeat = new Cesium.Cartesian2(repeatX, repeatY)
        //   break
        // }
      }
    } //====================
    //转换为json简单对象，用于导出

  }, {
    key: "toJSON",
    value: function toJSON(czmVal) {
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      czmVal = Object(Util["getAttrVal"])(czmVal);

      for (var key in czmVal) {
        var value = czmVal[key];

        if (Object(Util["isSimpleType"])(value)) {
          style[key] = value;
        } else {
          this._toOneJson(key, czmVal[key], style);
        }
      }

      return style;
    } //将cesium属性转为style ，用于导出json

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {} //====================

  }, {
    key: "getColorByStyle",
    value: function getColorByStyle(style) {
      return Object(Util["getColorByStyle"])(style, this.options.color);
    }
  }, {
    key: "getOutlineColorByStyle",
    value: function getOutlineColorByStyle(style) {
      var color;

      if (style.outlineColor) {
        if (Object(Util["isString"])(style.outlineColor)) {
          color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(style.outlineColor);
        } else {
          color = style.outlineColor;
        }
      } else {
        color = this.options.outlineColor;
      }

      if (!color) {
        return color;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.outlineOpacity)) {
        color = color.withAlpha(Number(style.outlineOpacity));
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.opacity)) {
        color = color.withAlpha(Number(style.opacity));
      }

      return color;
    }
  }], [{
    key: "getColorByStyle",
    value: function getColorByStyle(style) {
      if (!this.baseOptsConver) {
        this.baseOptsConver = new BaseOptsConver();
      }

      return this.baseOptsConver.getColorByStyle(style);
    }
  }]);

  return BaseOptsConver;
}();
// CONCATENATED MODULE: ./src/util/converMaterial/BaseMaterialConver.js






function BaseMaterialConver_createSuper(Derived) { var hasNativeReflectConstruct = BaseMaterialConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseMaterialConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 通用材质 转换处理类
 *
 * @export
 * @class BaseMaterialConver
 * @extends {BaseOptsConver}
 * @private
 */

var BaseMaterialConver_BaseMaterialConver = /*#__PURE__*/function (_BaseOptsConver) {
  inherits_default()(BaseMaterialConver, _BaseOptsConver);

  var _super = BaseMaterialConver_createSuper(BaseMaterialConver);

  function BaseMaterialConver() {
    classCallCheck_default()(this, BaseMaterialConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseMaterialConver, [{
    key: "excluded",
    get:
    /**
     * 排除的不用处理的属性
     * @type {String[]}
     * @readonly
     */
    function get() {
      var arr = ["label"];
      return arr.concat(this._getExcludedStyle());
    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return [];
    }
  }, {
    key: "_toOneCesiumVal",
    value: //点状数据的通用处理
    function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          czmVal[key] = value;
          break;

        case "color":
        case "randomColor":
          czmVal.color = this.getColorByStyle(style);
          break;

        case "color2":
        case "evenColor":
        case "outlineColor":
        case "oddColor":
        case "baseWaterColor":
        case "blendColor":
        case "gapColor":
        case "strokeColor":
        case "backgroundColor":
        case "asphaltColor":
        case "lightColor":
        case "darkColor":
        case "grassColor":
        case "dirtColor":
        case "lightWoodColor":
        case "darkWoodColor":
          czmVal[key] = Object(Util["getCesiumColor"])(value);
          break;

        case "repeat_x":
        case "repeat_y":
          {
            var repeatX = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.repeat_x, 1);
            var repeatY = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.repeat_y, 1);
            czmVal.repeat = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](repeatX, repeatY);
            break;
          }

        case "repeat":
          {
            if (style.materialType == Stripe || style.materialType == CylinderWave) {
              czmVal[key] = value;
            } else {
              czmVal[key] = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](style.repeat_x || value, style.repeat_y || value);
            }

            break;
          }

        case "lineCount":
        case "lineThickness":
        case "lineOffset":
        case "noiseScale":
          {
            czmVal[key] = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](value, value);
            break;
          }
      }
    }
  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]) {
        style[key] = value.toCssColorString();
        return;
      }

      switch (key) {
        default:
          // style[key] = value
          console.log("未处理的属性", key, value);
          break;

        case "label":
          break;

        case "color":
        case "evenColor":
        case "outlineColor":
        case "oddColor":
        case "baseWaterColor":
        case "blendColor":
        case "gapColor":
        case "strokeColor":
        case "backgroundColor":
        case "asphaltColor":
        case "lightColor":
        case "darkColor":
        case "grassColor":
        case "dirtColor":
        case "lightWoodColor":
        case "darkWoodColor":
          {
            var color = Object(Util["getCesiumValue"])(value, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]);

            if (color) {
              style[key] = color.toCssColorString();
            }

            break;
          }

        case "repeat":
          {
            if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]) {
              if (value.x != value.y) {
                style[key + "_x"] = value.x;
                style[key + "_y"] = value.y;
              } else {
                style[key] = value.x;
              }
            } else {
              style[key] = value;
            }

            break;
          }

        case "lineCount":
        case "lineThickness":
        case "lineOffset":
        case "noiseScale":
          {
            style[key + "_x"] = value.x;
            style[key + "_y"] = value.y;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: function toCesiumVal(style, czmVal) {
      if (!this.baseMaterialConver) {
        this.baseMaterialConver = new BaseMaterialConver();
      }

      return this.baseMaterialConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      if (!this.baseMaterialConver) {
        this.baseMaterialConver = new BaseMaterialConver();
      }

      return this.baseMaterialConver.toJSON(czmVal, style);
    }
  }]);

  return BaseMaterialConver;
}(BaseOptsConver_BaseOptsConver);
registerOptsConver("default", BaseMaterialConver_BaseMaterialConver);
// CONCATENATED MODULE: ./src/util/converMaterial/ColorOptsConver.js






function ColorOptsConver_createSuper(Derived) { var hasNativeReflectConstruct = ColorOptsConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ColorOptsConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 颜色材质 转换处理类
 *
 * @export
 * @class ColorOptsConver
 * @extends {BaseMaterialConver}
 * @private
 */

var ColorOptsConver_ColorOptsConver = /*#__PURE__*/function (_BaseMaterialConver) {
  inherits_default()(ColorOptsConver, _BaseMaterialConver);

  var _super = ColorOptsConver_createSuper(ColorOptsConver);

  function ColorOptsConver() {
    classCallCheck_default()(this, ColorOptsConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(ColorOptsConver, [{
    key: "toCesiumVal",
    value: function toCesiumVal(style) {
      var czmVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.isProperty) {
        return this.getColorByStyle(style);
      } else {
        return {
          color: this.getColorByStyle(style)
        };
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      var color = Object(Util["getCesiumValue"])(czmVal, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]);

      if (color.color) {
        color = color.color;
      }

      style.color = color.toCssColorString();
    }
  }], [{
    key: "toCesiumVal",
    value: function toCesiumVal(style, czmVal, isProperty) {
      if (style instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]) {
        return style;
      }

      if (!this.colorOptsConver) {
        this.colorOptsConver = new ColorOptsConver();
      }

      this.colorOptsConver.isProperty = isProperty;
      return this.colorOptsConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isProperty) {
      if (!this.colorOptsConver) {
        this.colorOptsConver = new ColorOptsConver();
      }

      this.colorOptsConver.isProperty = isProperty;
      return this.colorOptsConver.toJSON(czmVal, style);
    }
  }]);

  return ColorOptsConver;
}(BaseMaterialConver_BaseMaterialConver);
registerOptsConver(Color, ColorOptsConver_ColorOptsConver);
registerOptsConver(PolylineArrow, ColorOptsConver_ColorOptsConver);
// CONCATENATED MODULE: ./src/util/converMaterial/ImageOptsConver.js






function ImageOptsConver_createSuper(Derived) { var hasNativeReflectConstruct = ImageOptsConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ImageOptsConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 图片材质 转换处理类
 *
 * @export
 * @class ImageOptsConver
 * @extends {BaseMaterialConver}
 * @private
 */

var ImageOptsConver_ImageOptsConver = /*#__PURE__*/function (_BaseMaterialConver) {
  inherits_default()(ImageOptsConver, _BaseMaterialConver);

  var _super = ImageOptsConver_createSuper(ImageOptsConver);

  function ImageOptsConver() {
    classCallCheck_default()(this, ImageOptsConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(ImageOptsConver, [{
    key: "excluded",
    get:
    /**
     * 排除的不用处理的属性
     * @type {String[]}
     * @readonly
     */
    function get() {
      return ["repeat_y"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          czmVal[key] = value;
          break;

        case "repeat_x":
          {
            var repeatX = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.repeat_x, 1);
            var repeatY = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.repeat_y, 1);
            czmVal.repeat = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](repeatX, repeatY);
            break;
          }

        case "repeat":
          {
            czmVal[key] = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](style.repeat_x || value, style.repeat_y || value);
            break;
          }

        case "color":
          // czmVal.color = this.getColorByStyle(style)
          break;

        case "opacity":
          czmVal.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(style.opacity);
          break;
      }
    }
  }, {
    key: "_toCesiumValEnd",
    value: function _toCesiumValEnd(style, czmVal) {
      czmVal.transparent = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](czmVal.transparent, true);
    }
  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          console.log("未处理的属性", key, value);
          break;

        case "repeat":
          {
            style.repeat_x = value.x;
            style.repeat_y = value.y;
            break;
          }

        case "color":
          {
            var _getCesiumValue$alpha, _getCesiumValue;

            style.opacity = (_getCesiumValue$alpha = (_getCesiumValue = Object(Util["getCesiumValue"])(value, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"])) === null || _getCesiumValue === void 0 ? void 0 : _getCesiumValue.alpha) !== null && _getCesiumValue$alpha !== void 0 ? _getCesiumValue$alpha : 1;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: function toCesiumVal(style, czmVal) {
      if (!this.imageOptsConver) {
        this.imageOptsConver = new ImageOptsConver();
      }

      return this.imageOptsConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      if (!this.imageOptsConver) {
        this.imageOptsConver = new ImageOptsConver();
      }

      return this.imageOptsConver.toJSON(czmVal, style);
    }
  }]);

  return ImageOptsConver;
}(BaseMaterialConver_BaseMaterialConver);
registerOptsConver(MaterialType_Image, ImageOptsConver_ImageOptsConver);
// CONCATENATED MODULE: ./src/util/converStyle/BaseStyleConver.js






function BaseStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = BaseStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 矢量数据style转换处理基类
 *
 * @export
 * @class BaseStyleConver
 * @extends {BaseOptsConver}
 * @private
 */

var BaseStyleConver_BaseStyleConver = /*#__PURE__*/function (_BaseOptsConver) {
  inherits_default()(BaseStyleConver, _BaseOptsConver);

  var _super = BaseStyleConver_createSuper(BaseStyleConver);

  function BaseStyleConver() {
    classCallCheck_default()(this, BaseStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseStyleConver, [{
    key: "excluded",
    get:
    /**
     * 排除的不用处理的属性
     * @type {String[]}
     * @readonly
     */
    function get() {
      var arr = ["label", "outlineOpacity", "lineCount", "lineThickness", "cellAlpha", "oddcolor", "speed", "axisY", "image2", "color2", "scaleByDistance_near", "scaleByDistance_nearValue", "scaleByDistance_far", "scaleByDistance_farValue", "distanceDisplayCondition_far", "distanceDisplayCondition_near"];
      return arr.concat(this._getExcludedStyle());
    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return [];
    }
  }, {
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      if (!style.material && !style.materialType) {
        //没有类型时，如果有对应的属性值，即视为对应的类型
        if (style.color || style.randomColor) {
          style.materialType = Color;
        } else if (style.image) {
          style.materialType = MaterialType_Image;
        }
      }
    } //点状数据的通用处理

  }, {
    key: "_toOneCesiumVal_Point",
    value: function _toOneCesiumVal_Point(key, value, style, czmVal) {
      switch (key) {
        default:
          czmVal[key] = value;
          break;

        case "clampToGround":
          //贴地
          if (value) {
            czmVal.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND;
          } else {
            czmVal.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].NONE;
          }

          break;

        case "visibleDepth":
          if (value) {
            czmVal.disableDepthTestDistance = 0;
          } else {
            //一直显示，不被地形等遮挡
            czmVal.disableDepthTestDistance = Number.POSITIVE_INFINITY;
          }

          break;

        case "scaleByDistance":
          //是否按视距缩放
          if (value) {
            czmVal.scaleByDistance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["NearFarScalar"](Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.scaleByDistance_near, 1000)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.scaleByDistance_nearValue, 1.0)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.scaleByDistance_far, 1000000)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.scaleByDistance_farValue, 0.1)));
          } else {
            czmVal.scaleByDistance = undefined;
          }

          break;

        case "distanceDisplayCondition":
          //是否按视距显示
          if (value) {
            czmVal.distanceDisplayCondition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayCondition"](Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_near, 0)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_far, 100000)));
          } else {
            czmVal.distanceDisplayCondition = undefined;
          }

          break;
      }
    } //面状数据的通用处理

  }, {
    key: "_toOneCesiumVal_Poly",
    value: function _toOneCesiumVal_Poly(key, value, style, czmVal) {
      switch (key) {
        default:
          if (czmVal[key] instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {//回调时不覆盖
          } else {
            czmVal[key] = value;
          }

          break;

        case "materialType":
          {
            if (this.isEntity) {
              czmVal.material = createMaterialProperty(style.materialType, style);
            } else {
              czmVal.material = createMaterial(style.materialType, style);
            }

            break;
          }

        case "color":
        case "randomColor":
          {
            //color本身也需要处理
            czmVal.color = this.getColorByStyle(style);
            break;
          }

        case "outlineColor":
          {
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }

        case "hasShadows":
          //阴影
          if (value) {
            //对象投射并接收阴影。
            czmVal.shadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].ENABLED;
          } else {
            //该对象不会投射或接收阴影
            czmVal.shadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].DISABLED;
          }

          break;

        case "distanceDisplayCondition":
          //是否按视距显示
          if (value) {
            czmVal.distanceDisplayCondition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayCondition"](Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_near, 0)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_far, 100000) + 6378137));
          } else {
            czmVal.distanceDisplayCondition = undefined;
          }

          break;
      }
    }
  }, {
    key: "_toOneJson_Poly",
    value: function _toOneJson_Poly(key, value, style) {
      switch (key) {
        default:
          // style[key] = value
          console.log("未处理的属性", value);
          break;

        case "label":
          break;

        case "material":
          {
            MaterialUtil_toJSON(value, style);
            break;
          }

        case "color":
          {
            var color = Object(Util["getCesiumValue"])(value, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]);

            if (color) {
              style[key] = color.toCssColorString();
            }

            break;
          }

        case "outlineColor":
          {
            var _color = Object(Util["getCesiumValue"])(value, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]);

            if (_color) {
              style[key] = _color.toCssColorString();
            }

            break;
          }

        case "shadows":
          {
            if (value == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].ENABLED) {
              style.shadows = true;
            } else {
              style[key] = value;
            }

            break;
          }

        case "distanceDisplayCondition":
          {
            style.distanceDisplayCondition_near = value.near;
            style.distanceDisplayCondition_far = value.far;
            break;
          }
      }
    }
  }, {
    key: "_toOneJson_Point",
    value: function _toOneJson_Point(key, value, style) {
      switch (key) {
        default:
          // style[key] = value
          console.log("未处理的属性", value);
          break;

        case "label":
          break;

        case "color":
          {
            var color = Object(Util["getCesiumValue"])(value, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]);

            if (color) {
              style.color = color.toCssColorString();
            }

            break;
          }

        case "heightReference":
          {
            if (value == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND) {
              style.clampToGround = true;
            }

            break;
          }

        case "disableDepthTestDistance":
          {
            if (value === Number.POSITIVE_INFINITY) {
              style.visibleDepth = false;
            } else {
              style.disableDepthTestDistance = value;
            }

            break;
          }

        case "scaleByDistance":
          {
            style.scaleByDistance = true;
            style.scaleByDistance_near = value.near;
            style.scaleByDistance_nearValue = value.nearValue;
            style.scaleByDistance_far = value.far;
            style.scaleByDistance_farValue = value.farValue;
            break;
          }

        case "distanceDisplayCondition":
          {
            style.distanceDisplayCondition = true;
            style.distanceDisplayCondition_near = value.near;
            style.distanceDisplayCondition_far = value.far;
            break;
          }
      }
    }
  }]);

  return BaseStyleConver;
}(BaseOptsConver_BaseOptsConver);
// CONCATENATED MODULE: ./src/util/converStyle/BillboardStyleConver.js






function BillboardStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = BillboardStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BillboardStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var BillboardStyleConver_BillboardStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(BillboardStyleConver, _BaseStyleConver);

  var _super = BillboardStyleConver_createSuper(BillboardStyleConver);

  function BillboardStyleConver() {
    classCallCheck_default()(this, BillboardStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(BillboardStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      czmVal.horizontalOrigin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](czmVal.horizontalOrigin, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER);
      czmVal.verticalOrigin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](czmVal.verticalOrigin, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].BOTTOM);
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);

          break;

        case "opacity":
          //透明度
          czmVal.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](value, 1.0));
          break;

        case "rotationDegree":
          //旋转角度 (度数)
          czmVal.rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;

        case "hasPixelOffset":
          //是否存在偏移量
          if (!value) {
            czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, 0);
          }

          break;

        case "pixelOffsetX": //偏移量

        case "pixelOffsetY":
          czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](style.pixelOffsetX || 0, style.pixelOffsetY || 0);
          break;

        case "pixelOffset":
          //偏移量
          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](value[0]) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](value[1])) {
            czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](value[0], value[1]);
          } else {
            czmVal.pixelOffset = value;
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Point(key, value, style);

          break;

        case "pixelOffset":
          {
            style.pixelOffsetX = value.x;
            style.pixelOffsetY = value.y;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.billboardStyleConver) {
        this.billboardStyleConver = new BillboardStyleConver();
      }

      this.billboardStyleConver.isEntity = isEntity;
      return this.billboardStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.billboardStyleConver) {
        this.billboardStyleConver = new BillboardStyleConver();
      }

      this.billboardStyleConver.isEntity = isEntity;
      return this.billboardStyleConver.toJSON(czmVal, style);
    }
  }]);

  return BillboardStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/BoxStyleConver.js






function BoxStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = BoxStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BoxStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var BoxStyleConver_BoxStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(BoxStyleConver, _BaseStyleConver);

  var _super = BoxStyleConver_createSuper(BoxStyleConver);

  function BoxStyleConver() {
    classCallCheck_default()(this, BoxStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(BoxStyleConver, [{
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return ["opacity", "dimensions_y", "dimensions_z", "color"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "outlineColor":
          {
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }

        case "dimensions_x":
          {
            //盒子的长宽高
            var dimensions_x = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.dimensions_x, 100.0);
            var dimensions_y = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.dimensions_y, 100.0);
            var dimensions_z = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.dimensions_z, 100.0);
            czmVal.dimensions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](dimensions_x, dimensions_y, dimensions_z);
            break;
          }
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "dimensions":
          {
            //盒子的长宽高
            style.dimensions_x = value.x;
            style.dimensions_y = value.y;
            style.dimensions_z = value.z;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.boxStyleConver) {
        this.boxStyleConver = new BoxStyleConver();
      }

      this.boxStyleConver.isEntity = isEntity;
      return this.boxStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.boxStyleConver) {
        this.boxStyleConver = new BoxStyleConver();
      }

      this.boxStyleConver.isEntity = isEntity;
      return this.boxStyleConver.toJSON(czmVal, style);
    }
  }]);

  return BoxStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/CircleStyleConver.js







function CircleStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = CircleStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CircleStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var CircleStyleConver_CircleStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(CircleStyleConver, _BaseStyleConver);

  var _super = CircleStyleConver_createSuper(CircleStyleConver);

  function CircleStyleConver() {
    classCallCheck_default()(this, CircleStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(CircleStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(CircleStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //圆 的特殊处理


      if (style.clampToGround) {
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }

        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }

        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
        style.clampToGround = false;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "rotation":
          //旋转角度 (弧度)
          czmVal.rotation = value;

          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }

          break;

        case "rotationDegree":
          //旋转角度 (度数)
          czmVal.rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);

          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }

          break;

        case "stRotationDegree":
          //(度数)
          czmVal.stRotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;

        case "height":
          czmVal.height = value;

          if (style.diffHeight) {
            czmVal.extrudedHeight = Number(style.diffHeight) + Number(value);
          }

          break;

        case "diffHeight":
          if (value > 0 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }

          break;

        case "radius":
          //半径（圆）
          if (this.isEntity) {
            czmVal.semiMinorAxis = Number(value);
            czmVal.semiMajorAxis = Number(value);
          } else {
            czmVal.radius = Number(value);
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "rotation":
          {
            style.rotationDegree = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(value), 1);
            break;
          }

        case "stRotation":
          {
            style.stRotationDegree = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(value), 1);
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.circleStyleConver) {
        this.circleStyleConver = new CircleStyleConver();
      }

      this.circleStyleConver.isEntity = isEntity;
      return this.circleStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.circleStyleConver) {
        this.circleStyleConver = new CircleStyleConver();
      }

      this.circleStyleConver.isEntity = isEntity;
      return this.circleStyleConver.toJSON(czmVal, style);
    }
  }]);

  return CircleStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/CorridorStyleConver.js







function CorridorStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = CorridorStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CorridorStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var CorridorStyleConver_CorridorStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(CorridorStyleConver, _BaseStyleConver);

  var _super = CorridorStyleConver_createSuper(CorridorStyleConver);

  function CorridorStyleConver() {
    classCallCheck_default()(this, CorridorStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(CorridorStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(CorridorStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理


      if (style.clampToGround) {
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }

        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }

        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "outlineColor":
          {
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }

        case "height":
          czmVal.height = value;

          if (style.diffHeight) {
            czmVal.extrudedHeight = Number(style.diffHeight) + Number(value);
          }

          break;

        case "diffHeight":
          if (value > 0 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.corridorStyleConver) {
        this.corridorStyleConver = new CorridorStyleConver();
      }

      this.corridorStyleConver.isEntity = isEntity;
      return this.corridorStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.corridorStyleConver) {
        this.corridorStyleConver = new CorridorStyleConver();
      }

      this.corridorStyleConver.isEntity = isEntity;
      return this.corridorStyleConver.toJSON(czmVal, style);
    }
  }]);

  return CorridorStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/CylinderStyleConver.js







function CylinderStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = CylinderStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CylinderStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var CylinderStyleConver_CylinderStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(CylinderStyleConver, _BaseStyleConver);

  var _super = CylinderStyleConver_createSuper(CylinderStyleConver);

  function CylinderStyleConver() {
    classCallCheck_default()(this, CylinderStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(CylinderStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(CylinderStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理


      if (!style.topRadius) {
        style.topRadius = 0;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "diffHeight":
          //高度
          if (czmVal.length instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {//回调时不覆盖
          } else {
            czmVal.length = Number(value);
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.cylinderStyleConver) {
        this.cylinderStyleConver = new CylinderStyleConver();
      }

      this.cylinderStyleConver.isEntity = isEntity;
      return this.cylinderStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.cylinderStyleConver) {
        this.cylinderStyleConver = new CylinderStyleConver();
      }

      this.cylinderStyleConver.isEntity = isEntity;
      return this.cylinderStyleConver.toJSON(czmVal, style);
    }
  }]);

  return CylinderStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/DivGraphicStyleConver.js






function DivGraphicStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = DivGraphicStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivGraphicStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var DivGraphicStyleConver_DivGraphicStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(DivGraphicStyleConver, _BaseStyleConver);

  var _super = DivGraphicStyleConver_createSuper(DivGraphicStyleConver);

  function DivGraphicStyleConver() {
    classCallCheck_default()(this, DivGraphicStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(DivGraphicStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {//覆盖父类
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Point(key, value, style, czmVal);
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Point(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal) {
      if (!this.divGraphicStyleConver) {
        this.divGraphicStyleConver = new DivGraphicStyleConver();
      }

      return this.divGraphicStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      if (!this.divGraphicStyleConver) {
        this.divGraphicStyleConver = new DivGraphicStyleConver();
      }

      return this.divGraphicStyleConver.toJSON(czmVal, style);
    }
  }]);

  return DivGraphicStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/EllipsoidStyleConver.js







function EllipsoidStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = EllipsoidStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipsoidStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var EllipsoidStyleConver_EllipsoidStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(EllipsoidStyleConver, _BaseStyleConver);

  var _super = EllipsoidStyleConver_createSuper(EllipsoidStyleConver);

  function EllipsoidStyleConver() {
    classCallCheck_default()(this, EllipsoidStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(EllipsoidStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(EllipsoidStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理

    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return ["radii_y", "radii_z", "innerRadii_y", "innerRadii_z", "color"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "radii":
          czmVal.radii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](value, value, value);
          break;

        case "radii_x":
          //球体 长宽高半径
          czmVal.radii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.radii_x, 100), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.radii_y, 100), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.radii_z, 100));
          break;

        case "innerRadii":
          czmVal.innerRadii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](value, value, value);
          break;

        case "innerRadii_x":
          //球体内圈 长宽高半径
          if (style.innerRadii_x > 0 && style.innerRadii_y > 0 && style.innerRadii_z > 0) {
            czmVal.innerRadii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.innerRadii_x, 0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.innerRadii_y, 0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.innerRadii_z, 0));
          } else {
            czmVal.innerRadii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0.001, 0.001, 0.001);
          }

          break;

        case "minimumClockDegree": //（度数值，0-360度）

        case "maximumClockDegree":
        case "minimumConeDegree":
        case "maximumConeDegree":
          czmVal[key.replace("Degree", "")] = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value || 0);
          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "radii":
          {
            style.radii_x = value.x;
            style.radii_y = value.y;
            style.radii_z = value.z;
            break;
          }

        case "innerRadii":
          {
            style.innerRadii_x = value.x;
            style.innerRadii_y = value.y;
            style.innerRadii_z = value.z;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.ellipsoidStyleConver) {
        this.ellipsoidStyleConver = new EllipsoidStyleConver();
      }

      this.ellipsoidStyleConver.isEntity = isEntity;
      return this.ellipsoidStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.ellipsoidStyleConver) {
        this.ellipsoidStyleConver = new EllipsoidStyleConver();
      }

      this.ellipsoidStyleConver.isEntity = isEntity;
      return this.ellipsoidStyleConver.toJSON(czmVal, style);
    }
  }]);

  return EllipsoidStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/LabelStyleConver.js






function LabelStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = LabelStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LabelStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var LabelStyleConver_LabelStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(LabelStyleConver, _BaseStyleConver);

  var _super = LabelStyleConver_createSuper(LabelStyleConver);

  function LabelStyleConver() {
    classCallCheck_default()(this, LabelStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(LabelStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      czmVal.horizontalOrigin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](czmVal.horizontalOrigin, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER);
      czmVal.verticalOrigin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](czmVal.verticalOrigin, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].BOTTOM);
    }
  }, {
    key: "_toCesiumValEnd",
    value: function _toCesiumValEnd(style, czmVal) {
      //样式（倾斜、加粗等）
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.font)) {
        var fontStyle = (style.font_style || "normal") + " small-caps " + (style.font_weight || "normal") + " " + (style.font_size || "18") + "px " + (style.font_family || "楷体");
        czmVal.font = fontStyle;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.style) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.fill, true)) {
        if (style.outline) {
          czmVal.style = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelStyle"].FILL_AND_OUTLINE;
        } else {
          czmVal.style = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelStyle"].FILL;
        }
      }
    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return ["font_style", "font_weight", "font_size", "font_family", "backgroundOpacity", "fill", "outline"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);

          break;

        case "text":
          {
            if (this.attr) {
              value = Object(Util["template"])(value, this.attr, true);
            }

            czmVal.text = value.replace(new RegExp("<br />", "gm"), "\n");
            break;
          }

        case "color":
          {
            //颜色
            czmVal.fillColor = this.getColorByStyle(style);
            break;
          }

        case "outlineColor":
          {
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }

        case "strokeColor":
        case "fillColor":
          {
            czmVal[key] = Object(Util["getCesiumColor"])(value);
            break;
          }

        case "background":
          //是否背景色
          czmVal.showBackground = value;
          break;

        case "backgroundColor":
          {
            //背景色
            var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(value || "#000000");

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.backgroundOpacity)) {
              color = color.withAlpha(Number(style.backgroundOpacity));
            } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.opacity)) {
              color = color.withAlpha(Number(style.opacity));
            }

            czmVal.backgroundColor = color;
            break;
          }

        case "backgroundPadding":
          czmVal.backgroundPadding = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](value * 1.2, value);
          break;

        case "hasPixelOffset":
          //是否存在偏移量
          if (!value) {
            czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, 0);
          }

          break;

        case "pixelOffsetX": //偏移量

        case "pixelOffsetY":
          czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](style.pixelOffsetX || 0, style.pixelOffsetY || 0);
          break;

        case "pixelOffset":
          //偏移量
          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](value[0]) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](value[1])) {
            czmVal.pixelOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](value[0], value[1]);
          } else {
            czmVal.pixelOffset = value;
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Point(key, value, style);

          break;

        case "pixelOffset":
          {
            style.pixelOffsetX = value.x;
            style.pixelOffsetY = value.y;
            break;
          }

        case "disableDepthTestDistance":
          {
            if (value === Number.POSITIVE_INFINITY) {
              style.visibleDepth = false;
            } else {
              style.disableDepthTestDistance = value;
            }

            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, attr) {
      if (!this.labelStyleConver) {
        this.labelStyleConver = new LabelStyleConver();
      }

      this.labelStyleConver.attr = attr;
      czmVal = this.labelStyleConver.toCesiumVal(style, czmVal);
      return czmVal;
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      if (!this.labelStyleConver) {
        this.labelStyleConver = new LabelStyleConver();
      }

      return this.labelStyleConver.toJSON(czmVal, style);
    }
  }]);

  return LabelStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/ModelStyleConver.js






function ModelStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = ModelStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var ModelStyleConver_ModelStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(ModelStyleConver, _BaseStyleConver);

  var _super = ModelStyleConver_createSuper(ModelStyleConver);

  function ModelStyleConver() {
    classCallCheck_default()(this, ModelStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(ModelStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {//覆盖父类
    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return ["silhouette", "silhouetteColor", "silhouetteAlpha", "silhouetteSize", "fill", "color", "opacity"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);

          break;

        case "url": //模型uri

        case "modelUrl":
        case "uri":
          if (this.isEntity) {
            czmVal.uri = value;
          } else {
            czmVal.url = value;
          }

          break;
      }
    }
  }, {
    key: "_toCesiumValEnd",
    value: function _toCesiumValEnd(style, czmVal) {
      //轮廓
      if (style.silhouette) {
        if (Object(Util["isString"])(style.silhouetteColor)) {
          czmVal.silhouetteColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(style.silhouetteColor || "#FFFFFF").withAlpha(Number(style.silhouetteAlpha || 1.0));
        } else {
          czmVal.silhouetteColor = style.silhouetteColor;
        }

        czmVal.silhouetteSize = Number(style.silhouetteSize || 1.0);
      } else {
        czmVal.silhouetteSize = 0.0;
      } //透明度、颜色


      var opacity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.opacity, 1);

      if (style.fill) {
        if (Object(Util["isString"])(style.color)) {
          czmVal.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(style.color || "#FFFFFF").withAlpha(opacity);
        } else {
          czmVal.color = style.color;
        }
      } else {
        czmVal.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(opacity);
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Point(key, value, style);

          break;

        case "uri":
          {
            style.url = value;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.modelStyleConver) {
        this.modelStyleConver = new ModelStyleConver();
      }

      this.modelStyleConver.isEntity = isEntity;
      return this.modelStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.modelStyleConver) {
        this.modelStyleConver = new ModelStyleConver();
      }

      this.modelStyleConver.isEntity = isEntity;
      return this.modelStyleConver.toJSON(czmVal, style);
    }
  }]);

  return ModelStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PathStyleConver.js






function PathStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PathStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PathStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var PathStyleConver_PathStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PathStyleConver, _BaseStyleConver);

  var _super = PathStyleConver_createSuper(PathStyleConver);

  function PathStyleConver() {
    classCallCheck_default()(this, PathStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PathStyleConver, [{
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.pathStyleConver) {
        this.pathStyleConver = new PathStyleConver();
      }

      this.pathStyleConver.isEntity = isEntity;
      return this.pathStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.pathStyleConver) {
        this.pathStyleConver = new PathStyleConver();
      }

      this.pathStyleConver.isEntity = isEntity;
      return this.pathStyleConver.toJSON(czmVal, style);
    }
  }]);

  return PathStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PlaneStyleConver.js







function PlaneStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PlaneStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PlaneStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var PlaneStyleConver_PlaneStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PlaneStyleConver, _BaseStyleConver);

  var _super = PlaneStyleConver_createSuper(PlaneStyleConver);

  function PlaneStyleConver() {
    classCallCheck_default()(this, PlaneStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PlaneStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(PlaneStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理

    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "dimensions_x":
          {
            //平面的长宽
            var dimensions_x = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.dimensions_x, 100.0);
            var dimensions_y = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.dimensions_y, 100.0);
            czmVal.dimensions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](dimensions_x, dimensions_y);
            break;
          }

        case "plane_normal":
          {
            //平面的方向及距离
            var plane_normal;

            switch (value) {
              default:
                plane_normal = value;
                break;

              case "x":
                plane_normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_X;
                break;

              case "y":
                plane_normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Y;
                break;

              case "z":
                plane_normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z;
                break;
            }

            var plane_distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.plane_distance, 0.0);
            czmVal.plane = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Plane"](plane_normal, plane_distance);
            break;
          }
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "dimensions":
          {
            style.dimensions_x = value.x;
            style.dimensions_y = value.y;
            break;
          }

        case "plane":
          {
            if (value.normal.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_X)) {
              style.plane_normal = "x";
            } else if (value.normal.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Y)) {
              style.plane_normal = "y";
            } else if (value.normal.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z)) {
              style.plane_normal = "z";
            } else {
              Object(Log["logWarn"])("plane类型未识别", value);
              style.plane_normal = "z";
            }

            style.plane_distance = value.distance;
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }

      this.planeStyleConver.isEntity = isEntity;
      return this.planeStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }

      this.planeStyleConver.isEntity = isEntity;
      return this.planeStyleConver.toJSON(czmVal, style);
    }
  }, {
    key: "toOneJson",
    value: function toOneJson(key, value, style) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }

      return this.planeStyleConver._toOneJson(key, value, style);
    }
  }]);

  return PlaneStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PointStyleConver.js






function PointStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PointStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PointStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PointStyleConver_PointStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PointStyleConver, _BaseStyleConver);

  var _super = PointStyleConver_createSuper(PointStyleConver);

  function PointStyleConver() {
    classCallCheck_default()(this, PointStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PointStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      //覆盖父类
      czmVal.pixelSize = 6; //默认值
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);

          break;

        case "color":
        case "randomColor":
          {
            //填充颜色
            czmVal.color = this.getColorByStyle(style);
            break;
          }

        case "outlineColor":
          {
            //边框颜色
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Point(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.pointStyleConver) {
        this.pointStyleConver = new PointStyleConver();
      }

      this.pointStyleConver.isEntity = isEntity;
      return this.pointStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.pointStyleConver) {
        this.pointStyleConver = new PointStyleConver();
      }

      this.pointStyleConver.isEntity = isEntity;
      return this.pointStyleConver.toJSON(czmVal, style);
    }
  }]);

  return PointStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PolygonStyleConver.js







function PolygonStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PolygonStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolygonStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PolygonStyleConver_PolygonStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PolygonStyleConver, _BaseStyleConver);

  var _super = PolygonStyleConver_createSuper(PolygonStyleConver);

  function PolygonStyleConver() {
    classCallCheck_default()(this, PolygonStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolygonStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(PolygonStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal);

      if (!this.isEntity && style.materialType == "Color") {
        delete style.materialType;
      } //面的特殊处理


      if (style.clampToGround) {
        czmVal.arcType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcType"].GEODESIC;
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
        style.clampToGround = false;
        czmVal.perPositionHeight = false;
      } else {
        style.clampToGround = false;
        czmVal.perPositionHeight = true;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "outlineColor":
          {
            czmVal.outlineColor = this.getOutlineColorByStyle(style);
            break;
          }

        case "height":
          {
            czmVal[key] = value;
            czmVal.perPositionHeight = false;
            break;
          }

        case "diffHeight":
          {
            if (value > 0 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
              czmVal.extrudedHeight = value + style.height;
            }

            break;
          }

        case "clampToGround":
          //贴地
          czmVal[key] = value;
          czmVal.perPositionHeight = !value && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height);
          break;

        case "stRotationDegree":
          //材质旋转角度(度数)
          czmVal.stRotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;
      }
    }
  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "stRotation":
          {
            style.stRotationDegree = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(value), 1);
            break;
          }
      }
    }
  }], [{
    key: "toCesiumVal",
    value:
    /**
     * style样式属性赋值到 entity
     *
     * @param {PolygonEntity.StyleOptions} style 样式
     * @param {Cesium.PolygonGraphics|null} entityGraphic 矢量数据对应的 Cesium内部对象
     * @param {Boolean} isEntity 是否为entity
     * @return {Cesium.PolygonGraphics} 矢量数据所需的Cesium内部对象
     * @function
     */
    function toCesiumVal(style, entityGraphic, isEntity) {
      if (!this.polygonStyleConver) {
        this.polygonStyleConver = new PolygonStyleConver();
      }

      this.polygonStyleConver.isEntity = isEntity;
      return this.polygonStyleConver.toCesiumVal(style, entityGraphic);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.polygonStyleConver) {
        this.polygonStyleConver = new PolygonStyleConver();
      }

      this.polygonStyleConver.isEntity = isEntity;
      return this.polygonStyleConver.toJSON(czmVal, style);
    }
  }]);

  return PolygonStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PolylineStyleConver.js







function PolylineStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PolylineStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PolylineStyleConver_PolylineStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PolylineStyleConver, _BaseStyleConver);

  var _super = PolylineStyleConver_createSuper(PolylineStyleConver);

  function PolylineStyleConver() {
    classCallCheck_default()(this, PolylineStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylineStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(PolylineStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理


      if (style.clampToGround) {
        czmVal.arcType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcType"].GEODESIC;
      }

      if (style.materialType == Color && style.outline && style.outlineColor) {
        style.materialType = PolylineOutline;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "distanceDisplayCondition":
          //是否按视距显示
          if (value) {
            czmVal.distanceDisplayCondition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayCondition"](Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_near, 0)), Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.distanceDisplayCondition_far, 100000)));
          } else {
            czmVal.distanceDisplayCondition = undefined;
          }

          break;

        case "depthFail":
          if (value) {
            czmVal.depthFailMaterial = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(style.depthFailColor || "#FFFF00").withAlpha(Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.depthFailOpacity, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.opacity, 0.9))));

            if (style.opacity == 1.0) {
              //不透明时，竟然不显示depthFailMaterial？！
              style.opacity = 0.9;
            }
          } else {
            czmVal.depthFailMaterial = undefined;
          }

          break;

        case "closure":
          //在primitive中
          if (!this.isEntity) {
            czmVal.loop = value;
          }

          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      switch (key) {
        default:
          this._toOneJson_Poly(key, value, style);

          break;

        case "loop":
          //在primitive中
          style.closure = value;
          break;
      }
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.polylineStyleConver) {
        this.polylineStyleConver = new PolylineStyleConver();
      }

      this.polylineStyleConver.isEntity = isEntity;
      return this.polylineStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.polylineStyleConver) {
        this.polylineStyleConver = new PolylineStyleConver();
      }

      this.polylineStyleConver.isEntity = isEntity;
      return this.polylineStyleConver.toJSON(czmVal, style);
    }
  }]);

  return PolylineStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/PolylineVolumeStyleConver.js






function PolylineVolumeStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = PolylineVolumeStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineVolumeStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PolylineVolumeStyleConver_PolylineVolumeStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(PolylineVolumeStyleConver, _BaseStyleConver);

  var _super = PolylineVolumeStyleConver_createSuper(PolylineVolumeStyleConver);

  function PolylineVolumeStyleConver() {
    classCallCheck_default()(this, PolylineVolumeStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylineVolumeStyleConver, [{
    key: "_toCesiumValEnd",
    value: function _toCesiumValEnd(style, czmVal) {
      var shape = style.shape || style.shapePositions;
      style.radius = style.radius || 10;

      switch (shape) {
        default:
          czmVal.shape = shape;
          break;

        case "pipeline":
          czmVal.shape = PolylineVolumeStyleConver.getCorridorShape1(style.radius); //（厚度固定为半径的1/3）

          break;

        case "circle":
          czmVal.shape = PolylineVolumeStyleConver.getCorridorShape2(style.radius);
          break;

        case "star":
          czmVal.shape = PolylineVolumeStyleConver.getCorridorShape3(style.radius);
          break;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    } //===================================
    //管道形状1【内空管道】 radius整个管道的外半径

  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.polylineVolumeStyleConver) {
        this.polylineVolumeStyleConver = new PolylineVolumeStyleConver();
      }

      this.polylineVolumeStyleConver.isEntity = isEntity;
      return this.polylineVolumeStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.polylineVolumeStyleConver) {
        this.polylineVolumeStyleConver = new PolylineVolumeStyleConver();
      }

      this.polylineVolumeStyleConver.isEntity = isEntity;
      return this.polylineVolumeStyleConver.toJSON(czmVal, style);
    }
  }, {
    key: "getCorridorShape1",
    value: function getCorridorShape1(radius) {
      var hd = radius / 3;
      var startAngle = 0;
      var endAngle = 360;
      var pss = [];

      for (var i = startAngle; i <= endAngle; i++) {
        var radians = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(i);
        pss.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](radius * Math.cos(radians), radius * Math.sin(radians)));
      }

      for (var _i = endAngle; _i >= startAngle; _i--) {
        var _radians = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(_i);

        pss.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]((radius - hd) * Math.cos(_radians), (radius - hd) * Math.sin(_radians)));
      }

      return pss;
    } //管道形状2【圆柱体】 radius整个管道的外半径

  }, {
    key: "getCorridorShape2",
    value: function getCorridorShape2(radius) {
      var startAngle = 0;
      var endAngle = 360;
      var pss = [];

      for (var i = startAngle; i <= endAngle; i++) {
        var radians = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(i);
        pss.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](radius * Math.cos(radians), radius * Math.sin(radians)));
      }

      return pss;
    } //管道形状3【星状】 radius整个管道的外半径 ,arms星角的个数（默认6个角）

  }, {
    key: "getCorridorShape3",
    value: function getCorridorShape3(radius) {
      var arms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
      var angle = Math.PI / arms;
      var length = 2 * arms;
      var pss = new Array(length);

      for (var i = 0; i < length; i++) {
        var r = i % 2 == 0 ? radius : radius / 3;
        pss[i] = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](Math.cos(i * angle) * r, Math.sin(i * angle) * r);
      }

      return pss;
    }
  }]);

  return PolylineVolumeStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/RectangleStyleConver.js







function RectangleStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = RectangleStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectangleStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var RectangleStyleConver_RectangleStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(RectangleStyleConver, _BaseStyleConver);

  var _super = RectangleStyleConver_createSuper(RectangleStyleConver);

  function RectangleStyleConver() {
    classCallCheck_default()(this, RectangleStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(RectangleStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(RectangleStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal);

      if (style.clampToGround) {
        //贴地时，剔除高度相关属性
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }

        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }

        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }
      } else {
        style.clampToGround = false;
        czmVal.height = 0;
      }
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "height":
          czmVal.height = value;

          if (style.diffHeight) {
            czmVal.diffHeight = Number(style.diffHeight) + Number(value);
          }

          break;

        case "diffHeight":
          if (value > 0 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }

          break;

        case "rotation":
          //旋转角度 (弧度)
          czmVal.rotation = value;

          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }

          break;

        case "rotationDegree":
          //旋转角度 (度数)
          czmVal.rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);

          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }

          break;

        case "stRotationDegree":
          //(度数)
          czmVal.stRotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.rectangleStyleConver) {
        this.rectangleStyleConver = new RectangleStyleConver();
      }

      this.rectangleStyleConver.isEntity = isEntity;
      return this.rectangleStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.rectangleStyleConver) {
        this.rectangleStyleConver = new RectangleStyleConver();
      }

      this.rectangleStyleConver.isEntity = isEntity;
      return this.rectangleStyleConver.toJSON(czmVal, style);
    }
  }]);

  return RectangleStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/RectangularSensorStyleConver.js







function RectangularSensorStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = RectangularSensorStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectangularSensorStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var RectangularSensorStyleConver_RectangularSensorStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(RectangularSensorStyleConver, _BaseStyleConver);

  var _super = RectangularSensorStyleConver_createSuper(RectangularSensorStyleConver);

  function RectangularSensorStyleConver() {
    classCallCheck_default()(this, RectangularSensorStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(RectangularSensorStyleConver, [{
    key: "_toCesiumValBefore",
    value: function _toCesiumValBefore(style, czmVal) {
      get_default()(getPrototypeOf_default()(RectangularSensorStyleConver.prototype), "_toCesiumValBefore", this).call(this, style, czmVal); //XX的特殊处理

    }
  }, {
    key: "_getExcludedStyle",
    value: function _getExcludedStyle() {
      return ["lineOpacity", "scanPlaneOpacity"];
    }
  }, {
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);

          break;

        case "lineColor":
          {
            //边框颜色
            var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(value || "#ffffff");

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.lineOpacity)) {
              color = color.withAlpha(Number(style.lineOpacity));
            } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.opacity)) {
              color = color.withAlpha(Number(style.opacity));
            }

            czmVal.lineColor = color;
            break;
          }

        case "scanPlaneColor":
          {
            //扫描面颜色
            var _color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(value || "#ffffff");

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.scanPlaneOpacity)) {
              _color = _color.withAlpha(Number(style.scanPlaneOpacity));
            } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.opacity)) {
              _color = _color.withAlpha(Number(style.opacity));
            }

            czmVal.scanPlaneColor = _color;
            break;
          }

        case "xHalfAngleDegree":
          //传感器水平半角(度数)
          czmVal.xHalfAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;

        case "yHalfAngleDegree":
          //传感器垂直半角(度数)
          czmVal.yHalfAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
          break;

        case "depthTest":
          czmVal.showThroughEllipsoid = !value;
          break;
      }
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal) {
      if (!this.rectangularSensorStyleConver) {
        this.rectangularSensorStyleConver = new RectangularSensorStyleConver();
      }

      this.rectangularSensorStyleConver.isEntity = true;
      return this.rectangularSensorStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style) {
      if (!this.rectangularSensorStyleConver) {
        this.rectangularSensorStyleConver = new RectangularSensorStyleConver();
      }

      this.rectangularSensorStyleConver.isEntity = true;
      return this.rectangularSensorStyleConver.toJSON(czmVal, style);
    }
  }]);

  return RectangularSensorStyleConver;
}(BaseStyleConver_BaseStyleConver);
// CONCATENATED MODULE: ./src/util/converStyle/WallStyleConver.js






function WallStyleConver_createSuper(Derived) { var hasNativeReflectConstruct = WallStyleConver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WallStyleConver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var WallStyleConver_WallStyleConver = /*#__PURE__*/function (_BaseStyleConver) {
  inherits_default()(WallStyleConver, _BaseStyleConver);

  var _super = WallStyleConver_createSuper(WallStyleConver);

  function WallStyleConver() {
    classCallCheck_default()(this, WallStyleConver);

    return _super.apply(this, arguments);
  }

  createClass_default()(WallStyleConver, [{
    key: "_toOneCesiumVal",
    value: function _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    } //导出Cesium的样式对象到json可以保存的格式

  }, {
    key: "_toOneJson",
    value: function _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }], [{
    key: "toCesiumVal",
    value: //转换style到Cesium对象需要的格式
    function toCesiumVal(style, czmVal, isEntity) {
      if (!this.wallStyleConver) {
        this.wallStyleConver = new WallStyleConver();
      }

      this.wallStyleConver.isEntity = isEntity;
      return this.wallStyleConver.toCesiumVal(style, czmVal);
    }
  }, {
    key: "toJSON",
    value: function toJSON(czmVal, style, isEntity) {
      if (!this.wallStyleConver) {
        this.wallStyleConver = new WallStyleConver();
      }

      this.wallStyleConver.isEntity = isEntity;
      return this.wallStyleConver.toJSON(czmVal, style);
    }
  }]);

  return WallStyleConver;
}(BaseStyleConver_BaseStyleConver);
// EXTERNAL MODULE: ./src/shaders/czm/cellular.glsl
var cellular = __webpack_require__(40);
var cellular_default = /*#__PURE__*/__webpack_require__.n(cellular);

// EXTERNAL MODULE: ./src/shaders/czm/snoise.glsl
var snoise = __webpack_require__(41);
var snoise_default = /*#__PURE__*/__webpack_require__.n(snoise);

// EXTERNAL MODULE: ./src/shaders/Materials/LineFlowMaterial.glsl
var LineFlowMaterial = __webpack_require__(42);
var LineFlowMaterial_default = /*#__PURE__*/__webpack_require__.n(LineFlowMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/LineFlowColorMaterial.glsl
var LineFlowColorMaterial = __webpack_require__(43);
var LineFlowColorMaterial_default = /*#__PURE__*/__webpack_require__.n(LineFlowColorMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ODLineMaterial.glsl
var ODLineMaterial = __webpack_require__(44);
var ODLineMaterial_default = /*#__PURE__*/__webpack_require__.n(ODLineMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/LineFlickerMaterial.glsl
var LineFlickerMaterial = __webpack_require__(45);
var LineFlickerMaterial_default = /*#__PURE__*/__webpack_require__.n(LineFlickerMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/LineTrailMaterial.glsl
var LineTrailMaterial = __webpack_require__(46);
var LineTrailMaterial_default = /*#__PURE__*/__webpack_require__.n(LineTrailMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/WallScrollMaterial.glsl
var WallScrollMaterial = __webpack_require__(47);
var WallScrollMaterial_default = /*#__PURE__*/__webpack_require__.n(WallScrollMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ScanLineMaterial.glsl
var ScanLineMaterial = __webpack_require__(48);
var ScanLineMaterial_default = /*#__PURE__*/__webpack_require__.n(ScanLineMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/CircleScanMaterial.glsl
var CircleScanMaterial = __webpack_require__(49);
var CircleScanMaterial_default = /*#__PURE__*/__webpack_require__.n(CircleScanMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/CircleWaveMaterial.glsl
var CircleWaveMaterial = __webpack_require__(50);
var CircleWaveMaterial_default = /*#__PURE__*/__webpack_require__.n(CircleWaveMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/RadarLineMaterial.glsl
var RadarLineMaterial = __webpack_require__(51);
var RadarLineMaterial_default = /*#__PURE__*/__webpack_require__.n(RadarLineMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/RadarWaveMaterial.glsl
var RadarWaveMaterial = __webpack_require__(52);
var RadarWaveMaterial_default = /*#__PURE__*/__webpack_require__.n(RadarWaveMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/RectSlideMaterial.glsl
var RectSlideMaterial = __webpack_require__(53);
var RectSlideMaterial_default = /*#__PURE__*/__webpack_require__.n(RectSlideMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/EllipsoidElectricMaterial.glsl
var EllipsoidElectricMaterial = __webpack_require__(54);
var EllipsoidElectricMaterial_default = /*#__PURE__*/__webpack_require__.n(EllipsoidElectricMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/EllipsoidWaveMaterial.glsl
var EllipsoidWaveMaterial = __webpack_require__(55);
var EllipsoidWaveMaterial_default = /*#__PURE__*/__webpack_require__.n(EllipsoidWaveMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyGradientMaterial.glsl
var PolyGradientMaterial = __webpack_require__(56);
var PolyGradientMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyGradientMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyAsphaltMaterial.glsl
var PolyAsphaltMaterial = __webpack_require__(57);
var PolyAsphaltMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyAsphaltMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyBlobMaterial.glsl
var PolyBlobMaterial = __webpack_require__(58);
var PolyBlobMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyBlobMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyFacetMaterial.glsl
var PolyFacetMaterial = __webpack_require__(59);
var PolyFacetMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyFacetMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyGrassMaterial.glsl
var PolyGrassMaterial = __webpack_require__(60);
var PolyGrassMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyGrassMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/PolyWoodMaterial.glsl
var PolyWoodMaterial = __webpack_require__(61);
var PolyWoodMaterial_default = /*#__PURE__*/__webpack_require__.n(PolyWoodMaterial);

// CONCATENATED MODULE: ./src/material/type/addMaterial.js

 ////////////////////////////////////////////////////////////////////////////


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderSource"]._czmBuiltinsAndUniforms.czm_cellular = cellular_default.a;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderSource"]._czmBuiltinsAndUniforms.czm_snoise = snoise_default.a; /////////////////////////////////line线状//////////////////////////////////////


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowType = LineFlow;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowType,
    uniforms: {
      image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId,
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 0, 0, 1.0),
      repeat: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](1.0, 1.0),
      axisY: false,
      speed: 10.0,
      hasImage2: false,
      image2: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId,
      color2: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 1, 1)
    },
    source: LineFlowMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowColorType = LineFlowColor;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowColorType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlowColorType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0, 0.7),
      startTime: 0,
      speed: 2,
      percent: 0.04,
      alpha: 0.1
    },
    source: LineFlowColorMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ODLineType = ODLine;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ODLineType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ODLineType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 0.7),
      startTime: 0,
      speed: 20,
      bgColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 0.1),
      bidirectional: 0 // 运行形式：0 正向运动 1 反向运动 2 双向运动

    },
    source: ODLineMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlickerType = LineFlicker;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlickerType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineFlickerType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0, 0.7),
      speed: 10
    },
    source: LineFlickerMaterial_default.a
  },
  translucent: function translucent(material) {
    return true;
  }
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineTrailType = LineTrail;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineTrailType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].LineTrailType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0, 0.7),
      image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId,
      //没有用
      speed: 5.0
    },
    source: LineTrailMaterial_default.a
  },
  translucent: function translucent(material) {
    return true;
  }
}); //////////////////////////////////////wall墙体//////////////////////////////////////



external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].WallScrollType = WallScroll;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].WallScrollType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].WallScrollType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0, 0.7),
      image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId,
      count: 1,
      speed: 5.0
    },
    source: WallScrollMaterial_default.a
  },
  translucent: function translucent(material) {
    return true;
  }
}); //////////////////////////////////////circle圆形//////////////////////////////////////



external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ScanLineType = ScanLine;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ScanLineType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ScanLineType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 1.0),
      speed: 10
    },
    source: ScanLineMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleScanType = CircleScan;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleScanType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleScanType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0, 1.0),
      image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId
    },
    source: CircleScanMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleWaveType = CircleWave;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleWaveType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].CircleWaveType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 1.0),
      speed: 10.0,
      count: 1.0,
      gradient: 0.1
    },
    source: CircleWaveMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarLineType = RadarLine;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarLineType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarLineType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0.7),
      speed: 5.0
    },
    source: RadarLineMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarWaveType = RadarWave;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarWaveType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RadarWaveType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0.7),
      speed: 5.0
    },
    source: RadarWaveMaterial_default.a
  },
  translucent: true
}); ///////////////////////////////////矩形面/////////////////////////////////////////



external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RectSlideType = RectSlide;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RectSlideType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].RectSlideType,
    uniforms: {
      image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId,
      color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE,
      speed: 10.0,
      pure: false,
      diffusePower: 1.3 //不公开

    },
    source: RectSlideMaterial_default.a
  },
  translucent: true
}); ///////////////////////////////////球/////////////////////////////////////////



external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidElectricType = EllipsoidElectric;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidElectricType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidElectricType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0.7),
      speed: 5.0
    },
    source: EllipsoidElectricMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidWaveType = EllipsoidWave;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidWaveType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].EllipsoidWaveType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0.7),
      speed: 5.0
    },
    source: EllipsoidWaveMaterial_default.a
  },
  translucent: true
}); ///////////////////////////////////polygon面/////////////////////////////////////////



external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGradientType = PolyGradient;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGradientType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGradientType,
    uniforms: {
      color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 0.5),
      diffusePower: 1.6,
      alphaPower: 1.5
    },
    source: PolyGradientMaterial_default.a
  },
  translucent: true
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyAsphaltType = PolyAsphalt;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyAsphaltType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyAsphaltType,
    uniforms: {
      asphaltColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.15, 0.15, 0.15, 1.0),
      bumpSize: 0.02,
      roughness: 0.2
    },
    source: PolyAsphaltMaterial_default.a
  },
  translucent: function translucent(material) {
    return material.uniforms.asphaltColor.alpha < 1.0;
  }
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyBlobType = PolyBlob;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyBlobType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyBlobType,
    uniforms: {
      lightColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.5),
      darkColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 1.0, 0.5),
      frequency: 10.0
    },
    source: PolyBlobMaterial_default.a
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 0.0;
  }
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyFacetType = PolyFacet;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyFacetType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyFacetType,
    uniforms: {
      lightColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.25, 0.25, 0.25, 0.75),
      darkColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.75, 0.75, 0.75, 0.75),
      frequency: 10.0
    },
    source: PolyFacetMaterial_default.a
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 0.0;
  }
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGrassType = PolyGrass;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGrassType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyGrassType,
    uniforms: {
      grassColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.25, 0.4, 0.1, 1.0),
      dirtColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.1, 0.1, 0.1, 1.0),
      patchiness: 1.5
    },
    source: PolyGrassMaterial_default.a
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.grassColor.alpha < 1.0 || uniforms.dirtColor.alpha < 1.0;
  }
});


external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyWoodType = PolyWood;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]._materialCache.addMaterial(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyWoodType, {
  fabric: {
    type: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].PolyWoodType,
    uniforms: {
      lightWoodColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.6, 0.3, 0.1, 1.0),
      darkWoodColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.4, 0.2, 0.07, 1.0),
      ringFrequency: 3.0,
      noiseScale: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0.7, 0.5),
      grainFrequency: 27.0
    },
    source: PolyWoodMaterial_default.a
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightWoodColor.alpha < 1.0 || uniforms.darkWoodColor.alpha < 1.0;
  }
});
// CONCATENATED MODULE: ./src/material/type/TextMaterial.js





function TextMaterial_createSuper(Derived) { var hasNativeReflectConstruct = TextMaterial_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TextMaterial_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 文字贴图 primitive材质
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String} [options.text] 文本内容
 *
 * @param {String} [options.font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体,
 * @param {Number} [options.font_size = 30] 字体大小
 * @param {String} [options.font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
 * @param {String} [options.font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
 * @param {string} [options.font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
 *
 * @param {Color} [options.fillColor=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 填充颜色。
 * @param {Boolean} [options.stroke=true] 是否描边文本。
 * @param {Color} [options.strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
 * @param {Number} [options.strokeWidth=2] 描边的宽度。
 * @param {Color} [options.backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
 * @param {Number} [options.padding=10] 要在文本周围添加的填充的像素大小。
 * @param {String} [options.textBaseline='top'] 文本的基线。
 *
 * @export
 * @class TextMaterial
 * @extends {Cesium.Material}
 * @example
var primitive = new tudou3d.graphic.WallPrimitive({
  positions: [
    [121.479343, 29.791419, 25],
    [121.479197, 29.791474, 25],
  ],
  style: {
    diffHeight: 5,
    material: new tudou3d.material.TextMaterial({
      text: '土豆数据',
      font: '60px 楷体',
      fill: true,
      fillColor: Cesium.Color.YELLOW,
      backgroundColor: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
      textBaseline: 'middle',
      padding: 10,
    }),
  },
})
graphicLayer.addGraphic(primitive)
 */

var TextMaterial_TextMaterial = /*#__PURE__*/function (_Cesium$Material) {
  inherits_default()(TextMaterial, _Cesium$Material);

  var _super = TextMaterial_createSuper(TextMaterial);

  function TextMaterial() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TextMaterial);

    return _super.call(this, conventOptions(options));
  }

  return TextMaterial;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]);

function conventOptions(options) {
  var _text = options.text;

  var _textStyles = LabelStyleConver_LabelStyleConver.toCesiumVal(options, {
    font: "23px 楷体",
    fill: true,
    fillColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 1.0),
    stroke: true,
    strokeWidth: 2,
    strokeColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.8),
    backgroundColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.1),
    textBaseline: "top",
    padding: 10
  });

  var image = Object(Util["getTextImage"])(_text, _textStyles);
  return {
    fabric: {
      uniforms: {
        image: image,
        repeat: options.repeat || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](1.0, 1.0),
        color: options.color || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 1.0)
      },
      components: {
        diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb",
        alpha: "texture2D(image, fract(repeat * materialInput.st)).a * color.a"
      }
    },
    translucent: function translucent(material) {
      return material.uniforms.color.alpha < 1.0;
    }
  };
}

register(Text, TextMaterial_TextMaterial);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(24);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// CONCATENATED MODULE: ./src/material/type/CylinderWaveMaterial.js








function CylinderWaveMaterial_createSuper(Derived) { var hasNativeReflectConstruct = CylinderWaveMaterial_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CylinderWaveMaterial_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 圆锥 波纹扩散效果 材质
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color} [options.color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
 * @param {Number} [options.repeat=30] 圈数量
 * @param {Number} [options.frameRate=60] 每秒刷新次数
 *
 * @export
 * @class CylinderWaveMaterial
 * @extends {Cesium.Material}
 * @example
var primitive = new tudou3d.graphic.CylinderPrimitive({
  position: [116.328775, 30.954602, 5000],
  style: {
    topRadius: 0.0,
    bottomRadius: 1500.0,
    length: 10000.0,
    material: new tudou3d.material.CylinderWaveMaterial({
      color: 'rgba(255,0,0,0.7)',
      repeat: 30.0,
    }),
    faceForward: false,
    closed: true,
  },
})
graphicLayer.addGraphic(primitive)
 */

var CylinderWaveMaterial_CylinderWaveMaterial = /*#__PURE__*/function (_Cesium$Material) {
  inherits_default()(CylinderWaveMaterial, _Cesium$Material);

  var _super = CylinderWaveMaterial_createSuper(CylinderWaveMaterial);

  function CylinderWaveMaterial() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CylinderWaveMaterial);

    _this = _super.call(this, CylinderWaveMaterial_conventOptions(options)); //每秒刷新次数，因为requestAnimationFrame固定每秒60次的渲染，所以如果不想这么快，就把该数值调小一些

    _this.frameTime = 1000 / (options.frameRate || 60); // 动态修改雷达材质中的offset变量，从而实现动态效果。

    var that = assertThisInitialized_default()(_this);

    var then = Date.now();

    (function frame() {
      that.animateFrame = window.requestAnimationFrame(frame);
      var now = Date.now();
      var delta = now - then;

      if (delta > that.frameTime) {
        then = now - delta % that.frameTime;
        that.updateOffset(); //按帧率执行
      }
    })();

    return _this;
  } // 动态修改雷达材质中的offset变量，从而实现动态效果。


  createClass_default()(CylinderWaveMaterial, [{
    key: "updateOffset",
    value: function updateOffset() {
      var offset = this.uniforms.offset;
      offset -= 0.001;

      if (offset > 1.0) {
        offset = 0.0;
      }

      this.uniforms.offset = offset; // map.scene.preUpdate.addEventListener(function () {
      //     var offset = radar.appearance.material.uniforms.offset;
      //     offset -= 0.001;
      //     if (offset > 1.0) {
      //         offset = 0.0;
      //     }
      //     radar.appearance.material.uniforms.offset = offset;
      // });
    }
  }, {
    key: "destroy",
    value: function destroy(noDel) {
      window.cancelAnimationFrame(this.animateFrame);
      delete this.animateFrame;
      return get_default()(getPrototypeOf_default()(CylinderWaveMaterial.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return CylinderWaveMaterial;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]);

function CylinderWaveMaterial_conventOptions(options) {
  return {
    fabric: {
      uniforms: {
        color: Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](2, 1, 0.0, 0.8)),
        repeat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.repeat, 30.0),
        offset: 0.0,
        thickness: 0.3
      },
      source: " uniform vec4 color;\n                uniform float repeat;\n                uniform float offset;\n                uniform float thickness;\n                czm_material czm_getMaterial(czm_materialInput materialInput)\n                {\n                    czm_material material = czm_getDefaultMaterial(materialInput);\n                    float sp = 1.0/repeat;\n                    vec2 st = materialInput.st;\n                    float dis = distance(st, vec2(0.5));\n                    float m = mod(dis + offset, sp);\n                    float a = step(sp*(1.0-thickness), m);\n                    material.diffuse = color.rgb;\n                    material.alpha = a * color.a;\n                    return material;\n                }  "
    },
    translucent: function translucent(material) {
      return material.uniforms.color.alpha < 1.0;
    }
  };
}

register(CylinderWave, CylinderWaveMaterial_CylinderWaveMaterial);
// CONCATENATED MODULE: ./src/material/property/addProperty.js



registerProperty(Color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"]);
registerProperty(MaterialType_Image, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ImageMaterialProperty"]);
registerProperty(PolylineArrow, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineArrowMaterialProperty"]);
registerProperty(PolylineOutline, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineOutlineMaterialProperty"]);
registerProperty(PolylineDash, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineDashMaterialProperty"]);
registerProperty(PolylineGlow, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineGlowMaterialProperty"]);
registerProperty(Grid, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GridMaterialProperty"]);
registerProperty(Checkerboard, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CheckerboardMaterialProperty"]);
registerProperty(Stripe, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["StripeMaterialProperty"]);
// CONCATENATED MODULE: ./src/material/property/BaseMaterialProperty.js



/**
 * 材质属性(Entity使用) 基础类
 *
 * @param {Object} options 参数对象
 *
 * @export
 * @class BaseMaterialProperty
 */

var BaseMaterialProperty_BaseMaterialProperty = /*#__PURE__*/function () {
  function BaseMaterialProperty() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseMaterialProperty);

    this.options = options;
    this._definitionChanged = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Event"]();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._speed = undefined;
    this._speedSubscription = undefined;
  }

  createClass_default()(BaseMaterialProperty, [{
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */

  }, {
    key: "getType",
    value: function getType(time) {
      return null;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      result = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](result, {});
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other;
    }
  }]);

  return BaseMaterialProperty;
}();
// CONCATENATED MODULE: ./src/material/property/CircleScanMaterialProperty.js






function CircleScanMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = CircleScanMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CircleScanMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 圆形扫描效果 材质属性
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String} options.image 背景图片URL
 * @param {String|Cesium.Color} [options.color= new Cesium.Color(1, 0, 0, 0.5))] 颜色
 *
 * @export
 * @class CircleScanMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var CircleScanMaterialProperty_CircleScanMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(CircleScanMaterialProperty, _BaseMaterialProperty);

  var _super = CircleScanMaterialProperty_createSuper(CircleScanMaterialProperty);

  //========== 构造方法 ==========
  function CircleScanMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CircleScanMaterialProperty);

    _this = _super.call(this, options);
    _this._image = options.image || options.url; //背景图片

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 0, 0, 0.5)); //颜色

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(CircleScanMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return CircleScan;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.image = this._image;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof CircleScanMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._image == other._image;
    }
  }]);

  return CircleScanMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty); //属性

Object.defineProperties(CircleScanMaterialProperty_CircleScanMaterialProperty.prototype, {
  /**
   * 颜色
   * @type { Cesium.Color}
   * @memberof CircleScanMaterialProperty.prototype
   */
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color"),

  /**
   * 背景图片URL
   * @type {String}
   * @memberof CircleScanMaterialProperty.prototype
   */
  image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("image")
});
registerProperty(CircleScan, CircleScanMaterialProperty_CircleScanMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/CircleWaveMaterialProperty.js






function CircleWaveMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = CircleWaveMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CircleWaveMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 圆形扩散波纹效果 材质属性
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color} [options.color= Cesium.Color.YELLOW] 颜色
 * @param {Number} [options.speed=10] 速度
 * @param {Number} [options.count=1] 圆圈个数
 * @param {Number} [options.gradient=0.1] 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
 *
 * @export
 * @class CircleWaveMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var CircleWaveMaterialProperty_CircleWaveMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(CircleWaveMaterialProperty, _BaseMaterialProperty);

  var _super = CircleWaveMaterialProperty_createSuper(CircleWaveMaterialProperty);

  //========== 构造方法 ==========
  function CircleWaveMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CircleWaveMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW); //颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 10); //速度

    _this._count = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.count, 1); //圆圈个数

    _this._gradient = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.gradient, 0.1); //透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
    //属性容错

    if (_this._count <= 0) {
      _this._count = 1;
    }

    if (_this._gradient < 0) {
      _this._gradient = 0;
    }

    if (_this._gradient > 1) {
      _this._gradient = 1;
    }

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(CircleWaveMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return CircleWave;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      result.count = this._count;
      result.gradient = this._gradient;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof CircleWaveMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._count == other._count && this._speed == other._speed && this._gradient == other._gradient;
    }
  }]);

  return CircleWaveMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(CircleWaveMaterialProperty_CircleWaveMaterialProperty.prototype, {
  /**
   * 颜色
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color"),

  /**
   * 速度
   * @type { Number}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  speed: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("speed"),

  /**
   * 圆圈个数
   * @type { Number}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  count: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("count"),

  /**
   * 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
   * @type {Number}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  gradient: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("gradient")
});
registerProperty(CircleWave, CircleWaveMaterialProperty_CircleWaveMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/EllipsoidElectricMaterialProperty.js






function EllipsoidElectricMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = EllipsoidElectricMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipsoidElectricMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 球体: 电弧球体效果  材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=5.0] 速度，值越大越快
 *
 * @export
 * @class EllipsoidElectricMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var EllipsoidElectricMaterialProperty_EllipsoidElectricMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(EllipsoidElectricMaterialProperty, _BaseMaterialProperty);

  var _super = EllipsoidElectricMaterialProperty_createSuper(EllipsoidElectricMaterialProperty);

  //========== 构造方法 ==========
  function EllipsoidElectricMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EllipsoidElectricMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 5.0); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(EllipsoidElectricMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return EllipsoidElectric;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof EllipsoidElectricMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return EllipsoidElectricMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(EllipsoidElectricMaterialProperty_EllipsoidElectricMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(EllipsoidElectric, EllipsoidElectricMaterialProperty_EllipsoidElectricMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/EllipsoidWaveMaterialProperty.js






function EllipsoidWaveMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = EllipsoidWaveMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipsoidWaveMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 球体: 波纹球体效果  材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=5.0] 速度，值越大越快
 *
 * @export
 * @class EllipsoidWaveMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var EllipsoidWaveMaterialProperty_EllipsoidWaveMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(EllipsoidWaveMaterialProperty, _BaseMaterialProperty);

  var _super = EllipsoidWaveMaterialProperty_createSuper(EllipsoidWaveMaterialProperty);

  //========== 构造方法 ==========
  function EllipsoidWaveMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EllipsoidWaveMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 5.0); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(EllipsoidWaveMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return EllipsoidWave;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof EllipsoidWaveMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return EllipsoidWaveMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(EllipsoidWaveMaterialProperty_EllipsoidWaveMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(EllipsoidWave, EllipsoidWaveMaterialProperty_EllipsoidWaveMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/LineFlickerMaterialProperty.js






function LineFlickerMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = LineFlickerMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LineFlickerMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 线状: 闪烁线 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=2] 速度，值越大越快
 *
 * @export
 * @class LineFlickerMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var LineFlickerMaterialProperty_LineFlickerMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(LineFlickerMaterialProperty, _BaseMaterialProperty);

  var _super = LineFlickerMaterialProperty_createSuper(LineFlickerMaterialProperty);

  //========== 构造方法 ==========
  function LineFlickerMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LineFlickerMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 2); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(LineFlickerMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return LineFlicker;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = Object(Util["getCesiumColor"])(this._color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], time);
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof LineFlickerMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return LineFlickerMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(LineFlickerMaterialProperty_LineFlickerMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(LineFlicker, LineFlickerMaterialProperty_LineFlickerMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/LineFlowColorMaterialProperty.js






function LineFlowColorMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = LineFlowColorMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LineFlowColorMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 线状 流动效果 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=2] 速度，值越大越快
 * @param {Number} [options.percent=0.04] 比例
 * @param {Number} [options.alpha=0.1] 透明程度 0.0-1.0
 * @param {Number} [options.startTime=0] 开始的时间系数
 *
 * @export
 * @class LineFlowColorMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var LineFlowColorMaterialProperty_LineFlowColorMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(LineFlowColorMaterialProperty, _BaseMaterialProperty);

  var _super = LineFlowColorMaterialProperty_createSuper(LineFlowColorMaterialProperty);

  //========== 构造方法 ==========
  function LineFlowColorMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LineFlowColorMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 2); //速度

    _this._percent = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.percent, 0.04);
    _this._alpha = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.alpha, 0.1);
    _this._startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.startTime, 0);
    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(LineFlowColorMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return LineFlowColor;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = Object(Util["getCesiumValue"])(this._color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], time);
      result.speed = this._speed;
      result.percent = this._percent;
      result.alpha = this._alpha;
      result.startTime = this._startTime;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof LineFlowColorMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed && this._percent == other._percent && this._startTime == other._startTime && this._alpha == other._alpha;
    }
  }]);

  return LineFlowColorMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(LineFlowColorMaterialProperty_LineFlowColorMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(LineFlowColor, LineFlowColorMaterialProperty_LineFlowColorMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/LineFlowMaterialProperty.js






function LineFlowMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = LineFlowMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LineFlowMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 线状 流动效果 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String}  options.image 背景图片URL
 * @param {String|Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
 * @param {Cesium.Cartesian2} [options.repeat=new Cesium.Cartesian2(1.0, 1.0)] 横纵方向重复次数
 * @param {Boolean} [options.axisY=false] 是否Y轴朝上
 * @param {Number} [options.speed=10] 速度，建议取值范围1-100
 * @param {Boolean} [options.hasImage2=false] 是否有2张图片的混合模式
 * @param {String} [options.image2] 第2张背景图片URL地址
 * @param {String|Cesium.Color} [options.color2=new Cesium.Color(1, 1, 1)] 第2张背景图片颜色
 *
 * @export
 * @class LineFlowMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var LineFlowMaterialProperty_LineFlowMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(LineFlowMaterialProperty, _BaseMaterialProperty);

  var _super = LineFlowMaterialProperty_createSuper(LineFlowMaterialProperty);

  //========== 构造方法 ==========
  function LineFlowMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LineFlowMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._image = options.image || options.url; //背景图片

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._axisY = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.axisY, false);
    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 10); //速度

    _this._repeat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.repeat, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](1.0, 1.0));
    _this._image2 = options.image2 || options.bgUrl; //第2张背景图片

    _this._color2 = Object(Util["getCesiumColor"])(options.color2 || options.bgColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 1, 1)); //第2张背景图片颜色

    _this._hasImage2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this._image2);
    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(LineFlowMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return LineFlow;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.image = this._image;
      result.color = Object(Util["getCesiumValue"])(this._color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], time);
      result.repeat = Object(Util["getCesiumValue"])(this._repeat, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"], time);
      result.axisY = this._axisY;
      result.speed = Object(Util["getCesiumValue"])(this._speed, Number, time);
      result.hasImage2 = this._hasImage2;
      result.image2 = this._image2;
      result.color2 = Object(Util["getCesiumValue"])(this._color2, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], time);
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof LineFlowMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._repeat, other._repeat) && this._image == other._image && this._axisY == other._axisY && this._speed == other._speed && this._hasImage2 == other._hasImage2 && this._image2 == other._image2 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color2, other._color2);
    }
  }]);

  return LineFlowMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty); // Object.defineProperties(LineFlowMaterialProperty.prototype, {
//   // image: Cesium.createPropertyDescriptor('image'),
//   // color: Cesium.createPropertyDescriptor('color'),
//   // repeat: Cesium.createPropertyDescriptor('repeat'),
//   // axisY: Cesium.createPropertyDescriptor('axisY'),
//   // speed: Cesium.createPropertyDescriptor('speed'),
//   // image2: Cesium.createPropertyDescriptor('image2'),
//   // color2: Cesium.createPropertyDescriptor('color2')
// });

registerProperty(LineFlow, LineFlowMaterialProperty_LineFlowMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/LineTrailMaterialProperty.js






function LineTrailMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = LineTrailMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LineTrailMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 线状: 轨迹线 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=5.0] 速度，值越大越快
 *
 * @export
 * @class LineTrailMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var LineTrailMaterialProperty_LineTrailMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(LineTrailMaterialProperty, _BaseMaterialProperty);

  var _super = LineTrailMaterialProperty_createSuper(LineTrailMaterialProperty);

  //========== 构造方法 ==========
  function LineTrailMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LineTrailMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0));
    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 2); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(LineTrailMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return LineTrail;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof LineTrailMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return LineTrailMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(LineTrailMaterialProperty_LineTrailMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(LineTrail, LineTrailMaterialProperty_LineTrailMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/ODLineMaterialProperty.js






function ODLineMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = ODLineMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ODLineMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 线状 OD线效果 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color} [options.color=随机色] 运动对象的颜色
 * @param {String|Cesium.Color} [options.bgColor] 线的背景颜色
 * @param {Number} [options.speed=20 + 10 * Math.random()] 速度
 * @param {Number} [options.startTime=Math.random] 开始的时间系数
 * @param {Number} [options.bidirectional=0]  运行形式：0 正向运动 1 反向运动 2 双向运动
 *
 * @export
 * @class ODLineMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var ODLineMaterialProperty_ODLineMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(ODLineMaterialProperty, _BaseMaterialProperty);

  var _super = ODLineMaterialProperty_createSuper(ODLineMaterialProperty);

  function ODLineMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ODLineMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](Math.random() * 0.5 + 0.5, Math.random() * 0.8 + 0.2, 0.0, 1.0));
    _this._bgColor = Object(Util["getCesiumColor"])(options.bgColor, _this._color.withAlpha(0.1));
    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 20 + 10 * Math.random());
    _this._startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.startTime, Math.random());
    _this._bidirectional = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.bidirectional, 0);
    return _this;
  }
  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(ODLineMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return ODLine;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!result) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      result.startTime = this._startTime;
      result.bgColor = this._bgColor;
      result.bidirectional = this._bidirectional;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof ODLineMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._bgColor, other._bgColor) && this._speed == other._speed && this._startTime == other._startTime && this._bidirectional == other._bidirectional;
    }
  }]);

  return ODLineMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(ODLineMaterialProperty_ODLineMaterialProperty.prototype, {
  /**
   * 运动对象的颜色
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color"),

  /**
   * 线的背景颜色
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  bgColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("bgColor"),

  /**
   * 速度
   * @type { Number}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  speed: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("speed")
});
registerProperty(ODLine, ODLineMaterialProperty_ODLineMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/RadarLineMaterialProperty.js






function RadarLineMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = RadarLineMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RadarLineMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 圆形: 雷达线(圆+旋转半径线) 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=5.0] 速度，值越大越快
 *
 * @export
 * @class RadarLineMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var RadarLineMaterialProperty_RadarLineMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(RadarLineMaterialProperty, _BaseMaterialProperty);

  var _super = RadarLineMaterialProperty_createSuper(RadarLineMaterialProperty);

  //========== 构造方法 ==========
  function RadarLineMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RadarLineMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 5.0); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(RadarLineMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return RadarLine;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof RadarLineMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return RadarLineMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(RadarLineMaterialProperty_RadarLineMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(RadarLine, RadarLineMaterialProperty_RadarLineMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/RadarWaveMaterialProperty.js






function RadarWaveMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = RadarWaveMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RadarWaveMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 圆形: 雷达线(圆+旋转半径线) 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
 * @param {Number} [options.speed=5.0] 速度，值越大越快
 *
 * @export
 * @class RadarWaveMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var RadarWaveMaterialProperty_RadarWaveMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(RadarWaveMaterialProperty, _BaseMaterialProperty);

  var _super = RadarWaveMaterialProperty_createSuper(RadarWaveMaterialProperty);

  //========== 构造方法 ==========
  function RadarWaveMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RadarWaveMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 5.0); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(RadarWaveMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return RadarWave;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof RadarWaveMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return RadarWaveMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(RadarWaveMaterialProperty_RadarWaveMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // speed: Cesium.createPropertyDescriptor('speed'),

});
registerProperty(RadarWave, RadarWaveMaterialProperty_RadarWaveMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/ScanLineMaterialProperty.js






function ScanLineMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = ScanLineMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ScanLineMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 面状: 用于面状对象的 扫描线放大效果 材质属性
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color} [options.color=Cesium.Color.YELLOW]  颜色
 * @param {Number} [options.speed=10] 速度
 *
 * @export
 * @class ScanLineMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var ScanLineMaterialProperty_ScanLineMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(ScanLineMaterialProperty, _BaseMaterialProperty);

  var _super = ScanLineMaterialProperty_createSuper(ScanLineMaterialProperty);

  //========== 构造方法 ==========
  function ScanLineMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ScanLineMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW); //颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 10); //速度

    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(ScanLineMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return ScanLine;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.speed = this._speed;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof ScanLineMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._speed == other._speed;
    }
  }]);

  return ScanLineMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(ScanLineMaterialProperty_ScanLineMaterialProperty.prototype, {
  /**
   * 颜色
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color"),

  /**
   * 速度
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  speed: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("speed")
});
registerProperty(ScanLine, ScanLineMaterialProperty_ScanLineMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/TextMaterialProperty.js






function TextMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = TextMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TextMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 文字贴图 entity材质
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String} [options.text] 文本内容
 * @param {String} [options.font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体,
 * @param {Number} [options.font_size = 30] 字体大小
 * @param {String} [options.font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
 * @param {String} [options.font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
 * @param {string} [options.font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
 *
 * @param {Color} [options.fillColor=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 填充颜色。
 * @param {Boolean} [options.stroke=true] 是否描边文本。
 * @param {Color} [options.strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
 * @param {Number} [options.strokeWidth=2] 描边的宽度。
 * @param {Color} [options.backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
 * @param {Number} [options.padding=10] 要在文本周围添加的填充的像素大小。
 * @param {String} [options.textBaseline='top'] 文本的基线。
 *
 * @export
 * @class TextMaterialProperty
 * @extends {Cesium.ImageMaterialProperty}
 */

var TextMaterialProperty_TextMaterialProperty = /*#__PURE__*/function (_Cesium$ImageMaterial) {
  inherits_default()(TextMaterialProperty, _Cesium$ImageMaterial);

  var _super = TextMaterialProperty_createSuper(TextMaterialProperty);

  //========== 构造方法 ==========
  function TextMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TextMaterialProperty);

    _this = _super.call(this, options);
    _this.transparent = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.transparent, true);
    _this._text = options.text;
    _this._textStyles = LabelStyleConver_LabelStyleConver.toCesiumVal(options, {
      font: "23px 楷体",
      fill: true,
      fillColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 1.0),
      stroke: true,
      strokeWidth: 2,
      strokeColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.8),
      backgroundColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.1),
      textBaseline: "top",
      padding: 10
    });
    _this.image = Object(Util["getTextImage"])(_this._text, _this._textStyles);
    return _this;
  } //========== 对外属性 ==========

  /**
   * 文本内容
   * @type {String}
   * @memberof TextMaterialProperty
   */


  createClass_default()(TextMaterialProperty, [{
    key: "text",
    get: function get() {
      return this._text;
    },
    set: function set(val) {
      this._text = val;
      this.image = Object(Util["getTextImage"])(this._text, this._textStyles);
    }
    /**
     * 文本样式
     *
     * @type {Object}
     * @memberof TextMaterialProperty
     */

  }, {
    key: "textStyles",
    get: function get() {
      return this._textStyles;
    },
    set: function set(val) {
      this._textStyles = LabelStyleConver_LabelStyleConver.toCesiumVal(val, this._textStyles);
      this.image = Object(Util["getTextImage"])(this._text, this._textStyles);
    }
  }]);

  return TextMaterialProperty;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ImageMaterialProperty"]);
registerProperty(Text, TextMaterialProperty_TextMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/WallScrollMaterialProperty.js






function WallScrollMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = WallScrollMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WallScrollMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 墙体:  走马灯围墙 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String}  options.image 背景图片URL
 * @param {String|Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
 * @param {Number} [options.count=1] 数量
 * @param {Number} [options.speed=5.0] 速度
 *
 * @export
 * @class WallScrollMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var WallScrollMaterialProperty_WallScrollMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(WallScrollMaterialProperty, _BaseMaterialProperty);

  var _super = WallScrollMaterialProperty_createSuper(WallScrollMaterialProperty);

  //========== 构造方法 ==========
  function WallScrollMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, WallScrollMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._image = options.image; //背景图片

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 10); //速度

    _this._count = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.count, 1);
    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(WallScrollMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return WallScroll;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.image = this._image;
      result.color = this._color;
      result.speed = this._speed;
      result.count = this._count;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof WallScrollMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._image == other._image && this._count == other._count && this._speed == other._speed;
    }
  }]);

  return WallScrollMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(WallScrollMaterialProperty_WallScrollMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // image: Cesium.createPropertyDescriptor('image'),

});
registerProperty(WallScroll, WallScrollMaterialProperty_WallScrollMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/WaterMaterialProperty.js






function WaterMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = WaterMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WaterMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 水面效果材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color}  [options.baseWaterColor=new Cesium.Color(0.2, 0.3, 0.6, 1.0)] 基础颜色
 * @param {String|Cesium.Color}  [options.blendColor=new Cesium.Color(0.0, 1.0, 0.699, 1.0)] 从水中混合到非水域时使用的rgba颜色对象。
 * @param {String}  [options.specularMap] 单一通道纹理用来指示水域的面积。
 * @param {String}  [options.normalMap] 水正常扰动的法线图。
 * @param {Number}  [options.frequency=100] 控制波数的数字。
 * @param {Number}  [options.animationSpeed=0.01] 控制水的动画速度的数字。
 * @param {Number}  [options.amplitude=10] 控制水波振幅的数字。
 * @param {Number}  [options.specularIntensity=0.5] 控制镜面反射强度的数字。
 * @param {Number}  [options.fadeFactor=1.0] fadeFactor
 *
 * @export
 * @class WaterMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var WaterMaterialProperty_WaterMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(WaterMaterialProperty, _BaseMaterialProperty);

  var _super = WaterMaterialProperty_createSuper(WaterMaterialProperty);

  function WaterMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, WaterMaterialProperty);

    _this = _super.call(this, options);
    _this.baseWaterColor = Object(Util["getCesiumColor"])(options.baseWaterColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.2, 0.3, 0.6, 1.0));
    _this.blendColor = Object(Util["getCesiumColor"])(options.blendColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 0.699, 1.0));
    _this.specularMap = options.specularMap || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId;
    _this.normalMap = options.normalMap || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].DefaultImageId;
    _this.frequency = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.frequency, 1000);
    _this.animationSpeed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.animationSpeed, 0.01);
    _this.amplitude = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.amplitude, 10.0);
    _this.specularIntensity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.specularIntensity, 0.5);
    _this.fadeFactor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.fadeFactor, 1.0);
    return _this;
  }
  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(WaterMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return MaterialType_Water;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!result) {
        result = {};
      }

      result.baseWaterColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this._baseWaterColor, time);
      result.blendColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this._blendColor, time);
      result.specularMap = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this._specularMap, time);
      result.normalMap = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this._normalMap, time);
      result.frequency = this.frequency;
      result.animationSpeed = this.animationSpeed;
      result.amplitude = this.amplitude;
      result.specularIntensity = this.specularIntensity;
      result.fadeFactor = this.fadeFactor;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof WaterMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._baseWaterColor, other._baseWaterColor) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._blendColor, other._blendColor) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._specularMap, other._specularMap) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._normalMap, other._normalMap) && this.frequency == other.frequency && this.animationSpeed == other.animationSpeed && this.amplitude == other.amplitude && this.specularIntensity == other.specularIntensity && this.fadeFactor == other.fadeFactor;
    }
  }]);

  return WaterMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(WaterMaterialProperty_WaterMaterialProperty.prototype, {
  /**
   * 基础颜色
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  baseWaterColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("baseWaterColor"),

  /**
   * 从水中混合到非水域时使用的rgba颜色对象。
   * @type { Cesium.Color}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  blendColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("blendColor"),

  /**
   * 单一通道纹理用来指示水域的面积。
   * @type {String}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  specularMap: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("specularMap"),

  /**
   * 水正常扰动的法线图。
   * @type {String}
   * @memberof CircleWaveMaterialProperty.prototype
   */
  normalMap: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("normalMap")
});
registerProperty(MaterialType_Water, WaterMaterialProperty_WaterMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/PolyGradientMaterialProperty.js






function PolyGradientMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = PolyGradientMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolyGradientMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 面状： 渐变面 材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Cesium.Color} [options.color=new Cesium.Color(1.0, 1.0, 0.0, 0.5)] 颜色
 * @param {Number} [options.alphaPower=1.5] 透明度系数
 * @param {Number} [options.diffusePower=1.6] 漫射系数
 *
 * @export
 * @class PolyGradientMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var PolyGradientMaterialProperty_PolyGradientMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(PolyGradientMaterialProperty, _BaseMaterialProperty);

  var _super = PolyGradientMaterialProperty_createSuper(PolyGradientMaterialProperty);

  //========== 构造方法 ==========
  function PolyGradientMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, PolyGradientMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 0.5));
    _this._diffusePower = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.diffusePower, 1.6);
    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(PolyGradientMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return PolyGradient;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.color = this._color;
      result.diffusePower = this._diffusePower;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof PolyGradientMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._diffusePower == other._diffusePower;
    }
  }]);

  return PolyGradientMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(PolyGradientMaterialProperty_PolyGradientMaterialProperty.prototype, {
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color") // diffusePower: Cesium.createPropertyDescriptor('diffusePower'),

});
registerProperty(PolyGradient, PolyGradientMaterialProperty_PolyGradientMaterialProperty);
// CONCATENATED MODULE: ./src/material/property/RectSlideMaterialProperty.js






function RectSlideMaterialProperty_createSuper(Derived) { var hasNativeReflectConstruct = RectSlideMaterialProperty_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectSlideMaterialProperty_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 矩形面： 轮播图  材质
 * @param {Object} options 参数对象，包括以下：
 * @param {String}  options.image  图片URL
 * @param {Cesium.Color} [options.color=Cesium.Color.WHITE] 颜色和透明度
 * @param {Number} [options.speed=1] 速度，值越大越快
 * @param {Boolean} [options.pure=false] 是否纯色
 *
 * @export
 * @class RectSlideMaterialProperty
 * @extends {BaseMaterialProperty}
 */

var RectSlideMaterialProperty_RectSlideMaterialProperty = /*#__PURE__*/function (_BaseMaterialProperty) {
  inherits_default()(RectSlideMaterialProperty, _BaseMaterialProperty);

  var _super = RectSlideMaterialProperty_createSuper(RectSlideMaterialProperty);

  //========== 构造方法 ==========
  function RectSlideMaterialProperty() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RectSlideMaterialProperty);

    _this = _super.call(this, options); //支持的属性

    _this._image = options.image; //背景图片

    _this._color = Object(Util["getCesiumColor"])(options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 1, 1, 0.9)); //背景图片颜色

    _this._speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.speed, 1); //速度

    _this._pure = options.pure ? true : false;
    return _this;
  } //========== 方法 ==========

  /**
   * 获取 材质名称
   *
   * @param {Cesium.JulianDate} [time] 检索值的时间。
   * @returns {String} 材质名称
   */


  createClass_default()(RectSlideMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return RectSlide;
    }
    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        result = {};
      }

      result.image = this._image;
      result.color = this._color;
      result.speed = this._speed;
      result.pure = this._pure;
      return result;
    }
    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this == other || other instanceof RectSlideMaterialProperty && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].equals(this._color, other._color) && this._image == other._image && this._pure == other._pure && this._speed == other._speed;
    }
  }]);

  return RectSlideMaterialProperty;
}(BaseMaterialProperty_BaseMaterialProperty);
Object.defineProperties(RectSlideMaterialProperty_RectSlideMaterialProperty.prototype, {
  image: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("image"),
  color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("color")
});
registerProperty(RectSlide, RectSlideMaterialProperty_RectSlideMaterialProperty);
// CONCATENATED MODULE: ./src/material/index.js






















// CONCATENATED MODULE: ./src/graphic/BaseGraphic.js








function BaseGraphic_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseGraphic_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseGraphic_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseGraphic_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseGraphic_createSuper(Derived) { var hasNativeReflectConstruct = BaseGraphic_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseGraphic_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











/**
 * 矢量数据 通用构造参数
 *
 * @typedef {Object} BaseGraphic.ConstructorOptions
 *
 * @property {String|Number} [id = uuid()] 矢量数据id标识
 * @property {String} [name = ''] 矢量数据名称
 * @property {Boolean} [show = true] 矢量数据是否显示
 *
 * @property {LatLngPoint|Cesium.Cartesian3} position 【点状】矢量数据时的坐标位置，具体看子类实现
 * @property {LatLngPoint[]|Cesium.Cartesian3[]} positions 【线面状（多点）】矢量数据时的坐标位置，具体看子类实现
 * @property {Object} style 矢量数据的 样式信息，具体见各类数据的说明
 * @property {Object} [attr] 矢量数据的 属性信息，可以任意附加属性。
 *
 * @property {Object} [geojson] 允许直接传入geojson格式规范数据，内部自动解析。【部分矢量对象】
 *
 * @property {Object} [popup] 当矢量数据支持popup弹窗时，绑定的值
 * @property {Object} [tooltip]  当矢量数据支持tooltip弹窗时，绑定的值
 * @property {Object} [contextmenuItems] 当矢量数据支持右键菜单时，绑定的值
 * @property {Boolean} [stopPropagation=false] 当前类中事件是否停止冒泡, false时：事件冒泡到layer种。
 *
 */

/**
 * @typedef {Object} BaseGraphic.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} add 添加对象
 * @property {String} remove 移除对象
 * @property {String} show 显示了对象
 * @property {String} hide 隐藏了对象
 *
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了矢量数据对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 矢量数据 基础类
 *
 * @param {BaseGraphic.ConstructorOptions} options 描述初始化构造参数选项的对象
 *
 * @export
 * @class BaseGraphic
 * @extends {BaseClass}
 *
 * @see [支持的事件类型]{@link BaseGraphic.EventType}
 */

var BaseGraphic_BaseGraphic = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(BaseGraphic, _BaseClass);

  var _super = BaseGraphic_createSuper(BaseGraphic);

  function BaseGraphic() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseGraphic);

    options.style = options.style || {}; //样式

    options.attr = options.attr || {}; //属性

    _this = _super.call(this, options);
    _this.options = options;
    _this._uuid = Object(Util["uuid"])();
    _this._id = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.id, _this._uuid);
    _this._name = options.attr.name || options.name || "";
    _this._show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.show, true);
    _this.popup = options.popup;
    _this.tooltip = options.tooltip;
    _this.contextmenuItems = options.contextmenuItems;
    _this._state = State.INITIALIZED;
    return _this;
  }
  /**
   *  矢量数据类型
   *
   * @type {String}
   * @readonly
   */


  createClass_default()(BaseGraphic, [{
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     *  内置唯一标识ID
     *
     * @type {String}
     * @readonly
     */

  }, {
    key: "uuid",
    get: function get() {
      return this._uuid;
    }
    /**
     * 对象的id标识
     *
     * @type {String|Number}
     */

  }, {
    key: "id",
    get: function get() {
      return this._id;
    },
    set: function set(id) {
      this._id = id;
    }
    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * 是否已添加到图层
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isAdded",
    get: function get() {
      return this._state == State.ADDED;
    }
    /**
     * 是否已经销毁了
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isDestroy",
    get: function get() {
      return this._state == State.DESTROY;
    }
    /**
     * 矢量数据对应的 Cesium内部对象
     * @private
     */

  }, {
    key: "czmObject",
    get: function get() {
      return null;
    }
    /**
     * 矢量数据对应的 附加的Cesium内部对象，比如文本等
     * @private
     */

  }, {
    key: "czmObjectEx",
    get: function get() {
      return null;
    }
    /**
     * 显示隐藏状态
     *
     * @type {Boolean}
     */

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(show) {
      if (this._show == show) {
        return;
      }

      this._show = show;

      if (this.czmObject) {
        this.czmObject.show = this._show;
      }

      if (this.czmObjectEx) {
        this.czmObjectEx.forEach(function (item) {
          item.show = show;
        });
      }

      this._showHook && this._showHook(show);

      if (show) {
        this.fire(EventType.show, {
          graphic: this
        });
      } else {
        this.fire(EventType.hide, {
          graphic: this
        });
      }
    }
    /**
     * 名称
     * @type {String}
     */

  }, {
    key: "name",
    get: function get() {
      return this._name;
    },
    set: function set(name) {
      this._name = name;
    }
    /**
     * 属性信息
     * @type {Object}
     */

  }, {
    key: "attr",
    get: function get() {
      return this.options.attr;
    },
    set: function set(attr) {
      this.options.attr = attr;
      this.fire(EventType.updateAttr, {
        graphic: this,
        attr: attr
      }, true);
    }
    /**
     * 样式信息
     * @type {Object}
     */

  }, {
    key: "style",
    get: function get() {
      return this.options.style;
    },
    set: function set(style) {
      this.setStyle(style);
    }
    /**
     * 中心点坐标（笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "center",
    get: function get() {
      return null;
    }
    /**
     * 中心点坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "centerPoint",
    get: function get() {
      return LatLngPoint["a" /* LatLngPoint */].fromCartesian(this.center);
    } //=============方法==================

    /**
     * 添加到图层上，同  layer.addGraphic
     *
     * @param {GraphicLayer} layer 图层对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addTo",
    value: function addTo(layer) {
      if (layer && layer.addGraphic) {
        layer.addGraphic(this);
      }

      return this;
    }
    /**
     * 从图层上移除，同 layer.removeGraphic
     *
     * @param {Boolean} hasDestory 是否调用destroy释放
     * @return {void}  无
     */

  }, {
    key: "remove",
    value: function remove(hasDestory) {
      if (this._layer) {
        this._layer.removeGraphic(this, hasDestory);
      }
    }
    /**
     * 绑定Cesium内部对象进行相关管理。
     *
     * @param {*} item Cesium对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "bindPickId",
    value: function bindPickId(item) {
      item._tudou3d_layerId = this._layer._uuid;
      item._tudou3d_graphicId = this._uuid;
      return this;
    }
    /**
     * 添加到图层上的钩子方法
     *
     * @param {GraphicLayer} layer 图层对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onAdd",
    value: function _onAdd(layer) {
      var _this2 = this;

      if (this._state == State.ADDED) {
        return;
      }

      this._layer = layer;
      this._map = layer._map;

      if (!this.options.stopPropagation) {
        this.addEventParent(layer);
      }

      if (!this.czmObject) {
        this._mountedHook && this._mountedHook();
      }

      this._addedHook && this._addedHook(); //将矢量数据关联的tudou3d图层和graphic记录下

      if (this.czmObject) {
        this.bindPickId(this.czmObject);
      }

      if (this.czmObjectEx) {
        this.czmObjectEx.forEach(function (item) {
          _this2.bindPickId(item);
        });
      }

      this._state = State.ADDED;
      this.fire(EventType.add);

      if (!this._isDragger) {
        this.fire(EventType.addGraphic, {
          graphic: this
        }, true);
      }
    }
    /**
     * 从图层上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onRemove",
    value: function _onRemove() {
      if (this._state == State.REMOVED) {
        return;
      }

      if (!this._layer) {
        return;
      }

      this._closeAllControl();

      if (this.update) {
        this._map.off(EventType.preRender, this._map_preRenderHandler, this);
      }

      this._removedHook && this._removedHook();
      this._state = State.REMOVED;
      this.fire(EventType.remove);

      if (!this._isDragger) {
        this.fire(EventType.removeGraphic, {
          graphic: this
        }, true);
      }

      if (this.options && !this.options.stopPropagation) {
        this.removeEventParent(this._layer);
      }

      this._layer = null;
      this._map = null;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @abstract
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @abstract
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @abstract
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {}
    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options.attr) {
        this.options.attr = Object(Util["merge"])(this.options.attr, options.attr);
        this.fire(EventType.updateAttr, {
          graphic: this,
          attr: options.attr
        }, true);
      }

      if (options.style) {
        this.options.style = Object(Util["merge"])(this.options.style, options.style);

        this._updateStyleBaseHook(options.style);

        this.fire(EventType.updateStyle, {
          graphic: this,
          style: options.style
        }, true);
      }

      if (options.position) {
        this.position = options.position;
      }

      if (options.positions) {
        this.positions = options.positions;
      }

      return this;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息,内部会合并属性
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setStyle",
    value: function setStyle(newStyle) {
      this.options.style = Object(Util["merge"])(this.options.style, newStyle);

      this._updateStyleBaseHook(newStyle);

      this.fire(EventType.updateStyle, {
        graphic: this,
        style: newStyle
      }, true);
      return this;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleBaseHook",
    value: function _updateStyleBaseHook(newStyle) {}
    /**
     * 将矢量数据导出为GeoJSON格式规范对象。
     *
     * @return {Object} GeoJSON格式规范对象
     */

  }, {
    key: "toGeoJSON",
    value: function toGeoJSON() {
      var geojson = {
        type: "Feature",
        properties: BaseGraphic_objectSpread(BaseGraphic_objectSpread({}, this.attr), {}, {
          id: this.id,
          type: this.type,
          style: this._style2JsonBase(this.style)
        }),
        geometry: this._getGeoJsonGeometry()
      };

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.edittype)) {
        geojson.properties.edittype = this.options.edittype;
      }

      return geojson;
    }
    /**
     * 将矢量数据的坐标、样式及属性等信息导出为对象，可以用于存储。
     *
     * @return {Object} 导出的坐标、样式及属性等信息
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        id: this.id,
        type: this.type,
        attr: this.attr,
        style: this._style2JsonBase(this.style)
      };

      if (this.coordinate) {
        json.position = this.coordinate;
      } else if (this.coordinates) {
        json.positions = this.coordinates;
      } else {
        Object(Log["logError"])("toJSON:缺少坐标信息", this);
      }

      return json;
    } //坐标转geojson的geometry坐标，子类需要重写

  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {};
    } //style样式转object，子类可以重写

  }, {
    key: "_style2JsonBase",
    value: function _style2JsonBase(style) {
      var styleJson;

      if (this._style2Json) {
        styleJson = this._style2Json(style);
      } else {
        styleJson = Object(Util["getAttrVal"])(style);
      }

      if (style.label) {
        styleJson.label = LabelStyleConver_LabelStyleConver.toJSON(style.label);
      }

      return styleJson;
    } //绑定对定时刷新的绑定[需要做定时任务的子类中使用]

  }, {
    key: "bindUpdateEvent",
    value: function bindUpdateEvent() {
      if (!this.update) {
        return;
      }

      this._map.on(EventType.preRender, this._map_preRenderHandler, this);
    }
  }, {
    key: "_map_preRenderHandler",
    value: function _map_preRenderHandler(scene) {
      if (this.options.frameRate && this._last_preUpdateTime) {
        var delta = scene._frameState.frameNumber - this._last_preUpdateTime; //为了效率考虑，每frameRate帧才去update一次

        if (delta < this.options.frameRate) {
          return;
        }
      }

      this._last_preUpdateTime = scene._frameState.frameNumber;
      this.update(scene._frameState);
    }
    /**
     *  获取矢量数据位置的 矩形边界值
     *
     * @param {Boolean} [isFormat=true] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */

  }, {
    key: "getExtent",
    value: function getExtent() {
      var isFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var positions = this.positionsShow || this.positions;

      if (!positions || positions.length == 0) {
        return;
      }

      var extent = getRectangle(positions, isFormat);

      if (!extent) {
        return null;
      }

      extent.height = Object(PointUtil["getMaxHeight"])(positions);
      return extent;
    }
    /**
     * 飞行定位至 数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} options.radius 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.8] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
      * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      var positions;

      if (this.positionsShow) {
        positions = this.positionsShow;
      } else if (this.positions) {
        positions = this.positions;
      } else if (this.position) {
        positions = [this.position];
      }

      options.clampToGround = this.style.clampToGround;

      this._map.flyToPositions(positions, options);

      return this;
    } //============== popup ======================

  }, {
    key: "_getPopupPosition",
    value: function _getPopupPosition() {
      return this.position || this.center;
    }
    /**
     * 是否存在Popup绑定
     *
     * @return {Boolean} 是否存在Popup绑定
     */

  }, {
    key: "hasPopup",
    value: function hasPopup() {
      return this.popup != null && this.popup != false;
    }
    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.template=true] 是否使用内置的Html模版，false时全部使用外部指定的html。
     * @param {Boolean} [options.timeRender=false] 是否实时更新面板，此时需要绑定content回调方法处理。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法   *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "bindPopup",
    value: function bindPopup(content, options) {
      this.popup = BaseGraphic_objectSpread({
        html: content
      }, options);
      this._onEventHook && this._onEventHook("popup");
      return this;
    }
    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "unbindPopup",
    value: function unbindPopup(stopPropagation) {
      if (stopPropagation) {
        this.popup = false;
      } else {
        this.popup = null;
      }

      this._onEventHook && this._onEventHook("popup");
      return this;
    }
    /**
     * 打开绑定的弹窗
     *
     * @param {Cesium.Cartesian3} [position=this.center] 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindPopup绑定的参数，具体参考bindPopup方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "openPopup",
    value: function openPopup(position) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.popup && this._map) {
        this._map.openPopup(position || this._getPopupPosition(), this, BaseGraphic_objectSpread({
          heightReference: this.style.heightReference,
          clampToGround: this.style.clampToGround,
          event: {
            graphic: this
          }
        }, options));
      }

      return this;
    }
    /**
     * 关闭弹窗
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closePopup",
    value: function closePopup() {
      // if (this.popup && this._map) {
      if (this._map) {
        this._map.closePopup(this);
      }

      return this;
    } //============== tooltip ======================

    /**
     * 是否绑定了tooltip
     *
     * @return {Boolean} 是否绑定
     */

  }, {
    key: "hasTooltip",
    value: function hasTooltip() {
      return this.tooltip != null && this.tooltip != false;
    }
    /**
     * 绑定鼠标移入的弹窗
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "bindTooltip",
    value: function bindTooltip(content, options) {
      this.tooltip = BaseGraphic_objectSpread({
        html: content
      }, options);
      this._onEventHook && this._onEventHook("tooltip");
      return this;
    }
    /**
     * 解除绑定的鼠标移入对象后的弹窗。
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "unbindTooltip",
    value: function unbindTooltip(stopPropagation) {
      if (stopPropagation) {
        this.tooltip = false;
      } else {
        this.tooltip = null;
      }

      this._onEventHook && this._onEventHook("tooltip");
      return this;
    }
    /**
     * 打开绑定的tooltip弹窗
     *
     * @param {Cesium.Cartesian3} [position=this.center] 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindTooltip绑定的参数，具体参考bindTooltip方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openTooltip",
    value: function openTooltip(position, options) {
      if (this.tooltip && this._map) {
        this._map.openTooltip(position || this._getPopupPosition(), this, options);
      }

      return this;
    }
    /**
     *  关闭弹窗
     *
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "closeTooltip",
    value: function closeTooltip() {
      // if (this.tooltip && this._map) {
      if (this._map) {
        this._map.closeTooltip(this);
      }

      return this;
    } //============== Small tooltip ======================

    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openSmallTooltip",
    value: function openSmallTooltip(position, message) {
      if (this._map) {
        this._map.openSmallTooltip(position, message);
      }

      return this;
    }
    /**
     * 关闭小提示窗
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeSmallTooltip",
    value: function closeSmallTooltip() {
      if (this._map) {
        this._map.closeSmallTooltip();
      }

      return this;
    } //============== contextMenu ======================

    /**
     * 是否有绑定的右键菜单
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "hasContextMenu",
    value: function hasContextMenu() {
      return this.contextmenuItems != null;
    }
    /**
     * 获取绑定的右键菜单数组
     *
     * @return {Object[]} 右键菜单数组
     */

  }, {
    key: "getContextMenu",
    value: function getContextMenu() {
      return this.contextmenuItems;
    }
    /**
     * 绑定右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
     * @param {String} [content.iconCls] 小图标css
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 参数对象(预留，目前未用)
     * @return {this} 当前对象本身，可以链式调用
     *
     * @example
     *
        graphic.bindContextMenu([
          {
            text: '删除对象',
            iconCls: 'fa fa-trash-o',
            callback: function (e) {
              let graphic = e.graphic
              if (graphic) {
                graphic.remove()
              }
            },
          },
        ])
     */

  }, {
    key: "bindContextMenu",
    value: function bindContextMenu(content, options) {
      this.contextmenuItems = content;
      this._onEventHook && this._onEventHook("contextMenu");
      return this;
    }
    /**
     * 解除绑定的右键菜单
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "unbindContextMenu",
    value: function unbindContextMenu(stopPropagation) {
      if (stopPropagation) {
        this.contextmenuItems = false;
      } else {
        this.contextmenuItems = null;
      }

      this._onEventHook && this._onEventHook("contextMenu");
      return this;
    }
    /**
     * 打开右键菜单
     *
     * @param {Cesium.Cartesian3} [position=this.center] 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindContextMenu绑定的参数，具体参考bindContextMenu方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openContextMenu",
    value: function openContextMenu(position, options) {
      if (this.contextmenuItems && this._map) {
        this._map.openContextMenu(position || this._getPopupPosition(), this, options);
      }

      return this;
    }
    /**
     *  关闭右键菜单
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeContextMenu",
    value: function closeContextMenu() {
      // if (this.contextmenuItems && this._map) {
      if (this._map) {
        this._map.closeContextMenu(this);
      }

      return this;
    }
  }, {
    key: "_closeAllControl",
    value: function _closeAllControl() {
      this.closePopup();
      this.closeTooltip();
      this.closeSmallTooltip();
      this.closeContextMenu();
    } //销毁

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      if (this._state != State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }

      get_default()(getPrototypeOf_default()(BaseGraphic.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return BaseGraphic;
}(BaseClass_BaseClass);
// CONCATENATED MODULE: ./src/graphic/entity/core/FlashingEntity.js


 //定时闪烁高亮Entity（点、线、面）

var FlashingEntity_FlashingEntity = /*#__PURE__*/function () {
  //========== 构造方法 ==========
  function FlashingEntity() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FlashingEntity);

    this.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW.withAlpha(0);
  } //========== 方法 ==========


  createClass_default()(FlashingEntity, [{
    key: "highlight",
    value: function highlight(entitys) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var that = this;
      this.unHighlight();
      this.entitys = entitys;
      this.maxAlpha = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](opts.maxAlpha, 0.3);
      this.time = opts.time; //播放时长，默认一直不停止

      this.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](opts.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW);
      this.color = this.color.withAlpha(this.maxAlpha);
      this.onEnd = opts.onEnd;

      this._startTime();

      loopArrayForFun(entitys, function (entity) {
        if (entity.polygon) {
          entity.polygon.material_bak = entity.polygon.material;
          entity.polygon.material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return that.color;
          }, false));
        }

        if (entity.polyline) {
          entity.polyline.material_bak = entity.polyline.material;
          entity.polyline.material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return that.color;
          }, false));
        }

        if (entity.ellipse) {
          entity.ellipse.material_bak = entity.ellipse.material;
          entity.ellipse.material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return that.color;
          }, false));
        }

        if (entity.rectangle) {
          entity.rectangle.material_bak = entity.rectangle.material;
          entity.rectangle.material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return that.color;
          }, false));
        }

        if (entity.wall) {
          entity.wall.material_bak = entity.wall.material;
          entity.wall.material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorMaterialProperty"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return that.color;
          }, false));
        }

        if (entity.point) {
          entity.point.color_bak = entity.point.color;
          entity.point.color = that.color;
        }

        if (entity.billboard) {
          entity.billboard.color_bak = entity.billboard.color;
          entity.billboard.color = that.color;
        }

        if (entity.model) {
          entity.model.color_bak = entity.model.color;
          entity.model.color = that.color;
        }

        if (entity.label) {
          entity.label.fillColor_bak = entity.label.fillColor;
          entity.label.fillColor = that.color;
        }
      });
      return this;
    }
  }, {
    key: "unHighlight",
    value: function unHighlight() {
      this._stopTime();

      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.polygon) {
            if (entity.polygon.material_bak) {
              entity.polygon.material = entity.polygon.material_bak;
            }
          }

          if (entity.polyline) {
            if (entity.polyline.material_bak) {
              entity.polyline.material = entity.polyline.material_bak;
            }
          }

          if (entity.ellipse) {
            if (entity.ellipse.material_bak) {
              entity.ellipse.material = entity.ellipse.material_bak;
            }
          }

          if (entity.rectangle) {
            if (entity.rectangle.material_bak) {
              entity.rectangle.material = entity.rectangle.material_bak;
            }
          }

          if (entity.wall) {
            if (entity.wall.material_bak) {
              entity.wall.material = entity.wall.material_bak;
            }
          }

          if (entity.point) {
            if (entity.point.color_bak) {
              entity.point.color = entity.point.color_bak;
            }
          }

          if (entity.billboard) {
            if (entity.billboard.color_bak) {
              entity.billboard.color = entity.billboard.color_bak;
            } else {
              entity.billboard.color = undefined;
            }
          }

          if (entity.model) {
            if (entity.model.color_bak) {
              entity.model.color = entity.model.color_bak;
            } else {
              entity.model.color = undefined;
            }
          }

          if (entity.label) {
            if (entity.label.fillColor_bak) {
              entity.label.fillColor = entity.label.fillColor_bak;
            }
          }
        });

        if (this.onEnd) {
          this.onEnd(this.entitys);
        }

        delete this.entitys;
      }

      return this;
    }
  }, {
    key: "_updateClr",
    value: function _updateClr() {
      var that = this;

      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.point) {
            entity.point.color = that.color;
          }

          if (entity.billboard) {
            entity.billboard.color = that.color;
          }

          if (entity.model) {
            entity.model.color = that.color;
          }

          if (entity.label) {
            entity.label.fillColor = that.color;
          }
        });
      }
    }
  }, {
    key: "_startTime",
    value: function _startTime() {
      var _this = this;

      var time = 30;
      var setp = this.maxAlpha / time;
      var alpha = 0;
      this.interVal = setInterval(function () {
        alpha += setp;

        if (alpha > _this.maxAlpha) {
          alpha = 0;
        }

        _this.color = _this.color.withAlpha(alpha);

        _this._updateClr();
      }, time);

      if (this.time) {
        this.timeEndVal = setTimeout(function () {
          _this.unHighlight();
        }, this.time * 1000);
      }
    }
  }, {
    key: "_stopTime",
    value: function _stopTime() {
      if (this.interVal) {
        clearInterval(this.interVal);
        this.interVal = null;
      }

      if (this.timeEndVal) {
        clearTimeout(this.timeEndVal);
        this.timeEndVal = null;
      }
    }
  }]);

  return FlashingEntity;
}(); //循环执行数组或对象
// 调用示例 loopArrayForFun(ArrOrObj, function (entity) {
//    drawControl.deleteEntity(entity);
// });

function loopArrayForFun(ArrOrObj, callback) {
  if (ArrOrObj == null) {
    return;
  }

  if (Array.isArray(ArrOrObj)) {
    var arr = [];

    for (var i = 0, len = ArrOrObj.length; i < len; i++) {
      arr.push(callback(ArrOrObj[i]));
    }

    return arr;
  } else {
    return callback(ArrOrObj);
  }
}
// CONCATENATED MODULE: ./src/graphic/entity/BaseEntity.js







function BaseEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseEntity_createSuper(Derived) { var hasNativeReflectConstruct = BaseEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











/**
 * @typedef {Object} BaseEntity.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 *
 * @property {String} drawStart 开始绘制 标绘事件
 * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
 * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
 * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
 * @property {String} drawCreated 创建完成 标绘事件
 * @property {String} editStart 开始编辑 标绘事件
 * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
 * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
 * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
 * @property {String} editRemovePoint 编辑删除了点 标绘事件
 * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
 * @property {String} editStop 停止编辑 标绘事件
 *
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了矢量数据对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * Entity实体 矢量对象 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数

 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class BaseEntity
 * @extends {BaseGraphic}
 *
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var BaseEntity_BaseEntity = /*#__PURE__*/function (_BaseGraphic) {
  inherits_default()(BaseEntity, _BaseGraphic);

  var _super = BaseEntity_createSuper(BaseEntity);

  function BaseEntity() {
    classCallCheck_default()(this, BaseEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseEntity, [{
    key: "dataSource",
    get:
    /**
     * 加载Entity数据的内部Cesium容器
     * @type {Cesium.CustomDataSource}
     * @readonly
     */
    function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.dataSource;
    } // 内部用

  }, {
    key: "czmObject",
    get: function get() {
      return this._entity;
    } //内部用，文本等附加对象

  }, {
    key: "czmObjectEx",
    get: function get() {
      var arr = [];

      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }

      if (this._entity_outlines) {
        arr = arr.concat(this._entity_outlines);
      }

      return arr;
    }
    /**
     *
     * 矢量数据对应的 Cesium内部对象
     * @type {Cesium.Entity}
     * @readonly
     */

  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.XXXGraphics}
     * @readonly
     */

  }, {
    key: "entityGraphic",
    get: function get() {
      return this._entity.point;
    }
    /**
     *
     * 附加的label文本对象
     * @type {Cesium.Label |Cesium.LabelGraphics}
     * @readonly
     */

  }, {
    key: "label",
    get: function get() {
      var _this$_entity, _this$style;

      //线面数据时
      if (this._primitive_label) {
        return this._primitive_label.label;
      } //点状数据时


      if ((_this$_entity = this._entity) !== null && _this$_entity !== void 0 && _this$_entity.label) {
        return this._entity.label;
      } //尚未添加entity、primitive时


      if ((_this$style = this.style) !== null && _this$style !== void 0 && _this$style.label) {
        var _this$style2;

        return (_this$style2 = this.style) === null || _this$style2 === void 0 ? void 0 : _this$style2.label;
      }

      return {};
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this = this;

      this.dataSource.entities.add(this.czmObject);
      this.czmObjectEx.forEach(function (item) {
        if (item instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]) {
          _this.dataSource.entities.add(item);
        }
      });
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      var _this2 = this;

      this.stopEditing();
      this.stopDraw();
      this.dataSource.entities.remove(this.czmObject);
      this.czmObjectEx.forEach(function (item) {
        if (item instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]) {
          _this2.dataSource.entities.remove(item);
        }
      });

      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);

        delete this._primitive_label;
      }
    }
  }, {
    key: "_initFromEntity",
    value: function _initFromEntity(entity) {
      if (entity.entityCollection) {
        //从原有的集合中删除
        entity.entityCollection.remove(entity);
      }

      entity._id = this.uuid;
      return entity;
    } //如果在编辑中，更新编辑的拖拽点。

  }, {
    key: "_updateEditDraggers",
    value: function _updateEditDraggers() {
      if (this._enabledEdit && this.editing) {
        this.editing.updateDraggers();
      }
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleBaseHook",
    value: function _updateStyleBaseHook(newStyle) {
      if (!this.czmObject) {
        return;
      }

      this._updateStyleHook(newStyle, this._entity); //同时加文字


      if (newStyle.label && this._primitive_label) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.label.clampToGround)) {
          newStyle.label.clampToGround = this.style.clampToGround;
        }

        LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, this._primitive_label, this.attr);
      }

      if (this._enabledEdit && this.editing) {
        this.editing._updateStyleHook(newStyle);
      }

      return this;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {*} newStyle 样式信息
     * @param {Cesium.Entity} entity 实体对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {} //创建Entity，并附加Graphic的一些属性

  }, {
    key: "_createEntity",
    value: function _createEntity(addattr) {
      //可以在添加前做特殊处理的。
      if (this.options.onBeforeCreate) {
        addattr = this.options.onBeforeCreate(addattr) || addattr;
      }

      var defAttr = {
        id: this.uuid,
        name: this.name || this.id,
        properties: this.attr,
        show: this.show,
        parent: this.options.parent
      };

      if (this.options.availability) {
        defAttr.availability = this.options.availability;
      }

      if (this.options.description) {
        defAttr.description = this.options.description;
      }

      if (this.options.viewFrom) {
        defAttr.viewFrom = this.options.viewFrom;
      }

      if (this.options.parent) {
        defAttr.parent = this.options.parent;
      }

      var entity = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"](BaseEntity_objectSpread(BaseEntity_objectSpread({}, defAttr), addattr));
      return entity;
    }
    /**
     * 添加文本的统一方法 (不含Point、Billboard对象)
     * @return {Cesium.Label} 文本矢量对象
     * @private
     */

  }, {
    key: "_addLabel",
    value: function _addLabel() {
      var style = this.style.label;

      if (!style || !style.text) {
        return;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
        style.clampToGround = this.style.clampToGround;
      }

      var labelattr = LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
      labelattr.position = this._getLablePosition();
      this._primitive_label = this._layer.labelCollection.add(labelattr);
      this.bindPickId(this._primitive_label);
      return this._primitive_label;
    } //更新文本的位置

  }, {
    key: "_updateLabelPosition",
    value: function _updateLabelPosition() {
      if (this._primitive_label) {
        this._primitive_label.position = this._getLablePosition();
      }
    } //根据配置获取文本的坐标位置

  }, {
    key: "_getLablePosition",
    value: function _getLablePosition() {
      var style = this.style.label;
      var position;

      if (style.position) {
        if (style.position == "center") {
          position = this.centerOfMass;
        } else {
          if (Object(Util["isString"])(style.position)) {
            var cfgPt = Object(Util["template"])(style.position, this.attr, true);

            if (cfgPt) {
              position = LatLngPoint["a" /* LatLngPoint */].parse(cfgPt).toCartesian();
            }
          } else {
            position = LatLngPoint["a" /* LatLngPoint */].parse(style.position).toCartesian();
          }
        }
      }

      if (!position) {
        position = this.center;
      }

      if (!position) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.height)) {
        var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.height, this.style.height);
        position = Object(PointUtil["setPositionsHeight"])(position, height);
      } //存在垂直高度


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
        position = Object(PointUtil["addPositionsHeight"])(position, this.style.diffHeight);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.setHeight)) {
        position = Object(PointUtil["setPositionsHeight"])(position, style.setHeight);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.addHeight)) {
        position = Object(PointUtil["addPositionsHeight"])(position, style.addHeight);
      }

      return position;
    }
  }, {
    key: "_getOutlineStyle",
    value: function _getOutlineStyle(exStyle) {
      var cloneStyle = BaseEntity_objectSpread({}, this.style);

      delete cloneStyle.material;
      delete cloneStyle.materialType;
      return BaseEntity_objectSpread(BaseEntity_objectSpread(BaseEntity_objectSpread({}, cloneStyle), {}, {
        show: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.outline, false),
        color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.outlineColor, this.style.color),
        opacity: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.outlineOpacity, this.style.opacity),
        width: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.outlineWidth, 1),
        arcType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.arcType, this.style.clampToGround ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcType"].GEODESIC : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcType"].NONE)
      }, this.style.outlineStyle || {}), exStyle || {});
    }
  }, {
    key: "_updateOutlineStyle",
    value: function _updateOutlineStyle(target, arrline, exStyle) {
      var outlineStyle = this._getOutlineStyle(exStyle); //加上线宽


      if (outlineStyle.show && outlineStyle.width > 1) {
        target.outline = false; //_outlineEx是数组，支持挖洞多边形的多个边线。

        if (this._entity_outlines) {
          for (var i = 0, len = this._entity_outlines.length; i < len; i++) {
            var polyline = this._entity_outlines[i].polyline;

            if (arrline && arrline[i]) {
              var positions = arrline[i];

              if (positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
                polyline.positions = positions;
              } else if (Array.isArray(positions) && positions.length > 0) {
                polyline.positions = positions.concat(positions[0]);
              }
            }

            PolylineStyleConver_PolylineStyleConver.toCesiumVal(outlineStyle, polyline, true);
          }
        } else {
          if (arrline) {
            this._entity_outlines = [];

            for (var _i = 0, _len = arrline.length; _i < _len; _i++) {
              var _positions = arrline[_i];

              var _polyline = PolylineStyleConver_PolylineStyleConver.toCesiumVal(outlineStyle, {}, true);

              if (_positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
                _polyline.positions = _positions;
              } else if (Array.isArray(_positions) && _positions.length > 0) {
                _polyline.positions = _positions.concat(_positions[0]);
              }

              var lineEx = this._createEntity({
                id: this.uuid + "-outline" + _i,
                polyline: _polyline
              });

              this.bindPickId(lineEx);

              this._entity_outlines.push(lineEx);

              if (this._state == State.ADDED) {
                this.dataSource.entities.add(lineEx);
              }
            }
          }
        }

        return true;
      } else {
        if (this._entity_outlines) {
          for (var _i2 = 0, _len2 = this._entity_outlines.length; _i2 < _len2; _i2++) {
            var _polyline2 = this._entity_outlines[_i2].polyline;
            _polyline2.show = false;
          }
        } //本身的outline处理


        target.outline = outlineStyle.show && outlineStyle.width == 1;
        return false;
      }
    }
  }, {
    key: "_updateOutlineToCallback",
    value: function _updateOutlineToCallback() {
      var _this3 = this;

      if (this._entity_outlines) {
        for (var i = 0, len = this._entity_outlines.length; i < len; i++) {
          var entity = this._entity_outlines[i];

          if (entity.polyline.positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
            continue;
          }

          entity.polyline.positions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return _this3.outlinePositions;
          }, false);
        }
      }
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelOutlinePositionsCallback",
    value: function _cancelOutlinePositionsCallback() {
      if (this._entity_outlines) {
        for (var i = 0, len = this._entity_outlines.length; i < len; i++) {
          var entity = this._entity_outlines[i];

          if (!(entity.polyline.positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"])) {
            continue;
          }

          entity.polyline.positions = this.outlinePositions;
        }
      }
    }
    /**
     *
     * 高亮闪烁 Enity实体对象
     * @export
     * @param {Object} options 参数
     * @param {Number} [options.time=null] 闪烁的时长(秒)，未设置时不自动停止。
     * @param {Cesium.Color} [options.color=Cesium.Color.YELLOW] 高亮的颜色
     * @param {Number} [options.maxAlpha=0.3] 闪烁的最大透明度，从 0 到 maxAlpha 渐变
     * @param {Function} [options.onEnd=null] 播放完成后的回调方法
     * @return {FlashingEntity} 高亮闪烁控制 对象
     */

  }, {
    key: "highlight",
    value: function highlight(options) {
      if (!this.flashingEntity) {
        this.flashingEntity = new FlashingEntity_FlashingEntity();
      }

      var arr = this.czmObjectEx.concat(this.czmObject);
      this.flashingEntity.highlight(arr, options);
      return this.flashingEntity;
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      var _this$entityGraphic, _this$entityGraphic$m, _this$_entity2;

      var opacity = value * (this.style.opacity || 1);

      if ((_this$entityGraphic = this.entityGraphic) !== null && _this$entityGraphic !== void 0 && (_this$entityGraphic$m = _this$entityGraphic.material) !== null && _this$entityGraphic$m !== void 0 && _this$entityGraphic$m.color) {
        this._updatEntityAlpha(this.entityGraphic.material.color, opacity);
      }

      if ((_this$_entity2 = this._entity) !== null && _this$_entity2 !== void 0 && _this$_entity2.label) {
        var _this$style$label;

        var _opacity = value * (((_this$style$label = this.style.label) === null || _this$style$label === void 0 ? void 0 : _this$style$label.opacity) || 1);

        if (this._entity.label.fillColor) {
          this._updatEntityAlpha(this._entity.label.fillColor, _opacity);
        }

        if (this._entity.label.outlineColor) {
          this._updatEntityAlpha(this._entity.label.outlineColor, _opacity);
        }

        if (this._entity.label.backgroundColor) {
          this._updatEntityAlpha(this._entity.label.backgroundColor, _opacity);
        }
      }

      if (this._primitive_label) {
        var _this$style$label2;

        var _opacity2 = value * (((_this$style$label2 = this.style.label) === null || _this$style$label2 === void 0 ? void 0 : _this$style$label2.opacity) || 1);

        if (this._primitive_label.fillColor) {
          this._updatEntityAlpha(this._primitive_label.fillColor, _opacity2);
        }

        if (this._primitive_label.outlineColor) {
          this._updatEntityAlpha(this._primitive_label.outlineColor, _opacity2);
        }

        if (this._primitive_label.backgroundColor) {
          this._updatEntityAlpha(this._primitive_label.backgroundColor, _opacity2);
        }
      }
    }
  }, {
    key: "_updatEntityAlpha",
    value: function _updatEntityAlpha(color, opacity) {
      if (!color) {
        return;
      }

      var newclr = Object(Util["getCesiumColor"])(color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], this._map.clock.currentTime);

      if (!newclr || !newclr.withAlpha) {
        return color;
      }

      newclr = newclr.withAlpha(opacity);
      color.setValue(newclr);
    }
    /**
     * 停止高亮闪烁
     * @return {void}  无
     */

  }, {
    key: "unHighlight",
    value: function unHighlight() {
      if (!this.flashingEntity) {
        return;
      }

      return this.flashingEntity.unHighlight();
    } //==================Draw绘制相关=================

    /**
     * 开始绘制矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */

  }, {
    key: "startDraw",
    value: function startDraw(layer) {
      if (this._enabledDraw) {
        return this;
      }

      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }

      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map");
      }

      this._map.mouseEvent.noPickEntity = this._entity;

      this._map.setCursor(true);

      this.enableControl(false);

      this._setPositionsToCallback();

      this._startDrawHook();

      this.fire(EventType.drawStart, {
        drawtype: this.type,
        graphic: this
      }, true);
    }
    /**
     * 停止绘制
     * @return {void}  无
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      var _this$_positions_draw;

      if (!this._enabledDraw) {
        return this;
      }

      this._stopDrawHook();

      this._map.setCursor(false);

      this.enableControl(true);

      this._map.closeSmallTooltip();

      this._map.mouseEvent.noPickEntity = null;
      this._enabledDraw = false;

      if (!this._position_draw && (!this._positions_draw || ((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) == 0)) {
        this.remove();
        return;
      }

      if (this._positions_draw && this._positions_draw.length < this._minPointNum) {
        this.remove();
        return;
      }

      if (this._layer.options.isRestorePositions) {
        this._cancelPositionsCallback(); //坐标CallbackProperty属性改为实际值,提高效率

      }

      if (this.options.success) {
        this.options.success(this);
      }

      this.fire(EventType.drawCreated, {
        drawtype: this.type,
        graphic: this
      }, true);
    }
  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {}
  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {}
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {}
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {}
  }, {
    key: "_showDrawMouseMoveSmallTooltip",
    value: function _showDrawMouseMoveSmallTooltip(event) {
      var position = event.endPosition;

      if (this._positions_draw.length <= 1) {
        this._map.openSmallTooltip(position, this._map.getLangText("_单击开始绘制"));
      } else if (this._positions_draw.length < this._minPointNum) {
        //点数不满足最少数量
        this._map.openSmallTooltip(position, this._map.getLangText("_单击增加点右击删除点"));
      } else if (this._positions_draw.length >= this._maxPointNum) {
        //点数满足最大数量
        this._map.openSmallTooltip(position, this._map.getLangText("_单击完成绘制"));
      } else {
        var tooltip = this._map.getLangText("_单击增加点右击删除点") + "<br/>" + this._map.getLangText("_双击完成绘制");

        this._map.openSmallTooltip(position, tooltip);
      }
    } //鼠标移动

  }, {
    key: "_onMouseMoveHandler",
    value: function _onMouseMoveHandler(event) {
      this._showDrawMouseMoveSmallTooltip(event);

      var point = event.cartesian;

      if (point) {
        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }

        this.lastPointTemporary = true;

        this._positions_draw.push(point);

        this.updateAttrForDrawing(false);
        this.fire(EventType.drawMouseMove, BaseEntity_objectSpread(BaseEntity_objectSpread({}, event), {}, {
          drawtype: this.type,
          graphic: this,
          positions: this._positions_draw
        }), true);
      }
    }
  }, {
    key: "_onClickHandler",
    value: function _onClickHandler(event) {
      //下面代码是 避免双击带来的2次click事件
      var times = new Date().getTime() - (this._last_clickTime || 0);

      if (this._last_clickTime && times < 200) {
        // console.log('屏蔽了单击时间很近的点')
        return;
      }

      this._last_clickTime = new Date().getTime();

      if (this._last_clickPositionX && Math.abs(this._last_clickPositionX - event.windowPosition.x) < 10 && Math.abs(this._last_clickPositionY - event.windowPosition.y) < 10) {
        // console.log('屏蔽了单击像素很近的点')
        return;
      }

      this._last_clickPositionX = event.windowPosition.x;
      this._last_clickPositionY = event.windowPosition.y; //上面代码是 避免双击带来的2个重复点

      var point = event.cartesian;

      if (!point && this.lastPointTemporary) {
        //如果未拾取到点，并且存在MOUSE_MOVE时，取最后一个move的点
        point = this._positions_draw[this._positions_draw.length - 1];
      }

      if (point) {
        var _this$options;

        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }

        this.lastPointTemporary = false;
        this.removeNearPoint(); //消除双击带来的多余经纬度
        //在绘制点基础自动增加高度

        if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.addHeight) {
          point = Object(PointUtil["addPositionsHeight"])(point, this.options.addHeight);
        }

        this._positions_draw.push(point);

        this.updateAttrForDrawing(false);
        this.fire(EventType.drawAddPoint, BaseEntity_objectSpread(BaseEntity_objectSpread({}, event), {}, {
          drawtype: this.type,
          graphic: this,
          positions: this._positions_draw
        }), true);

        if (this._positions_draw.length >= this._maxPointNum) {
          //点数满足最大数量，自动结束
          this.stopDraw();
        }
      }
    }
  }, {
    key: "_onRightClickHandler",
    value: function _onRightClickHandler(event) {
      //右击删除上一个点
      this._positions_draw.pop(); //删除最后标的一个点


      var point = event.cartesian;

      if (point) {
        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }

        this.lastPointTemporary = true;
        this.fire(EventType.drawRemovePoint, BaseEntity_objectSpread(BaseEntity_objectSpread({}, event), {}, {
          drawtype: this.type,
          graphic: this,
          positions: this._positions_draw
        }), true);

        this._positions_draw.push(point);

        this.updateAttrForDrawing(false);
      }
    }
  }, {
    key: "_onDbClickHandler",
    value: function _onDbClickHandler(event) {
      //双击结束标绘
      this.removeNearPoint(); //消除双击带来的多余经纬度

      this.endDraw();
    }
    /**
     * 移除绘制的坐标中的重复点，比如快速单击或双击产生的冗余坐标。
     * @return {void}  无
     */

  }, {
    key: "removeNearPoint",
    value: function removeNearPoint() {
      if (this._positions_draw.length < 3) {
        return;
      } //消除双击带来的多余经纬度


      for (var i = this._positions_draw.length - 1; i > 0; i--) {
        var mpt1 = this._positions_draw[i];
        var mpt2 = this._positions_draw[i - 1];
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(mpt1, mpt2);

        if (distance < 0.01) {
          this._positions_draw.splice(i, 1);
        } else {
          break;
        }
      }
    }
    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {void}  无
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (!this._enabledDraw) {
        return this;
      } //点数不够


      if (this._positions_draw.length < this._minPointNum) {
        return;
      }

      this.updateAttrForDrawing(false);
      this.stopDraw();
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {}
    /**
     * 启用或禁用所有内部控件（含tooltip、popup、contextmenu）
     * @param {Boolean} value 是否启用
     * @return {void}  无
     */

  }, {
    key: "enableControl",
    value: function enableControl(value) {
      this._map.mouseEvent.enabledMoveTarget = value;

      if (this._map.popup) {
        this._map.popup.enabled = value;
      }

      if (this._map.tooltip) {
        this._map.tooltip.enabled = value;
      }

      if (this._map.contextmenu) {
        this._map.contextmenu.enabled = value;
      }
    } //==================Draw编辑相关=================

    /**
     * 开始编辑对象
     * @return {void}  无
     */

  }, {
    key: "startEditing",
    value: function startEditing() {
      if (this._enabledEdit) {
        return this;
      }

      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到图层，并且图层已添加到Map");
      }

      this._map.mouseEvent.noPickEntity = this._entity;
      this._map.mouseEvent.enabledMoveTarget = false; // this.enableControl(false)

      if (!this.editing) {
        this.editing = new this.EditClass(this);
      }

      if (this.editing.activate) {
        this.editing.activate();
      }
    }
    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */

  }, {
    key: "stopEditing",
    value: function stopEditing() {
      var _this$editing;

      if (!this._enabledEdit) {
        return this;
      }

      if ((_this$editing = this.editing) !== null && _this$editing !== void 0 && _this$editing.disable) {
        this.editing.disable();
      } // this.enableControl(true)


      this._map.closeSmallTooltip();

      this._map.mouseEvent.noPickEntity = null;
      this._map.mouseEvent.enabledMoveTarget = true;
      this._enabledEdit = false;
    }
  }]);

  return BaseEntity;
}(BaseGraphic_BaseGraphic);
// CONCATENATED MODULE: ./src/graphic/primitive/BasePrimitive.js







function BasePrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BasePrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BasePrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BasePrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BasePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = BasePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BasePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * Primitive 通用参数（不含Billboard、Label、Point、Model、Polyline）
 *
 * @typedef {Object} BasePrimitive.ConstructorOptions
 *
 * @property {Cesium.Appearance} [appearance] [cesium原生]用于渲染图元的外观。
 * @property {Cesium.Appearance} [attributes] [cesium原生]每个实例的属性。
 *
 * @property {Appearance} [depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
 * @property {Boolean} [vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
 * @property {Boolean} [interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
 * @property {Boolean} [compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
 * @property {Boolean} [releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
 * @property {Boolean} [allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
 * @property {Boolean} [cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
 * @property {Boolean} [asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
 * @property {Boolean} [debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
 * @property {Boolean} [debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
 *
 *
 * @see Cesium.Primitive
 * @see Cesium.GroundPrimitive
 */

/**
 * @typedef {Object} BasePrimitive.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了矢量数据对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * Primitive图元 矢量对象 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] Primitive通用参数
 *
 * @export
 * @class BasePrimitive
 * @extends {BaseGraphic}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var BasePrimitive_BasePrimitive = /*#__PURE__*/function (_BaseGraphic) {
  inherits_default()(BasePrimitive, _BaseGraphic);

  var _super = BasePrimitive_createSuper(BasePrimitive);

  function BasePrimitive() {
    classCallCheck_default()(this, BasePrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(BasePrimitive, [{
    key: "czmObject",
    get: // 内部用
    function get() {
      return this._primitive;
    } //内部用，文本等附加对象

  }, {
    key: "czmObjectEx",
    get: function get() {
      var arr = [];

      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }

      if (this._primitive_outline) {
        arr.push(this._primitive_outline);
      }

      return arr;
    }
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.PrimitiveCollection}
     */

  }, {
    key: "primitiveCollection",
    get: function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.primitiveCollection;
    }
    /**
     *
     * 矢量数据对应的 Cesium内部对象
     * @type {Cesium.Primitive}
     * @readonly
     */

  }, {
    key: "primitive",
    get: function get() {
      return this._primitive;
    }
    /**
     * 返回实例可修改的属性。{@link Cesium.GeometryInstance}
     *
     * @type {Object}
     * @readonly
     * @memberof BasePrimitive
     * @exception {DeveloperError} 在调用getGeometryInstanceAttributes之前必须调用update。
     *
     * @example
     * var attributes = primitiveGraphic.geometryInstanceAttributes;
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     */

  }, {
    key: "geometryInstanceAttributes",
    get: function get() {
      if (this._primitive) {
        return this._primitive.getGeometryInstanceAttributes(this.uuid);
      } else if (this._primitive_outline) {
        return this._primitive_outline.getGeometryInstanceAttributes(this.uuid);
      }

      return null;
    }
    /**
     *
     * 附加的label文本对象
     * @type {Cesium.Label}
     * @readonly
     */

  }, {
    key: "label",
    get: function get() {
      if (this._primitive_label) {
        return this._primitive_label;
      } //尚未添加primitive时
      else {
        return this.style.label;
      }
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var addattr = this._conversionStyle(this.style);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.fill, true)) {
        this._primitive = this._createPrimitive(addattr);
      } //添加边线


      if (this.style.outline && !this.style.clampToGround) {
        this._primitive_outline = this._createPrimitive(addattr, true);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      if (this._primitive_outline) {
        this.primitiveCollection.remove(this._primitive_outline);
      }

      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);
      }
    } //子类需要继承实现

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return this.style;
    } //创建主体primitive

  }, {
    key: "_createPrimitive",
    value: function _createPrimitive(addattr, outline) {
      if (!addattr.material || addattr.classification || outline) {
        addattr.vertexFormat = addattr.vertexFormat || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"].VERTEX_FORMAT;
      }

      var primitiveOpts = BasePrimitive_objectSpread(BasePrimitive_objectSpread({}, this.options), {}, {
        geometryInstances: this._createGeometryInstance(addattr, outline),
        show: this.show,
        shadows: addattr.shadows //Primitive支持

      });

      delete primitiveOpts.style;
      delete primitiveOpts.attr;

      if (!primitiveOpts.appearance) {
        if (this._createAppearance) {
          primitiveOpts.appearance = this._createAppearance(addattr, primitiveOpts);
        } else if (addattr.material && !addattr.classification && !outline) {
          //存在材质时
          primitiveOpts.appearance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialAppearance"](BasePrimitive_objectSpread({}, addattr));
        } else {
          //纯色时
          if (primitiveOpts.geometryInstances instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]) {
            var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](outline ? addattr.outlineColor : addattr.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW.withAlpha(0.5));
            addattr.translucent = color.alpha != 1;
            primitiveOpts.geometryInstances.attributes = primitiveOpts.geometryInstances.attributes || {};
            primitiveOpts.geometryInstances.attributes.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(color);
            primitiveOpts.geometryInstances.attributes.show = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShowGeometryInstanceAttribute"](this.show);
          } //合并渲染等对象，内部计算得到translucent


          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.translucent)) {
            addattr.translucent = this.translucent;
          }

          primitiveOpts.appearance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"](BasePrimitive_objectSpread({}, addattr));
        }
      }

      var primitive;

      if (this.style.clampToGround) {
        primitiveOpts.classificationType = addattr.classificationType;

        if (this.type === "polylineP" || this.type === "polylineCombine") {
          primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GroundPolylinePrimitive"](primitiveOpts));
        } else {
          primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GroundPrimitive"](primitiveOpts));
        }
      } else if (addattr.classification) {
        primitiveOpts.classificationType = addattr.classificationType || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClassificationType"].CESIUM_3D_TILE;
        primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClassificationPrimitive"](primitiveOpts));
      } else {
        primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"](primitiveOpts));
      }

      this.bindPickId(primitive);
      return primitive;
    } //子类需要继承实现

  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      return this.options.geometryInstances;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleBaseHook",
    value: function _updateStyleBaseHook(newStyle) {
      if (this.czmObject) {
        this._updateStyleHook(newStyle);
      } //同时加文字


      if (newStyle !== null && newStyle !== void 0 && newStyle.label && this._primitive_label) {
        LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, this._primitive_label, this.attr);
      }

      return this;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {*} newStyle 样式信息
     * @param {Cesium.Primitive} primitive 图元对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      var _this = this;

      if (this.isAdded && this.show) {
        this._removedHook();

        this._addedHook(this.style);

        if (this.czmObject) {
          this.bindPickId(this.czmObject);
        }

        if (this.czmObjectEx) {
          this.czmObjectEx.forEach(function (item) {
            _this.bindPickId(item);
          });
        }
      }
    } //添加线面的文本的统一方法

  }, {
    key: "_addLabel",
    value: function _addLabel() {
      var style = this.style.label;

      if (!style || !style.text) {
        return;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height)) {
        style.clampToGround = this.style.clampToGround;
      }

      var labelattr = LabelStyleConver_LabelStyleConver.toCesiumVal(style, {}, this.attr);
      labelattr.position = this._getLablePosition();
      this._primitive_label = this._layer.labelCollection.add(labelattr);
      this.bindPickId(this._primitive_label);
      return this._primitive_label;
    }
  }, {
    key: "_updateLabelPosition",
    value: function _updateLabelPosition() {
      if (this._primitive_label) {
        this._primitive_label.position = this._getLablePosition();
      }
    } //根据配置获取文本的坐标位置

  }, {
    key: "_getLablePosition",
    value: function _getLablePosition() {
      var style = this.style.label;
      var position;

      if (style.position) {
        if (style.position == "center") {
          position = this.centerOfMass;
        } else {
          if (Object(Util["isString"])(style.position)) {
            var cfgPt = Object(Util["template"])(style.position, this.attr, true);

            if (cfgPt) {
              position = LatLngPoint["a" /* LatLngPoint */].parse(cfgPt).toCartesian();
            }
          } else {
            position = LatLngPoint["a" /* LatLngPoint */].parse(style.position).toCartesian();
          }
        }
      }

      if (!position) {
        position = this.center;
      }

      if (!position) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.height) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.height)) {
        var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.height, this.style.height);
        position = Object(PointUtil["setPositionsHeight"])(position, height);
      } //存在垂直高度


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
        position = Object(PointUtil["addPositionsHeight"])(position, this.style.diffHeight);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.setHeight)) {
        position = Object(PointUtil["setPositionsHeight"])(position, style.setHeight);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.addHeight)) {
        position = Object(PointUtil["addPositionsHeight"])(position, style.addHeight);
      }

      return position;
    }
  }]);

  return BasePrimitive;
}(BaseGraphic_BaseGraphic);
// CONCATENATED MODULE: ./src/graphic/primitive/BasePointPrimitive.js







function BasePointPrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BasePointPrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BasePointPrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BasePointPrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BasePointPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = BasePointPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BasePointPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 *
 * 单个坐标的点状 Primitive图元 矢量对象 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @export
 * @class BasePointPrimitive
 * @extends {BasePrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var BasePointPrimitive_BasePointPrimitive = /*#__PURE__*/function (_BasePrimitive) {
  inherits_default()(BasePointPrimitive, _BasePrimitive);

  var _super = BasePointPrimitive_createSuper(BasePointPrimitive);

  function BasePointPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BasePointPrimitive);

    _this = _super.call(this, options); //坐标位置

    if (options.positions) {
      _this.positions = options.positions;
    }

    if (options.position) {
      _this.position = options.position;
    }

    return _this;
  } //=============坐标相关==================

  /**
   * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
   * @type {Cesium.Cartesian3}
   */


  createClass_default()(BasePointPrimitive, [{
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      var _this$_point;

      this._point = LatLngPoint["a" /* LatLngPoint */].parse(value); //按配置调整高度值

      if (this._point) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.setHeight)) {
          this._point.alt = this.style.setHeight;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.addHeight)) {
          this._point.alt = this._point.alt + this.style.addHeight;
        }
      }

      this._position = (_this$_point = this._point) === null || _this$_point === void 0 ? void 0 : _this$_point.toCartesian();

      if (this.czmObject) {
        this._updatePositionsHook();
      }

      if (this._primitive_label) {
        this._updateLabelPosition();
      }
    } //兼容entity的同名属性

  }, {
    key: "positionShow",
    get: function get() {
      return this._position;
    }
    /**
     * 位置坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "point",
    get: function get() {
      return this._point;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */

  }, {
    key: "coordinate",
    get: function get() {
      return this.getCoordinate();
    }
    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "center",
    get: function get() {
      return this.position;
    }
    /**
     * 中心点坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "centerPoint",
    get: function get() {
      return this.point;
    }
    /**
     * 坐标对应的高度值（单位：米）
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      var _this$point;

      return (_this$point = this.point) === null || _this$point === void 0 ? void 0 : _this$point.alt;
    },
    set: function set(val) {
      this.point.alt = val;
      this.position = this.point;
    } //兼容线面的属性，方便标绘统一控制。 start

  }, {
    key: "positions",
    get: function get() {
      return [this.position];
    },
    set: function set(value) {
      if (value && value.length > 0) {
        this.position = value[0];
      }
    }
  }, {
    key: "points",
    get: function get() {
      return [this.point];
    }
  }, {
    key: "coordinates",
    get: function get() {
      return [this.coordinate];
    } //兼容线面的属性，方便标绘统一控制。 end

    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "modelMatrix",
    get: function get() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix;
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll);
      var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollToFixedFrame(this.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll));
      return modelMatrix;
    }
    /**
     * 四周方向角，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "heading",
    get: function get() {
      var _this$style$heading;

      return (_this$style$heading = this.style.heading) !== null && _this$style$heading !== void 0 ? _this$style$heading : 0;
    },
    set: function set(val) {
      this.style.heading = val;
      this.updateModelMatrix();
    }
    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "pitch",
    get: function get() {
      var _this$style$pitch;

      return (_this$style$pitch = this.style.pitch) !== null && _this$style$pitch !== void 0 ? _this$style$pitch : 0;
    },
    set: function set(val) {
      this.style.pitch = val;
      this.updateModelMatrix();
    }
    /**
     * 滚转角，左右搬动的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "roll",
    get: function get() {
      var _this$style$roll;

      return (_this$style$roll = this.style.roll) !== null && _this$style$roll !== void 0 ? _this$style$roll : 0;
    },
    set: function set(val) {
      this.style.roll = val;
      this.updateModelMatrix();
    }
  }, {
    key: "updateModelMatrix",
    value: function updateModelMatrix() {
      if (this._primitive) {
        this._primitive.modelMatrix = this.modelMatrix;
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {//规划功能，需要后期完善
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry(options) {
      return {
        type: "Point",
        coordinates: this.getCoordinate(options === null || options === void 0 ? void 0 : options.noAlt)
      };
    } //以下为对动态属性的坐标的支持

  }, {
    key: "_forPositionProperty",
    value: function _forPositionProperty() {
      var pt = this.options.position;

      if (pt instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"] || pt instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]) {
        this.property = pt;
        this.bindUpdateEvent();
      }
    }
  }, {
    key: "_initSampledPositionProperty",
    value: function _initSampledPositionProperty() {
      this._cacheTimes = [];
      this._clampToTilesetFrame = -1;
      this._maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxCacheCount, 50); //保留的坐标点数量

      var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
      property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].NONE; //当超出样本数据范围时的

      this.property = property;
      this._orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](property);
      this.bindUpdateEvent();
    } //内部自动刷新的方法体

  }, {
    key: "update",
    value: function update(frameState) {
      //自动定时更新坐标
      if (this.property) {
        var nowPt = this.property.getValue(frameState.time);

        if (nowPt) {
          this.position = nowPt;
        }
      }
    }
  }, {
    key: "_getPopupPosition",
    value: function _getPopupPosition() {
      return this.property || this.position || this.center;
    }
    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LatLngPoint|Cesium.Cartesian3} point 指定位置坐标
     * @param {Cesium.JulianDate|String|Number} [currTime=Cesium.JulianDate.now()] 指定时间, 默认为当前时间5秒后。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addDynamicPosition",
    value: function addDynamicPosition(point, currTime) {
      if (!this.property) {
        this._initSampledPositionProperty();
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now();
      } else if (Object(Util["isNumber"])(currTime)) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now(), currTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      } else if (Object(Util["isString"])(currTime)) {
        if (currTime.indexOf("Z") == -1) {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(currTime));
        } else {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(currTime);
        }
      } else if (currTime instanceof Date) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(currTime);
      }

      var pt = LatLngPoint["a" /* LatLngPoint */].parse(point).toCartesian();
      this.property.addSample(currTime, pt);
      this.stopTime = currTime;

      this._cacheTimes.push(currTime);

      return this;
    }
  }, {
    key: "_removeDynamicPosition",
    value: function _removeDynamicPosition() {
      var duoyu = this._cacheTimes.length - this._maxCacheCount;

      if (duoyu > 0) {
        var start = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(this._cacheTimes[0], -0.1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
        var stop = this._cacheTimes[duoyu - 1];
        this.property.removeSamples(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
          start: start,
          stop: stop
        }));

        this._cacheTimes.splice(0, duoyu);
      }
    }
    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {getSurfaceHeight_callback} options.callback  异步计算高度完成后 的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object(PointUtil["getSurfaceHeight"])(this._map.scene, this.position, BasePointPrimitive_objectSpread(BasePointPrimitive_objectSpread({
        asyn: true
      }, options), {}, {
        callback: function callback(newHeight, cartOld) {
          _this2.height = newHeight;

          if (options.callback) {
            options.callback(newHeight, cartOld);
          }
        }
      }));
      return this;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */

  }, {
    key: "getCoordinate",
    value: function getCoordinate(noAlt) {
      return this.point.toArray(noAlt);
    }
  }]);

  return BasePointPrimitive;
}(BasePrimitive_BasePrimitive); //对类是否为点状数据的判断,GraphicUtil内用到

BasePointPrimitive_BasePointPrimitive.isPoint = true;
// CONCATENATED MODULE: ./src/graphic/primitive/PointPrimitive.js






function PointPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = PointPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PointPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 像素点 支持的样式信息
 *
 * @typedef {Object} PointPrimitive.StyleOptions
 *
 * @property {Number} [pixelSize = 10] 像素大小
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 * @property {Number} [outlineWidth = 2] 边框宽度
 *
 * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 指定用于基于距离缩放点。
 * @property {Number} [scaleByDistance_far = 1000000] 上限
 * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
 * @property {Number} [scaleByDistance_near = 1000] 下限
 * @property {Number} [scaleByDistance_nearValue = 1] 比例值
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [visibleDepth = true] 是否被遮挡
 * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
 * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.PointPrimitive
 */

/**
 * 像素点 Primitive矢量数据
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {PointPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
  *
* @export
 * @class PointPrimitive
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PointPrimitive_PointPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(PointPrimitive, _BasePointPrimitive);

  var _super = PointPrimitive_createSuper(PointPrimitive);

  function PointPrimitive() {
    classCallCheck_default()(this, PointPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(PointPrimitive, [{
    key: "primitiveCollection",
    get:
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.PointPrimitiveCollection}
     * @readonly
     */
    function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.pointCollection;
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var addattr = PointStyleConver_PointStyleConver.toCesiumVal(this.style, {
        show: this.show,
        position: this.position
      });
      this._primitive = this.primitiveCollection.add(addattr); //同时加文字

      if (this.style.label) {
        this._addLabel();
      }
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PointStyleConver_PointStyleConver.toCesiumVal(this.style, this.primitive);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._primitive.position = this.position;
    }
  }]);

  return PointPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("pointP", PointPrimitive_PointPrimitive);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditBase.js




function EditBase_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function EditBase_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { EditBase_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { EditBase_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








/**
 * 标绘处理对应的编辑基类
 *
 * @export
 * @class EditBase
 */

var EditBase_EditBase = /*#__PURE__*/function () {
  //========== 构造方法 ==========
  function EditBase(graphic) {
    classCallCheck_default()(this, EditBase);

    this._graphic = graphic;
    this._map = graphic._map;
    this.draggers = [];
  }

  createClass_default()(EditBase, [{
    key: "map",
    get: function get() {
      return this._map;
    }
  }, {
    key: "layer",
    get: function get() {
      return this._graphic._layer;
    }
  }, {
    key: "style",
    get: function get() {
      return this._graphic.style;
    }
  }, {
    key: "type",
    get: function get() {
      return this._graphic.type;
    }
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Object}
     * @readonly
     */

  }, {
    key: "entityGraphic",
    get: function get() {
      return this._graphic.entityGraphic;
    }
  }, {
    key: "positions",
    get: function get() {
      return this._graphic._positions_draw;
    },
    set: function set(value) {
      this._graphic._positions_draw = value;
    }
  }, {
    key: "fire",
    value: function fire(type, data, propagate) {
      if (this._graphic) {
        this._graphic.fire(type, data, propagate);
      }
    }
  }, {
    key: "formatNum",
    value: function formatNum(num, digits) {
      return Object(Util["formatNum"])(num, digits);
    } //激活绘制

  }, {
    key: "activate",
    value: function activate() {
      if (this._enabled) {
        return this;
      }

      this._enabled = true;

      this._graphic._setPositionsToCallback();

      this.destroyDraggers();
      this.bindDraggers();
      this.bindEvent();
      this.fire(EventType.editStart, {
        edittype: this.type,
        graphic: this._graphic
      }, true);
      return this;
    } //释放绘制

  }, {
    key: "disable",
    value: function disable() {
      var _this$_graphic;

      if (!this._enabled) {
        return this;
      }

      this._enabled = false;
      this.unbindEvent();
      this.destroyDraggers();
      this.finish();

      if ((_this$_graphic = this._graphic) !== null && _this$_graphic !== void 0 && _this$_graphic._layer.options.isRestorePositions) {
        this._graphic._cancelPositionsCallback(); //坐标CallbackProperty属性改为实际值,提高效率

      }

      this.fire(EventType.editStop, {
        edittype: this.type,
        graphic: this._graphic
      }, true);
      return this;
    } //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {} //拖拽点 事件

  }, {
    key: "bindEvent",
    value: function bindEvent() {
      this._map.on(EventType.leftDown, this._onLeftDownHandler, this);

      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.leftUp, this._onLeftUpHandler, this);

      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
    }
  }, {
    key: "unbindEvent",
    value: function unbindEvent() {
      this._map.off(EventType.leftDown, this._onLeftDownHandler, this);

      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.leftUp, this._onLeftUpHandler, this);

      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      this._map.scene.screenSpaceCameraController.enableRotate = true;
      this._map.scene.screenSpaceCameraController.enableTilt = true;
      this._map.scene.screenSpaceCameraController.enableTranslate = true;
      this._map.scene.screenSpaceCameraController.enableInputs = true;

      this._map.setCursor(false);

      if (!this._graphic.show) {
        this._graphic.show = true;
      }
    }
  }, {
    key: "_onLeftDownHandler",
    value: function _onLeftDownHandler(event) {
      var result = this._map.mouseEvent.getPickTarget(event.position);

      if (result.layer != this.layer) {
        return;
      }

      var graphic = result === null || result === void 0 ? void 0 : result.graphic;

      if (!graphic || !graphic._isDragger) {
        return;
      }

      this._map.scene.screenSpaceCameraController.enableRotate = false;
      this._map.scene.screenSpaceCameraController.enableTilt = false;
      this._map.scene.screenSpaceCameraController.enableTranslate = false;
      this._map.scene.screenSpaceCameraController.enableInputs = false;

      this._map.setCursor(true);

      graphic._closeAllControl();

      this._draggerIng = graphic;
      this._draggerIng.show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](graphic.options.drawShow, false);

      if (graphic.onDragStart) {
        graphic.onDragStart(graphic, result.cartesian || graphic.position);
      }

      this.fire(EventType.editMouseDown, EditBase_objectSpread(EditBase_objectSpread(EditBase_objectSpread({}, event), result), {}, {
        edittype: this.type,
        graphic: this._graphic
      }), true);
    }
  }, {
    key: "_onMouseMoveHandler",
    value: function _onMouseMoveHandler(event) {
      if (this._draggerIng) {
        this._onMouseMoveDraggerHandler(event);
      } else {
        this._onMouseMoveMapHandler(event);
      }
    }
  }, {
    key: "_onMouseMoveDraggerHandler",
    value: function _onMouseMoveDraggerHandler(event) {
      switch (this._draggerIng._pointType) {
        case PointType.MoveHeight:
          {
            var _this$_map;

            //改变高度垂直拖动
            var dy = event.endPosition.y - event.startPosition.y;
            var position = Object(PointUtil["getPositionValue"])(this._draggerIng.position, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime);
            var tangentPlane = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidTangentPlane"](position);
            var scratchBoundingSphere = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"]();
            var zOffset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
            scratchBoundingSphere.center = position;
            scratchBoundingSphere.radius = 1;
            var metersPerPixel = this._map.scene.frameState.camera.getPixelSize(scratchBoundingSphere, this._map.scene.frameState.context.drawingBufferWidth, this._map.scene.frameState.context.drawingBufferHeight) * 1.5;
            external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
            var newPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(position);
            external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(position, zOffset, newPosition);
            this._draggerIng.position = newPosition;

            if (this._draggerIng.onDrag) {
              this._draggerIng.onDrag(this._draggerIng, newPosition, position);
            }

            this.updateAttrForEditing();
            break;
          }

        default:
          {
            //默认修改位置
            this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_释放后完成修改"));

            var cartesian = Object(PointUtil["getCurrentMousePosition"])(this._map.scene, event.endPosition, this._graphic._entity);

            if (cartesian) {
              this._draggerIng.position = cartesian;

              if (this._draggerIng.onDrag) {
                this._draggerIng.onDrag(this._draggerIng, cartesian);
              }

              this.updateAttrForEditing();
            }
          }
          break;
      }

      this.fire(EventType.editMouseMove, EditBase_objectSpread(EditBase_objectSpread({}, event), {}, {
        windowPosition: event.endPosition,
        edittype: this.type,
        graphic: this._graphic
      }), true);
    }
  }, {
    key: "_onMouseMoveMapHandler",
    value: function _onMouseMoveMapHandler(event) {
      var _this$_graphic2, _this$_graphic2$_posi;

      var result = this._map.mouseEvent.getPickTarget(event.endPosition);

      var graphic = result === null || result === void 0 ? void 0 : result.graphic;

      if (graphic == null) {
        this._map.closeSmallTooltip();

        return;
      }

      if (result.layer != this.layer || !graphic._isDragger) {
        return;
      } //右键菜单打开了，跳出


      if (this._map.contextmenu.show && this._map.contextmenu.target == graphic) {
        return;
      }

      var _draw_tooltip = graphic._draw_tooltip;

      if (!_draw_tooltip) {
        return;
      }

      if (PointType.Control == graphic._pointType && ((_this$_graphic2 = this._graphic) === null || _this$_graphic2 === void 0 ? void 0 : (_this$_graphic2$_posi = _this$_graphic2._positions_draw) === null || _this$_graphic2$_posi === void 0 ? void 0 : _this$_graphic2$_posi.length) > this._graphic._minPointNum) {
        //可删除时，提示右击删除
        _draw_tooltip += "<br/>" + this._map.getLangText("_右击删除该点");
      }

      this._map.openSmallTooltip(event.endPosition, _draw_tooltip);
    }
  }, {
    key: "_onLeftUpHandler",
    value: function _onLeftUpHandler(event) {
      var _this$_map2;

      if (!this._draggerIng) {
        return;
      }

      this._draggerIng.show = true;
      var position = Object(PointUtil["getPositionValue"])(this._draggerIng.position, (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : _this$_map2.clock.currentTime);

      if (this._draggerIng.onDragEnd) {
        this._draggerIng.onDragEnd(this._draggerIng, position);
      }

      this.updateAttrForEditing();
      this._draggerIng = null;

      this._map.setCursor(false);

      this._map.scene.screenSpaceCameraController.enableRotate = true;
      this._map.scene.screenSpaceCameraController.enableTilt = true;
      this._map.scene.screenSpaceCameraController.enableTranslate = true;
      this._map.scene.screenSpaceCameraController.enableInputs = true;
      this.fire(EventType.editMovePoint, EditBase_objectSpread(EditBase_objectSpread({}, event), {}, {
        edittype: this.type,
        graphic: this._graphic,
        cartesian: position
      }), true);
    }
  }, {
    key: "_onRightClickHandler",
    value: function _onRightClickHandler(event) {
      //右击删除上一个点
      var result = this._map.mouseEvent.getPickTarget(event.position);

      if (result.layer != this.layer) {
        return;
      }

      var graphic = result === null || result === void 0 ? void 0 : result.graphic;

      if (!graphic || !graphic._isDragger || graphic._pointType != PointType.Control) {
        return;
      }

      var isDelOk = this.deletePointForDragger(graphic, event.position);

      if (isDelOk) {
        this.fire(EventType.editRemovePoint, EditBase_objectSpread(EditBase_objectSpread({}, event), {}, {
          edittype: this.type,
          graphic: this._graphic
        }), true);
      }
    } //创建Dragger拖动点的公共方法

  }, {
    key: "createDragger",
    value: function createDragger(options) {
      var dragger;

      if (options.dragger) {
        dragger = options.dragger;
      } else {
        dragger = new PointPrimitive_PointPrimitive({
          position: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.position, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO),
          style: getEditPointStyle(options.type)
        });
        this.layer.addGraphic(dragger);
      }

      dragger._draw_tooltip = this._map.getLangText("_拖动该点后") + "<br/>" + (options.tooltip || this._map.getLangText("_修改位置"));
      dragger._isDragger = true;
      dragger._noMousePick = true; //不被getCurrentMousePosition拾取

      dragger._pointType = options.type || PointType.Control; //默认是位置控制拖拽点

      dragger.onDragStart = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.onDragStart, null);
      dragger.onDrag = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.onDrag, null);
      dragger.onDragEnd = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.onDragEnd, null);
      dragger._parent = this._graphic; //右键删除时关联删除对应的graphic

      return dragger;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {}
  }, {
    key: "destroyDraggers",
    value: function destroyDraggers() {
      for (var i = 0, len = this.draggers.length; i < len; i++) {
        this.layer.removeGraphic(this.draggers[i], true);
      }

      this.draggers = [];
    }
  }, {
    key: "updateDraggers",
    value: function updateDraggers() {
      if (!this._enabled) {
        return this;
      }

      this.destroyDraggers();
      this.bindDraggers();
    } //删除点

  }, {
    key: "deletePointForDragger",
    value: function deletePointForDragger(dragger, position) {
      var _this$_graphic3;

      if (!((_this$_graphic3 = this._graphic) !== null && _this$_graphic3 !== void 0 && _this$_graphic3._positions_draw)) {
        return;
      }

      if (this._graphic._positions_draw.length - 1 < this._graphic._minPointNum) {
        this._map.openSmallTooltip(position, this._map.getLangText("_无法删除不能少于最小点数") + " " + this._graphic._minPointNum);

        return false;
      }

      var index = dragger.index;

      if (index >= 0 && index < this._graphic._positions_draw.length) {
        this._graphic._positions_draw.splice(index, 1);

        this.updateDraggers();
        this.updateAttrForEditing();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      this._graphic.updateAttrForDrawing(true);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {}
  }, {
    key: "destroy",
    value: function destroy() {
      this.disable(); //删除所有绑定的数据

      for (var i in this) {
        delete this[i];
      }
    }
  }]);

  return EditBase;
}();
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditPoint.js






function EditPoint_createSuper(Derived) { var hasNativeReflectConstruct = EditPoint_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditPoint_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var EditPoint_EditPoint = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditPoint, _EditBase);

  var _super = EditPoint_createSuper(EditPoint);

  function EditPoint() {
    classCallCheck_default()(this, EditPoint);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditPoint, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      this.createDragger({
        dragger: this._graphic,
        onDrag: function onDrag(dragger, newPosition) {
          _this._graphic._position_draw = newPosition;
        }
      });
    } //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      delete this._graphic._draw_tooltip;
      delete this._graphic._isDragger;
      delete this._graphic._noMousePick;
      delete this._graphic._pointType;
      delete this._graphic.onDrag;
    }
  }]);

  return EditPoint;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/BasePointEntity.js








function BasePointEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BasePointEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BasePointEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BasePointEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BasePointEntity_createSuper(Derived) { var hasNativeReflectConstruct = BasePointEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BasePointEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 单个坐标的点状Entity矢量数据 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {Cesium.Property} [options.orientation] 指定实体方向的属性。
 *
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 * @param {Cesium.Entity} [options.entity] 传入外部已经构造好的Entity对象
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
 * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
 * @param {Number} [options.frameRate=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
 *
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class BasePointEntity
 * @extends {BaseEntity}
 *
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var BasePointEntity_BasePointEntity = /*#__PURE__*/function (_BaseEntity) {
  inherits_default()(BasePointEntity, _BaseEntity);

  var _super = BasePointEntity_createSuper(BasePointEntity);

  function BasePointEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BasePointEntity);

    //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
    options.drawShow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.drawShow, true);
    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minPointNum, 1); //至少需要点的个数

    _this._maxPointNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxPointNum, 1); //最多允许点的个数

    _this.hasEdit = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.hasEdit, true); //是否允许编辑
    //已经存在entity时

    if (options.entity) {
      _this.position = options.entity.position;
    } //坐标位置


    if (options.positions) {
      _this.positions = options.positions;
    }

    if (options.position) {
      _this.position = options.position;
    }

    return _this;
  } //=============坐标相关==================

  /**
   * 编辑处理类
   * @type {EditPoint}
   * @readonly
   */


  createClass_default()(BasePointEntity, [{
    key: "EditClass",
    get: function get() {
      return EditPoint_EditPoint;
    }
    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3}
     */

  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      var _this$_point;

      this._point = LatLngPoint["a" /* LatLngPoint */].parse(value); //按配置调整高度值

      if (this._point) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.setHeight)) {
          this._point.alt = this.style.setHeight;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.addHeight)) {
          this._point.alt = this._point.alt + this.style.addHeight;
        }
      }

      var _position = (_this$_point = this._point) === null || _this$_point === void 0 ? void 0 : _this$_point.toCartesian();

      if (_position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"] && this._enabledEdit && this.editing) {
        var _this$_positions_draw;

        this._position_draw = _position;

        if (_position && ((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 0) {
          this._positions_draw[0] = _position;
        }
      } else {
        this._position = _position;
      }

      if (this._entity) {
        this._updatePositionsHook();
      }
    }
  }, {
    key: "positionShow",
    get: function get() {
      var _this$_map;

      return Object(PointUtil["getPositionValue"])(this.position, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime);
    }
    /**
     * 位置坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "point",
    get: function get() {
      if (!(this._position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"])) {
        this._point = LatLngPoint["a" /* LatLngPoint */].parse(this.positionShow);
      }

      return this._point;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */

  }, {
    key: "coordinate",
    get: function get() {
      return this.point.toArray();
    }
    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "center",
    get: function get() {
      var _this$_map2;

      return Object(PointUtil["getPositionValue"])(this.positionShow, (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : _this$_map2.clock.currentTime); //回调时需要取值
    }
    /**
     * 中心点坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "centerPoint",
    get: function get() {
      return this.point;
    } //兼容线面的属性，方便标绘统一控制。 start

  }, {
    key: "positions",
    get: function get() {
      if (this.position) {
        return [this.position];
      } else {
        return [];
      }
    },
    set: function set(value) {
      if (value && value.length > 0) {
        this.position = value[0];
      }
    }
  }, {
    key: "points",
    get: function get() {
      if (this.point) {
        return [this.point];
      } else {
        return [];
      }
    }
  }, {
    key: "coordinates",
    get: function get() {
      if (this.coordinate) {
        return [this.coordinate];
      } else {
        return [];
      }
    }
  }, {
    key: "positionsShow",
    get: function get() {
      if (this.positionShow) {
        return [this.positionShow];
      } else {
        return [];
      }
    } //兼容线面的属性，方便标绘统一控制。 end

    /**
     * 三维空间中的旋转。
     * @type {Cesium.Quaternion}
     * @readonly
     */

  }, {
    key: "orientation",
    get: function get() {
      return this.options.orientation;
    },
    set: function set(val) {
      this.options.orientation = val;
      this.updateOrientation();
    }
    /**
     * 四周方向角，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "heading",
    get: function get() {
      var _this$style$heading;

      return (_this$style$heading = this.style.heading) !== null && _this$style$heading !== void 0 ? _this$style$heading : 0;
    },
    set: function set(val) {
      this.style.heading = val;
      this.updateOrientation();
    }
    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "pitch",
    get: function get() {
      var _this$style$pitch;

      return (_this$style$pitch = this.style.pitch) !== null && _this$style$pitch !== void 0 ? _this$style$pitch : 0;
    },
    set: function set(val) {
      this.style.pitch = val;
      this.updateOrientation();
    }
    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "roll",
    get: function get() {
      var _this$style$roll;

      return (_this$style$roll = this.style.roll) !== null && _this$style$roll !== void 0 ? _this$style$roll : 0;
    },
    set: function set(val) {
      this.style.roll = val;
      this.updateOrientation();
    }
    /**
     * 坐标对应的高度值（单位：米）
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      var _this$point;

      return (_this$point = this.point) === null || _this$point === void 0 ? void 0 : _this$point.alt;
    },
    set: function set(val) {
      this.point.alt = val;
      this.position = this.point;
    }
    /**
     * 获取当前转换计算模型矩阵。如果方向或位置未定义，则返回undefined。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "modelMatrix",
    get: function get() {
      if (this._entity) {
        var _this$_map3, _this$_map3$clock;

        return this._entity.computeModelMatrix((_this$_map3 = this._map) === null || _this$_map3 === void 0 ? void 0 : (_this$_map3$clock = _this$_map3.clock) === null || _this$_map3$clock === void 0 ? void 0 : _this$_map3$clock.currentTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      } else {
        return undefined;
      }
    }
    /**
     * 是否显示3个方向轴，用于对比测试
     * @type {Boolean}
     */

  }, {
    key: "debugAxis",
    get: function get() {
      return this._debugAxis;
    },
    set: function set(value) {
      var _this2 = this;

      this._debugAxis = value;

      if (!this.debugAxisPrimitive) {
        var axislength = Math.max(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this.positionShow).height * 0.06, 100);
        this.debugAxisPrimitive = this._layer.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DebugModelMatrixPrimitive"]({
          modelMatrix: this.modelMatrix,
          length: axislength,
          //默认 debugAxisLength
          width: 5.0
        }));
        this.debugAxisPrimitive.tooltip = "\n        <span style=\"color: red;\">\u7EA2\u8272</span> \u662F X\u8F74<br/>\n        <span style=\"color: green;\">\u7EFF\u8272</span> \u662F Y\u8F74<br/>\n        <span style=\"color: blue;\">\u84DD\u8272</span> \u662F Z\u8F74";

        if (this.position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"] || this.position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]) {
          this.debugAxisPrimitive._timeTik = setInterval(function () {
            _this2.debugAxisPrimitive.modelMatrix = _this2.modelMatrix;
          }, 300);
        }

        this.bindPickId(this.debugAxisPrimitive);
      }

      this.debugAxisPrimitive.show = value;
    }
    /**
     * 显示3个方向轴时的对应轴长度，用于对比测试
     * @type {Number}
     */

  }, {
    key: "debugAxisLength",
    get: function get() {
      if (this.debugAxisPrimitive) {
        return this.debugAxisPrimitive.length;
      } else {
        return 0;
      }
    },
    set: function set(value) {
      if (!this.debugAxisPrimitive) {
        this.debugAxis = true;
      }

      this.debugAxisPrimitive.length = value;
    }
    /**
     * 贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities 等
     * @type {Object[]|undefined}
     * @readonly
     */

  }, {
    key: "objectsToExclude",
    get: function get() {
      var _this$_entity;

      if (this.options.objectsToExclude) {
        return this.options.objectsToExclude;
      }

      if ((_this$_entity = this._entity) !== null && _this$_entity !== void 0 && _this$_entity.model) {
        return [this._entity];
      }

      return undefined;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(BasePointEntity.prototype), "_removedHook", this).call(this);

      if (this.debugAxisPrimitive) {
        clearInterval(this.debugAxisPrimitive._timeTik);

        this._layer.primitiveCollection.remove(this.debugAxisPrimitive);

        delete this.debugAxisPrimitive;
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._entity.position = this._position;

      if (this.debugAxisPrimitive) {
        this.debugAxisPrimitive.modelMatrix = this.modelMatrix;
      } //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    }
    /**
     * 更新 三维空间中的Quaternion旋转对象。
     *
     * @return {Cesium.Quaternion} 更新后的Quaternion旋转对象
     */

  }, {
    key: "updateOrientation",
    value: function updateOrientation() {
      this._entity.orientation = this.getOrientation();

      if (this.debugAxisPrimitive) {
        this.debugAxisPrimitive.modelMatrix = this.modelMatrix;
      }

      return this._entity.orientation;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      var _this3 = this;

      if (this.options.orientation) {
        if (this.options.orientation instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"] && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.heading)) {
          var originOrientation = this.options.orientation; //由于模型不是标准的方向时的处理

          var _heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.style.heading);

          this.options.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            var _this3$_map, _this3$_map$scene;

            var position = Object(PointUtil["getPositionValue"])(_this3.position, time);
            var orientation = originOrientation.getValue(time);

            if (!position || !orientation) {
              return null;
            }

            var hpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, orientation);
            hpr.heading += _heading;
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr, (_this3$_map = _this3._map) === null || _this3$_map === void 0 ? void 0 : (_this3$_map$scene = _this3$_map.scene) === null || _this3$_map$scene === void 0 ? void 0 : _this3$_map$scene.globe.ellipsoid);
          }, false);
        }

        return this.options.orientation;
      }

      var position = this.positionShow;

      if (position == null) {
        return;
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll);
      var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll);
      var orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr);
      return orientation;
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Point",
        coordinates: this.coordinate
      };
    }
    /**
     * 清除addDynamicPosition添加的动态轨迹
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clearDynamicPosition",
    value: function clearDynamicPosition() {
      this._cacheTimes = [];
      this.property = null;
      this.position = undefined;
      return this;
    }
  }, {
    key: "_initSampledPositionProperty",
    value: function _initSampledPositionProperty() {
      var _this4 = this;

      this._cacheTimes = [];
      this._clampToTilesetFrame = -1;
      this._frameRate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.frameRate, 30);
      this._maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxCacheCount, 50); //保留的坐标点数量

      var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
      property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD; //当超出样本数据范围时使用第一个或最后一个值。

      if (!this.options.orientation) {
        this.options.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](property);

        if (this._entity) {
          this._entity.orientation = this.getOrientation();
        }
      }

      this.property = property;
      this.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        if (!_this4._map) {
          return undefined;
        }

        var position = property.getValue(time);

        if (position && _this4.options.clampToTileset) {
          //贴模型
          _this4._clampToTilesetFrame++;

          if (!_this4._clampToTilesetHeight || _this4._clampToTilesetFrame % _this4._frameRate == 0) {
            _this4._clampToTilesetHeight = Object(PointUtil["getSurfaceHeight"])(_this4._map.scene, position, {
              objectsToExclude: _this4.objectsToExclude
            });
          }

          if (_this4._clampToTilesetHeight) {
            var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
            position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, _this4._clampToTilesetHeight);
          }
        }

        return position;
      }, false);
    }
    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LatLngPoint|Cesium.Cartesian3} point 指定位置坐标
     * @param {Cesium.JulianDate|String|Number} [currTime=Cesium.JulianDate.now()] 指定时间, 默认为当前时间5秒后。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addDynamicPosition",
    value: function addDynamicPosition(point, currTime) {
      if (!this.property) {
        this._initSampledPositionProperty();
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now();
      } else if (Object(Util["isNumber"])(currTime)) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now(), currTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      } else if (Object(Util["isString"])(currTime)) {
        if (currTime.indexOf("Z") == -1) {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(currTime));
        } else {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(currTime);
        }
      }

      var pt = LatLngPoint["a" /* LatLngPoint */].parse(point).toCartesian();
      this.property.addSample(currTime, pt);
      this._lastTime = currTime;

      this._cacheTimes.push(this._lastTime);

      return this;
    }
  }, {
    key: "_removeDynamicPosition",
    value: function _removeDynamicPosition() {
      var duoyu = this._cacheTimes.length - this._maxCacheCount;

      if (duoyu > 0) {
        var start = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(this._cacheTimes[0], -0.1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
        var stop = this._cacheTimes[duoyu - 1];
        this.property.removeSamples(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
          start: start,
          stop: stop
        }));

        this._cacheTimes.splice(0, duoyu);
      }
    }
    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {getSurfaceHeight_callback} options.callback  异步计算高度完成后 的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object(PointUtil["getSurfaceHeight"])(this._map.scene, this.position, BasePointEntity_objectSpread(BasePointEntity_objectSpread({
        asyn: true,
        //是否异步求准确高度
        objectsToExclude: this.objectsToExclude
      }, options), {}, {
        callback: function callback(newHeight, cartOld) {
          if (newHeight != 0) {
            _this5.height = newHeight;
          }

          if (options.callback) {
            options.callback(newHeight, cartOld);
          }
        }
      }));
      return this;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */

  }, {
    key: "getCoordinate",
    value: function getCoordinate(noAlt) {
      return this.point.toArray(noAlt);
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this6 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true; //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。

      this.show = this.options.drawShow;
      this._position_draw = this._position;
      this.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this6._position_draw;
      }, false);
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this._position = this._position_draw; // this._updatePositionsHook()

      this._entity.position = this._position;
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler_point, this);

      this._map.on(EventType.click, this._onClickHandler_point, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler_point, this);

      this._map.off(EventType.click, this._onClickHandler_point, this);

      this.show = true; //重置为 true
    }
  }, {
    key: "_onMouseMoveHandler_point",
    value: function _onMouseMoveHandler_point(event) {
      var point = event.cartesian;

      if (point) {
        this._position_draw = point;
      }

      this._map.openSmallTooltip(event.endPosition, this._draw_tooltip || this._map.getLangText("_单击完成绘制"));

      this.fire(EventType.drawMouseMove, BasePointEntity_objectSpread(BasePointEntity_objectSpread({}, event), {}, {
        drawtype: this.type,
        graphic: this
      }), true);
    }
  }, {
    key: "_onClickHandler_point",
    value: function _onClickHandler_point(event) {
      var point = event.cartesian;

      if (point) {
        this._position_draw = point;
      }

      if (this._position_draw) {
        this.stopDraw();
      }
    }
  }]);

  return BasePointEntity;
}(BaseEntity_BaseEntity); //对类是否为点状数据的判断,GraphicUtil内用到

BasePointEntity_BasePointEntity.isPoint = true;
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditPoly.js






function EditPoly_createSuper(Derived) { var hasNativeReflectConstruct = EditPoly_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditPoly_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var EditPoly_EditPoly = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditPoly, _EditBase);

  var _super = EditPoly_createSuper(EditPoly);

  function EditPoly() {
    classCallCheck_default()(this, EditPoly);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditPoly, [{
    key: "hasClosure",
    get: //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    function get() {
      return this.style.closure;
    } //是否可在中间新增点

  }, {
    key: "hasMidPoint",
    get: function get() {
      return this.positions.length < this._graphic._maxPointNum;
    } //是否贴地

  }, {
    key: "clampToGround",
    get: function get() {
      var _this$_graphic, _this$_graphic$style;

      return (_this$_graphic = this._graphic) === null || _this$_graphic === void 0 ? void 0 : (_this$_graphic$style = _this$_graphic.style) === null || _this$_graphic$style === void 0 ? void 0 : _this$_graphic$style.clampToGround;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions;

      var _loop = function _loop(i, len) {
        var position = _this.updatePositionsHeightByAttr(positions[i]); //各顶点


        var dragger = _this.createDragger({
          position: position,
          onDrag: function onDrag(dragger, position) {
            var _this$_heightDraggers;

            position = _this.updatePositionsHeightByAttr(position);
            dragger.position = position;
            _this.positions[dragger.index] = position;

            if (((_this$_heightDraggers = _this._heightDraggers) === null || _this$_heightDraggers === void 0 ? void 0 : _this$_heightDraggers.length) > 0) {
              return;
            } //============新增点拖拽点处理=============


            if (_this.hasMidPoint) {
              var draggersIdx;
              var nextPositionIdx;
              var midpoint; //与前一个点之间的中点

              if (_this.hasClosure || !_this.hasClosure && dragger.index != 0) {
                if (dragger.index == 0) {
                  draggersIdx = len * 2 - 1;
                  nextPositionIdx = len - 1;
                } else {
                  draggersIdx = dragger.index * 2 - 1;
                  nextPositionIdx = dragger.index - 1;
                }

                var nextPosition = positions[nextPositionIdx];
                midpoint = Object(PointUtil["getMidpoint"])(position, nextPosition);
                midpoint = _this.updatePositionsHeightByAttr(midpoint);
                _this.draggers[draggersIdx].position = midpoint;
              } //与后一个点之间的中点


              if (_this.hasClosure || !_this.hasClosure && dragger.index != len - 1) {
                if (dragger.index == len - 1) {
                  draggersIdx = dragger.index * 2 + 1;
                  nextPositionIdx = 0;
                } else {
                  draggersIdx = dragger.index * 2 + 1;
                  nextPositionIdx = dragger.index + 1;
                }

                midpoint = Object(PointUtil["getMidpoint"])(position, positions[nextPositionIdx]);
                midpoint = _this.updatePositionsHeightByAttr(midpoint);
                _this.draggers[draggersIdx].position = midpoint;
              }
            } //============整体平移移动点处理=============


            if (_this._draggerMove) {
              var positionMove = centerOfMass(positions);
              positionMove = _this.updatePositionsHeightByAttr(positionMove);
              _this._draggerMove.position = positionMove;
            }
          },
          onDragStart: function onDragStart(dragger, position) {
            var _this$_heightDraggers2;

            if (((_this$_heightDraggers2 = _this._heightDraggers) === null || _this$_heightDraggers2 === void 0 ? void 0 : _this$_heightDraggers2.length) > 0) {
              for (var _i = 0, _len = _this.draggers.length; _i < _len; _i++) {
                _this.draggers[_i].show = false;
              }
            }
          },
          onDragEnd: function onDragEnd(dragger, position) {
            var _this$_heightDraggers3;

            if (((_this$_heightDraggers3 = _this._heightDraggers) === null || _this$_heightDraggers3 === void 0 ? void 0 : _this$_heightDraggers3.length) > 0) {
              _this.updateDraggers();
            }
          }
        });

        dragger.index = i;

        _this.draggers.push(dragger); //中间点，拖动后新增点


        if (_this.hasMidPoint && (_this.hasClosure || !_this.hasClosure && i < len - 1)) {
          var nextIndex = (i + 1) % len;
          var midpoint = Object(PointUtil["getMidpoint"])(position, positions[nextIndex]);
          midpoint = _this.updatePositionsHeightByAttr(midpoint);

          var draggerMid = _this.createDragger({
            position: midpoint,
            type: PointType.AddMidPoint,
            tooltip: _this._map.getLangText("_增加点"),
            onDragStart: function onDragStart(dragger, position) {
              _this.positions.splice(dragger.index, 0, position); //插入点

            },
            onDrag: function onDrag(dragger, position) {
              _this.positions[dragger.index] = position;
            },
            onDragEnd: function onDragEnd(dragger, position) {
              _this.updateDraggers();
            }
          });

          draggerMid.index = nextIndex;

          _this.draggers.push(draggerMid);
        }
      };

      for (var i = 0, len = positions.length; i < len; i++) {
        _loop(i, len);
      } //整体平移移动点


      this._bindMoveAllDragger(); //创建高度拖拽点


      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    } //整体平移移动点

  }, {
    key: "_bindMoveAllDragger",
    value: function _bindMoveAllDragger() {
      var _this2 = this;

      if (!this._graphic._hasMoveEdit) {
        return;
      }

      var positionMove = centerOfMass(this.positions);
      positionMove = this.updatePositionsHeightByAttr(positionMove);
      var draggerMove = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: function onDrag(dragger, position) {
          // position = this.updatePositionsHeightByAttr(position)
          // dragger.position = position
          //记录差值
          var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, positionMove, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          positionMove = position;

          _this2.positions.forEach(function (pos, index, arr) {
            var newPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(pos, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
            _this2.positions[index] = newPos;
          });

          for (var i = 0, len = _this2.draggers.length; i < len; i++) {
            if (draggerMove !== _this2.draggers[i]) {
              _this2.draggers[i].position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(_this2.draggers[i].position, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
            }
          }
        } // onDragStart: (dragger, position) => {
        //   for (let i = 0, len = this.draggers.length; i < len; i++) {
        //     this.draggers[i].show = false
        //   }
        // },
        // onDragEnd: (dragger, position) => {
        //   this.updateDraggers()
        // },

      });
      this._draggerMove = draggerMove;
      this.draggers.push(draggerMove);
    } //高度调整拖拽点

  }, {
    key: "_bindHeightDraggers",
    value: function _bindHeightDraggers(positions) {
      var _this3 = this;

      this._heightDraggers = [];
      positions = positions || this.positions;
      var extrudedHeight = Object(Util["getCesiumValue"])(this.entityGraphic.extrudedHeight, Number, this._map.clock.currentTime);

      for (var i = 0, len = positions.length; i < len; i++) {
        var loc = Object(PointUtil["setPositionsHeight"])(positions[i], extrudedHeight);
        var dragger = this.createDragger({
          position: loc,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改高度"),
          onDrag: function onDrag(dragger, position) {
            var thisHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position).height;
            _this3.entityGraphic.extrudedHeight = thisHeight;
            var maxHeight = Object(PointUtil["getMaxHeight"])(_this3.positions);
            _this3.style.diffHeight = _this3.formatNum(thisHeight - maxHeight, 2);

            _this3.updateHeightDraggers(thisHeight);

            _this3.updateAttrForEditing();
          }
        });
        this.draggers.push(dragger);

        this._heightDraggers.push(dragger);
      }
    }
  }, {
    key: "updateHeightDraggers",
    value: function updateHeightDraggers(extrudedHeight) {
      for (var i = 0; i < this._heightDraggers.length; i++) {
        var _this$_map;

        var heightDragger = this._heightDraggers[i];
        var position = Object(PointUtil["setPositionsHeight"])(Object(PointUtil["getPositionValue"])(heightDragger.position, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime), extrudedHeight);
        heightDragger.position = position;
      }
    } //根据属性更新坐标

  }, {
    key: "updatePositionsHeightByAttr",
    value: function updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        //贴地时求贴模型和贴地的高度
        position = Object(PointUtil["getSurfacePosition"])(this._map, position);
      }

      return position;
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditPoly;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/BasePolyEntity.js






function BasePolyEntity_createSuper(Derived) { var hasNativeReflectConstruct = BasePolyEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BasePolyEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 *
 * 多个坐标的线面状  Entity矢量数据 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 *
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class BasePolyEntity
 * @extends {BaseEntity}
 *
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var BasePolyEntity_BasePolyEntity = /*#__PURE__*/function (_BaseEntity) {
  inherits_default()(BasePolyEntity, _BaseEntity);

  var _super = BasePolyEntity_createSuper(BasePolyEntity);

  function BasePolyEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BasePolyEntity);

    _this = _super.call(this, options);
    _this.hasEdit = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.hasEdit, true); //是否允许编辑
    //配置的参数

    _this._minPointNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minPointNum, 2); //至少需要点的个数

    _this._maxPointNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxPointNum, 9999); //最多允许点的个数

    _this._hasMoveEdit = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.hasMoveEdit, true); //是否可以整体平移
    //坐标位置

    if (options.positions) {
      _this.positions = options.positions;
    }

    return _this;
  } //=============坐标相关==================

  /**
   * 编辑处理类
   * @type {EditPoly}
   * @readonly
   */


  createClass_default()(BasePolyEntity, [{
    key: "EditClass",
    get: function get() {
      return EditPoly_EditPoly;
    }
    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "center",
    get: function get() {
      if (this.style.closure) {
        return this.centerOfMass;
      } else {
        return this.centerOfLine;
      }
    }
    /**
     * 围合面的内部中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "centerOfMass",
    get: function get() {
      var pots = this.positionsShow;

      if (!pots || pots.length < 2) {
        return null;
      }

      return centerOfMass(pots);
    }
    /**
     * 边线的中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "centerOfLine",
    get: function get() {
      var pots = this.positionsShow;

      if (!pots || pots.length < 2) {
        return null;
      }

      if (pots.length < 10) {
        return sliceByMaxDistance(pots, this.distance / 2, {
          point: true
        });
      } else {
        return pots[Math.floor(pots.length / 2)];
      }
    }
    /**
     * 距离（单位：米）
     * @type {Number}
     * @readonly
     */

  }, {
    key: "distance",
    get: function get() {
      return getDistance(this.positionsShow);
    }
    /**
     * 面积（单位：平方米）
     * @type {Number}
     * @readonly
     */

  }, {
    key: "area",
    get: function get() {
      return getArea(this.positionsShow);
    }
    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(value) {
      var _this2 = this;

      if (!value) {
        return;
      }

      if (Array.isArray(value)) {
        var _points = [];
        var _positions = [];
        value.forEach(function (item, index) {
          var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

          if (!_point) {
            return;
          } //按配置调整高度值


          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this2.style.setHeight)) {
            if (Array.isArray(_this2.style.setHeight)) {
              _point.alt = _this2.style.setHeight[index] || 0;
            } else {
              _point.alt = _this2.style.setHeight;
            }
          }

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this2.style.addHeight)) {
            if (Array.isArray(_this2.style.addHeight)) {
              if (_this2.style.addHeight[index]) {
                _point.alt = _point.alt + _this2.style.addHeight[index];
              }
            } else {
              _point.alt = _point.alt + _this2.style.addHeight;
            }
          }

          _points.push(_point);

          _positions.push(_point.toCartesian());
        });

        if (this._enabledEdit && this.editing) {
          this._positions_draw = _positions;
        } else {
          this._positions = _positions;
        }

        this._points = _points;
      } else {
        this._positions = value;
      }

      if (this._entity) {
        this._updatePositionsHook();
      }
    }
    /**
     * 实际显示的坐标数组 （笛卡尔坐标），
     * 如标绘中时positions对应的可能只是控制点坐标或CallbackProperty属性
     *
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */

  }, {
    key: "positionsShow",
    get: function get() {
      var pots = Object(Util["getCesiumValue"])(this._positions);

      if (pots instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]) {
        pots = pots.positions;
      } else if (pots instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]) {
        pots = this.outlinePositions;
      }

      return pots;
    }
    /**
     * 位置坐标数组
     * @type {LatLngPoint[]}
     * @readonly
     */

  }, {
    key: "points",
    get: function get() {
      if (this._positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
        //callback属性时
        var _positions;

        if (this._positions_draw) {
          _positions = this._positions_draw;
        } else {
          _positions = this.positionsShow;

          if (this.style.closure) {
            _positions.pop(); //闭合时删除最后一个

          }
        }

        var _points = [];

        _positions.forEach(function (item) {
          var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

          if (!_point) {
            return;
          }

          _points.push(_point);
        });

        this._points = _points;
      }

      return this._points;
    }
    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @type {Array[]}
     * @readonly
     */

  }, {
    key: "coordinates",
    get: function get() {
      return this.getCoordinates();
    }
    /**
     * 坐标数据对应的矩形边界
     * @type {Cesium.Rectangle}
     * @readonly
     */

  }, {
    key: "rectangle",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
    } //获取entity的实际坐标值

  }, {
    key: "getEntityPositions",
    value: function getEntityPositions() {
      return this.entityGraphic.positions;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._updateLabelPosition(); //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry(options) {
      return {
        type: "LineString",
        coordinates: this.getCoordinates(options === null || options === void 0 ? void 0 : options.noAlt)
      };
    }
    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates(noAlt) {
      var coords = [];
      this.points.forEach(function (item) {
        coords.push(item.toArray(noAlt));
      });
      return coords;
    }
    /**
     * 判断点是否在当前对象的坐标点围成的多边形内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在多边形内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      var point = LatLngPoint["a" /* LatLngPoint */].parse(position); //面的时候，为了提高效率，先判断是否在外接矩形内

      var isInArea = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].contains(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positionsShow), point.toCartographic());

      if (!isInArea) {
        return false;
      }

      var pt = {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: point.toArray()
        }
      };
      var coordinates = this.coordinates;
      var poly = {
        type: "Polygon",
        coordinates: [coordinates]
      };
      return Object(turf_root_turf_["booleanPointInPolygon"])(pt, poly); //turf插件计算的
    }
    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @param {surfaceLineWork_callback} options.callback  异步计算高度完成后 的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //求对比的贴地地面高度
      computeSurfacePoints({
        map: this._map,
        positions: this.positionsShow,
        //需要计算的源路线坐标数组
        callback: function callback(raisedPositions, noHeight) {
          if (!noHeight) {
            _this3.positions = raisedPositions;
          }

          if (options.callback) {
            options.callback(raisedPositions, noHeight);
          }
        }
      });
      return this;
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this4 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true;
      this._positions_draw = this._positions || [];
      this.positions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this4._positions_CallbackProperty();
      }, false); //存在边线时

      this._updateOutlineToCallback();

      this.updateAttrForDrawing && this.updateAttrForDrawing(true);
    }
  }, {
    key: "_positions_CallbackProperty",
    value: function _positions_CallbackProperty() {
      return this._positions_draw;
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this._positions = this._positions_draw;

      this._updatePositionsHook();

      this._cancelOutlinePositionsCallback();
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.rightClick, this._onRightClickHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }
  }]);

  return BasePolyEntity;
}(BaseEntity_BaseEntity);
// CONCATENATED MODULE: ./src/graphic/primitive/BasePolyPrimitive.js






function BasePolyPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = BasePolyPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BasePolyPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 *
 * 多个坐标的线面状 Primitive图元 矢量对象 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 *
 *
 * @export
 * @class BasePolyPrimitive
 * @extends {BasePrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var BasePolyPrimitive_BasePolyPrimitive = /*#__PURE__*/function (_BasePrimitive) {
  inherits_default()(BasePolyPrimitive, _BasePrimitive);

  var _super = BasePolyPrimitive_createSuper(BasePolyPrimitive);

  function BasePolyPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BasePolyPrimitive);

    _this = _super.call(this, options);

    if (options.positions) {
      //坐标位置
      _this.positions = options.positions;
    }

    return _this;
  } //=============坐标相关==================

  /**
   * 中心点坐标 （笛卡尔坐标）
   * @type {Cesium.Cartesian3}
   * @readonly
   */


  createClass_default()(BasePolyPrimitive, [{
    key: "center",
    get: function get() {
      if (this.style.closure) {
        return this.centerOfMass;
      } else {
        return this.centerOfLine;
      }
    }
    /**
     * 围合面的内部中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "centerOfMass",
    get: function get() {
      return centerOfMass(this.positions);
    }
    /**
     * 边线的中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "centerOfLine",
    get: function get() {
      var pots = this.positions;

      if (!pots || pots.length < 2) {
        return null;
      }

      if (pots.length < 10) {
        return sliceByMaxDistance(pots, this.distance / 2, {
          point: true
        });
      } else {
        return pots[Math.floor(pots.length / 2)];
      }
    }
    /**
     * 距离（单位：米）
     * @type {Number}
     * @readonly
     */

  }, {
    key: "distance",
    get: function get() {
      return getDistance(this.positions);
    }
    /**
     * 面积（单位：平方米）
     * @type {Number}
     * @readonly
     */

  }, {
    key: "area",
    get: function get() {
      return getArea(this.positions);
    }
    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(value) {
      var _this2 = this;

      if (!value) {
        return;
      }

      var _points = [];
      var _positions = [];
      value.forEach(function (item, index) {
        var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

        if (!_point) {
          return;
        } //按配置调整高度值


        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this2.style.setHeight)) {
          if (Array.isArray(_this2.style.setHeight)) {
            _point.alt = _this2.style.setHeight[index] || 0;
          } else {
            _point.alt = _this2.style.setHeight;
          }
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this2.style.addHeight)) {
          if (Array.isArray(_this2.style.addHeight)) {
            if (_this2.style.addHeight[index]) {
              _point.alt = _point.alt + _this2.style.addHeight[index];
            }
          } else {
            _point.alt = _point.alt + _this2.style.addHeight;
          }
        }

        _points.push(_point);

        _positions.push(_point.toCartesian());
      });
      this._points = _points;
      this._positions = _positions;

      if (this._primitive) {
        this._updatePositionsHook();
      }

      if (this._primitive_label) {
        this._updateLabelPosition();
      }
    }
    /**
     * 位置坐标数组
     * @type {LatLngPoint[]}
     * @readonly
     */

  }, {
    key: "points",
    get: function get() {
      return this._points;
    }
    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @type {Array[]}
     * @readonly
     */

  }, {
    key: "coordinates",
    get: function get() {
      return this.getCoordinates();
    }
    /**
     * 坐标数据对应的矩形边界
     * @type {Cesium.Rectangle}
     * @readonly
     */

  }, {
    key: "rectangle",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      var _this3 = this;

      if (this.isAdded && this.show) {
        this._removedHook();

        this._addedHook(this.style);

        if (this.czmObject) {
          this.bindPickId(this.czmObject);
        }

        if (this.czmObjectEx) {
          this.czmObjectEx.forEach(function (item) {
            _this3.bindPickId(item);
          });
        }
      }
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry(options) {
      return {
        type: "LineString",
        coordinates: this.getCoordinates(options === null || options === void 0 ? void 0 : options.noAlt)
      };
    }
    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */

  }, {
    key: "getCoordinates",
    value: function getCoordinates(noAlt) {
      var coords = [];
      this.points.forEach(function (item) {
        coords.push(item.toArray(noAlt));
      });
      return coords;
    }
    /**
     * 判断点是否在当前对象的坐标点围成的多边形内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在多边形内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      var point = LatLngPoint["a" /* LatLngPoint */].parse(position); //面的时候，为了提高效率，先判断是否在外接矩形内

      var isInArea = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].contains(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions), point.toCartographic());

      if (!isInArea) {
        return false;
      }

      var pt = {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: point.toArray()
        }
      };
      var coordinates = this.coordinates;
      var poly = {
        type: "Polygon",
        coordinates: [coordinates]
      };
      return Object(turf_root_turf_["booleanPointInPolygon"])(pt, poly); //turf插件计算的
    }
    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @param {surfaceLineWork_callback} options.callback  异步计算高度完成后 的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //求对比的贴地地面高度
      computeSurfacePoints({
        map: this._map,
        positions: this.positions,
        //需要计算的源路线坐标数组
        callback: function callback(raisedPositions, noHeight) {
          _this4.positions = raisedPositions;

          if (options.callback) {
            options.callback(raisedPositions, noHeight);
          }
        }
      });
      return this;
    }
  }]);

  return BasePolyPrimitive;
}(BasePrimitive_BasePrimitive);
// CONCATENATED MODULE: ./src/graphic/entity/PointEntity.js







function PointEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PointEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PointEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PointEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PointEntity_createSuper(Derived) { var hasNativeReflectConstruct = PointEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PointEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 像素点 支持的样式信息
 *
 * @typedef {Object} PointEntity.StyleOptions
 *
 * @property {Number} [pixelSize = 10] 像素大小
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 * @property {Number} [outlineWidth = 2] 边框宽度
 *
 * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 指定用于基于距离缩放点。
 * @property {Number} [scaleByDistance_far = 1000000] 上限
 * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
 * @property {Number} [scaleByDistance_near = 1000] 下限
 * @property {Number} [scaleByDistance_nearValue = 1] 比例值
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [visibleDepth = true] 是否被遮挡
 * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
 * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.PointGraphics.ConstructorOptions
 */

/**
 * 像素点 Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {PointEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class PointEntity
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PointEntity_PointEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(PointEntity, _BasePointEntity);

  var _super = PointEntity_createSuper(PointEntity);

  function PointEntity() {
    classCallCheck_default()(this, PointEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(PointEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PointGraphics}
     * @readonly
     */
    function get() {
      return this._entity.point;
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          position: this.position,
          point: PointStyleConver_PointStyleConver.toCesiumVal(this.style)
        }; //同时加文字

        if (this.style.label) {
          addattr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
        }

        this._entity = this._createEntity(addattr);
      }
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PointStyleConver_PointStyleConver.toCesiumVal(this.style, this.entityGraphic); //同时加文字

      if (newStyle.label) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.label.clampToGround)) {
          newStyle.label.clampToGround = this.style.clampToGround;
        }

        this._entity.label = this._entity.label || {};
        LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PointStyleConver_PointStyleConver.toJSON(czmStyle, styleJson);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {PointEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new PointEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.point) {
        return undefined;
      }

      return new PointEntity(PointEntity_objectSpread(PointEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PointEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("point", PointEntity_PointEntity);
// CONCATENATED MODULE: ./src/graphic/entity/BillboardEntity.js








function BillboardEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BillboardEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BillboardEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BillboardEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BillboardEntity_createSuper(Derived) { var hasNativeReflectConstruct = BillboardEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BillboardEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 图标点 支持的样式信息
 *
 * @typedef {Object} BillboardEntity.StyleOptions
 *
 * @property {string | HTMLCanvasElement} [image] 用于矢量对象的 图像、URI或Canvas
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Number} [scale = 1] 图像大小的比例
 * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
 * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
 * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
 * @property {Number} [width] 指定广告牌的宽度(以像素为单位)，覆盖图片本身大小。
 * @property {Number} [height] 指定广告牌的高度(以像素为单位)，覆盖图片本身大小。
 *
 * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
 * @property {Number} [pixelOffsetX = 0] 横向偏移像素
 * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
 * @property {Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO]  指定像素偏移量。
 *
 * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设置基于与相机的距离缩放点
 * @property {Number} [scaleByDistance_far = 1000000] 上限
 * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
 * @property {Number} [scaleByDistance_near = 1000] 下限
 * @property {Number} [scaleByDistance_nearValue = 1] 比例值
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定该广告牌将显示在与摄像机的多大距离
 * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 *
 * @property {Boolean} [visibleDepth = true] 是否被遮挡
 * @property {Number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
 *
 * @property {Cesium.Color} [color=Color.WHITE] 附加的颜色
 * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] 眼偏移量
 * @property {Cesium.Cartesian3} [alignedAxis=Cartesian3.ZERO] 指定单位旋转向量轴。
 * @property {boolean} [sizeInMeters] 指定该广告牌的大小是否应该以米来度量。
 * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
 * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] 用于基于与相机的距离设置pixelOffset。
 * @property {Cesium.BoundingRectangle} [imageSubRegion] 定义用于广告牌的图像的子区域，而不是从左下角开始以像素为单位的整个图像。
 *
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.BillboardGraphics.ConstructorOptions
 */

/**
 * 图标点  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {BillboardEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var BillboardEntity_BillboardEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(BillboardEntity, _BasePointEntity);

  var _super = BillboardEntity_createSuper(BillboardEntity);

  function BillboardEntity() {
    classCallCheck_default()(this, BillboardEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(BillboardEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.BillboardGraphics}
     * @readonly
     */
    function get() {
      return this._entity.billboard;
    }
    /**
     * 图像、URI或Canvas
     * @type {string | HTMLCanvasElement}
     */

  }, {
    key: "image",
    get: function get() {
      return this.style.image;
    },
    set: function set(val) {
      this.style.image = val;

      if (this._entity) {
        this._entity.billboard.image = val;
      }
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          position: this.position,
          billboard: BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.style)
        }; //同时加文字

        if (this.style.label) {
          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.label.clampToGround)) {
            this.style.label.clampToGround = this.style.clampToGround;
          }

          addattr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
        }

        this._entity = this._createEntity(addattr);
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return BillboardStyleConver_BillboardStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.style, this.entityGraphic); //同时加文字

      if (newStyle !== null && newStyle !== void 0 && newStyle.label) {
        this._entity.label = this._entity.label || {};
        LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
      }
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._entity.billboard.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(value);

      get_default()(getPrototypeOf_default()(BillboardEntity.prototype), "setOpacity", this).call(this, value);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {BillboardEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new BillboardEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.billboard) {
        return undefined;
      }

      return new BillboardEntity(BillboardEntity_objectSpread(BillboardEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return BillboardEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("billboard", BillboardEntity_BillboardEntity);
// CONCATENATED MODULE: ./src/graphic/entity/LabelEntity.js







function LabelEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function LabelEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LabelEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LabelEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function LabelEntity_createSuper(Derived) { var hasNativeReflectConstruct = LabelEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LabelEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 文本点 支持的样式信息
 *
 * @typedef {Object} LabelEntity.StyleOptions
 *
 * @property {String} [text = "文字"] 文本内容，换行可以用换行符'\n'。
 *
 * @property {number} [scale=1.0] 指定缩放比例。
 * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
 * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
 *
 * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
 * @property {Number} [font_size = 30] 字体大小
 * @property {String} [font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
 * @property {String} [font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
 * @property {string} [font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
 *
 * @property {Boolean} [fill = true] 是否填充
 * @property {String} [color = "#ffffff"] 文本颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否衬色
 * @property {String|Cesium.Color} [outlineColor = "#000000"] 衬色颜色
 * @property {Number} [outlineOpacity = 0.6] 衬色透明度
 * @property {Number} [outlineWidth = 2.0] 衬色宽度
 *
 * @property {Boolean} [background = false] 是否背景
 * @property {String|Cesium.Color} [backgroundColor = "#000000"] 背景颜色
 * @property {Number} [backgroundOpacity = 0.5] 背景透明度
 * @property {Number|Cesium.Cartesian2} [backgroundPadding=new Cesium.Cartesian2(7, 5)] 背景内边距，指定文字与填充边界内容之间的空间(以像素为单位)。
 *
 * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
 * @property {Number} [pixelOffsetX = 0] 横向偏移像素
 * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
 * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
 * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
 * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
 *
 * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设定基于与相机的距离设置比例。
 * @property {Number} [scaleByDistance_far = 1000000] 上限
 * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
 * @property {Number} [scaleByDistance_near = 1000] 下限
 * @property {Number} [scaleByDistance_nearValue = 1] 比例值
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 *
 * @property {Boolean} [visibleDepth = true] 是否被遮挡
 * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
 *
 * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @see Cesium.LabelGraphics.ConstructorOptions
 */

/**
 * 文字  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {LabelEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var LabelEntity_LabelEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(LabelEntity, _BasePointEntity);

  var _super = LabelEntity_createSuper(LabelEntity);

  function LabelEntity() {
    classCallCheck_default()(this, LabelEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(LabelEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.LabelGraphics}
     * @readonly
     */
    function get() {
      return this._entity.label;
    }
  }, {
    key: "label",
    get: function get() {
      if (this._entity) {
        return this._entity.label;
      } else {
        return this.style;
      }
    }
    /**
     * 文本内容
     * @type {String}
     * @readonly
     */

  }, {
    key: "text",
    get: function get() {
      return this.style.text;
    },
    set: function set(value) {
      this.style.text = value;

      if (this._entity) {
        this.entityGraphic.text = value;
      }
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          position: this.position,
          label: LabelStyleConver_LabelStyleConver.toCesiumVal(this.style)
        };
        this._entity = this._createEntity(addattr);
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return LabelStyleConver_LabelStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      LabelStyleConver_LabelStyleConver.toCesiumVal(this.style, this.entityGraphic);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {LabelEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new LabelEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.label) {
        return undefined;
      }

      return new LabelEntity(LabelEntity_objectSpread(LabelEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return LabelEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("label", LabelEntity_LabelEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditCircle.js






function EditCircle_createSuper(Derived) { var hasNativeReflectConstruct = EditCircle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditCircle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var EditCircle_EditCircle = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditCircle, _EditPoly);

  var _super = EditCircle_createSuper(EditCircle);

  function EditCircle() {
    classCallCheck_default()(this, EditCircle);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditCircle, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this,
          _getCesiumValue;

      var positions = this.positions; //中心点

      var position = this.updatePositionsHeightByAttr(positions[0]);
      var dragger = this.createDragger({
        position: position,
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDrag: function onDrag(dragger, position) {
          positions[0] = position;
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger);
      var time = this._map.clock.currentTime; //获取圆（或椭圆）边线上的坐标点数组

      var outerPositions = getEllipseOuterPositions({
        position: position,
        semiMajorAxis: Object(Util["getCesiumValue"])(this.entityGraphic.semiMajorAxis, Number, time),
        //长半轴
        semiMinorAxis: Object(Util["getCesiumValue"])(this.entityGraphic.semiMinorAxis, Number, time),
        //短半轴
        rotation: (_getCesiumValue = Object(Util["getCesiumValue"])(this.entityGraphic.rotation, Number, time)) !== null && _getCesiumValue !== void 0 ? _getCesiumValue : 0
      }); //长半轴上的坐标点

      var majorPos = this.updatePositionsHeightByAttr(outerPositions[1]);
      positions[1] = majorPos;
      var majorDragger = this.createDragger({
        position: majorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDragStart: function onDragStart(dragger, position) {
          if (!_this._heightDraggers) {
            return;
          }

          for (var i = 0, len = _this._heightDraggers.length; i < len; i++) {
            _this._heightDraggers[i].show = false;
          }
        },
        onDrag: function onDrag(dragger, position) {
          if (_this.entityGraphic.height != undefined) {
            var newHeight = Object(Util["getCesiumValue"])(_this.entityGraphic.height, Number, time);
            position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
            dragger.position = position;
          }

          positions[dragger.index] = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position), 2);

          _this.entityGraphic.semiMajorAxis = radius;

          if (_this._graphic._maxPointNum == 3 || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this.style.radius)) {
            //椭圆
            _this.style.semiMajorAxis = radius;
          } else {
            //圆
            _this.entityGraphic.semiMinorAxis = radius;
            _this.style.radius = radius;
          }
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      majorDragger.index = 1;
      dragger.majorDragger = majorDragger;
      this.draggers.push(majorDragger); //短半轴上的坐标点

      if (this._graphic._maxPointNum == 3) {
        //椭圆
        //短半轴上的坐标点
        var minorPos = this.updatePositionsHeightByAttr(outerPositions[0]);
        positions[2] = minorPos;
        var minorDragger = this.createDragger({
          position: minorPos,
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改半径"),
          onDragStart: function onDragStart(dragger, position) {
            if (!_this._heightDraggers) {
              return;
            }

            for (var i = 0, len = _this._heightDraggers.length; i < len; i++) {
              _this._heightDraggers[i].show = false;
            }
          },
          onDrag: function onDrag(dragger, position) {
            if (_this.entityGraphic.height != undefined) {
              var newHeight = Object(Util["getCesiumValue"])(_this.entityGraphic.height, Number, time);
              position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
              dragger.position = position;
            }

            positions[dragger.index] = position;

            var semiMinorAxis = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position), 2);

            var semiMajorAxis = Object(Util["getCesiumValue"])(_this.entityGraphic.semiMajorAxis, Number, time); //长半轴

            if (semiMinorAxis > semiMajorAxis) {
              semiMinorAxis = semiMajorAxis;
            }

            _this.entityGraphic.semiMinorAxis = semiMinorAxis;

            if (_this._graphic._maxPointNum == 3 || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this.style.radius)) {
              //椭圆
              _this.style.semiMinorAxis = semiMinorAxis;
            } else {
              //圆
              _this.entityGraphic.semiMajorAxis = semiMinorAxis;
              _this.style.radius = semiMinorAxis;
            }
          },
          onDragEnd: function onDragEnd(dragger, position) {
            _this.updateDraggers();
          }
        });
        minorDragger.index = 2;
        dragger.minorDragger = minorDragger;
        this.draggers.push(minorDragger);
      } //创建高度拖拽点


      if (this.entityGraphic.extrudedHeight) {
        var _pos = this._graphic._maxPointNum == 3 ? [positions[1], positions[2]] : [positions[1]];

        this._bindHeightDraggers(_pos);
      }
    } //根据属性更新坐标

  }, {
    key: "updatePositionsHeightByAttr",
    value: function updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        //贴地时求贴模型和贴地的高度
        position = Object(PointUtil["getSurfacePosition"])(this._map, position);
      }

      if (this.entityGraphic.height != undefined) {
        var newHeight = Object(Util["getCesiumValue"])(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
      }

      return position;
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radius) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.semiMinorAxis) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.semiMajorAxis) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditCircle;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/CircleEntity.js







function CircleEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CircleEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CircleEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CircleEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CircleEntity_createSuper(Derived) { var hasNativeReflectConstruct = CircleEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CircleEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }













/**
 * 圆、圆柱 支持的样式信息
 *
 * @typedef {Object} CircleEntity.StyleOptions
 *
 * @property {Number} [radius = 100] 半径
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 * @property {Number} [diffHeight = 100] 高度差（圆柱本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定椭圆的挤压面相对于椭球面的高度。
 * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
 *
 * @property {Boolean} [fill = true] 是否填充
 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String} [color = "#3388ff"] 填充颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {Number} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
 *
 * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
 * @property {Number} [stRotation = 0] 椭圆纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 椭圆纹理的角度（度数值，0-360度），与stRotation二选一
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定椭圆上各点之间的角距离。
 * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
 *
 * @property {Boolean} [hasShadows = false] 是否投射阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定椭圆是投射还是接收来自光源的阴影。
 *
 * @property {String} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Number} [zIndex = 0] 层级顺序。用于排序地面几何。只有在椭圆为常量且没有指定height或exturdedHeight时才有效果。
 *
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.EllipseGraphics.ConstructorOptions
 */

/**
 * 圆、圆柱  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {CircleEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShowRadius=true] 绘制时，是否显示圆的半径。
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var CircleEntity_CircleEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(CircleEntity, _BasePointEntity);

  var _super = CircleEntity_createSuper(CircleEntity);

  function CircleEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CircleEntity);

    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    _this.options.drawShowRadius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.drawShowRadius, true);
    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.EllipseGraphics}
   * @readonly
   */


  createClass_default()(CircleEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.ellipse;
    }
    /**
     * 编辑处理类
     * @type {EditCircle}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditCircle_EditCircle;
    }
    /**
     * 圆的边线坐标集合（笛卡尔坐标）
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "outlinePositions",
    get: function get() {
      if (!this._outlinePositions && this._entity) {
        this._outlinePositions = _getOutlinePositions(this._entity);
      }

      return this._outlinePositions;
    },
    set: function set(value) {
      this._outlinePositions = value;
    }
    /**
     * 圆的边线坐标集合（经纬度二维数组），示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7], …… ]
     * @type {Array[]}
     * @readonly
     */

  }, {
    key: "outlineCoordinates",
    get: function get() {
      return Object(PointTrans["cartesians2lonlats"])(this.outlinePositions);
    } //距离长度（单位：米）

  }, {
    key: "distance",
    get: function get() {
      return Math.PI * 2 * this.radius;
    } //面积（单位：平方米）

  }, {
    key: "area",
    get: function get() {
      var radius = this.radius;
      return Math.PI * radius * radius;
    }
    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */

  }, {
    key: "radius",
    get: function get() {
      var _this$entityGraphic;

      if (this.style.radius) {
        return this.style.radius;
      }

      return Object(Util["getCesiumValue"])((_this$entityGraphic = this.entityGraphic) === null || _this$entityGraphic === void 0 ? void 0 : _this$entityGraphic.semiMajorAxis, Number, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now()); //长半轴
    },
    set: function set(value) {
      this.style.radius = value;

      if (this.entityGraphic) {
        this.entityGraphic.semiMajorAxis = value;
        this.entityGraphic.semiMinorAxis = value;
      }
    }
    /**
     * 高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      var _getCesiumValue, _this$entityGraphic2;

      if (this.style.height) {
        return this.style.height;
      }

      return (_getCesiumValue = Object(Util["getCesiumValue"])((_this$entityGraphic2 = this.entityGraphic) === null || _this$entityGraphic2 === void 0 ? void 0 : _this$entityGraphic2.height, Number)) !== null && _getCesiumValue !== void 0 ? _getCesiumValue : 0;
    },
    set: function set(value) {
      this.style.height = value;

      if (this.entityGraphic) {
        this.entityGraphic.height = value;
      }
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        CircleStyleConver_CircleStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
      } else {
        var addattr = {
          position: this.position,
          ellipse: CircleStyleConver_CircleStyleConver.toCesiumVal(this.style, {}, true)
        };
        this._entity = this._createEntity(addattr);
      }

      this._updateHeight();

      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //边线
      //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return CircleStyleConver_CircleStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      CircleStyleConver_CircleStyleConver.toCesiumVal(this.style, this.entityGraphic, true); //边线

      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //边线


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height)) {
        this._updateHeight();
      } //更改了半径


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radius) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.semiMajorAxis) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.semiMinorAxis)) {
        this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]);
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._entity.position = this.position;

      this._updateHeight(); //更改了坐标


      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //边线


      this._updateEditDraggers();
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this2 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true;
      this._positions_draw = this.positions || [];
      this.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        if (_this2._positions_draw.length < 1) {
          return null;
        }

        return _this2._positions_draw[0];
      }, false);

      this._updateOutlineToCallback();
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this._position = this._positions_draw[0];

      this._updatePositionsHook();
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.rightClick, this._onRightClickHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "_showDrawMouseMoveSmallTooltip",
    value: function _showDrawMouseMoveSmallTooltip(event) {
      if (this._positions_draw.length <= 1) {
        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击开始绘制"));

        return;
      }

      var disableStr = "";

      if (this.options.drawShowRadius && this._positions_draw.length > 0 && event.cartesian) {
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], event.cartesian);

        if (distance > 0) {
          disableStr = "\u534A\u5F84\uFF1A".concat(formatDistance(distance), "<br />");
        }
      }

      this._map.openSmallTooltip(event.endPosition, disableStr + this._map.getLangText("_单击完成绘制"));
    } //高度处理

  }, {
    key: "_updateHeight",
    value: function _updateHeight() {
      var _this$_positions_draw;

      if (this.style.clampToGround) {
        return;
      }

      var position = this._position;

      if (((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 0) {
        position = this._positions_draw[0];
      }

      if (!position) {
        return;
      }

      var height = LatLngPoint["a" /* LatLngPoint */].fromCartesian(position).alt;
      this.entityGraphic.height = height;
      this.style.height = height; //存在extrudedHeight高度设置时

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
        if (this.style.diffHeight > 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      if (this._positions_draw.length < 2) {
        return;
      } //高度处理


      this._updateHeight(); //中心文本处理


      this._updateLabelPosition(); //编辑时无需更新半径


      if (!isEditing) {
        //半径处理
        var radius = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], this._positions_draw[1]), 2);

        if (radius < 1) {
          return;
        }

        if (this._maxPointNum == 3) {
          var semiMinorAxis = radius; //短半轴

          var semiMajorAxis = radius; //长半轴

          if (this._positions_draw.length == 3) {
            semiMajorAxis = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], this._positions_draw[2]), 2);
          }

          if (semiMinorAxis > semiMajorAxis) {
            //semiMajorAxis must be greater than or equal to the semiMinorAxis. 所以交换下
            var temp = semiMinorAxis;
            semiMinorAxis = semiMajorAxis;
            semiMajorAxis = temp;
          }

          this.entityGraphic.semiMajorAxis = semiMajorAxis;
          this.entityGraphic.semiMinorAxis = semiMinorAxis;
          this.style.semiMajorAxis = semiMajorAxis;
          this.style.semiMinorAxis = semiMinorAxis;
        } else {
          this.entityGraphic.semiMajorAxis = radius; //长半轴

          this.entityGraphic.semiMinorAxis = radius; //短半轴

          this.style.radius = radius;
        }
      }

      if (this._entity_outlines) {
        this._outlinePositions = _getOutlinePositions(this._entity);

        this._updateOutlineToCallback();
      }
    }
    /**
     * 获取圆的边线坐标集合（笛卡尔坐标）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Int} [count=90] 象限内点的数量，返回的总数为 count*4
     * @return  {Cesium.Cartesian3[]} 边线坐标数组
     */

  }, {
    key: "getOutlinePositions",
    value: function getOutlinePositions(closure, count) {
      return _getOutlinePositions(this._entity, closure, count);
    }
    /**
     *  获取圆的边线坐标集合（经纬度二维数组）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Int} [count=90] 象限内点的数量，返回的总数为 count*4
     * @return  {Array[]} 边线坐标数组（经纬度二维数组）
     */

  }, {
    key: "getOutlineCoordinates",
    value: function getOutlineCoordinates(closure, count) {
      return Object(PointTrans["cartesians2lonlats"])(this.getOutlinePositions(closure, count));
    }
    /**
     * 判断点是否在圆内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在圆内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      position = LatLngPoint["a" /* LatLngPoint */].parse(position).toCartesian();
      position = Object(PointUtil["setPositionsHeight"])(position, this.height);
      var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this.positionShow, position);
      return len <= this.radius; //小于半径的说明在圆内
    } //定位至数据区域

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      options.radius = this.radius * 2 * (options.scale || 1.8);

      this._map.flyToPoint(this.point, options);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {CircleEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new CircleEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.ellipse) {
        return undefined;
      }

      return new CircleEntity(CircleEntity_objectSpread(CircleEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return CircleEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("circle", CircleEntity_CircleEntity); //获取entity对应的 边界 的坐标

function _getOutlinePositions(entity) {
  var _entity$ellipse, _entity$ellipse2, _getCesiumValue2, _entity$ellipse3;

  var closure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;
  var time = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now(); //获取圆（或椭圆）边线上的坐标点数组

  var outerPositions = getEllipseOuterPositions({
    position: Object(PointUtil["getPositionValue"])(entity.position),
    semiMajorAxis: Object(Util["getCesiumValue"])((_entity$ellipse = entity.ellipse) === null || _entity$ellipse === void 0 ? void 0 : _entity$ellipse.semiMajorAxis, Number, time),
    //长半轴
    semiMinorAxis: Object(Util["getCesiumValue"])((_entity$ellipse2 = entity.ellipse) === null || _entity$ellipse2 === void 0 ? void 0 : _entity$ellipse2.semiMinorAxis, Number, time),
    //短半轴
    rotation: (_getCesiumValue2 = Object(Util["getCesiumValue"])((_entity$ellipse3 = entity.ellipse) === null || _entity$ellipse3 === void 0 ? void 0 : _entity$ellipse3.rotation, Number, time)) !== null && _getCesiumValue2 !== void 0 ? _getCesiumValue2 : 0,
    count: count //共返回count*4个点

  });

  if (closure && outerPositions) {
    outerPositions.push(outerPositions[0]);
  }

  return outerPositions;
}
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditModel.js







function EditModel_createSuper(Derived) { var hasNativeReflectConstruct = EditModel_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditModel_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








var EditModel_EditModel = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditModel, _EditBase);

  var _super = EditModel_createSuper(EditModel);

  function EditModel() {
    classCallCheck_default()(this, EditModel);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditModel, [{
    key: "position",
    get: function get() {
      return this._graphic._position_draw;
    },
    set: function set(value) {
      this._graphic._position_draw = value;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      this._graphic._draw_tooltip = this._map.getLangText("_拖动该点后") + "<br/>" + this._map.getLangText("_修改位置");
      this.createDragger({
        dragger: this._graphic,
        onDragStart: function onDragStart(dragger, newPosition) {
          // if (this.axisModel) {
          //   this.axisModel.show = false
          // }
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDrag: function onDrag(dragger, newPosition) {
          _this.position = newPosition;
        },
        onDragEnd: function onDragEnd(dragger, newPosition) {
          // if (this.axisModel) {
          //   this.axisModel.show = true
          // }
          _this.updateDraggers();
        }
      });
      var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this.position).height;
      var radius = this.style.radius; // 加载坐标轴模型

      if (this._graphic.options.editType == "point") {
        //辅助显示：创建角度调整底部圆
        this.entityAngle = new CircleEntity_CircleEntity({
          name: "角度调整底部圆",
          position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return _this.position;
          }, false),
          style: {
            fill: false,
            outline: true,
            outlineColor: "#ffff00",
            outlineOpacity: 0.8,
            radius: radius,
            height: height
          }
        });
        this.entityAngle._isDragger = true;
        this.layer.addGraphic(this.entityAngle); //创建角度调整 拖拽点

        var majorPos = Object(PointUtil["getPositionByDirectionAndLen"])(this.position, this.style.heading, radius);
        var majorDragger = this.createDragger({
          position: majorPos,
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改方向"),
          onDrag: function onDrag(dragger, position) {
            var heading = getAngle(_this.position, position); //模型是正东为0
            // this.style.radius = Cesium.Cartesian3.distance(this.position, position)
            // this.entityAngle.radius = this.style.radius

            _this.style.heading = Object(Util["formatNum"])(heading, 1);
            dragger.position = Object(PointUtil["getPositionByDirectionAndLen"])(_this.position, _this.style.heading, _this.style.radius);

            _this._graphic.updateOrientation(_this.position);
          }
        });
        this.draggers.push(majorDragger); //缩放控制点

        var position_scale = Object(PointUtil["addPositionsHeight"])(this.position, radius);
        var draggerScale = this.createDragger({
          position: position_scale,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改缩放比例"),
          onDragStart: function onDragStart(dragger, position) {
            if (_this.entityAngle) {
              _this.entityAngle.show = false;
            }

            for (var i = 0, len = _this.draggers.length; i < len; i++) {
              _this.draggers[i].show = false;
            }
          },
          onDrag: function onDrag(dragger, positionNew) {
            var radiusNew = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positionNew, _this.position);
            var radiusOld = dragger.radius / _this.style.scale;
            _this.style.scale = Object(Util["formatNum"])(radiusNew / radiusOld, 3);

            if (_this.style.scale <= 0) {
              _this.style.scale = 0.001;
            }

            _this.entityGraphic.scale = _this.style.scale;
            dragger.radius = radiusNew;
            _this.style.radius = radiusNew;
          },
          onDragEnd: function onDragEnd(dragger, position) {
            _this.updateDraggers();
          }
        });
        draggerScale.radius = radius;
        this.draggers.push(draggerScale);
      }
    }
  }, {
    key: "destroyDraggers",
    value: function destroyDraggers() {
      get_default()(getPrototypeOf_default()(EditModel.prototype), "destroyDraggers", this).call(this);

      if (this.entityAngle) {
        this.layer.removeGraphic(this.entityAngle, true);
        delete this.entityAngle;
      } // if (this.axisModel) {
      //   this.axisModel.show = false
      //   this.destroyAxisEvent()
      // }

    } // getModelMatrix(position) {
    //   let cfg = this.style
    //   position = position || getPositionValue(this.position)
    //   let hpRoll = new Cesium.HeadingPitchRoll(
    //     Cesium.Math.toRadians(cfg.heading || 0),
    //     Cesium.Math.toRadians(cfg.pitch || 0),
    //     Cesium.Math.toRadians(cfg.roll || 0)
    //   )
    //   let modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position, hpRoll)
    //   let style = this.style
    //   let scale = (style.radius * style.scale) / 1.5
    //   Cesium.Matrix4.multiplyByUniformScale(modelMatrix, scale, modelMatrix)
    //   return modelMatrix
    // }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      // if (this.axisModel) {
      //   this._map.scene.primitives.remove(this.axisModel)
      //   delete this.axisModel
      // }
      delete this._graphic._draw_tooltip;
      delete this._graphic._isDragger;
      delete this._graphic._noMousePick;
      delete this._graphic._pointType;
      delete this._graphic.onDrag;
    }
  }]);

  return EditModel;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/ModelEntity.js








function ModelEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ModelEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ModelEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ModelEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ModelEntity_createSuper(Derived) { var hasNativeReflectConstruct = ModelEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * gltf小模型 支持的样式信息
 *
 * @typedef {Object} ModelEntity.StyleOptions
 *
 * @property {String| Cesium.Resource} [url] glTF模型的URI的字符串或资源属性。
 * @property {Number} [scale = 1] 比例
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {number} [minimumPixelSize=0.0] 指定模型的近似最小像素大小，而不考虑缩放。
 * @property {number} [maximumScale] 模型的最大比例尺寸。minimumPixelSize的上限。
 *
 * @property {Boolean} [fill = false] 是否填充，指定与模型渲染颜色混合
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Cesium.ColorBlendMode} [colorBlendMode=ColorBlendMode.HIGHLIGHT] 指定颜色如何与模型混合。
 * @property {number} [colorBlendAmount=0.5] 当colorBlendMode为MIX时指定颜色强度的数字属性。0.0的值表示模型渲染的颜色，1.0的值表示纯色，任何介于两者之间的值表示两者的混合。
 *
 * @property {Boolean} [silhouette = false] 是否轮廓
 * @property {String|Cesium.Color} [silhouetteColor = "#ffffff"] 轮廓颜色
 * @property {Number} [silhouetteSize = 2] 轮廓宽度
 * @property {Number} [silhouetteAlpha = 0.8] 轮廓透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = true] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 *
 * @property {boolean} [incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
 * @property {boolean} [runAnimations=true]  指定模型中指定的glTF动画是否应该启动。
 * @property {boolean} [clampAnimations=true]  指定在没有关键帧的情况下，glTF动画是否应该保持最后一个姿势。
 *
 * @property {Cesium.Cartesian2} [imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] 指定来自基于图像的漫反射和镜面照明的贡献。
 * @property {Color} [lightColor]  在为模型着色时指定光的颜色的属性。当undefined场景的浅色被使用代替。
 * @property {Cesium.PropertyBag | Object.<string, Cesium.TranslationRotationScale>} [nodeTransformations] 一个对象，其中键是节点的名称，值是{@link TranslationRotationScale}属性，描述要应用到该节点的转换。该转换是在节点的现有转换之后(如glTF中指定的那样)应用的，并且不会替换节点的现有转换。
 * @property {Cesium.PropertyBag | Object.<string, number>} [articulations] An object, where keys are composed of an articulation name, a single space, and a stage name, and the values are numeric properties.
 * @property {Cesium.ClippingPlaneCollection} [clippingPlanes]  用于裁剪模型的Plane平面集合
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.ModelGraphics.ConstructorOptions
 */

/**
 * @typedef {Object} ModelEntity.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 * @property {String} load 模型加载完成后
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('发送了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * gltf小模型  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {ModelEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
 * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
 * @param {Number} [options.frameRate=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link ModelEntity.EventType}
 */

var ModelEntity_ModelEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(ModelEntity, _BasePointEntity);

  var _super = ModelEntity_createSuper(ModelEntity);

  function ModelEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ModelEntity);

    //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
    options.drawShow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.drawShow, true);
    options.editType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.editType, "point");
    _this = _super.call(this, options);
    _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.radius, 100); //默认值

    _this.style.heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.heading, 0); //默认值

    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.ModelGraphics}
   * @readonly
   */


  createClass_default()(ModelEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.model;
    }
    /**
     * 编辑处理类
     * @type {EditModel}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditModel_EditModel;
    }
    /**
     * 模型整体的缩放比例
     * @type {Number}
     */

  }, {
    key: "scale",
    get: function get() {
      var _this$style$scale;

      return (_this$style$scale = this.style.scale) !== null && _this$style$scale !== void 0 ? _this$style$scale : 1;
    },
    set: function set(val) {
      this.style.scale = val;

      this._updateStyleHook();
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        ModelStyleConver_ModelStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
      } else {
        var addattr = {
          position: this.position,
          orientation: this.getOrientation(),
          model: ModelStyleConver_ModelStyleConver.toCesiumVal(this.style, {}, true)
        };

        if (!addattr.model.uri && this.options.url) {
          addattr.model.uri = this.options.url;
        } //同时加文字


        if (this.style.label) {
          addattr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
        }

        this._entity = this._createEntity(addattr);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExpandByTudou"]) {
        this.loadOk = false;
        this._draw_tooltip = "加载模型中…"; //readyPromise为修改cesium内部源码来实现的回调

        this._entity.readyPromise = function (entity, model) {
          delete _this2._draw_tooltip;
          _this2.loadOk = true;

          if (model.boundingSphere.radius < external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this2.style.maxRadius, 1000)) {
            _this2.style.radius = model.boundingSphere.radius;
          }

          _this2.fire(EventType.load, {
            drawtype: _this2.type,
            entity: entity,
            model: model,
            graphic: _this2
          }, true);
        };
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return ModelStyleConver_ModelStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      this._entity.orientation = this.getOrientation();
      ModelStyleConver_ModelStyleConver.toCesiumVal(this.style, this.entityGraphic, true); //同时加文字

      if (newStyle.label) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.label.clampToGround)) {
          newStyle.label.clampToGround = this.style.clampToGround;
        }

        this._entity.label = this._entity.label || {};
        LabelStyleConver_LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {} //==================常用util方法=================

    /**
     * 获取模型的当前时间的实际hpr角度(如动态模型)
     *
     * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
     */

  }, {
    key: "getHeadingPitchRoll",
    value: function getHeadingPitchRoll() {
      var time = this._map.clock.currentTime;
      var position = this.positionShow;
      var orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this._entity.orientation, time, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"]());
      var hpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, orientation);
      return hpr;
    }
    /**
     * 开始运行 自旋转动画效果
     *
     * @param {Object} [options={}] 参数包括：
     * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
     * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
     * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
     * @return {void}  无
     */

  }, {
    key: "rotateStart",
    value: function rotateStart() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._isRotateStart) {
        this.rotateStop();
      }

      this._rotateDirection = options.direction ? 1 : -1; //控制方向, true逆时针，false顺时针

      this._rotateAngle = 360 / (options.time || 60); //time：给定飞行一周所需时间(单位 秒)，控制速度

      this._rotateAutoStopAngle = options.autoStopAngle; //自动停止

      this._rotateStartTime = this._map.clock.currentTime.clone();
      this._rotateStartHpr = this.getHeadingPitchRoll();
      this._isRotateStart = true;
      this._map.clock.shouldAnimate = true;

      this._map.on(EventType.clockTick, this._rotate_onClockTickHandler, this);
    }
  }, {
    key: "_rotate_onClockTickHandler",
    value: function _rotate_onClockTickHandler(e) {
      var delTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this._map.clock.currentTime, this._rotateStartTime); // 当前已经过去的时间，单位 秒

      var angle = delTime * this._rotateAngle;

      if (this._rotateAutoStopAngle && angle >= this._rotateAutoStopAngle) {
        this.rotateStop();
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(angle * this._rotateDirection) + this._rotateStartHpr.heading; //角度控制


      var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, this._rotateStartHpr.pitch, this._rotateStartHpr.roll);
      this.entity.orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(this.positionShow, hpr);
    }
    /**
     * 停止运行 自旋转动画效果
     * @return {void}  无
     */

  }, {
    key: "rotateStop",
    value: function rotateStop() {
      if (!this._isRotateStart) {
        return;
      }

      this.isStart = false;

      this._map.off(EventType.clockTick, this._rotate_onClockTickHandler, this);
    }
    /**
     * 动画移动到指定目标位置
     *
     * @param {Object} [options={}] 参数包括：
     * @param {LatLngPoint|Cesium.Cartesian3} options.position 指定目标位置的坐标
     * @param {Number} [options.time=5] 移动的时长(单位 秒)，控制速度
     * @param {Function} [options.onEnd]  移动完成的回调方法
     * @return {void}  无
     */

  }, {
    key: "moveTo",
    value: function moveTo(options) {
      var _this3 = this;

      var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();

      var startTime = this._map.clock.currentTime.clone(); //飞行开始时间


      var stopTime; //飞行结束时间

      var pointStart = this.positionShow;
      property.addSample(startTime, pointStart);
      var pointEnd = LatLngPoint["a" /* LatLngPoint */].parse(options.position).toCartesian();
      var time = options.time || 5; //移动的时长(单位 秒)

      stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(startTime, time, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      property.addSample(stopTime, pointEnd); //为了保证到结束时间了，一直停留在那，所以加个很远的时间

      stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addDays(stopTime, 365, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      property.addSample(stopTime, pointEnd);
      this._entity.position = property;
      var _bak_multiplier = this._map.clock.multiplier;
      this._map.clock.shouldAnimate = true;
      this._map.clock.multiplier = options.speed || 1; //飞行速度

      setTimeout(function () {
        _this3.position = pointEnd;
        _this3._map.clock.multiplier = _bak_multiplier;

        if (options.onEnd) {
          options.onEnd();
        }
      }, time * 1000);
    } //

    /**
     * 飞行定位至数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.scale=1.8] 缩放比例，可以根据控制视角比模型大小略大一些，这样效果更友好。
     * @param {Number} options.radius  相机距离目标点的距离（单位：米），与scale二选一
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
      * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.radius)) {
        options.radius = this.style.radius * 2 * (options.scale || 1.8);
      }

      this._map.flyToPoint(this.point, options);
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._entity.model.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(value);

      get_default()(getPrototypeOf_default()(ModelEntity.prototype), "setOpacity", this).call(this, value);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {ModelEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new ModelEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.model) {
        return undefined;
      }

      return new ModelEntity(ModelEntity_objectSpread(ModelEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return ModelEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("model", ModelEntity_ModelEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditBox.js






function EditBox_createSuper(Derived) { var hasNativeReflectConstruct = EditBox_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditBox_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * BoxEntity对象，标绘处理对应的编辑类
 *
 * @export
 * @class EditBox
 * @extends {EditBase}
 */

var EditBox_EditBox = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditBox, _EditBase);

  var _super = EditBox_createSuper(EditBox);

  function EditBox() {
    classCallCheck_default()(this, EditBox);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditBox, [{
    key: "position",
    get:
    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     */
    function get() {
      return this._graphic._position_draw;
    },
    set: function set(value) {
      this._graphic._position_draw = value;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var style = this.style;
      var dragger; //位置中心点

      var positionZXD = this.position;
      dragger = this.createDragger({
        position: positionZXD,
        onDrag: function onDrag(dragger, position) {
          //记录差值
          var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, _this.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          _this.position = position;

          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(_this.draggers[i].position, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          }
        }
      });
      this.draggers.push(dragger); //方向

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.heading);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.pitch);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.roll);
      var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll); //x长度调整

      var positionX = Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](style.dimensions_x / 2, 0, 0), hpr);
      dragger = this.createDragger({
        position: positionX,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改长度"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(_this.position).height;
          position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
          dragger.position = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

          style.dimensions_x = radius * 2;

          _this.updateBox(style);
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      this.draggers.push(dragger); //y宽度调整

      var positionY = Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, style.dimensions_y / 2, 0), hpr);
      dragger = this.createDragger({
        position: positionY,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改宽度"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positionZXD).height;
          position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
          dragger.position = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

          style.dimensions_y = radius * 2;

          _this.updateBox(style);
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      this.draggers.push(dragger); //z高度调整

      var positionZ = Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, style.dimensions_z / 2), hpr);
      dragger = this.createDragger({
        position: positionZ,
        type: PointType.MoveHeight,
        tooltip: this._map.getLangText("_修改高度"),
        onDrag: function onDrag(dragger, position) {
          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

          style.dimensions_z = radius * 2;

          _this.updateBox(style);
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      this.draggers.push(dragger);
    }
  }, {
    key: "updateBox",
    value: function updateBox(style) {
      var dimensions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](style.dimensions_x, style.dimensions_y, style.dimensions_z);
      this.entityGraphic.dimensions.setValue(dimensions);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.dimensions_x) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.dimensions_y) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.dimensions_z)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditBox;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/BoxEntity.js








function BoxEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BoxEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BoxEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BoxEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BoxEntity_createSuper(Derived) { var hasNativeReflectConstruct = BoxEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BoxEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 盒子 支持的样式信息
 *
 * @typedef {Object} BoxEntity.StyleOptions
 *
 * @property {Cesium.Cartesian3} [dimensions] 指定盒子的长度、宽度和高度。
 * @property {Number} [dimensions_x = 100] 盒子长度
 * @property {Number} [dimensions_y = 100] 盒子宽度
 * @property {Number} [dimensions_z = 100] 盒子高度
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {Boolean} [fill = true] 是否填充
 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String} [outlineWidth = 1.0] 边框宽度
 * @property {String|Cesium.Color} [outlineColor = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否投射阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 是投射还是接收来自光源的阴影。
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 *  @see Cesium.BoxGraphics.ConstructorOptions
 */

/**
 * 盒子  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {BoxEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var BoxEntity_BoxEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(BoxEntity, _BasePointEntity);

  var _super = BoxEntity_createSuper(BoxEntity);

  function BoxEntity() {
    classCallCheck_default()(this, BoxEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(BoxEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.BoxGraphics}
     * @readonly
     */
    function get() {
      return this._entity.box;
    }
    /**
     * 编辑处理类
     * @type {EditBox}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditBox_EditBox;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          position: this.position,
          orientation: this.getOrientation(),
          box: BoxStyleConver_BoxStyleConver.toCesiumVal(this.style, {}, true)
        };
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return BoxStyleConver_BoxStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.heading) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.pitch) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.roll)) {
        this._entity.orientation = this.getOrientation();
      }

      BoxStyleConver_BoxStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
    }
  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      get_default()(getPrototypeOf_default()(BoxEntity.prototype), "_setPositionsToCallback", this).call(this);

      var dimensions = Object(Util["getCesiumValue"])(this.entityGraphic.dimensions, Number, this._map.clock.currentTime);
      this.style.dimensions_x = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.dimensions_x, dimensions.x);
      this.style.dimensions_y = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.dimensions_y, dimensions.y);
      this.style.dimensions_z = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.dimensions_z, dimensions.z);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {BoxEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new BoxEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.box) {
        return undefined;
      }

      return new BoxEntity(BoxEntity_objectSpread(BoxEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return BoxEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("box", BoxEntity_BoxEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditPlane.js






function EditPlane_createSuper(Derived) { var hasNativeReflectConstruct = EditPlane_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditPlane_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var EditPlane_EditPlane = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditPlane, _EditBase);

  var _super = EditPlane_createSuper(EditPlane);

  function EditPlane() {
    classCallCheck_default()(this, EditPlane);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditPlane, [{
    key: "position",
    get: function get() {
      return this._graphic._position_draw;
    },
    set: function set(value) {
      this._graphic._position_draw = value;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var style = this.style;
      var dragger; //位置中心点

      var positionZXD = this.position;
      dragger = this.createDragger({
        position: positionZXD,
        onDrag: function onDrag(dragger, position) {
          //记录差值
          var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, _this.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          _this.position = position;

          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(_this.draggers[i].position, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          }
        }
      });
      this.draggers.push(dragger); //方向

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.heading);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.pitch);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._graphic.roll);
      var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll); //平面的x长度调整

      var offest = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();

      switch (style.plane_normal) {
        case "x":
          offest.y = style.dimensions_x / 2;
          break;

        default:
          offest.x = style.dimensions_x / 2;
          break;
      }

      dragger = this.createDragger({
        position: Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, offest, hpr),
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改长度"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(_this.position).height;
          position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
          dragger.position = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

          style.dimensions_x = radius * 2;

          _this.updatePlane(style);
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      this.draggers.push(dragger); //平面的y宽度调整

      if (style.plane_normal == "z") {
        dragger = this.createDragger({
          position: Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, style.dimensions_y / 2, 0), hpr),
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改宽度"),
          onDrag: function onDrag(dragger, position) {
            var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(_this.position).height;
            position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
            dragger.position = position;

            var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

            style.dimensions_y = radius * 2;

            _this.updatePlane(style);
          },
          onDragEnd: function onDragEnd(dragger, position) {
            _this.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      } else {
        var offestTop = {
          x: 0,
          y: 0,
          z: 0
        };

        switch (style.plane_normal) {
          case "x":
          case "y":
            offestTop.z = style.dimensions_y / 2;
            break;

          default:
            offestTop.y = style.dimensions_y / 2;
            break;
        } //顶部的 高半径 编辑点


        dragger = this.createDragger({
          position: Object(PointUtil["getPositionByHprAndOffset"])(positionZXD, offestTop, hpr),
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改宽度"),
          onDrag: function onDrag(dragger, position) {
            var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_this.position, position), 2);

            style.dimensions_y = radius * 2;

            _this.updatePlane(style);
          },
          onDragEnd: function onDragEnd(dragger, position) {
            _this.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      }
    }
  }, {
    key: "updatePlane",
    value: function updatePlane(style) {
      var dimensions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](style.dimensions_x, style.dimensions_y);
      this.entityGraphic.dimensions.setValue(dimensions);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.dimensions_x) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.dimensions_y)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditPlane;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/PlaneEntity.js








function PlaneEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PlaneEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PlaneEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PlaneEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PlaneEntity_createSuper(Derived) { var hasNativeReflectConstruct = PlaneEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PlaneEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 平面 支持的样式信息
 *
 * @typedef {Object} PlaneEntity.StyleOptions
 *
 * @property {Cesium.Cartesian2} [dimensions] 指定平面的宽度和高度。
 * @property {Number} [dimensions_x = 100] 长度
 * @property {Number} [dimensions_y = 100] 宽度
 * @property {Cesium.Plane} [plane] 指定平面的法线和距离。
 * @property {String} [plane_normal = "z"] 方向 ,可选项：x (解释：X轴),y (解释：Y轴),z (解释：Z轴),
 * @property {Number} [plane_distance = 0] 偏移距离
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {Boolean} [fill = true] 是否填充

 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {Boolean} [randomColor = false] 是否随机颜色
 * @property {String} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定平面是投射还是接收来自光源的阴影。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.PlaneGraphics.ConstructorOptions
 */

/**
 * 平面  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {PlaneEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PlaneEntity_PlaneEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(PlaneEntity, _BasePointEntity);

  var _super = PlaneEntity_createSuper(PlaneEntity);

  function PlaneEntity() {
    classCallCheck_default()(this, PlaneEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(PlaneEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PlaneGraphics}
     * @readonly
     */
    function get() {
      return this._entity.plane;
    }
    /**
     * 编辑处理类
     * @type {EditPlane}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditPlane_EditPlane;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          position: this.position,
          orientation: this.getOrientation(),
          plane: PlaneStyleConver_PlaneStyleConver.toCesiumVal(this.style, {}, true)
        };
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PlaneStyleConver_PlaneStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.heading) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.pitch) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.roll)) {
        this._entity.orientation = this.getOrientation();
      }

      PlaneStyleConver_PlaneStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
    }
  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      get_default()(getPrototypeOf_default()(PlaneEntity.prototype), "_setPositionsToCallback", this).call(this);

      var dimensions = Object(Util["getCesiumValue"])(this.entityGraphic.dimensions, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"], this._map.clock.currentTime);
      PlaneStyleConver_PlaneStyleConver.toOneJson("dimensions", dimensions, this.style);
      var plane = Object(Util["getCesiumValue"])(this.entityGraphic.plane, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Plane"], this._map.clock.currentTime);
      PlaneStyleConver_PlaneStyleConver.toOneJson("plane", plane, this.style);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {PlaneEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new PlaneEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.plane) {
        return undefined;
      }

      return new PlaneEntity(PlaneEntity_objectSpread(PlaneEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PlaneEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("plane", PlaneEntity_PlaneEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditCylinder.js






function EditCylinder_createSuper(Derived) { var hasNativeReflectConstruct = EditCylinder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditCylinder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var EditCylinder_EditCylinder = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditCylinder, _EditPoly);

  var _super = EditCylinder_createSuper(EditCylinder);

  function EditCylinder() {
    classCallCheck_default()(this, EditCylinder);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditCylinder, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions;
      var center = positions[0]; //中心点

      var index = 0;
      var dragger = this.createDragger({
        position: center,
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDrag: function onDrag(dragger, position) {
          positions[0] = position;
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      dragger.index = index;
      this.draggers.push(dragger); //获取圆（或椭圆）边线上的坐标点数组

      var outerPositions = getEllipseOuterPositions({
        position: center,
        semiMajorAxis: this.style.bottomRadius,
        //长半轴
        semiMinorAxis: this.style.bottomRadius,
        //短半轴
        rotation: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(Number(this.style.rotation || 0))
      }); //底部半径 拖拽点

      index = 1;
      var majorPos = outerPositions[0];
      positions[index] = majorPos;
      var bottomRadiusDragger = this.createDragger({
        position: majorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDrag: function onDrag(dragger, position) {
          positions[1] = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position), 2);

          _this.style.bottomRadius = radius;
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      bottomRadiusDragger.index = index;
      this.draggers.push(bottomRadiusDragger); // 高度 拖拽点

      index = 2;
      var positionTop = Object(PointUtil["addPositionsHeight"])(center, this.style.length);
      positions[index] = positionTop;
      var draggerTop = this.createDragger({
        position: positionTop,
        type: PointType.MoveHeight,
        tooltip: this._map.getLangText("_修改高度"),
        onDrag: function onDrag(dragger, position) {
          positions[dragger.index] = position;

          var length = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position), 2);

          _this.style.length = length;
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      draggerTop.index = index;
      this.draggers.push(draggerTop);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.topRadius) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.bottomRadius) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.length) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditCylinder;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/CylinderEntity.js








function CylinderEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CylinderEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CylinderEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CylinderEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CylinderEntity_createSuper(Derived) { var hasNativeReflectConstruct = CylinderEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CylinderEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









/**
 * 圆锥 支持的样式信息
 *
 * @typedef {Object} CylinderEntity.StyleOptions
 *
 * @property {Number} [topRadius = 0] 顶部半径，指定圆柱体顶部的半径，当为0时即为圆锥。
 * @property {Number} [bottomRadius = 100] 底部半径，指定圆柱体底部半径。
 * @property {Number} [length = 100] 高度，柱面长度。
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {Boolean} [fill = true] 是否填充
 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String} [color = "#00FF00"] 填充颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
 * @property {number} [slices=128] 圆柱体周长周围的边数。
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定圆柱是投射还是接收来自光源的阴影。
 *
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 *  @see Cesium.CylinderGraphics.ConstructorOptions
 */

/**
 * 圆锥  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {CylinderEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var CylinderEntity_CylinderEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(CylinderEntity, _BasePointEntity);

  var _super = CylinderEntity_createSuper(CylinderEntity);

  function CylinderEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CylinderEntity);

    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.CylinderGraphics}
   * @readonly
   */


  createClass_default()(CylinderEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.cylinder;
    }
    /**
     * 编辑处理类
     * @type {EditCylinder}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditCylinder_EditCylinder;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        CylinderStyleConver_CylinderStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
      } else {
        this._entity = this._createEntity(this._getCreateEntityAttr());
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
  }, {
    key: "_getCreateEntityAttr",
    value: function _getCreateEntityAttr() {
      var addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        cylinder: CylinderStyleConver_CylinderStyleConver.toCesiumVal(this.style, {}, true)
      };
      return addattr;
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver_CylinderStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.heading) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.pitch) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.roll)) {
        this._entity.orientation = this.getOrientation();
      }

      CylinderStyleConver_CylinderStyleConver.toCesiumVal(this.style, this.entityGraphic, {}, true);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.length) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight)) {
        var _this$_positions_draw;

        if (((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 0) {
          this._position_show = Object(PointUtil["addPositionsHeight"])(this._positions_draw[0], this.style.length / 2);
        }
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      var _this$_positions_draw2;

      if (this._enabledEdit && this.editing && ((_this$_positions_draw2 = this._positions_draw) === null || _this$_positions_draw2 === void 0 ? void 0 : _this$_positions_draw2.length) > 0) {
        this._position_show = Object(PointUtil["addPositionsHeight"])(this._positions_draw[0], this.style.length / 2);
      }

      get_default()(getPrototypeOf_default()(CylinderEntity.prototype), "_updatePositionsHook", this).call(this);
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this2 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true;
      var time = this._map.clock.currentTime;
      this.style.topRadius = Object(Util["getCesiumValue"])(this.entityGraphic.topRadius, Number, time);
      this.entityGraphic.topRadius = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2.style.topRadius;
      }, false);
      this.style.bottomRadius = Object(Util["getCesiumValue"])(this.entityGraphic.bottomRadius, Number, time);
      this.entityGraphic.bottomRadius = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2.style.bottomRadius;
      }, false);
      this.style.length = Object(Util["getCesiumValue"])(this.entityGraphic.length, Number, time);
      this.entityGraphic.length = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2.style.length;
      }, false); //位置

      if (this.position) {
        this._positions_draw = this.positions;
        this._positions_draw[0] = Object(PointUtil["addPositionsHeight"])(this.position, -this.style.length / 2);
      } else {
        this._positions_draw = [];
      }

      this._position_show = this.position;
      this.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2._position_show;
      }, false);
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this.entityGraphic.length = this.style.length;
      this.entityGraphic.topRadius = this.style.topRadius;
      this.entityGraphic.bottomRadius = this.style.bottomRadius;
      this._position = this._position_show;

      this._updatePositionsHook();
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.rightClick, this._onRightClickHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      this._position_show = Object(PointUtil["addPositionsHeight"])(this._positions_draw[0], this.style.length / 2); //半径处理

      if (!isEditing && this._positions_draw.length > 1) {
        var radius = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], this._positions_draw[1]), 2);
        this.style.bottomRadius = radius;
        this.style.length = radius * 2;
      }
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {CylinderEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new CylinderEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.cylinder) {
        return undefined;
      }

      return new CylinderEntity(CylinderEntity_objectSpread(CylinderEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return CylinderEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("cylinder", CylinderEntity_CylinderEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditEllipsoid.js






function EditEllipsoid_createSuper(Derived) { var hasNativeReflectConstruct = EditEllipsoid_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditEllipsoid_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var EditEllipsoid_EditEllipsoid = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditEllipsoid, _EditBase);

  var _super = EditEllipsoid_createSuper(EditEllipsoid);

  function EditEllipsoid() {
    classCallCheck_default()(this, EditEllipsoid);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditEllipsoid, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var dragger;
      var center = this.positions[0]; //位置中心点

      dragger = this.createDragger({
        position: center,
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDrag: function onDrag(dragger, position) {
          _this.positions[0] = position;
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      this.draggers.push(dragger); //顶部的 高半径 编辑点

      dragger = this.createDragger({
        position: Object(PointUtil["addPositionsHeight"])(center, this.style.radii_z),
        type: PointType.MoveHeight,
        tooltip: this._map.getLangText("_修改半径"),
        onDrag: function onDrag(dragger, position) {
          var positionZXD = _this.positions[0];

          var length = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positionZXD, position), 2);

          _this.style.radii_z = length; //高半径

          _this._graphic.updateRadii(_this.style);
        }
      });
      this.draggers.push(dragger); //获取圆（或椭圆）边线上的坐标点数组

      var outerPositions = getEllipseOuterPositions({
        position: center,
        semiMajorAxis: Number(this.style.radii_x),
        semiMinorAxis: Number(this.style.radii_y),
        rotation: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(Number(this.style.rotation || 0))
      }); //长半轴上的坐标点

      var majorPos = outerPositions[0];
      var majorDragger = this.createDragger({
        position: majorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDrag: function onDrag(dragger, position) {
          var positionZXD = _this.positions[0];
          var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positionZXD).height;
          position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
          dragger.position = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positionZXD, position), 2);

          _this.style.radii_y = radius; //长半轴

          _this._graphic.updateRadii(_this.style);
        }
      });
      dragger.majorDragger = majorDragger;
      this.draggers.push(majorDragger); //短半轴上的坐标点

      var minorPos = outerPositions[1];
      var minorDragger = this.createDragger({
        position: minorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDrag: function onDrag(dragger, position) {
          var positionZXD = _this.positions[0];
          var newHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positionZXD).height;
          position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
          dragger.position = position;

          var radius = _this.formatNum(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positionZXD, position), 2);

          _this.style.radii_x = radius; //短半轴

          _this._graphic.updateRadii(_this.style);
        }
      });
      dragger.minorDragger = minorDragger;
      this.draggers.push(minorDragger);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_x) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_y) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_z)) {
        this.updateDraggers();
      }
    }
  }]);

  return EditEllipsoid;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/entity/EllipsoidEntity.js







function EllipsoidEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function EllipsoidEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { EllipsoidEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { EllipsoidEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function EllipsoidEntity_createSuper(Derived) { var hasNativeReflectConstruct = EllipsoidEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipsoidEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 球、半球、椭球 支持的 样式信息
 *
 * @typedef {Object} EllipsoidEntity.StyleOptions
 *
 * @property {Cesium.Cartesian3} [radii] 指定椭球半径。
 * @property {Number} [radii_x = 100] X半径
 * @property {Number} [radii_y = 100] Y半径
 * @property {Number} [radii_z = 100] Z半径
 * @property {Cesium.Cartesian3} [innerRadii] 指定椭球的内半径。
 * @property {Number} [innerRadii_x = 0] 内部X半径
 * @property {Number} [innerRadii_y = 0] 内部Y半径
 * @property {Number} [innerRadii_z = 0] 内部Z半径
 *
 * @property {Number} [minimumClock = 0] 最小时钟角度（弧度值）
 * @property {Number} [minimumClockDegree = 0] 最小时钟角度（度数值，0-360度），与minimumClock二选一
 * @property {Number} [maximumClock = 360] 最大时钟角度（弧度值）
 * @property {Number} [maximumClockDegree = 360] 最大时钟角度（度数值，0-360度），与maximumClock二选一
 * @property {Number} [minimumCone = 0] 最小锥角（弧度值）
 * @property {Number} [minimumConeDegree = 0] 最小锥角（度数值，0-360度），与minimumCone二选一
 * @property {Number} [maximumCone = 180] 最大圆锥角（弧度值）
 * @property {Number} [maximumConeDegree = 180] 最大圆锥角（度数值，0-360度），与maximumCone二选一
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {Boolean} [fill = true] 是否填充

 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {number} [stackPartitions=64] 指定竖向划分数量
 * @property {number} [slicePartitions=64] 指定横向划分数量
 * @property {number} [subdivisions=128] 指定每个轮廓环的样本数量，确定曲率的粒度。
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 *
 * @property {Boolean} [hasShadows = false] 是否投射阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定椭球是否投射或接收来自光源的阴影。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.EllipsoidGraphics.ConstructorOptions
 */

/**
 * 动态扫描面 参数
 * @typedef {Object} EllipsoidEntity.ScanPlaneOptions
 *
 * @property {Object} planeOptions 扫描面构造参数
 * @property {String} [planeOptions.type='heading'] 扫描旋转的方向，可选值：'heading'，'pitch'，'roll'
 * @property {Number} [planeOptions.step=0.5] 旋转的步长（角度），控制速度
 * @property {EllipsoidEntity.StyleOptions} [planeOptions.style] 样式信息
 */

/**
 * 球、半球、椭球  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {EllipsoidEntity.StyleOptions} options.style 样式信息
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {EllipsoidEntity.ScanPlaneOptions|EllipsoidEntity.ScanPlaneOptions[]} options.scanPlane 动态扫描面
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var EllipsoidEntity_EllipsoidEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(EllipsoidEntity, _BasePointEntity);

  var _super = EllipsoidEntity_createSuper(EllipsoidEntity);

  function EllipsoidEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EllipsoidEntity);

    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 3; //最多允许点的个数

    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.EllipsoidGraphics}
   * @readonly
   */


  createClass_default()(EllipsoidEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.ellipsoid;
    }
    /**
     * 编辑处理类
     * @type {EditEllipsoid}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditEllipsoid_EditEllipsoid;
    } //内部用，文本等附加对象

  }, {
    key: "czmObjectEx",
    get: function get() {
      var arr = [];

      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }

      if (this._entity_scanPlane) {
        arr = arr.concat(this._entity_scanPlane);
      }

      return arr;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        EllipsoidStyleConver_EllipsoidStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
      } else {
        var addattr = {
          position: this.position,
          orientation: this.getOrientation(),
          ellipsoid: EllipsoidStyleConver_EllipsoidStyleConver.toCesiumVal(this.style, {}, true)
        };
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }

      var scanPlane = this.options.scanPlane || this.style.scanPlane;

      if (scanPlane) {
        if (Array.isArray(scanPlane)) {
          scanPlane.forEach(function (item) {
            _this2.addScanPlane(item);
          });
        } else {
          this.addScanPlane(scanPlane);
        }
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      styleJson = EllipsoidStyleConver_EllipsoidStyleConver.toJSON(czmStyle, styleJson);

      if (this._entity_scanPlane && this._entity_scanPlane.length > 0) {
        var scanPlane = [];

        this._entity_scanPlane.forEach(function (entity) {
          scanPlane.push(entity._planeOptions);
        });

        styleJson.scanPlane = scanPlane;
      }

      return styleJson;
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      this._entity.orientation = this.getOrientation();
      EllipsoidStyleConver_EllipsoidStyleConver.toCesiumVal(this.style, this.entityGraphic, true);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_x) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_y) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.radii_z)) {
        this.updateRadii(this.style);
      }
    } //更新球的半径

  }, {
    key: "updateRadii",
    value: function updateRadii(style) {
      var radii = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](style.radii_x, style.radii_y, style.radii_z);

      if (this.entityGraphic.radii) {
        this.entityGraphic.radii.setValue(radii);
      } else {
        this.entityGraphic.radii = radii;
      }
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this3 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true;
      var radii = Object(Util["getCesiumValue"])(this.entityGraphic.radii, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"], this._map.clock.currentTime);

      if (radii) {
        this.style.radii_x = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.radii_x, radii.x);
        this.style.radii_y = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.radii_y, radii.y);
        this.style.radii_z = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.radii_z, radii.z);
      }

      this._positions_draw = this.positions || [];
      this.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        if (_this3._positions_draw.length < 1) {
          return null;
        }

        return _this3._positions_draw[0];
      }, false);
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this._position = this._positions_draw[0];

      this._updatePositionsHook();
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.rightClick, this._onRightClickHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      if (this._positions_draw.length < 2) {
        return;
      }

      if (!isEditing) {
        //半径处理
        var radius = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], this._positions_draw[1]), 2);
        this.style.radii_x = radius; //短半轴

        this.style.radii_z = radius; //长半轴

        var semiMajorAxis;

        if (this._positions_draw.length == 3) {
          semiMajorAxis = Object(Util["formatNum"])(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._positions_draw[0], this._positions_draw[2]), 2);
        } else {
          semiMajorAxis = radius;
        }

        this.style.radii_y = semiMajorAxis;
        this.updateRadii(this.style);
      }
    }
    /**
     * 添加 动态扫描面
     * @param {EllipsoidEntity.ScanPlaneOptions} planeOptions 扫描面构造参数
     * @return {Cesium.Entity} 矢量对象
     */

  }, {
    key: "addScanPlane",
    value: function addScanPlane() {
      var _this4 = this;

      var planeOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._entity_scanPlane = this._entity_scanPlane || [];
      planeOptions.style = planeOptions.style || {}; //默认样式

      var defStyle = {
        radii: this.entityGraphic.radii,
        innerRadii: 0.00001,
        minimumClockDegree: -0.00001,
        maximumClockDegree: 0.00001,
        minimumConeDegree: this.style.minimumConeDegree || 0.0,
        maximumConeDegree: this.style.maximumConeDegree || 90.0,
        outline: false
      };

      if (this.style.color) {
        defStyle.color = this.style.color;

        if (this.style.opacity) {
          defStyle.opacity = this.style.opacity;
        }
      } else if (this.style.outlineColor) {
        defStyle.color = this.style.outlineColor;

        if (this.style.outlineOpacity) {
          defStyle.opacity = this.style.outlineOpacity;
        }
      } //旋转动画回调


      var orientation;
      var step = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(planeOptions.step || 0.5);
      var headingPitchRoll = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(planeOptions.style.heading || this.heading), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(planeOptions.style.pitch || this.pitch), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(planeOptions.style.roll || this.roll));

      switch (planeOptions.type) {
        default:
        case "heading":
          {
            //heading四周环绕
            orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (e) {
              headingPitchRoll.heading = (headingPitchRoll.heading + step) % external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].TWO_PI;
              return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(_this4.position, headingPitchRoll);
            }, false);
          }
          break;

        case "pitch":
          {
            //pitch环绕
            var minimumCone = 0.0;
            var maximumCone = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI;
            orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (e) {
              headingPitchRoll.pitch += step;

              if (headingPitchRoll.pitch >= maximumCone) {
                headingPitchRoll.pitch = minimumCone; //Cesium.Math.PI_OVER_TWO为90度
              }

              return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(_this4.position, headingPitchRoll);
            }, false);
          }
          break;

        case "roll":
          {
            //roll环绕
            var _minimumCone = -external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO; //Cesium.Math.PI_OVER_TWO为90度


            var _maximumCone = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO;
            orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (e) {
              headingPitchRoll.roll += step;

              if (headingPitchRoll.roll >= _maximumCone) {
                headingPitchRoll.roll = _minimumCone;
              }

              return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(_this4.position, headingPitchRoll);
            }, false);
          }
          break;
      }

      var addattr = {
        id: "scanPlane-" + Object(Util["uuid"])(),
        position: this.position,
        orientation: orientation,
        ellipsoid: EllipsoidStyleConver_EllipsoidStyleConver.toCesiumVal(EllipsoidEntity_objectSpread(EllipsoidEntity_objectSpread({}, defStyle), planeOptions.style), {}, true)
      };

      var entity = this._createEntity(addattr);

      if (this.dataSource && this.isAdded) {
        this.dataSource.entities.add(entity);
      }

      this.bindPickId(entity);
      entity._planeOptions = planeOptions; //用于导出数据

      this._entity_scanPlane.push(entity);

      return entity;
    }
    /**
     * 移除单个指定的扫描面
     * @param {Cesium.Entity} entity addScanPlane返回的矢量对象
     * @return {void}  无
     */

  }, {
    key: "removeScanPlan",
    value: function removeScanPlan(entity) {
      if (this.dataSource && this.isAdded) {
        this.dataSource.entities.remove(entity);
      }

      Object(Util["removeArrayItem"])(this._entity_scanPlane, entity);
    }
    /**
     * 清除所有扫描面
     * @return {void}  无
     */

  }, {
    key: "removeAllScanPlan",
    value: function removeAllScanPlan() {
      var _this5 = this;

      if (this.dataSource && this.isAdded) {
        this._entity_scanPlane.forEach(function (entity) {
          _this5.dataSource.entities.remove(entity);
        });
      }

      this._entity_scanPlane = [];
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {EllipsoidEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new EllipsoidEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.ellipsoid) {
        return undefined;
      }

      return new EllipsoidEntity(EllipsoidEntity_objectSpread(EllipsoidEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return EllipsoidEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("ellipsoid", EllipsoidEntity_EllipsoidEntity);
// CONCATENATED MODULE: ./src/graphic/entity/PolylineEntity.js








function PolylineEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolylineEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolylineEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolylineEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolylineEntity_createSuper(Derived) { var hasNativeReflectConstruct = PolylineEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 线 支持的样式信息
 *
 * @typedef {Object} PolylineEntity.StyleOptions
 *
 * @property {String} [materialType = "Color"] 线型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {Number} [width = 4] 线宽
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Boolean} [randomColor = false] 是否随机颜色
 * @property {Cesium.MaterialProperty | Color} [depthFailMaterial] 指定当折线位于地形之下时用于绘制折线的材质。
 *
 * @property {Boolean} [closure = false] 是否闭合
 *
 * @property {Boolean} [outline = false] 是否衬色
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 衬色颜色
 * @property {Number} [outlineWidth = 2] 衬色宽度
 *
 * @property {Boolean} [depthFail = false] 是否显示遮挡
 * @property {String} [depthFailColor = "#ff0000"] 遮挡处颜色
 * @property {Number} [depthFailOpacity = 0.2] 遮挡处透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  折线段必须遵循的线的类型。
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 如果arcType不是arcType.none，则指定每个纬度和经度之间的角距离的数字属性。
 *
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Number} [zIndex = 0] 层级顺序,指定用于排序地面几何的zIndex。只有当' clampToGround '为真且支持地形上的折线时才会有效果。
 *
 * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 * @see Cesium.PolylineGraphics.ConstructorOptions
 */

/**
 * 线  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolylineEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 * @export
 * @class PolylineEntity
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PolylineEntity_PolylineEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(PolylineEntity, _BasePolyEntity);

  var _super = PolylineEntity_createSuper(PolylineEntity);

  function PolylineEntity() {
    classCallCheck_default()(this, PolylineEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylineEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PolylineGraphics}
     * @readonly
     */
    function get() {
      return this._entity.polyline;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          polyline: PolylineStyleConver_PolylineStyleConver.toCesiumVal(this.style, {}, true)
        };
        addattr.polyline.positions = this.getShowPositon(this.positions);
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
  }, {
    key: "getShowPositon",
    value: function getShowPositon(positions) {
      if (this.style.closure && (positions === null || positions === void 0 ? void 0 : positions.length) > 0) {
        return positions.concat(positions[0]);
      } else {
        return positions;
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PolylineStyleConver_PolylineStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PolylineStyleConver_PolylineStyleConver.toCesiumVal(this.style, this.entityGraphic, true);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.closure)) {
        this.updateAttrForDrawing();
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this.entityGraphic.positions = this.getShowPositon(this._positions); //中心文本处理

      this._updateLabelPosition(); //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    } //==================Draw绘制相关=================

  }, {
    key: "_positions_CallbackProperty",
    value: function _positions_CallbackProperty() {
      return this.getShowPositon(this._positions_draw);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.entityGraphic.depthFailMaterial)) {
        this.entityGraphic.positions = this._positions_CallbackProperty();
      } //中心文本处理


      this._updateLabelPosition();
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      get_default()(getPrototypeOf_default()(PolylineEntity.prototype), "_stopDrawHook", this).call(this); //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.entityGraphic.depthFailMaterial)) {
        this.positions = this._positions_draw;
      }
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {PolylineEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new PolylineEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.polyline) {
        return undefined;
      }

      return new PolylineEntity(PolylineEntity_objectSpread(PolylineEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PolylineEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("polyline", PolylineEntity_PolylineEntity);
// CONCATENATED MODULE: ./src/graphic/entity/PolylineVolumeEntity.js







function PolylineVolumeEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolylineVolumeEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolylineVolumeEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolylineVolumeEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolylineVolumeEntity_createSuper(Derived) { var hasNativeReflectConstruct = PolylineVolumeEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineVolumeEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 管道线 支持的样式信息
 *
 * @typedef {Object} PolylineVolumeEntity.StyleOptions
 *
 * @property {Number} [radius = 10] 半径
 * @property {String|Array<Cesium.Cartesian2>} [shape = "pipeline"] 形状类型 或 定义要挤压的形状。类型可选项：pipeline (解释：空心管),circle (解释：实心管),star (解释：星状管),
 * @property {boolean} [fill=true] 是否填充
 * @property {String} [color = "#FFFF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后fillType和color属性将被覆盖。
 *
 * @property {Boolean} [outline = false] 是否边线
 * @property {number} [outlineWidth=1.0] 边线宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边线颜色
 * @property {Number} [outlineOpacity = opacity] 边框透明度
 *
 * @property {Cesium.CornerType} [cornerType=CornerType.ROUNDED] 指定边角的样式。
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否投射阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定管道是否投射或接收来自光源的阴影。
 *
 * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.PolylineVolumeGraphics.ConstructorOptions
 */

/**
 * 管道线  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolylineVolumeEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class PolylineVolumeEntity
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PolylineVolumeEntity_PolylineVolumeEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(PolylineVolumeEntity, _BasePolyEntity);

  var _super = PolylineVolumeEntity_createSuper(PolylineVolumeEntity);

  function PolylineVolumeEntity() {
    classCallCheck_default()(this, PolylineVolumeEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylineVolumeEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PolylineVolumeEntity}
     * @readonly
     */
    function get() {
      return this._entity.polylineVolume;
    }
    /**
     * 编辑处理类
     * @type {EditPoly}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditPoly_EditPoly;
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          polylineVolume: PolylineVolumeStyleConver_PolylineVolumeStyleConver.toCesiumVal(this.style, {}, true)
        };
        addattr.polylineVolume.positions = this.positions;
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PolylineVolumeStyleConver_PolylineVolumeStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PolylineVolumeStyleConver_PolylineVolumeStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this.entityGraphic.positions = this.positions; //如果在编辑中，更新编辑的拖拽点。

      this._updateEditDraggers();
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {PolylineVolumeEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new PolylineVolumeEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.polylineVolume) {
        return undefined;
      }

      return new PolylineVolumeEntity(PolylineVolumeEntity_objectSpread(PolylineVolumeEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PolylineVolumeEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("polylineVolume", PolylineVolumeEntity_PolylineVolumeEntity);
// CONCATENATED MODULE: ./src/graphic/entity/PathEntity.js








function PathEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PathEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PathEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PathEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PathEntity_createSuper(Derived) { var hasNativeReflectConstruct = PathEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PathEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * path路径 支持的样式信息
 *
 * @typedef {Object} PathEntity.StyleOptions
 *
 * @property {Number} [width=1.0] 以像素为单位指定宽度的数字属性。
 * @property {String} [color = "#FFFF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后fillType和color属性将被覆盖。
 * @property {Number} [leadTime] 指定要在保留path对象前面显示的秒数。
 * @property {Number} [trailTime] 指定要显示的对象后面的秒数。
 * @property {Number} [resolution=60]  指定在对位置进行采样时步进的最大秒数。
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.PathGraphics.ConstructorOptions
 */

/**
 * path路径  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {Cesium.SampledPositionProperty} options.position 坐标位置（含时序的点集合）
 * @param {Cesium.Property} [options.orientation] 实体方向
 * @param {PathEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {LabelEntity.StyleOptions} [options.label]  设置是否显示 文本 和对应的样式
 * @param {ModelEntity.StyleOptions} [options.model]  设置是否显示 gltf模型 和对应的样式
 * @param {PointEntity.StyleOptions} [options.point]  设置是否显示 像素点 和对应的样式，如果不设置gltf模型时，可以选择该项。
 * @param {BillboardEntity.StyleOptions} [options.billboard]  设置是否显示 图标 和对应的样式，如果不设置gltf模型时，可以选择该项。
 *
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class PathEntity
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PathEntity_PathEntity = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(PathEntity, _BasePointEntity);

  var _super = PathEntity_createSuper(PathEntity);

  function PathEntity() {
    classCallCheck_default()(this, PathEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(PathEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PathGraphics}
     * @readonly
     */
    function get() {
      return this._entity.path;
    }
    /**
     * 获取当前时间的三维空间中的旋转。
     * @type {Cesium.Quaternion}
     * @readonly
     */

  }, {
    key: "orientationShow",
    get: function get() {
      var _orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this.orientation, this._map.clock.currentTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"]());

      return _orientation;
    }
    /**
     * 获取当前时间的方向角
     * @type {Cesium.HeadingPitchRoll}
     * @readonly
     */

  }, {
    key: "hpr",
    get: function get() {
      return Object(PointUtil["getHeadingPitchRollByOrientation"])(this.positionShow, this.orientationShow);
    }
    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "pitch",
    get: function get() {
      var _this$style$pitch;

      return (_this$style$pitch = this.style.pitch) !== null && _this$style$pitch !== void 0 ? _this$style$pitch : 0;
    },
    set: function set(val) {
      this.style.pitch = val;
      this.updateOrientation();
    }
    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "roll",
    get: function get() {
      var _this$style$roll;

      return (_this$style$roll = this.style.roll) !== null && _this$style$roll !== void 0 ? _this$style$roll : 0;
    },
    set: function set(val) {
      this.style.roll = val;
      this.updateOrientation();
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      get_default()(getPrototypeOf_default()(PathEntity.prototype), "_updatePositionsHook", this).call(this);

      if (!this.position || this.position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]) {
        this._entity.orientation = undefined;
        this._entity.availability = undefined;
      } else {
        var _this$position, _this$position$_prope, _this$position$_prope2;

        if (this.options._auto_orientation) {
          this._entity.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](this.position); //基于移动位置自动计算方位
        }

        if (this.options._auto_availability && ((_this$position = this.position) === null || _this$position === void 0 ? void 0 : (_this$position$_prope = _this$position._property) === null || _this$position$_prope === void 0 ? void 0 : (_this$position$_prope2 = _this$position$_prope._times) === null || _this$position$_prope2 === void 0 ? void 0 : _this$position$_prope2.length) > 0) {
          var times = this.position._property._times;
          this._entity.availability = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeIntervalCollection"]([new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
            start: times[0],
            stop: times[times.length - 1]
          })]);
        }
      }
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);

        this._updateStyleHook(this.style);
      } else {
        var _this$position2, _this$position2$_prop, _this$position2$_prop2;

        if (this.position && !this.options.orientation) {
          this.options.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](this.position); //基于移动位置自动计算方位
        }

        var addattr = {
          position: this.position,
          orientation: this.options.orientation,
          path: PathStyleConver_PathStyleConver.toCesiumVal(this.style || this.options.path, {}, true)
        };

        if (!this.options.availability && ((_this$position2 = this.position) === null || _this$position2 === void 0 ? void 0 : (_this$position2$_prop = _this$position2._property) === null || _this$position2$_prop === void 0 ? void 0 : (_this$position2$_prop2 = _this$position2$_prop._times) === null || _this$position2$_prop2 === void 0 ? void 0 : _this$position2$_prop2.length) > 0) {
          var times = this.position._property._times;
          addattr.availability = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeIntervalCollection"]([new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
            start: times[0],
            stop: times[times.length - 1]
          })]);
        }

        if (this.options.label) {
          this.options.label.text = this.options.label.text || this.name;
          addattr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.options.label);
        }

        if (this.options.billboard) {
          addattr.billboard = BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.options.billboard);
        }

        if (this.options.point) {
          addattr.point = PointStyleConver_PointStyleConver.toCesiumVal(this.options.point);
        }

        if (this.options.model) {
          addattr.model = ModelStyleConver_ModelStyleConver.toCesiumVal(this.options.model, {}, true);

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.model.heading)) {
            //由于模型不是标准的方向时的处理
            var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.options.model.heading);
            addattr.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
              var _this$_map, _this$_map$scene;

              var position = _this.position;
              var hpr;

              if (_this.options.orientation) {
                var orientation = _this.options.orientation.getValue(time);

                hpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, orientation);
                hpr.heading += heading;
              } else {
                hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading);
              }

              return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr, (_this$_map = _this._map) === null || _this$_map === void 0 ? void 0 : (_this$_map$scene = _this$_map.scene) === null || _this$_map$scene === void 0 ? void 0 : _this$_map$scene.globe.ellipsoid);
            }, false);
          }
        }

        this._entity = this._createEntity(addattr);
      }
    }
  }, {
    key: "_initSampledPositionProperty",
    value: function _initSampledPositionProperty() {
      this._cacheTimes = [];
      this._clampToTilesetFrame = -1;
      this._frameRate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.frameRate, 30);
      this._maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxCacheCount, 50); //保留的坐标点数量

      if (!this.position) {
        var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
        property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.forwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
        property.backwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.backwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);

        if (!this.options.orientation) {
          this.options.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](property);

          if (this._entity) {
            this._entity.orientation = this.getOrientation();
          }
        }

        if (this._entity && !this._entity.availability && this._map) {
          this._entity.availability = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeIntervalCollection"]([new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
            start: this._map.clock.currentTime,
            stop: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addDays(this._map.clock.currentTime, 1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]())
          })]);
        }

        this.position = property;
      }

      this.property = this.position;
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PathStyleConver_PathStyleConver.toCesiumVal(this.style, this.entityGraphic, {}, true);
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PathStyleConver_PathStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 定位至当前时间所在的位置 (非相机位置)
     *
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} options.radius 相机距离目标点的距离（单位：米）
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToPoint",
    value: function flyToPoint() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      var positionShow = this.positionShow;

      if (!positionShow) {
        return;
      }

      if (this._map.scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        this._map.clock.shouldAnimate = false;
        setTimeout(function () {
          var _this2$hpr;

          if (options.duration === 0) {
            options.duration = 0.01;
          }

          var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(((_this2$hpr = _this2.hpr) === null || _this2$hpr === void 0 ? void 0 : _this2$hpr.heading) || 0) + external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.heading, 0);

          _this2._map.flyToPoint(positionShow, PathEntity_objectSpread(PathEntity_objectSpread({}, options), {}, {
            heading: heading,
            complete: function complete() {
              _this2._map.clock.shouldAnimate = true;
            }
          }));
        }, 10);
      } else {
        //二维模式下
        if (this._entity) {
          this._map.flyTo(this._entity);
        }
      }
    } //==================静态方法=================

  }], [{
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.path) {
        return undefined;
      }

      return new PathEntity(PathEntity_objectSpread(PathEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PathEntity;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("path", PathEntity_PathEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditCorridor.js







function EditCorridor_createSuper(Derived) { var hasNativeReflectConstruct = EditCorridor_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditCorridor_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var EditCorridor_EditCorridor = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditCorridor, _EditPoly);

  var _super = EditCorridor_createSuper(EditCorridor);

  function EditCorridor() {
    classCallCheck_default()(this, EditCorridor);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditCorridor, [{
    key: "updatePositionsHeightByAttr",
    value: //继承父类，根据属性更新坐标
    function updatePositionsHeightByAttr(position) {
      if (this.entityGraphic.height != undefined) {
        var newHeight = Object(Util["getCesiumValue"])(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
      }

      return position;
    } //创建Dragger拖动点的公共方法

  }, {
    key: "createDragger",
    value: function createDragger(options) {
      var dragger = get_default()(getPrototypeOf_default()(EditCorridor.prototype), "createDragger", this).call(this, options);

      if (this.clampToGround) {
        dragger.position = Object(PointUtil["getSurfacePosition"])(this._map.scene, dragger.position);
      }

      return dragger;
    }
  }]);

  return EditCorridor;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/CorridorEntity.js







function CorridorEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CorridorEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CorridorEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CorridorEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CorridorEntity_createSuper(Derived) { var hasNativeReflectConstruct = CorridorEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CorridorEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 走廊 支持的样式信息
 *
 * @typedef {Object} CorridorEntity.StyleOptions
 *
 * @property {Number} [width = 100] 走廊宽度，指定走廊边缘之间的距离。
 * @property {String|Cesium.CornerType} [cornerType = "ROUNDED"] 指定边角的样式。String可选项：ROUNDED (解释：圆滑),MITERED (解释：斜接),BEVELED (解释：斜切),
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
 * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
 *
 * @property {boolean} [fill=true] 是否填充。
 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后fillType和color属性将被覆盖。
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {Number} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度和经度之间的距离。
 *
 * @property {Boolean} [hasShadows = false] 是否投射阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定走廊是投射还是接收来自光源的阴影。
 *
 * @property {String} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Number} [zIndex = 0] 层级顺序，用于排序。只有在高度和挤压高度未定义，并且走廊是静态的情况下才有效果。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.CorridorGraphics.ConstructorOptions
 */

/**
 * 走廊  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {CorridorEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var CorridorEntity_CorridorEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(CorridorEntity, _BasePolyEntity);

  var _super = CorridorEntity_createSuper(CorridorEntity);

  function CorridorEntity() {
    classCallCheck_default()(this, CorridorEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(CorridorEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.CorridorGraphics}
     * @readonly
     */
    function get() {
      return this._entity.corridor;
    }
    /**
     * 编辑处理类
     * @type {EditCorridor}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditCorridor_EditCorridor;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();
        CorridorStyleConver_CorridorStyleConver.toCesiumVal(this.style, this.entityGraphic, true);
      } else {
        var addattr = {
          corridor: CorridorStyleConver_CorridorStyleConver.toCesiumVal(this.style, {}, true)
        };
        addattr.corridor.positions = this.positions;
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return CorridorStyleConver_CorridorStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      CorridorStyleConver_CorridorStyleConver.toCesiumVal(this.style, this.entityGraphic, true);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height)) {
        this._updateHeight();
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this.entityGraphic.positions = this.positions; //如果在编辑中，更新编辑的拖拽点。

      this._updateEditDraggers();
    } //高度处理

  }, {
    key: "_updateHeight",
    value: function _updateHeight() {
      if (this.style.clampToGround) {
        return;
      }

      var height = 0;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.height)) {
        height = this.style.height;
      } else {
        height = Object(PointUtil["getMaxHeight"])(this._positions_draw || this._positions);
      }

      this.entityGraphic.height = height;
      this.style.height = height; //存在extrudedHeight高度设置时

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
        if (this.style.diffHeight > 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }
    } //==================Draw绘制相关=================

  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      if (!isEditing) {
        if (!this.style.clampToGround) {
          var maxHight = Object(PointUtil["getMaxHeight"])(this._positions_draw);

          if (maxHight != 0) {
            this.entityGraphic.height = maxHight;
            this.style.height = maxHight;

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
              if (this.style.diffHeight > 0) {
                this.entityGraphic.extrudedHeight = maxHight + Number(this.style.diffHeight);
              } else {
                this.entityGraphic.extrudedHeight = undefined;
              }
            }
          }
        }
      } else {
        this._updateHeight();
      }
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {CorridorEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new CorridorEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.corridor) {
        return undefined;
      }

      return new CorridorEntity(CorridorEntity_objectSpread(CorridorEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return CorridorEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("corridor", CorridorEntity_CorridorEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditWall.js






function EditWall_createSuper(Derived) { var hasNativeReflectConstruct = EditWall_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditWall_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var EditWall_EditWall = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditWall, _EditPoly);

  var _super = EditWall_createSuper(EditWall);

  function EditWall() {
    classCallCheck_default()(this, EditWall);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditWall, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions;
      var style = this.style;
      var hasMidPoint = this.hasMidPoint; //是否有新增点

      for (var i = 0, len = positions.length; i < len; i++) {
        var position = positions[i]; //各顶点

        var dragger = this.createDragger({
          position: position,
          onDrag: function onDrag(dragger, position) {
            positions[dragger.index] = position; //============高度调整拖拽点处理=============

            if (_this._heightDraggers && _this._heightDraggers.length > 0) {
              _this._heightDraggers[dragger.index].position = Object(PointUtil["addPositionsHeight"])(position, style.diffHeight);
            } //============新增点拖拽点处理=============


            if (hasMidPoint) {
              if (dragger.index > 0) {
                //与前一个点之间的中点
                _this.draggers[dragger.index * 2 - 1].position = Object(PointUtil["getMidpoint"])(position, positions[dragger.index - 1], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
              }

              if (dragger.index < positions.length - 1) {
                //与后一个点之间的中点
                _this.draggers[dragger.index * 2 + 1].position = Object(PointUtil["getMidpoint"])(position, positions[dragger.index + 1]);
              }
            } //============整体平移移动点处理=============


            var positionMove = centerOfMass(positions);
            _this._draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger); //中间点，拖动后新增点

        if (this.hasMidPoint && (this.hasClosure || !this.hasClosure && i < len - 1)) {
          var nextIndex = (i + 1) % len;
          var midpoint = Object(PointUtil["getMidpoint"])(position, positions[nextIndex]);
          var draggerMid = this.createDragger({
            position: midpoint,
            type: PointType.AddMidPoint,
            tooltip: this._map.getLangText("_增加点"),
            onDragStart: function onDragStart(dragger, position) {
              _this.positions.splice(dragger.index, 0, position); //插入点


              _this.updateAttrForEditing();
            },
            onDrag: function onDrag(dragger, position) {
              _this.positions[dragger.index] = position;
            },
            onDragEnd: function onDragEnd(dragger, position) {
              _this.updateDraggers();
            }
          });
          draggerMid.index = nextIndex;
          this.draggers.push(draggerMid);
        }
      } //整体平移移动点


      this._bindMoveAllDragger(); //创建高程拖拽点


      this._bindHeightDraggers();
    } //高度调整拖拽点

  }, {
    key: "_bindHeightDraggers",
    value: function _bindHeightDraggers() {
      var _this2 = this;

      this._heightDraggers = [];
      var positions = this.positions;
      var diffHeight = Number(this.style.diffHeight);

      for (var i = 0, len = positions.length; i < len; i++) {
        var position = Object(PointUtil["addPositionsHeight"])(positions[i], diffHeight);
        var dragger = this.createDragger({
          position: position,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改高度"),
          onDrag: function onDrag(dragger, position) {
            var thisHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position).height;
            _this2.style.diffHeight = Object(Util["formatNum"])(thisHeight - _this2._graphic._minimumHeights[dragger.index], 2);

            for (var _i = 0; _i < positions.length; _i++) {
              if (_i == dragger.index) {
                continue;
              }

              _this2._heightDraggers[_i].position = Object(PointUtil["addPositionsHeight"])(positions[_i], _this2.style.diffHeight);
            }

            _this2.updateAttrForEditing();
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);

        this._heightDraggers.push(dragger);
      }
    }
  }]);

  return EditWall;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/WallEntity.js








function WallEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WallEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WallEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WallEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WallEntity_createSuper(Derived) { var hasNativeReflectConstruct = WallEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WallEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 墙 支持的样式信息
 *
 * @typedef {Object} WallEntity.StyleOptions
 *
 * @property {Number} [diffHeight = 100] 墙高
 * @property {Array<number>} [minimumHeights] 没有指定diffHeight时，可以指定用于墙壁底部而不是球体表面的高度数组。
 * @property {Array<number>} [maximumHeights] 没有指定diffHeight时，可以指定用于墙顶的高度数组，而不是每个位置的高度。
 *
 * @property {Boolean} [fill = true] 是否填充
 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [closure = false] 是否闭合
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定墙壁是投射还是接收来自光源的阴影。
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 * @see Cesium.WallGraphics.ConstructorOptions
 */

/**
 * 墙  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {WallEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class WallEntity
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var WallEntity_WallEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(WallEntity, _BasePolyEntity);

  var _super = WallEntity_createSuper(WallEntity);

  function WallEntity() {
    classCallCheck_default()(this, WallEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(WallEntity, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.WallGraphics}
     * @readonly
     */
    function get() {
      return this._entity.wall;
    }
    /**
     * 编辑处理类
     * @type {EditWall}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditWall_EditWall;
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this.style.diffHeight = this.style.diffHeight || 100; //必须得有墙高

      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();

        this._updateStyleHook(this.style);
      } else {
        var _this$positions;

        var addattr = {
          wall: WallStyleConver_WallStyleConver.toCesiumVal(this.style, {}, true)
        };

        if (this.style.closure && ((_this$positions = this.positions) === null || _this$positions === void 0 ? void 0 : _this$positions.length) > 0) {
          addattr.wall.positions = this.positions.concat(this.positions[0]);
        } else {
          addattr.wall.positions = this.positions;
        }

        if (!this.style.maximumHeights || !this.style.minimumHeights) {
          this._updateMaxMinHeights(addattr);
        }

        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return WallStyleConver_WallStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      WallStyleConver_WallStyleConver.toCesiumVal(this.style, this.entityGraphic, true);

      if (newStyle !== null && newStyle !== void 0 && newStyle.diffHeight) {
        this._updateMaxMinHeights();
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      var _this$positions2;

      if (this.style.closure && ((_this$positions2 = this.positions) === null || _this$positions2 === void 0 ? void 0 : _this$positions2.length) > 0) {
        this.entityGraphic.positions = this.positions.concat(this.positions[0]);
      } else {
        this.entityGraphic.positions = this.positions;
      }

      if (!this.style.maximumHeights || !this.style.minimumHeights) {
        this._updateMaxMinHeights(this._entity);
      } //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    }
  }, {
    key: "_updateMaxMinHeights",
    value: function _updateMaxMinHeights(target) {
      var points = this.points;

      if (!points || points.length == 0) {
        return;
      }

      var len = points.length;
      var minimumHeights = new Array(len);
      var maximumHeights = new Array(len);

      for (var i = 0; i < len; i++) {
        var height = points[i].alt;
        minimumHeights[i] = height;
        maximumHeights[i] = height + this.style.diffHeight;
      }

      this._minimumHeights = minimumHeights;
      this._maximumHeights = maximumHeights;

      if (target) {
        if (this.style.closure) {
          if (!(target.wall.minimumHeights instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"])) {
            target.wall.minimumHeights = minimumHeights.concat(minimumHeights[0]);
          }

          if (!(target.wall.maximumHeights instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"])) {
            target.wall.maximumHeights = maximumHeights.concat(maximumHeights[0]);
          }
        } else {
          if (!(target.wall.minimumHeights instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"])) {
            target.wall.minimumHeights = minimumHeights;
          }

          if (!(target.wall.maximumHeights instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"])) {
            target.wall.maximumHeights = maximumHeights;
          }
        }
      }
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this = this;

      if (this._isCallbackPositions) {
        return;
      }

      get_default()(getPrototypeOf_default()(WallEntity.prototype), "_setPositionsToCallback", this).call(this); // this._minimumHeights = this._minimumHeights|| []


      this.entityGraphic.minimumHeights = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        var arr = _this._minimumHeights;

        if (_this.style.closure && (arr === null || arr === void 0 ? void 0 : arr.length) > 0) {
          //闭合
          return arr.concat(arr[0]);
        } else {
          return arr;
        }
      }, false); // this._maximumHeights = []

      this.entityGraphic.maximumHeights = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        var arr = _this._maximumHeights;

        if (_this.style.closure && (arr === null || arr === void 0 ? void 0 : arr.length) > 0) {
          //闭合
          return arr.concat(arr[0]);
        } else {
          return arr;
        }
      }, false);
    }
  }, {
    key: "_positions_CallbackProperty",
    value: function _positions_CallbackProperty() {
      var _this$_positions_draw;

      if (this.style.closure && ((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 0) {
        return this._positions_draw.concat(this._positions_draw[0]); //闭合线
      } else {
        return this._positions_draw;
      }
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      var _this$_minimumHeights;

      if (!this._isCallbackPositions) {
        return;
      }

      get_default()(getPrototypeOf_default()(WallEntity.prototype), "_cancelPositionsCallback", this).call(this);

      if (this.style.closure && ((_this$_minimumHeights = this._minimumHeights) === null || _this$_minimumHeights === void 0 ? void 0 : _this$_minimumHeights.length) > 0) {
        //闭合
        this.entityGraphic.minimumHeights = this._minimumHeights.concat(this._minimumHeights[0]);
        this.entityGraphic.maximumHeights = this._maximumHeights.concat(this._maximumHeights[0]);
      } else {
        this.entityGraphic.minimumHeights = this._minimumHeights;
        this.entityGraphic.maximumHeights = this._maximumHeights;
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      this._updateMaxMinHeights();
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {WallEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new WallEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.wall) {
        return undefined;
      }

      return new WallEntity(WallEntity_objectSpread(WallEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return WallEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("wall", WallEntity_WallEntity);
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditRectangle.js






function EditRectangle_createSuper(Derived) { var hasNativeReflectConstruct = EditRectangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditRectangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var EditRectangle_EditRectangle = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditRectangle, _EditPoly);

  var _super = EditRectangle_createSuper(EditRectangle);

  function EditRectangle() {
    classCallCheck_default()(this, EditRectangle);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditRectangle, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions;

      for (var i = 0, len = positions.length; i < len; i++) {
        var position = this.updatePositionsHeightByAttr(positions[i]); //各顶点

        var dragger = this.createDragger({
          position: position,
          onDrag: function onDrag(dragger, position) {
            var time = _this._map.clock.currentTime;

            if (_this.entityGraphic.height != undefined) {
              var newHeight = Object(Util["getCesiumValue"])(_this.entityGraphic.height, Number, time);
              position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
              dragger.position = position;
            }

            _this.positions[dragger.index] = position; //============高度调整拖拽点处理=============

            if (_this._heightDraggers && _this._heightDraggers.length > 0) {
              var extrudedHeight = Object(Util["getCesiumValue"])(_this.entityGraphic.extrudedHeight, Number, time);
              _this._heightDraggers[dragger.index].position = Object(PointUtil["setPositionsHeight"])(position, extrudedHeight);
            } //============整体平移移动点处理=============


            var positionMove = centerOfMass(_this.positions);
            positionMove = _this.updatePositionsHeightByAttr(positionMove);
            _this._draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);
      } //整体平移移动点


      this._bindMoveAllDragger(); //创建高程拖拽点


      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    } //根据属性更新坐标

  }, {
    key: "updatePositionsHeightByAttr",
    value: function updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        //贴地时求贴模型和贴地的高度
        position = Object(PointUtil["getSurfacePosition"])(this._map, position);
      }

      if (this.entityGraphic.height != undefined) {
        var newHeight = Object(Util["getCesiumValue"])(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = Object(PointUtil["setPositionsHeight"])(position, newHeight);
      }

      return position;
    }
  }]);

  return EditRectangle;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/RectangleEntity.js








function RectangleEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function RectangleEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RectangleEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RectangleEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RectangleEntity_createSuper(Derived) { var hasNativeReflectConstruct = RectangleEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectangleEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }












/**
 * 矩形 支持的样式信息
 *
 * @typedef {Object} RectangleEntity.StyleOptions
 *
 *
 *
 * @property {Boolean} [fill = true] 是否填充

 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {Number} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
 * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
 *
 * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
 * @property {Number} [stRotation = 0] 矩形纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 矩形纹理的角度（度数值，0-360度），与stRotation二选一
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定矩形是投射还是接收来自光源的阴影。
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定矩形上各点之间的角距离。
 * @property {String} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Number} [zIndex = 0] 层级顺序，指定用于排序地面几何的zIndex。只有当矩形为常量且没有指定height或extrdedheight时才有效果。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.RectangleGraphics.ConstructorOptions
 */

/**
 * 矩形  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {Cesium.Rectangle|Cesium.PositionProperty} options.rectangle  矩形范围，与positions二选一。
 *
 * @param {RectangleEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class RectangleEntity
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var RectangleEntity_RectangleEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(RectangleEntity, _BasePolyEntity);

  var _super = RectangleEntity_createSuper(RectangleEntity);

  function RectangleEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RectangleEntity);

    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    if (_this.options.rectangle) {
      _this._rectangle = _this.options.rectangle;
    } else if (_this.options.coordinates) {
      _this._rectangle = _this.options.coordinates;
    }

    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.RectangleGraphics}
   * @readonly
   */


  createClass_default()(RectangleEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.rectangle;
    }
    /**
     * 编辑处理类
     * @type {EditRectangle}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditRectangle_EditRectangle;
    } //中心点坐标，覆盖父类

  }, {
    key: "center",
    get: function get() {
      var rectangle = Object(Util["getCesiumValue"])(this.rectangle);

      if (!this.rectangle) {
        return null;
      }

      var position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].toCartesian(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].center(rectangle));
      return position;
    }
    /**
     * 矩形的边线坐标集合（笛卡尔坐标）
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "outlinePositions",
    get: function get() {
      if (this._entity) {
        //!this._outlinePositions?.length > 0 &&
        this._outlinePositions = RectangleEntity_getOutlinePositions(this._entity);
      }

      return this._outlinePositions;
    },
    set: function set(value) {
      this._outlinePositions = value;
    }
    /**
     * 矩形的边线坐标集合（经纬度二维数组），示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7], …… ]
     * @type {Array[]}
     * @readonly
     */

  }, {
    key: "outlineCoordinates",
    get: function get() {
      return Object(PointTrans["cartesians2lonlats"])(this.outlinePositions);
    }
    /**
     * 坐标数据对应的矩形边界对象
     * @type {Cesium.Rectangle}
     */

  }, {
    key: "rectangle",
    get: function get() {
      if (!this._rectangle && this.positions) {
        this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
      }

      return this._rectangle;
    },
    set: function set(value) {
      this._rectangle = value;

      if (this._entity) {
        this.entityGraphic.coordinates = value;
      }
    }
  }, {
    key: "points",
    get: function get() {
      var _points = [];

      var _positions;

      if (this._positions_draw) {
        _positions = this._positions_draw;
      } else {
        _positions = this._positions;
      }

      if (!_positions) {
        _positions = RectangleEntity_getOutlinePositions(this._entity, false);
      }

      _positions.forEach(function (item) {
        var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

        if (!_point) {
          return;
        }

        _points.push(_point);
      });

      this._points = _points;
      return this._points;
    } //距离长度（单位：米）

  }, {
    key: "distance",
    get: function get() {
      return getDistance(this.outlinePositions);
    } //面积（单位：平方米）

  }, {
    key: "area",
    get: function get() {
      return getArea(this.outlinePositions);
    } //获取entity的实际坐标值

  }, {
    key: "getEntityPositions",
    value: function getEntityPositions() {
      if (!this._entity.rectangle) {
        return null;
      }

      var re = Object(Util["getCesiumValue"])(this._entity.rectangle.coordinates, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]); //Rectangle

      var height = Object(Util["getCesiumValue"])(this._entity.rectangle.height, Number) || 0;
      var ptMin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(re.west, re.south, height); //西、南

      var ptMax = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(re.east, re.north, height); //东、北

      return [ptMin, ptMax];
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          rectangle: RectangleStyleConver_RectangleStyleConver.toCesiumVal(this.style, {}, true)
        };
        addattr.rectangle.coordinates = this.rectangle;
        this._entity = this._createEntity(addattr);

        this._updateHeight();
      } //边线


      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return RectangleStyleConver_RectangleStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      RectangleStyleConver_RectangleStyleConver.toCesiumVal(this.style, this.entityGraphic, true); //边线

      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //边线


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height)) {
        //高度处理
        this._updateHeight();
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this.rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
      this.outlinePositions = RectangleEntity_getOutlinePositions(this._entity); //边线处理

      this._updateOutlineStyle(this.entityGraphic, [this.outlinePositions]); //中心文本处理


      this._updateLabelPosition(); //高度处理


      this._updateHeight(); //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    }
  }, {
    key: "_getOutlineStyle",
    value: function _getOutlineStyle(exStyle) {
      var outlineStyle = get_default()(getPrototypeOf_default()(RectangleEntity.prototype), "_getOutlineStyle", this).call(this, exStyle);

      outlineStyle.arcType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcType"].RHUMB;
      return outlineStyle;
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Polygon",
        coordinates: [this.coordinates]
      };
    } //==================Draw绘制相关=================
    //将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑

  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {
      var _this2 = this;

      if (this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = true;

      if (this.positions) {
        this._positions_draw = this.positions;
        this._rectangle_draw = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
      } else {
        this._positions_draw = [];
        this._rectangle_draw = null;
      }

      this.rectangle = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2._rectangle_draw;
      }, false); //存在边线时

      this._updateOutlineToCallback();
    } //坐标CallbackProperty属性改为实际值

  }, {
    key: "_cancelPositionsCallback",
    value: function _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return;
      }

      this._isCallbackPositions = false;
      this._positions = this._positions_draw;
      this.rectangle = this._rectangle_draw;

      this._cancelOutlinePositionsCallback();
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      this._rectangle_draw = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this._positions_draw);

      if (this._entity_outlines) {
        this._updateOutlineToCallback();

        this._outlinePositions = RectangleEntity_getOutlinePositions(this._entity);
      } //高度处理


      this._updateHeight(false); //中心文本处理


      this._updateLabelPosition();
    } //高度处理

  }, {
    key: "_updateHeight",
    value: function _updateHeight() {
      var judgeHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.style.clampToGround) {
        return;
      }

      var height = 0;

      if (judgeHeight && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.height)) {
        height = this.style.height;
      } else {
        height = Object(PointUtil["getMaxHeight"])(this._positions_draw || this._positions);
      }

      this.entityGraphic.height = height;
      this.style.height = height; //存在extrudedHeight高度设置时

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight)) {
        if (this.style.diffHeight > 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }
    }
    /**
     * 获取矩形的4个边线坐标集合（笛卡尔坐标）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @return  {Cesium.Cartesian3[]} 边线坐标数组
     */

  }, {
    key: "getOutlinePositions",
    value: function getOutlinePositions(closure) {
      return RectangleEntity_getOutlinePositions(this._entity, closure);
    }
    /**
     * 获取矩形的4个边线坐标集合（经纬度二维数组）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @return  {Array[]} 边线坐标数组（经纬度二维数组）
     */

  }, {
    key: "getOutlineCoordinates",
    value: function getOutlineCoordinates(closure) {
      return Object(PointTrans["cartesians2lonlats"])(this.getOutlinePositions(closure));
    }
    /**
     * 判断点是否在矩形内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在矩形内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      var _this$_entity$rectang;

      var rectangle = Object(Util["getCesiumValue"])((_this$_entity$rectang = this._entity.rectangle) === null || _this$_entity$rectang === void 0 ? void 0 : _this$_entity$rectang.coordinates, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]);
      var isInRectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].contains(rectangle, LatLngPoint["a" /* LatLngPoint */].parse(position).toCartographic());
      return isInRectangle;
    } //飞行定位至图层数据所在的视角

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      options.clampToGround = this.style.clampToGround;

      this._map.flyToExtent(this.rectangle, options);

      return this;
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {RectangleEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new RectangleEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.rectangle) {
        return undefined;
      }

      return new RectangleEntity(RectangleEntity_objectSpread(RectangleEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return RectangleEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("rectangle", RectangleEntity_RectangleEntity); //获取entity对应的 边界 的坐标

function RectangleEntity_getOutlinePositions(entity) {
  var closure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!entity || !entity.rectangle) {
    return [];
  }

  var re = Object(Util["getCesiumValue"])(entity.rectangle.coordinates, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]);

  if (!re) {
    return [];
  }

  var rotation = Object(Util["getCesiumValue"])(entity.rectangle.rotation, Number) || 0; //Rectangle

  var height = Object(Util["getCesiumValue"])(entity.rectangle.height, Number) || 0;
  var arr = getRectangleOuterPositions({
    rectangle: re,
    rotation: rotation,
    height: height
  });

  if (closure) {
    arr.push(arr[0]);
  }

  return arr;
}
// CONCATENATED MODULE: ./src/util/PolygonHierarchyUtil.js


 //获取entity的多个坐标【只取多圈的坐标，如挖洞多边形】

function getAllPositions(entity) {
  var arr = Object(Util["getCesiumValue"])(entity.polygon.hierarchy, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]);
  var result = getHierarchyVal(arr);
  return result;
} //获取entity的坐标【只取最外层圈坐标】

function getPositions(entity, isShowPositions) {
  if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) {
    return entity._positions_draw;
  } //箭头标绘等情形时，取绑定的数据


  var arr = Object(Util["getCesiumValue"])(entity.polygon.hierarchy, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]);

  if (arr && arr instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]) {
    arr = arr.positions;
  }

  return arr;
}

function getHierarchyVal(arr) {
  if (arr && arr instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]) {
    var result = [];

    for (var i = 0, len = arr.holes.length; i < len; i++) {
      var item = arr.holes[i]; //PolygonHierarchy

      result = result.concat(getHierarchyVal(item));
    }

    result.push(arr.positions);
    return result;
  } else {
    return [arr];
  }
} //取PolygonHierarchy


function getPolygonHierarchy(coordinates) {
  if (coordinates.length == 0) {
    return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]();
  }

  var holes = [];

  if (coordinates.length > 1) {
    for (var i = 1, len = coordinates.length; i < len; i++) {
      holes.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](Object(PointTrans["lonlats2cartesians"])(coordinates[i])));
    }
  }

  var positions = coordinates[0];
  var hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](Object(PointTrans["lonlats2cartesians"])(positions), holes);
  return hierarchy;
}
// CONCATENATED MODULE: ./src/graphic/entity/edit/EditPolygon.js






function EditPolygon_createSuper(Derived) { var hasNativeReflectConstruct = EditPolygon_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditPolygon_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var EditPolygon_EditPolygon = /*#__PURE__*/function (_EditPoly) {
  inherits_default()(EditPolygon, _EditPoly);

  var _super = EditPolygon_createSuper(EditPolygon);

  function EditPolygon() {
    classCallCheck_default()(this, EditPolygon);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditPolygon, [{
    key: "hasClosure",
    get: //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this._graphic.hasClosure, true);
    } //是否贴地

  }, {
    key: "clampToGround",
    get: function get() {
      var _this$style$clampToGr, _this$_graphic, _this$_graphic$entity;

      return (_this$style$clampToGr = this.style.clampToGround) !== null && _this$style$clampToGr !== void 0 ? _this$style$clampToGr : !Object(Util["getCesiumValue"])((_this$_graphic = this._graphic) === null || _this$_graphic === void 0 ? void 0 : (_this$_graphic$entity = _this$_graphic.entityGraphic) === null || _this$_graphic$entity === void 0 ? void 0 : _this$_graphic$entity.perPositionHeight, Boolean);
    }
  }]);

  return EditPolygon;
}(EditPoly_EditPoly);
// CONCATENATED MODULE: ./src/graphic/entity/PolygonEntity.js








function PolygonEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolygonEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolygonEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolygonEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolygonEntity_createSuper(Derived) { var hasNativeReflectConstruct = PolygonEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolygonEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











var nullColor = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.01);
/**
 * 面 支持的样式信息
 *
 * @typedef {Object} PolygonEntity.StyleOptions
 *
 * @property {Boolean} [fill = true] 是否填充

 * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.MaterialProperty | Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 * @property {Boolean} [randomColor = false] 是否随机颜色
 *
 * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {Number} [outlineWidth = 1] 边框宽度
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
 * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE]  指定每个纬度点和经度点之间的角距离。
 * @property {Boolean | boolean} [closeTop=true]  当为false时，离开一个挤压多边形的顶部打开。
 * @property {Boolean | boolean} [closeBottom=true]  当为false时，离开挤压多边形的底部打开。
 * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  多边形的边缘必须遵循的线条类型。
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定多边形是投射还是接收来自光源的阴影。
 *
 * @property {String} [clampToGround = false] 是否贴地
 * @property {boolean} [perPositionHeight=false] 指定是否使用每个位置的高度。同clampToGround，与clampToGround反之
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Number} [zIndex = 0] 层级顺序，指定用于排序地面几何的zIndex。只有当多边形是常数且没有指定高度或挤压高度时才有效果。
 *
 * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 * @see Cesium.PolygonGraphics.ConstructorOptions
 */

/**
 * 面  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePolyEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var PolygonEntity_PolygonEntity = /*#__PURE__*/function (_BasePolyEntity) {
  inherits_default()(PolygonEntity, _BasePolyEntity);

  var _super = PolygonEntity_createSuper(PolygonEntity);

  function PolygonEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, PolygonEntity);

    _this = _super.call(this, options); //配置的参数

    _this._minPointNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](3, options.minPointNum); //至少需要点的个数

    return _this;
  }
  /**
   * 矢量数据对应的 Cesium内部对象的具体类型对象
   * @type {Cesium.PolygonGraphics}
   * @readonly
   */


  createClass_default()(PolygonEntity, [{
    key: "entityGraphic",
    get: function get() {
      return this._entity.polygon;
    }
    /**
     * 编辑处理类
     * @type {EditPolygon}
     * @readonly
     */

  }, {
    key: "EditClass",
    get: function get() {
      return EditPolygon_EditPolygon;
    } //中心点坐标，覆盖父类

  }, {
    key: "center",
    get: function get() {
      return this.centerOfMass;
    }
    /**
     * 对应的Cesium面entity内部位置对象
     * @type {Cesium.PolygonHierarchy}
     * @readonly
     */

  }, {
    key: "hierarchy",
    get: function get() {
      return this._hierarchy;
    }
    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象 或 Cesium.PolygonHierarchy
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]) {
        this._hierarchy = value;
        value = this._hierarchy.positions;
      }

      if (Array.isArray(value)) {
        //判断是否为存在holes的面
        if (value.length > 0 && Array.isArray(value[0]) && value[0].length > 0 && Array.isArray(value[0][0]) && Object(Util["isNumber"])(value[0][0][0])) {
          this._hierarchy = getPolygonHierarchy(value);
          value = this._hierarchy.positions;
        }

        var _points = [];
        var _positions = [];
        value.forEach(function (item) {
          var _point = LatLngPoint["a" /* LatLngPoint */].parse(item);

          if (!_point) {
            return;
          }

          _points.push(_point);

          _positions.push(_point.toCartesian());
        });
        this._points = _points;

        if (this._enabledEdit && this.editing) {
          this._positions_draw = _positions;
        } else {
          this._positions = _positions;
        }
      } else {
        this._positions = value;
      }

      if (this._entity) {
        this._updatePositionsHook();
      }
    } //获取entity的实际坐标值

  }, {
    key: "getEntityPositions",
    value: function getEntityPositions() {
      return getPositions(this._entity);
    } //方便子类覆盖

  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      return positions;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
        this.positions = this.getEntityPositions();

        this._updateStyleHook(this.style);
      } else {
        var addattr = {
          polygon: PolygonStyleConver_PolygonStyleConver.toCesiumVal(this.style, {}, true)
        };

        if (this._positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
          addattr.polygon.hierarchy = this._positions;
        } else if (this.hierarchy) {
          addattr.polygon.hierarchy = this.hierarchy;
        } else {
          addattr.polygon.hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](this.getShowPositions(this.positions));
        }

        this._entity = this._createEntity(addattr);
      } //存在extrudedHeight高度设置时


      this._updateDiffHeight();

      this._bindExType(); //边线


      this._updateOutlineStyle(this.entityGraphic, getAllPositions(this._entity)); //边线
      //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } //是特殊的面类型的处理

  }, {
    key: "_bindExType",
    value: function _bindExType() {
      //如果是建筑物时
      var buildings = this.options.buildings || this._layer.options.buildings;

      if (buildings) {
        if (buildings.bottomHeight) {
          var _bottomHeight = Number(this.attr[buildings.bottomHeight] || 0); //底部高度


          this._entity.polygon.height = _bottomHeight;
        }

        var floor = Number(this.attr[buildings.cloumn] || 1); //层数

        var height; //层高

        if (Object(Util["isNumber"])(buildings.height)) {
          height = buildings.height;
        } else if (Object(Util["isString"])(buildings.height)) {
          height = this.attr[buildings.height] || height;
        } else {
          height = 3.5; //默认值
        }

        var bottomHeight = Object(Util["getCesiumValue"])(this._entity.polygon.height) || 0;
        this._entity.polygon.extrudedHeight = bottomHeight + floor * height; //顶部高度
      } //如果是单体化时


      var dthCfg = this.options.dth || this._layer.options.dth;

      if (dthCfg) {
        this._entity.polygon.classificationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClassificationType"].BOTH;

        if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.color)) {
          this._entity.polygon.material = nullColor;
        }

        this._entity.polygon.perPositionHeight = false;
        this._entity.polygon.zIndex = 99;
      } //如果是行政区域反选遮罩层


      var maskCfg = this.options.mask || this._layer.options.mask;

      if (maskCfg) {
        var extent = {
          xmin: 73.0,
          xmax: 136.0,
          ymin: 3.0,
          ymax: 59.0
        };

        if (Object(Util["isObject"])(maskCfg) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.xmin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.xmax) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.ymin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.ymax)) {
          extent = maskCfg;
        }

        var outPositions = Object(PointTrans["lonlats2cartesians"])([[extent.xmin, extent.ymax], [extent.xmin, extent.ymin], [extent.xmax, extent.ymin], [extent.xmax, extent.ymax], [extent.xmin, extent.ymax]]);
        this._hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](outPositions, [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](this._positions)]);
        this.entityGraphic.hierarchy = this._hierarchy;
      }
    }
  }, {
    key: "_updateDiffHeight",
    value: function _updateDiffHeight() {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.diffHeight) || this.entityGraphic.extrudedHeight instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
        return;
      } //存在extrudedHeight高度设置时


      if (this.style.diffHeight > 0) {
        var height = 0;

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.height)) {
          height = this.style.height;
        } else {
          height = Object(PointUtil["getMaxHeight"])(this._positions_draw || this._positions);
        }

        this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
      } else {
        this.entityGraphic.extrudedHeight = undefined;
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PolygonStyleConver_PolygonStyleConver.toJSON(czmStyle, styleJson);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      PolygonStyleConver_PolygonStyleConver.toCesiumVal(this.style, this.entityGraphic, true);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.diffHeight) || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](newStyle.height)) {
        this._updateDiffHeight();
      } //边线


      this._updateOutlineStyle(this.entityGraphic, getAllPositions(this._entity)); //边线

    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      if (this._positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
        if (this._enabledEdit && this.editing && this._hierarchy) {
          this._hierarchy.positions = this.getShowPositions(this._positions_draw);
        } else {
          this.entityGraphic.hierarchy = this._positions;
        }
      } else if (this.hierarchy) {
        this.entityGraphic.hierarchy = this.hierarchy;
      } else {
        this.entityGraphic.hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](this.getShowPositions(this.positions));
      } //边线处理


      this._updateOutlineStyle(this.entityGraphic, getAllPositions(this._entity)); //中心文本处理


      this._updateLabelPosition(); //存在extrudedHeight高度设置时


      this._updateDiffHeight(); //如果在编辑中，更新编辑的拖拽点。


      this._updateEditDraggers();
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Polygon",
        coordinates: [this.coordinates]
      };
    } //==================Draw绘制相关=================

  }, {
    key: "_positions_CallbackProperty",
    value: function _positions_CallbackProperty() {
      return this._hierarchy;
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      var _this2 = this;

      get_default()(getPrototypeOf_default()(PolygonEntity.prototype), "_startDrawHook", this).call(this); //边线处理


      this._updateOutlineStyle(this.entityGraphic, [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2.outlinePositions;
      }, false)], {
        show: true,
        width: 2,
        color: this.style.color
      });
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      if (!this._hierarchy) {
        this._hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]();
      }

      var showPositions = this.getShowPositions(this._positions_draw);
      this._hierarchy.positions = showPositions; //中心文本处理

      this._updateLabelPosition(); //边线处理


      if ((showPositions === null || showPositions === void 0 ? void 0 : showPositions.length) > 0) {
        this.outlinePositions = showPositions.concat(showPositions[0]);
      } //绘制2个点时显示线


      var exStyle;

      if (this._positions_draw.length < this._minPointNum) {
        exStyle = {
          show: true,
          width: 2,
          color: this.style.color
        };
      }

      this._updateOutlineToCallback();

      this._updateOutlineStyle(this.entityGraphic, null, exStyle); //存在extrudedHeight高度设置时


      this._updateDiffHeight();
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {PolygonEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new PolygonEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.polygon) {
        return undefined;
      }

      return new PolygonEntity(PolygonEntity_objectSpread(PolygonEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return PolygonEntity;
}(BasePolyEntity_BasePolyEntity); //注册下

Object(GraphicUtil["register"])("polygon", PolygonEntity_PolygonEntity);
/**
 * 获取entity的坐标【只取最外层圈坐标】
 *
 * @param {Cesium.Entity} entity polygon面对象
 * @return  {Cesium.Cartesian3[]} 最外层圈坐标数组
 * @function
 */

PolygonEntity_PolygonEntity.getPositions = getPositions;
/**
 * 获取entity的多个坐标【只取多圈的坐标，如挖洞多边形】
 *
 * @param {Cesium.Entity} entity polygon面对象
 * @return  {Array[]}  多个 坐标数组
 * @function
 */

PolygonEntity_PolygonEntity.getAllPositions = getAllPositions;
// CONCATENATED MODULE: ./src/graphic/entity/DivBillboardEntity.js








function DivBillboardEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DivBillboardEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DivBillboardEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DivBillboardEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DivBillboardEntity_createSuper(Derived) { var hasNativeReflectConstruct = DivBillboardEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivBillboardEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * HTML转图片后的图标点Entity 支持的样式信息
 *
 * @typedef {Object} DivBillboardEntity.StyleOptions
 *
 * @property {BillboardEntity.StyleOptions} [图标点的参数] 支持父类的所有样式信息
 * @property {String} html Html内容
 *
 * @see Cesium.BillboardGraphics.ConstructorOptions
 */

/**
 * HTML转图片后的 图标点Entity，
 * 需要引入html2canvas或domtoimage插件进行DOM转图片
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {DivBillboardEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class DivBillboardEntity
 * @extends {BillboardEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var DivBillboardEntity_DivBillboardEntity = /*#__PURE__*/function (_BillboardEntity) {
  inherits_default()(DivBillboardEntity, _BillboardEntity);

  var _super = DivBillboardEntity_createSuper(DivBillboardEntity);

  function DivBillboardEntity() {
    classCallCheck_default()(this, DivBillboardEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(DivBillboardEntity, [{
    key: "_mountedHook",
    value:
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      get_default()(getPrototypeOf_default()(DivBillboardEntity.prototype), "_mountedHook", this).call(this);

      this._updateImage_delay();
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      get_default()(getPrototypeOf_default()(DivBillboardEntity.prototype), "_updateStyleHook", this).call(this, newStyle);

      if (newStyle.html || newStyle.iconSize || newStyle.color) {
        this._updateImage_delay();
      }
    }
  }, {
    key: "_updateImage_delay",
    value: function _updateImage_delay() {
      var _this = this;

      //setTimeout是为了优化效率
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      }

      this.updateTimer = setTimeout(function () {
        delete _this.updateTimer;

        if (!_this._entity) {
          return;
        }

        _this._updateImage();
      }, 300);
    } //更新图标

  }, {
    key: "_updateImage",
    value: function _updateImage() {
      var _this2 = this;

      var container = create("div");
      var content = this.style.html;

      if (Object(Util["isString"])(content)) {
        container.innerHTML = content;
      } else if (content instanceof Element) {
        container.appendChild(content);
      }

      document.body.appendChild(container);
      this._islosdImg = true;

      if (window.domtoimage) {
        //lib/dom2img/dom-to-image.js
        window.domtoimage.toPng(container).then(function (dataUrl) {
          _this2.entityGraphic.image = "" + dataUrl;
          document.body.removeChild(container);
          _this2._islosdImg = false;
        })["catch"](function (error) {
          Object(Log["logError"])("未知原因，导出失败!", error);
          document.body.removeChild(container);
          _this2._islosdImg = false;
        });
      } else if (window.html2canvas) {
        //lib/dom2img/html2canvas.js
        window.html2canvas(container, {
          backgroundColor: null,
          allowTaint: true
        }).then(function (canvas) {
          var newImg = new Image(canvas.width, canvas.height);
          newImg.src = canvas.toDataURL("image/png");
          _this2.entityGraphic.image = newImg;
          document.body.removeChild(container);
          _this2._islosdImg = false;
        })["catch"](function (error) {
          Object(Log["logError"])("未知原因，导出失败!", error);
          document.body.removeChild(container);
          _this2._islosdImg = false;
        });
      }
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {DivBillboardEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DivBillboardEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.billboard) {
        return undefined;
      }

      return new DivBillboardEntity(DivBillboardEntity_objectSpread(DivBillboardEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return DivBillboardEntity;
}(BillboardEntity_BillboardEntity); //注册下

Object(GraphicUtil["register"])("divBillboard", DivBillboardEntity_DivBillboardEntity);
// CONCATENATED MODULE: ./src/graphic/entity/FontBillboardEntity.js







function FontBillboardEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function FontBillboardEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FontBillboardEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FontBillboardEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function FontBillboardEntity_createSuper(Derived) { var hasNativeReflectConstruct = FontBillboardEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FontBillboardEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * Font CSS字体点转图片后的图标点  Entity 支持的样式信息
 *
 * @typedef {Object} FontBillboardEntity.StyleOptions
 *
 * @property {BillboardEntity.StyleOptions} [图标点的参数] 支持父类的所有样式信息
 * @property {String} [iconClass = "fa fa-automobile"] 字体css样式
 * @property {Number} [iconSize = 50] 字体大小
 * @property {String} [color='#ff0000'] 字体颜色
 *
 * @see BillboardEntity.StyleOptions
 */

/**
 * Font CSS字体点转图片后的图标点  Entity,
 * 需要引入html2canvas或domtoimage插件进行DOM转图片
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {FontBillboardEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var FontBillboardEntity_FontBillboardEntity = /*#__PURE__*/function (_DivBillboardEntity) {
  inherits_default()(FontBillboardEntity, _DivBillboardEntity);

  var _super = FontBillboardEntity_createSuper(FontBillboardEntity);

  function FontBillboardEntity() {
    classCallCheck_default()(this, FontBillboardEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(FontBillboardEntity, [{
    key: "_updateImage",
    value: //更新图标
    function _updateImage() {
      var _this = this;

      var size = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.iconSize, 50);
      var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.color, "#ff0000");
      var div = document.createElement("div"); //创建一个div

      div.setAttribute("style", "padding: 10px;text-align:center;max-width:" + (size + 10) + "px;max-height:" + (size + 10) + "px;");
      var jd = document.createElement("i");
      jd.setAttribute("class", external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.iconClass, "fa fa-automobile"));
      jd.setAttribute("style", "font-size:" + size + "px;color:" + color + ";");
      div.appendChild(jd);
      document.body.appendChild(div);
      this._islosdImg = true;

      if (window.domtoimage) {
        //lib/dom2img/dom-to-image.js
        window.domtoimage.toPng(div).then(function (dataUrl) {
          _this.entityGraphic.image = "" + dataUrl;
          document.body.removeChild(div);
          _this._islosdImg = false;
        })["catch"](function (error) {
          Object(Log["logError"])("未知原因，导出失败!", error);
          document.body.removeChild(div);
          _this._islosdImg = false;
        });
      } else if (window.html2canvas) {
        //lib/dom2img/html2canvas.js
        window.html2canvas(div, {
          backgroundColor: null,
          allowTaint: true
        }).then(function (canvas) {
          var newImg = new Image(canvas.width, canvas.height);
          newImg.src = canvas.toDataURL("image/png");
          _this.entityGraphic.image = newImg;
          document.body.removeChild(div);
          _this._islosdImg = false;
        })["catch"](function (error) {
          Object(Log["logError"])("未知原因，导出失败!", error);
          document.body.removeChild(div);
          _this._islosdImg = false;
        });
      }
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {FontBillboardEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new FontBillboardEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.billboard) {
        return undefined;
      }

      return new FontBillboardEntity(FontBillboardEntity_objectSpread(FontBillboardEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return FontBillboardEntity;
}(DivBillboardEntity_DivBillboardEntity); //注册下

Object(GraphicUtil["register"])("fontBillboard", FontBillboardEntity_FontBillboardEntity);
// CONCATENATED MODULE: ./src/graphic/entity/EllipseEntity.js







function EllipseEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function EllipseEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { EllipseEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { EllipseEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function EllipseEntity_createSuper(Derived) { var hasNativeReflectConstruct = EllipseEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipseEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 椭圆、椭圆柱 支持的样式信息
 *
 * @typedef {Object} EllipseEntity.StyleOptions
 *
 * @property {CircleEntity.StyleOptions} [圆的参数] 支持父类的所有样式信息
 * @property {Number} [semiMinorAxis = 100] 椭圆时的 短半径
 * @property {Number} [semiMajorAxis = 100] 椭圆时的 长半径
 *
 * @see Cesium.EllipseGraphics.ConstructorOptions
 */

/**
 * 椭圆、椭圆柱  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {EllipseEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {CircleEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var EllipseEntity_EllipseEntity = /*#__PURE__*/function (_CircleEntity) {
  inherits_default()(EllipseEntity, _CircleEntity);

  var _super = EllipseEntity_createSuper(EllipseEntity);

  function EllipseEntity() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EllipseEntity);

    _this = _super.call(this, options);
    _this._maxPointNum = 3; //最多允许点的个数

    return _this;
  } //==================静态方法=================

  /**
   * 通过标绘 来创建矢量对象
   *
   * @static
   * @param {GraphicLayer} layer 图层
   * @param {Object} options 矢量对象的构造参数
   * @return {EllipseEntity} 矢量对象
   */


  createClass_default()(EllipseEntity, null, [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new EllipseEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.ellipse) {
        return undefined;
      }

      return new EllipseEntity(EllipseEntity_objectSpread(EllipseEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return EllipseEntity;
}(CircleEntity_CircleEntity); //注册下

Object(GraphicUtil["register"])("ellipse", EllipseEntity_EllipseEntity);
// CONCATENATED MODULE: ./src/graphic/entity/CurveEntity.js







function CurveEntity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CurveEntity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CurveEntity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CurveEntity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CurveEntity_createSuper(Derived) { var hasNativeReflectConstruct = CurveEntity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CurveEntity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 曲线
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolylineEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
 * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @export
 * @class CurveEntity
 * @extends {PolylineEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var CurveEntity_CurveEntity = /*#__PURE__*/function (_PolylineEntity) {
  inherits_default()(CurveEntity, _PolylineEntity);

  var _super = CurveEntity_createSuper(CurveEntity);

  function CurveEntity() {
    classCallCheck_default()(this, CurveEntity);

    return _super.apply(this, arguments);
  }

  createClass_default()(CurveEntity, [{
    key: "getShowPositon",
    value: function getShowPositon(positions) {
      if (positions instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"]) {
        this._positions_curve = this.getShowPositon(this._positions_draw);
        return positions;
      }

      return getBezierCurve(positions, this.style.closure);
    } //==================Draw绘制相关=================

  }, {
    key: "_positions_CallbackProperty",
    value: function _positions_CallbackProperty() {
      return this._positions_curve;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      this._positions_curve = this.getShowPositon(this._positions_draw);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {CurveEntity} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new CurveEntity(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.polyline) {
        return undefined;
      }

      return new CurveEntity(CurveEntity_objectSpread(CurveEntity_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return CurveEntity;
}(PolylineEntity_PolylineEntity); //注册下

Object(GraphicUtil["register"])("curve", CurveEntity_CurveEntity);
// CONCATENATED MODULE: ./src/graphic/entity/ConeTrack.js







function ConeTrack_createSuper(Derived) { var hasNativeReflectConstruct = ConeTrack_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ConeTrack_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 圆锥追踪体 支持的样式信息
 *
 * @typedef {Object} ConeTrack.StyleOptions
 *
 * @property {Number} [angle] 圆锥追踪体张角（角度值，取值范围 0.01-89.99）
 * @property {Number} [bottomRadius = 100] 不指定angle时，也可以直接指定圆锥底部半径（单位：米）
 *
 * @property {Number} [length = 100]  圆锥追踪体长度值（单位：米），没有指定targetPosition时有效
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度），没有指定targetPosition时有效
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度），没有指定targetPosition时有效
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度），没有指定targetPosition时有效
 *
 * @property {CylinderEntity.StyleOptions} [其他] 支持父类其他样式
 *
 *  @see Cesium.CylinderGraphics.ConstructorOptions
 */

/**
 * 圆锥追踪体
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} [options.targetPosition] 追踪的目标位置
 * @param {ConeTrack.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class ConeTrack
 * @extends {CylinderEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var ConeTrack_ConeTrack = /*#__PURE__*/function (_CylinderEntity) {
  inherits_default()(ConeTrack, _CylinderEntity);

  var _super = ConeTrack_createSuper(ConeTrack);

  function ConeTrack() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ConeTrack);

    _this = _super.call(this, options);

    if (options.targetPosition) {
      _this.targetPosition = options.targetPosition;
    }

    return _this;
  }
  /**
   * 追踪的目标位置(确定了方向和距离)
   * @type {Cesium.Cartesian3}
   */


  createClass_default()(ConeTrack, [{
    key: "targetPosition",
    get: function get() {
      return this._targetPosition;
    },
    set: function set(value) {
      this._targetPoint = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._targetPosition = this._targetPoint.toCartesian();
    }
    /**
     * 追踪的目标位置
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "targetPoint",
    get: function get() {
      return this._targetPoint;
    }
    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */

  }, {
    key: "angle",
    get: function get() {
      return this.style.angle;
    },
    set: function set(val) {
      this.style.angle = val;
    }
  }, {
    key: "_getCreateEntityAttr",
    value: function _getCreateEntityAttr() {
      var _this2 = this;

      var addattr = get_default()(getPrototypeOf_default()(ConeTrack.prototype), "_getCreateEntityAttr", this).call(this);

      addattr.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        _this2._update(time);

        return _this2._cylinderPosition;
      }, false);
      addattr.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2._orientation;
      }, false);
      addattr.cylinder.length = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this2._cylinderLength;
      }, false);

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](addattr.cylinder.topRadius)) {
        addattr.cylinder.topRadius = 0.0;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.angle)) {
        addattr.cylinder.bottomRadius = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
          return _this2._cylinderBottomRadius;
        }, false);
      }

      return addattr;
    }
  }, {
    key: "_update",
    value: function _update(time) {
      var position = Object(PointUtil["getPositionValue"])(this.position, time);

      if (!position) {
        this._cylinderPosition = undefined;
        return;
      }

      var targetPosition = Object(PointUtil["getPositionValue"])(this.targetPosition, time);

      if (targetPosition) {
        this._cylinderLength = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(position, targetPosition);
        this._cylinderPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(position, targetPosition, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        this._orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(targetPosition, Object(PointUtil["getHeadingPitchRollForLine"])(targetPosition, position));
      } else {
        this._cylinderLength = this.style.length;
        var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll));
        this._orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr);
        this._cylinderPosition = Object(PointUtil["getPositionByHprAndLen"])(position, hpr, this._cylinderLength / 2);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.angle)) {
        this._cylinderBottomRadius = this._cylinderLength * Math.cos(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(90 - this.angle));
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {//无需计算，覆盖下父类
    }
  }]);

  return ConeTrack;
}(CylinderEntity_CylinderEntity); //注册下

Object(GraphicUtil["register"])("coneTrack", ConeTrack_ConeTrack);
// CONCATENATED MODULE: ./src/graphic/entity/rectangularSensor/RectangularSensorGraphics.js

/**
 * 相控阵雷达范围 Entity对象
 *
 * @alias RectangularSensorGraphics
 * @constructor
 *
 * @param {Object} [options] Object with the following properties:
 * @param {Number} [options.radius] 传感器的半径
 * @private
 */

function RectangularSensorGraphics(options) {
  this._show = undefined;
  this._radius = undefined;
  this._xHalfAngle = undefined;
  this._yHalfAngle = undefined;
  this._lineColor = undefined;
  this._showSectorLines = undefined;
  this._showSectorSegmentLines = undefined;
  this._showLateralSurfaces = undefined;
  this._material = undefined;
  this._showDomeSurfaces = undefined;
  this._showDomeLines = undefined;
  this._showIntersection = undefined;
  this._intersectionColor = undefined;
  this._intersectionWidth = undefined;
  this._showThroughEllipsoid = undefined;
  this._gaze = undefined;
  this._showScanPlane = undefined;
  this._scanPlaneColor = undefined;
  this._scanPlaneMode = undefined;
  this._scanPlaneRate = undefined;
  this._definitionChanged = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Event"]();
  this.merge(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"].EMPTY_OBJECT));
}

Object.defineProperties(RectangularSensorGraphics.prototype, {
  definitionChanged: {
    get: function get() {
      return this._definitionChanged;
    }
  },
  show: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("show"),
  radius: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("radius"),
  xHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("xHalfAngle"),
  yHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("yHalfAngle"),
  lineColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("lineColor"),
  showSectorLines: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showSectorLines"),
  showSectorSegmentLines: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showSectorSegmentLines"),
  showLateralSurfaces: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showLateralSurfaces"),
  material: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createMaterialPropertyDescriptor"]("material"),
  showDomeSurfaces: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showDomeSurfaces"),
  showDomeLines: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showDomeLines"),
  showIntersection: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showIntersection"),
  intersectionColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("intersectionColor"),
  intersectionWidth: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("intersectionWidth"),
  showThroughEllipsoid: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showThroughEllipsoid"),
  gaze: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("gaze"),
  showScanPlane: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("showScanPlane"),
  scanPlaneColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("scanPlaneColor"),
  scanPlaneMode: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("scanPlaneMode"),
  scanPlaneRate: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createPropertyDescriptor"]("scanPlaneRate")
});

RectangularSensorGraphics.prototype.clone = function (result) {
  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
    result = new RectangularSensorGraphics();
  }

  result.show = this.show;
  result.radius = this.radius;
  result.xHalfAngle = this.xHalfAngle;
  result.yHalfAngle = this.yHalfAngle;
  result.lineColor = this.lineColor;
  result.showSectorLines = this.showSectorLines;
  result.showSectorSegmentLines = this.showSectorSegmentLines;
  result.showLateralSurfaces = this.showLateralSurfaces;
  result.material = this.material;
  result.showDomeSurfaces = this.showDomeSurfaces;
  result.showDomeLines = this.showDomeLines;
  result.showIntersection = this.showIntersection;
  result.intersectionColor = this.intersectionColor;
  result.intersectionWidth = this.intersectionWidth;
  result.showThroughEllipsoid = this.showThroughEllipsoid;
  result.gaze = this.gaze;
  result.showScanPlane = this.showScanPlane;
  result.scanPlaneColor = this.scanPlaneColor;
  result.scanPlaneMode = this.scanPlaneMode;
  result.scanPlaneRate = this.scanPlaneRate;
  return result;
};

RectangularSensorGraphics.prototype.merge = function (source) {
  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](source)) {
    throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("source is required.");
  }

  this.slice = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.slice, source.slice);
  this.show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.show, source.show);
  this.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.radius, source.radius);
  this.xHalfAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.xHalfAngle, source.xHalfAngle);
  this.yHalfAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.yHalfAngle, source.yHalfAngle);
  this.lineColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.lineColor, source.lineColor);
  this.showSectorLines = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showSectorLines, source.showSectorLines);
  this.showSectorSegmentLines = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showSectorSegmentLines, source.showSectorSegmentLines);
  this.showLateralSurfaces = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showLateralSurfaces, source.showLateralSurfaces);
  this.material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.material, source.material);
  this.showDomeSurfaces = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showDomeSurfaces, source.showDomeSurfaces);
  this.showDomeLines = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showDomeLines, source.showDomeLines);
  this.showIntersection = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showIntersection, source.showIntersection);
  this.intersectionColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.intersectionColor, source.intersectionColor);
  this.intersectionWidth = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.intersectionWidth, source.intersectionWidth);
  this.showThroughEllipsoid = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showThroughEllipsoid, source.showThroughEllipsoid);
  this.gaze = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.gaze, source.gaze);
  this.showScanPlane = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.showScanPlane, source.showScanPlane);
  this.scanPlaneColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.scanPlaneColor, source.scanPlaneColor);
  this.scanPlaneMode = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.scanPlaneMode, source.scanPlaneMode);
  this.scanPlaneRate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.scanPlaneRate, source.scanPlaneRate);
};


// EXTERNAL MODULE: ./src/shaders/RectangularSensorVS.glsl
var RectangularSensorVS = __webpack_require__(31);
var RectangularSensorVS_default = /*#__PURE__*/__webpack_require__.n(RectangularSensorVS);

// EXTERNAL MODULE: ./src/shaders/RectangularSensorFS.glsl
var RectangularSensorFS = __webpack_require__(32);
var RectangularSensorFS_default = /*#__PURE__*/__webpack_require__.n(RectangularSensorFS);

// EXTERNAL MODULE: ./src/shaders/RectangularSensor.glsl
var shaders_RectangularSensor = __webpack_require__(30);
var RectangularSensor_default = /*#__PURE__*/__webpack_require__.n(shaders_RectangularSensor);

// EXTERNAL MODULE: ./src/shaders/RectangularSensorScanPlaneFS.glsl
var RectangularSensorScanPlaneFS = __webpack_require__(62);
var RectangularSensorScanPlaneFS_default = /*#__PURE__*/__webpack_require__.n(RectangularSensorScanPlaneFS);

// CONCATENATED MODULE: ./src/graphic/entity/rectangularSensor/RectangularSensorPrimitive.js
// 相控阵雷达范围





var BoundingSphere = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"];
var Cartesian3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"];
var RectangularSensorPrimitive_Color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"];
var combine = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["combine"];
var ComponentDatatype = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"];
var defaultValue = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"];
var defined = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"];
var DeveloperError = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"];
var Matrix4 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"];
var PrimitiveType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"];
var Buffer = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"];
var BufferUsage = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"];
var DrawCommand = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"];
var Pass = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Pass"];
var RenderState = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"];
var ShaderProgram = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"];
var ShaderSource = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderSource"];
var VertexArray = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexArray"];
var BlendingState = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BlendingState"];
var CullFace = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CullFace"];
var Material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"];
var SceneMode = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"];
var VertexFormat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexFormat"];
var CesiumMath = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"];
var Matrix3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"];
var JulianDate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]; // var BoxGeometry = Cesium.BoxGeometry;
// var EllipsoidGeometry = Cesium.EllipsoidGeometry;

var sin = Math.sin;
var cos = Math.cos;
var tan = Math.tan;
var atan = Math.atan;
var asin = Math.asin;
var RectangularSensorPrimitive_attributeLocations = {
  position: 0,
  normal: 1
};

function RectangularSensorPrimitive(options) {
  var that = this;
  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //是否显示

  this.show = defaultValue(options.show, true); //切分程度

  this.slice = defaultValue(options.slice, 32); //传感器的模型矩阵

  this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4());
  this._modelMatrix = new Matrix4();
  this._computedModelMatrix = new Matrix4();
  this._computedScanPlaneModelMatrix = new Matrix4(); //传感器的半径

  this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
  this._radius = undefined; //传感器水平半角

  this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
  this._xHalfAngle = undefined; //传感器垂直半角

  this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
  this._yHalfAngle = undefined; //线的颜色

  this.lineColor = defaultValue(options.lineColor, RectangularSensorPrimitive_Color.WHITE); //是否显示扇面的线

  this.showSectorLines = defaultValue(options.showSectorLines, true); //是否显示扇面和圆顶面连接的线

  this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true); //是否显示侧面

  this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true); //目前用的统一材质

  this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
  this._material = undefined;
  this._translucent = undefined; //侧面材质

  this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
  this._lateralSurfaceMaterial = undefined;
  this._lateralSurfaceTranslucent = undefined; //是否显示圆顶表面

  this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true); //圆顶表面材质

  this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
  this._domeSurfaceMaterial = undefined; //是否显示圆顶面线

  this.showDomeLines = defaultValue(options.showDomeLines, true); //是否显示与地球相交的线

  this.showIntersection = defaultValue(options.showIntersection, true); //与地球相交的线的颜色

  this.intersectionColor = defaultValue(options.intersectionColor, RectangularSensorPrimitive_Color.WHITE); //与地球相交的线的宽度（像素）

  this.intersectionWidth = defaultValue(options.intersectionWidth, 5.0); //是否穿过地球

  this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
  this._showThroughEllipsoid = undefined; //是否显示扫描面

  this.showScanPlane = defaultValue(options.showScanPlane, true); //扫描面颜色

  this.scanPlaneColor = defaultValue(options.scanPlaneColor, RectangularSensorPrimitive_Color.WHITE); //扫描面模式 垂直vertical/水平horizontal

  this.scanPlaneMode = defaultValue(options.scanPlaneMode, "horizontal"); //扫描速率

  this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);
  this._scanePlaneXHalfAngle = 0;
  this._scanePlaneYHalfAngle = 0; //时间计算的起点

  this._time = JulianDate.now();
  this._boundingSphere = new BoundingSphere();
  this._boundingSphereWC = new BoundingSphere(); //扇面 sector

  this._sectorFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorVA = undefined; //扇面边线 sectorLine

  this._sectorLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorLineVA = undefined; //扇面分割线 sectorSegmentLine

  this._sectorSegmentLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorSegmentLineVA = undefined; //弧面 dome

  this._domeFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeVA = undefined; //弧面线 domeLine

  this._domeLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeLineVA = undefined; //扫描面 scanPlane/scanRadial

  this._scanPlaneFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._scanPlaneBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._scanRadialCommand = undefined;
  this._colorCommands = [];
  this._frontFaceRS = undefined;
  this._backFaceRS = undefined;
  this._sp = undefined;
  this._uniforms = {
    u_type: function u_type() {
      return 0; //面
    },
    u_xHalfAngle: function u_xHalfAngle() {
      return that.xHalfAngle;
    },
    u_yHalfAngle: function u_yHalfAngle() {
      return that.yHalfAngle;
    },
    u_radius: function u_radius() {
      return that.radius;
    },
    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
      return that.showThroughEllipsoid;
    },
    u_showIntersection: function u_showIntersection() {
      return that.showIntersection;
    },
    u_intersectionColor: function u_intersectionColor() {
      return that.intersectionColor;
    },
    u_intersectionWidth: function u_intersectionWidth() {
      return that.intersectionWidth;
    },
    u_normalDirection: function u_normalDirection() {
      return 1.0;
    },
    u_lineColor: function u_lineColor() {
      return that.lineColor;
    }
  };
  this._scanUniforms = {
    u_xHalfAngle: function u_xHalfAngle() {
      return that._scanePlaneXHalfAngle;
    },
    u_yHalfAngle: function u_yHalfAngle() {
      return that._scanePlaneYHalfAngle;
    },
    u_radius: function u_radius() {
      return that.radius;
    },
    u_color: function u_color() {
      return that.scanPlaneColor;
    },
    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
      return that.showThroughEllipsoid;
    },
    u_showIntersection: function u_showIntersection() {
      return that.showIntersection;
    },
    u_intersectionColor: function u_intersectionColor() {
      return that.intersectionColor;
    },
    u_intersectionWidth: function u_intersectionWidth() {
      return that.intersectionWidth;
    },
    u_normalDirection: function u_normalDirection() {
      return 1.0;
    },
    u_lineColor: function u_lineColor() {
      return that.lineColor;
    }
  };
}

RectangularSensorPrimitive.prototype.update = function (frameState) {
  var mode = frameState.mode;

  if (!this.show || mode != SceneMode.SCENE3D) {
    return;
  }

  var createVS = false;
  var createRS = false;
  var createSP = false;
  var xHalfAngle = this.xHalfAngle;
  var yHalfAngle = this.yHalfAngle;

  if (xHalfAngle < 0.0 || yHalfAngle < 0.0) {
    throw new DeveloperError("halfAngle must be greater than or equal to zero.");
  }

  if (xHalfAngle == 0.0 || yHalfAngle == 0.0) {
    return;
  }

  if (this._xHalfAngle != xHalfAngle || this._yHalfAngle != yHalfAngle) {
    this._xHalfAngle = xHalfAngle;
    this._yHalfAngle = yHalfAngle;
    createVS = true;
  }

  var radius = this.radius;

  if (radius < 0.0) {
    throw new DeveloperError("this.radius must be greater than or equal to zero.");
  }

  var radiusChanged = false;

  if (this._radius != radius) {
    radiusChanged = true;
    this._radius = radius;
    this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
  }

  var modelMatrixChanged = !Matrix4.equals(this.modelMatrix, this._modelMatrix);

  if (modelMatrixChanged || radiusChanged) {
    Matrix4.clone(this.modelMatrix, this._modelMatrix);
    Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
    BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
  }

  var showThroughEllipsoid = this.showThroughEllipsoid;

  if (this._showThroughEllipsoid != this.showThroughEllipsoid) {
    this._showThroughEllipsoid = showThroughEllipsoid;
    createRS = true;
  }

  var material = this.material;

  if (this._material != material) {
    this._material = material;
    createRS = true;
    createSP = true;
  }

  var translucent = material.isTranslucent();

  if (this._translucent != translucent) {
    this._translucent = translucent;
    createRS = true;
  }

  if (this.showScanPlane) {
    var time = frameState.time;
    var timeDiff = JulianDate.secondsDifference(time, this._time);

    if (timeDiff < 0) {
      this._time = JulianDate.clone(time, this._time);
    }

    var percentage = Math.max(timeDiff % this.scanPlaneRate / this.scanPlaneRate, 0);
    var angle;
    var matrix3Scratch = new Matrix3();

    if (this.scanPlaneMode == "horizontal") {
      angle = 2 * yHalfAngle * percentage - yHalfAngle;
      var cosYHalfAngle = cos(angle);
      var tanXHalfAngle = tan(xHalfAngle);
      var maxX = atan(cosYHalfAngle * tanXHalfAngle);
      this._scanePlaneXHalfAngle = maxX;
      this._scanePlaneYHalfAngle = angle;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
    } else {
      angle = 2 * xHalfAngle * percentage - xHalfAngle;
      var tanYHalfAngle = tan(yHalfAngle);
      var cosXHalfAngle = cos(angle);
      var maxY = atan(cosXHalfAngle * tanYHalfAngle);
      this._scanePlaneXHalfAngle = angle;
      this._scanePlaneYHalfAngle = maxY;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
    }

    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
    Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
  }

  if (createVS) {
    createVertexArray(this, frameState);
  }

  if (createRS) {
    createRenderState(this, showThroughEllipsoid, translucent);
  }

  if (createSP) {
    createShaderProgram(this, frameState, material);
  }

  if (createRS || createSP) {
    createCommands(this, translucent);
  }

  var commandList = frameState.commandList;
  var passes = frameState.passes;
  var colorCommands = this._colorCommands;

  if (passes.render) {
    for (var i = 0, len = colorCommands.length; i < len; i++) {
      var colorCommand = colorCommands[i];
      commandList.push(colorCommand);
    }
  }
};

var nScratch = new Cartesian3(); //region -- VertexArray --
// /**
//  * 计算zoy面和zoy面单位扇形位置
//  * @param primitive
//  * @returns {{zoy: Array, zox: Array}}
//  */

function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
  var slice = primitive.slice; //以中心为角度

  var cosYHalfAngle = cos(yHalfAngle);
  var tanYHalfAngle = tan(yHalfAngle);
  var cosXHalfAngle = cos(xHalfAngle);
  var tanXHalfAngle = tan(xHalfAngle);
  var maxY = atan(cosXHalfAngle * tanYHalfAngle);
  var maxX = atan(cosYHalfAngle * tanXHalfAngle); //ZOY面单位圆

  var zoy = [];

  for (var i = 0; i < slice; i++) {
    var phi = 2 * maxY * i / (slice - 1) - maxY;
    zoy.push(new Cartesian3(0, sin(phi), cos(phi)));
  } //zox面单位圆


  var zox = [];

  for (var _i = 0; _i < slice; _i++) {
    var _phi = 2 * maxX * _i / (slice - 1) - maxX;

    zox.push(new Cartesian3(sin(_phi), 0, cos(_phi)));
  }

  return {
    zoy: zoy,
    zox: zox
  };
} // /**
//  * 计算扇面的位置
//  * @param unitPosition
//  * @returns {Array}
//  */


function computeSectorPositions(primitive, unitPosition) {
  var xHalfAngle = primitive.xHalfAngle,
      yHalfAngle = primitive.yHalfAngle,
      zoy = unitPosition.zoy,
      zox = unitPosition.zox;
  var positions = [];
  var matrix3Scratch = new Matrix3(); //zoy面沿y轴逆时针转xHalfAngle

  var matrix3 = Matrix3.fromRotationY(xHalfAngle, matrix3Scratch);
  positions.push(zoy.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  })); //zox面沿x轴顺时针转yHalfAngle

  matrix3 = Matrix3.fromRotationX(-yHalfAngle, matrix3Scratch);
  positions.push(zox.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  }).reverse()); //zoy面沿y轴顺时针转xHalfAngle

  matrix3 = Matrix3.fromRotationY(-xHalfAngle, matrix3Scratch);
  positions.push(zoy.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  }).reverse()); //zox面沿x轴逆时针转yHalfAngle

  matrix3 = Matrix3.fromRotationX(yHalfAngle, matrix3Scratch);
  positions.push(zox.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  }));
  return positions;
} // /**
//  * 创建扇面顶点
//  * @param context
//  * @param positions
//  * @returns {*}
//  */


function createSectorVertexArray(context, positions) {
  var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
  var vertices = new Float32Array(2 * 3 * 3 * planeLength);
  var k = 0;

  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];
    var n = Cartesian3.normalize(Cartesian3.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);

    for (var j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;
      vertices[k++] = planePositions[j].x;
      vertices[k++] = planePositions[j].y;
      vertices[k++] = planePositions[j].z;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;
      vertices[k++] = planePositions[j + 1].x;
      vertices[k++] = planePositions[j + 1].y;
      vertices[k++] = planePositions[j + 1].z;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;
    }
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });
  var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;
  var attributes = [{
    index: RectangularSensorPrimitive_attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }, {
    index: RectangularSensorPrimitive_attributeLocations.normal,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
    strideInBytes: stride
  }];
  return new VertexArray({
    context: context,
    attributes: attributes
  });
} // /**
//  * 创建扇面边线顶点
//  * @param context
//  * @param positions
//  * @returns {*}
//  */


function createSectorLineVertexArray(context, positions) {
  var planeLength = positions.length;
  var vertices = new Float32Array(3 * 3 * planeLength);
  var k = 0;

  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = planePositions[0].x;
    vertices[k++] = planePositions[0].y;
    vertices[k++] = planePositions[0].z;
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });
  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;
  var attributes = [{
    index: RectangularSensorPrimitive_attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];
  return new VertexArray({
    context: context,
    attributes: attributes
  });
} // /**
//  * 创建扇面圆顶面连接线顶点
//  * @param context
//  * @param positions
//  * @returns {*}
//  */


function createSectorSegmentLineVertexArray(context, positions) {
  var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
  var vertices = new Float32Array(3 * 3 * planeLength);
  var k = 0;

  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];

    for (var j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
      vertices[k++] = planePositions[j].x;
      vertices[k++] = planePositions[j].y;
      vertices[k++] = planePositions[j].z;
      vertices[k++] = planePositions[j + 1].x;
      vertices[k++] = planePositions[j + 1].y;
      vertices[k++] = planePositions[j + 1].z;
    }
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });
  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;
  var attributes = [{
    index: RectangularSensorPrimitive_attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];
  return new VertexArray({
    context: context,
    attributes: attributes
  });
} // /**
//  * 创建圆顶面顶点
//  * @param context
//  */


function createDomeVertexArray(context) {
  var geometry = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidGeometry"].createGeometry(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidGeometry"]({
    vertexFormat: VertexFormat.POSITION_ONLY,
    stackPartitions: 32,
    slicePartitions: 32
  }));
  var vertexArray = VertexArray.fromGeometry({
    context: context,
    geometry: geometry,
    attributeLocations: RectangularSensorPrimitive_attributeLocations,
    bufferUsage: BufferUsage.STATIC_DRAW,
    interleave: false
  });
  return vertexArray;
} // /**
//  * 创建圆顶面连线顶点
//  * @param context
//  */


function createDomeLineVertexArray(context) {
  var geometry = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidOutlineGeometry"].createGeometry(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidOutlineGeometry"]({
    vertexFormat: VertexFormat.POSITION_ONLY,
    stackPartitions: 32,
    slicePartitions: 32
  }));
  var vertexArray = VertexArray.fromGeometry({
    context: context,
    geometry: geometry,
    attributeLocations: RectangularSensorPrimitive_attributeLocations,
    bufferUsage: BufferUsage.STATIC_DRAW,
    interleave: false
  });
  return vertexArray;
} // /**
//  * 创建扫描面顶点
//  * @param context
//  * @param positions
//  * @returns {*}
//  */


function createScanPlaneVertexArray(context, positions) {
  var planeLength = positions.length - 1;
  var vertices = new Float32Array(3 * 3 * planeLength);
  var k = 0;

  for (var i = 0; i < planeLength; i++) {
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = positions[i].x;
    vertices[k++] = positions[i].y;
    vertices[k++] = positions[i].z;
    vertices[k++] = positions[i + 1].x;
    vertices[k++] = positions[i + 1].y;
    vertices[k++] = positions[i + 1].z;
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });
  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;
  var attributes = [{
    index: RectangularSensorPrimitive_attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];
  return new VertexArray({
    context: context,
    attributes: attributes
  });
}

function createVertexArray(primitive, frameState) {
  var context = frameState.context;
  var unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
  var positions = computeSectorPositions(primitive, unitSectorPositions); //显示扇面

  if (primitive.showLateralSurfaces) {
    primitive._sectorVA = createSectorVertexArray(context, positions);
  } //显示扇面线


  if (primitive.showSectorLines) {
    primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
  } //显示扇面圆顶面的交线


  if (primitive.showSectorSegmentLines) {
    primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
  } //显示弧面


  if (primitive.showDomeSurfaces) {
    primitive._domeVA = createDomeVertexArray(context);
  } //显示弧面线


  if (primitive.showDomeLines) {
    primitive._domeLineVA = createDomeLineVertexArray(context);
  } //显示扫描面


  if (primitive.showScanPlane) {
    if (primitive.scanPlaneMode == "horizontal") {
      var unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath.PI_OVER_TWO, 0);
      primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
    } else {
      var _unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath.PI_OVER_TWO);

      primitive._scanPlaneVA = createScanPlaneVertexArray(context, _unitScanPlanePositions.zoy);
    }
  }
} //endregion
//region -- ShaderProgram --


function createCommonShaderProgram(primitive, frameState, material) {
  var context = frameState.context;
  var vs = RectangularSensorVS_default.a;
  var fs = new ShaderSource({
    sources: [RectangularSensor_default.a, material.shaderSource, RectangularSensorFS_default.a]
  });
  primitive._sp = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: RectangularSensorPrimitive_attributeLocations
  });
  var pickFS = new ShaderSource({
    sources: [RectangularSensor_default.a, material.shaderSource, RectangularSensorFS_default.a],
    pickColorQualifier: "uniform"
  });
  primitive._pickSP = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._pickSP,
    vertexShaderSource: vs,
    fragmentShaderSource: pickFS,
    attributeLocations: RectangularSensorPrimitive_attributeLocations
  });
}

function createScanPlaneShaderProgram(primitive, frameState, material) {
  var context = frameState.context;
  var vs = RectangularSensorVS_default.a;
  var fs = new ShaderSource({
    sources: [RectangularSensor_default.a, material.shaderSource, RectangularSensorScanPlaneFS_default.a]
  });
  primitive._scanePlaneSP = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._scanePlaneSP,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: RectangularSensorPrimitive_attributeLocations
  });
}

function createShaderProgram(primitive, frameState, material) {
  createCommonShaderProgram(primitive, frameState, material);

  if (primitive.showScanPlane) {
    createScanPlaneShaderProgram(primitive, frameState, material);
  }
} //endregion
//region -- RenderState --


function createRenderState(primitive, showThroughEllipsoid, translucent) {
  if (translucent) {
    primitive._frontFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND,
      cull: {
        enabled: true,
        face: CullFace.BACK
      }
    });
    primitive._backFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND,
      cull: {
        enabled: true,
        face: CullFace.FRONT
      }
    });
    primitive._pickRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND
    });
  } else {
    primitive._frontFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: true
    });
    primitive._pickRS = RenderState.fromCache({
      depthTest: {
        enabled: true
      },
      depthMask: true
    });
  }
} //endregion
//region -- Command --


function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
  if (translucent && backCommand) {
    backCommand.vertexArray = va;
    backCommand.renderState = backFaceRS;
    backCommand.shaderProgram = sp;
    backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);

    backCommand.uniformMap.u_normalDirection = function () {
      return -1.0;
    };

    backCommand.pass = pass;
    backCommand.modelMatrix = modelMatrix;

    primitive._colorCommands.push(backCommand);
  }

  frontCommand.vertexArray = va;
  frontCommand.renderState = frontFaceRS;
  frontCommand.shaderProgram = sp;
  frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);

  if (isLine) {
    frontCommand.uniformMap.u_type = function () {
      return 1;
    };
  }

  frontCommand.pass = pass;
  frontCommand.modelMatrix = modelMatrix;

  primitive._colorCommands.push(frontCommand);
}

function createCommands(primitive, translucent) {
  primitive._colorCommands.length = 0;
  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE; //显示扇面

  if (primitive.showLateralSurfaces) {
    createCommand(primitive, primitive._sectorFrontCommand, primitive._sectorBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
  } //显示扇面线


  if (primitive.showSectorLines) {
    createCommand(primitive, primitive._sectorLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  } //显示扇面交接线


  if (primitive.showSectorSegmentLines) {
    createCommand(primitive, primitive._sectorSegmentLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorSegmentLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  } //显示弧面


  if (primitive.showDomeSurfaces) {
    createCommand(primitive, primitive._domeFrontCommand, primitive._domeBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
  } //显示弧面线


  if (primitive.showDomeLines) {
    createCommand(primitive, primitive._domeLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  } //显示扫描面


  if (primitive.showScanPlane) {
    createCommand(primitive, primitive._scanPlaneFrontCommand, primitive._scanPlaneBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._scanePlaneSP, primitive._scanPlaneVA, primitive._scanUniforms, primitive._computedScanPlaneModelMatrix, translucent, pass);
  }
} //endregion



// CONCATENATED MODULE: ./src/graphic/entity/rectangularSensor/RectangularSensorVisualizer.js


var AssociativeArray = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["AssociativeArray"];
var RectangularSensorVisualizer_Cartesian3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"];
var RectangularSensorVisualizer_Color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"];
var RectangularSensorVisualizer_defined = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"];
var RectangularSensorVisualizer_DeveloperError = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"];
var RectangularSensorVisualizer_Matrix3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"];
var RectangularSensorVisualizer_Matrix4 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"];
var Quaternion = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"];
var MaterialProperty = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialProperty"];
var Property = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"];
var RectangularSensorVisualizer_matrix3Scratch = new RectangularSensorVisualizer_Matrix3(); // var matrix4Scratch = new Matrix4();

var cachedPosition = new RectangularSensorVisualizer_Cartesian3();
var cachedGazePosition = new RectangularSensorVisualizer_Cartesian3();
var cachedOrientation = new Quaternion();
var diffVectorScratch = new RectangularSensorVisualizer_Cartesian3();
var orientationScratch = new Quaternion();
function removePrimitive(entity, hash, primitives) {
  var data = hash[entity.id];

  if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](data)) {
    var primitive = data.primitive;

    try {
      primitives.remove(primitive);
    } catch (e) {//
    }

    if (primitive.isDestroyed && !primitive.isDestroyed()) {
      primitive.destroy();
    }

    delete hash[entity.id];
  }
} // /**
//  *  相控阵雷达范围
//  */

function RectangularSensorVisualizer(scene, entityCollection) {
  // >>includeStart('debug', pragmas.debug);
  if (!RectangularSensorVisualizer_defined(scene)) {
    throw new RectangularSensorVisualizer_DeveloperError("scene is required.");
  }

  if (!RectangularSensorVisualizer_defined(entityCollection)) {
    throw new RectangularSensorVisualizer_DeveloperError("entityCollection is required.");
  } // >>includeEnd('debug');


  entityCollection.collectionChanged.addEventListener(RectangularSensorVisualizer.prototype._onCollectionChanged, this);
  this._scene = scene;
  this._primitives = scene.primitives;
  this._entityCollection = entityCollection;
  this._hash = {};
  this._entitiesToVisualize = new AssociativeArray();

  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
} // /**
//  * Updates the primitives created by this visualizer to match their
//  * Entity counterpart at the given time.
//  *
//  * @param {JulianDate} time The time to update to.
//  * @returns {Boolean} This function always returns true.
//  */


RectangularSensorVisualizer.prototype.update = function (time) {
  // >>includeStart('debug', pragmas.debug);
  if (!RectangularSensorVisualizer_defined(time)) {
    throw new RectangularSensorVisualizer_DeveloperError("time is required.");
  } // >>includeEnd('debug');


  var entities = this._entitiesToVisualize.values;
  var hash = this._hash;
  var primitives = this._primitives;
  var position;
  var orientation;
  var radius;
  var xHalfAngle;
  var yHalfAngle;

  for (var i = 0, len = entities.length; i < len; i++) {
    var entity = entities[i];
    var rectangularSensorGraphics = entity._rectangularSensorTudou;
    var data = hash[entity.id];
    var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(rectangularSensorGraphics._show, time, true);

    if (show) {
      position = Property.getValueOrUndefined(entity._position, time, cachedPosition);
      orientation = Property.getValueOrUndefined(entity._orientation, time, cachedOrientation);
      radius = Property.getValueOrUndefined(rectangularSensorGraphics._radius, time);
      xHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._xHalfAngle, time);
      yHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._yHalfAngle, time);
      show = RectangularSensorVisualizer_defined(position) && RectangularSensorVisualizer_defined(xHalfAngle) && RectangularSensorVisualizer_defined(yHalfAngle);
    }

    if (!show) {
      // don't bother creating or updating anything else
      if (RectangularSensorVisualizer_defined(data)) {
        data.primitive.show = false;
      }

      continue;
    }

    var primitive = RectangularSensorVisualizer_defined(data) ? data.primitive : undefined;

    if (!RectangularSensorVisualizer_defined(primitive)) {
      primitive = new RectangularSensorPrimitive();
      primitive.id = entity;
      primitives.add(primitive);
      data = {
        primitive: primitive,
        position: undefined,
        orientation: undefined
      };
      hash[entity.id] = data;
    }

    var gaze = Property.getValueOrUndefined(rectangularSensorGraphics._gaze, time);

    if (RectangularSensorVisualizer_defined(gaze)) {
      var targetPosition = Property.getValueOrUndefined(gaze._position, time, cachedGazePosition);

      if (!RectangularSensorVisualizer_defined(position) || !RectangularSensorVisualizer_defined(targetPosition)) {
        continue;
      }

      var diffVector = RectangularSensorVisualizer_Cartesian3.subtract(position, targetPosition, diffVectorScratch);
      var rotate = RectangularSensorVisualizer_Cartesian3.angleBetween(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z, diffVector);
      var cross = RectangularSensorVisualizer_Cartesian3.cross(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z, diffVector, diffVectorScratch);
      orientation = Quaternion.fromAxisAngle(cross, rotate - Math.PI, orientationScratch); //replace original radius

      radius = RectangularSensorVisualizer_Cartesian3.distance(position, targetPosition);
      primitive.modelMatrix = RectangularSensorVisualizer_Matrix4.fromRotationTranslation(RectangularSensorVisualizer_Matrix3.fromQuaternion(orientation, RectangularSensorVisualizer_matrix3Scratch), position, primitive.modelMatrix);
    } else {
      if (!RectangularSensorVisualizer_Cartesian3.equals(position, data.position) || !Quaternion.equals(orientation, data.orientation)) {
        if (RectangularSensorVisualizer_defined(orientation)) {
          primitive.modelMatrix = RectangularSensorVisualizer_Matrix4.fromRotationTranslation(RectangularSensorVisualizer_Matrix3.fromQuaternion(orientation, RectangularSensorVisualizer_matrix3Scratch), position, primitive.modelMatrix);
          data.position = RectangularSensorVisualizer_Cartesian3.clone(position, data.position);
          data.orientation = Quaternion.clone(orientation, data.orientation);
        } else {
          primitive.modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(position);
          data.position = RectangularSensorVisualizer_Cartesian3.clone(position, data.position);
        }
      }
    }

    primitive.show = true;
    primitive.gaze = gaze;
    primitive.radius = radius;
    primitive.xHalfAngle = xHalfAngle;
    primitive.yHalfAngle = yHalfAngle;
    primitive.lineColor = Property.getValueOrDefault(rectangularSensorGraphics._lineColor, time, RectangularSensorVisualizer_Color.WHITE);
    primitive.showSectorLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorLines, time, true);
    primitive.showSectorSegmentLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorSegmentLines, time, true);
    primitive.showLateralSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showLateralSurfaces, time, true);
    primitive.material = MaterialProperty.getValue(time, rectangularSensorGraphics._material, primitive.material);
    primitive.showDomeSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showDomeSurfaces, time, true);
    primitive.showDomeLines = Property.getValueOrDefault(rectangularSensorGraphics._showDomeLines, time, true);
    primitive.showIntersection = Property.getValueOrDefault(rectangularSensorGraphics._showIntersection, time, true);
    primitive.intersectionColor = Property.getValueOrDefault(rectangularSensorGraphics._intersectionColor, time, RectangularSensorVisualizer_Color.WHITE);
    primitive.intersectionWidth = Property.getValueOrDefault(rectangularSensorGraphics._intersectionWidth, time, 1);
    primitive.showThroughEllipsoid = Property.getValueOrDefault(rectangularSensorGraphics._showThroughEllipsoid, time, false);
    primitive.scanPlaneMode = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneMode, time);
    primitive.scanPlaneColor = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneColor, time, RectangularSensorVisualizer_Color.WHITE);
    primitive.showScanPlane = Property.getValueOrDefault(rectangularSensorGraphics._showScanPlane, time, true);
    primitive.scanPlaneRate = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneRate, time, 1);
  }

  return true;
};

RectangularSensorVisualizer.prototype.isDestroyed = function () {
  return false;
};

RectangularSensorVisualizer.prototype.destroy = function () {
  var entities = this._entitiesToVisualize.values;
  var hash = this._hash;
  var primitives = this._primitives;

  for (var i = entities.length - 1; i > -1; i--) {
    removePrimitive(entities[i], hash, primitives);
  } //删除所有绑定的数据


  for (var _i in this) {
    delete this[_i];
  }

  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["destroyObject"](this);
};

RectangularSensorVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
  var entities = this._entitiesToVisualize;

  if (!entities) {
    return;
  }

  var hash = this._hash;
  var primitives = this._primitives;
  var i;
  var entity;

  for (i = added.length - 1; i > -1; i--) {
    entity = added[i];

    if (RectangularSensorVisualizer_defined(entity._rectangularSensorTudou) && RectangularSensorVisualizer_defined(entity._position)) {
      entities.set(entity.id, entity);
    }
  }

  for (i = changed.length - 1; i > -1; i--) {
    entity = changed[i];

    if (RectangularSensorVisualizer_defined(entity._rectangularSensorTudou) && RectangularSensorVisualizer_defined(entity._position)) {
      entities.set(entity.id, entity);
    } else {
      removePrimitive(entity, hash, primitives);
      entities.remove(entity.id);
    }
  }

  for (i = removed.length - 1; i > -1; i--) {
    entity = removed[i];
    removePrimitive(entity, hash, primitives);
    entities.remove(entity.id);
  }
};

var originalDefaultVisualizersCallback = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DataSourceDisplay"].defaultVisualizersCallback;

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DataSourceDisplay"].defaultVisualizersCallback = function (scene, entityCluster, dataSource) {
  var entities = dataSource.entities;
  var array = originalDefaultVisualizersCallback(scene, entityCluster, dataSource);
  return array.concat([new RectangularSensorVisualizer(scene, entities)]);
};


// CONCATENATED MODULE: ./src/graphic/entity/RectangularSensor.js







function RectangularSensor_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function RectangularSensor_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RectangularSensor_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RectangularSensor_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RectangularSensor_createSuper(Derived) { var hasNativeReflectConstruct = RectangularSensor_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectangularSensor_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * 相控阵雷达 支持的样式信息
 *
 * @typedef {Object} RectangularSensor.StyleOptions
 *
 * @property {Number} radius 半径
 * @property {Number} [xHalfAngle = 0] 传感器水平半角（弧度值）
 * @property {Number} [xHalfAngleDegree = 0] 传感器水平半角（度数值，0-360度），与xHalfAngle二选一
 * @property {Number} [yHalfAngle = 0] 传感器垂直半角（弧度值）
 * @property {Number} [yHalfAngleDegree = 0] 传感器垂直半角（度数值，0-360度），与yHalfAngle二选一
 *
 * @property {String} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 0.4] 透明度
 * @property {Cesium.MaterialProperty | Cesium.Color} [material= new Cesium.Color(0.0, 1.0, 1.0, 0.4)] 指定用于填充的材质，指定material后color属性将被覆盖。
 *
 * @property {String|Cesium.Color} [lineColor = "#ffffff"] 边线颜色
 * @property {Number} [lineOpacity = 0.6] 边线透明度
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {Boolean} [showScanPlane = true] 是否显示扫描面
 * @property {String|Cesium.Color} [scanPlaneColor = new Cesium.Color(0.0, 1.0, 1.0, 1.0)] 扫描面颜色
 * @property {Number} [scanPlaneOpacity = 0.9] 扫描面透明度
 * @property {Number} [scanPlaneMode = 'vertical'] 扫描面方向模式,可选值：vertical（解释：垂直方向）、horizontal（解释：水平方向）
 * @property {Number} [scanPlaneRate = 3] 扫描速率
 *
 * @property {Boolean} [showSectorLines = true] 是否显示扇面的线
 * @property {Boolean} [showSectorSegmentLines = true] 是否显示扇面和圆顶面连接的线
 *
 * @property {Boolean} [showLateralSurfaces = true] 是否显示侧面
 * @property {Cesium.MaterialProperty } [lateralSurfaceMaterial] 侧面材质
 *
 * @property {Boolean} [showDomeSurfaces = true] 是否显示圆顶表面
 * @property {Cesium.MaterialProperty } [domeSurfaceMaterial] 圆顶表面材质
 * @property {Boolean} [showDomeLines = true] 是否显示圆顶面线
 *
 * @property {Boolean} [showIntersection = true] 是否显示与地球相交的线
 * @property {Cesium.Color} [intersectionColor = Cesium.Color.WHITE] 与地球相交的线的颜色
 * @property {Cesium.Color} [intersectionWidth = 5.0] 与地球相交的线的宽度（像素）
 *
 * @property {Number} [slice = 32] 切分程度
 * @property {Boolean} [depthTest = true] 是否被遮挡
 */

/**
 * 相控阵雷达  Entity对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {RectangularSensor.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Cesium.Property} [options.orientation] 实体方向
 *
 * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {BasePointEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var RectangularSensor_RectangularSensor = /*#__PURE__*/function (_BasePointEntity) {
  inherits_default()(RectangularSensor, _BasePointEntity);

  var _super = RectangularSensor_createSuper(RectangularSensor);

  function RectangularSensor() {
    classCallCheck_default()(this, RectangularSensor);

    return _super.apply(this, arguments);
  }

  createClass_default()(RectangularSensor, [{
    key: "entityGraphic",
    get:
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {RectangularSensorGraphics}
     * @readonly
     */
    function get() {
      return this._entity.rectangularSensorTudou;
    }
    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */

  }, {
    key: "radius",
    get: function get() {
      return this.style.radius;
    },
    set: function set(val) {
      this.style.radius = val;

      if (this._entity) {
        this.entityGraphic.radius = val;
      }
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (this.options.entity) {
        this._entity = this._initFromEntity(this.options.entity);
      } else {
        var addattr = {
          position: this.position,
          orientation: this.getOrientation(),
          rectangularSensorTudou: new RectangularSensorGraphics(RectangularSensorStyleConver_RectangularSensorStyleConver.toCesiumVal(this.style))
        };
        this._entity = this._createEntity(addattr);
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      if (this._entity && this._state == State.ADDED) {
        var dataSource = this._layer.dataSource;
        dataSource.entities.remove(this._entity);
        delete this._entity;

        this._mountedHook();

        dataSource.entities.add(this._entity);
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return RectangularSensorStyleConver_RectangularSensorStyleConver.toJSON(czmStyle, styleJson);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {RectangularSensor} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new RectangularSensor(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }, {
    key: "fromEntity",
    value: function fromEntity(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!entity.rectangularSensor) {
        return undefined;
      }

      return new RectangularSensor(RectangularSensor_objectSpread(RectangularSensor_objectSpread({}, options), {}, {
        entity: entity
      }));
    }
  }]);

  return RectangularSensor;
}(BasePointEntity_BasePointEntity); //注册下

Object(GraphicUtil["register"])("rectangularSensor", RectangularSensor_RectangularSensor);
// CONCATENATED MODULE: ./src/graphic/entity/Video2D.js








function Video2D_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Video2D_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Video2D_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Video2D_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Video2D_createSuper(Derived) { var hasNativeReflectConstruct = Video2D_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Video2D_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var RatateDirection = {
  LEFT: "Z",
  RIGHT: "-Z",
  TOP: "Y",
  BOTTOM: "-Y",
  ALONG: "X",
  INVERSE: "-X"
};
var DEF_STYLE = {
  dis: 10,
  perPositionHeight: true
};
/**
 * 视频融合（投射2D平面） 支持的样式信息
 *
 * @typedef {Object} Video2D.StyleOptions
 *
 * @property {PolygonEntity.StyleOptions} [面的参数] 支持父类的所有样式信息
 * @property {Object} camera 相机方向参数
 * @property {Cesium.Cartesian3} camera.direction direction方向
 * @property {Cesium.Cartesian3} camera.up up方向
 * @property {Cesium.Cartesian3} camera.right right方向
 * @property {Number} dis 投射距离
 * @property {Number} fov 张角(弧度值)
 * @property {Number} fovDegree 张角(角度值，0-180度)
 * @property {Number} aspectRatio 相机视野的宽高比例（垂直张角）
 * @property {Number} stRotation UV旋转(弧度值)
 * @property {Number} stRotationDegree  UV旋转(角度值，0-360度)
 *
 */

/**
 * 视频融合（投射2D平面）,
 * 根据相机位置、方向等参数，在相机前面生成一个PolygonEntity面，然后贴视频纹理
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 包含父类支持的部分参数
 * @param {LatLngPoint|Cesium.Cartesian3|Cesium.PositionProperty} options.position 坐标位置
 * @param {HTMLElement} options.dom 视频对应的video标签
 * @param {Video2D.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {boolean} [options.showFrustum=true] 是否显示视椎体框线
 * @param {boolean} [options.reverse=false] 是否反转计算得到的坐标
 *
 * @export
 * @class Video2D
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var Video2D_Video2D = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(Video2D, _PolygonEntity);

  var _super = Video2D_createSuper(Video2D);

  //========== 构造方法 ==========
  function Video2D() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Video2D);

    options.style = Video2D_objectSpread(Video2D_objectSpread({}, DEF_STYLE), options.style || {});
    _this = _super.call(this, options); //传入了DOM

    if (options.dom) {
      if (options.dom instanceof Object && options.dom.length) {
        _this.dom = options.dom[0];
      } else {
        _this.dom = options.dom;
      }
    }

    if (options.position) {
      _this.position = options.position;
    }

    _this._play = true;
    _this._frustumShow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.showFrustum, true);
    return _this;
  }
  /**
   * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
   * @type {Cesium.Cartesian3}
   */


  createClass_default()(Video2D, [{
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      var _this$_point;

      this._point = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._position = (_this$_point = this._point) === null || _this$_point === void 0 ? void 0 : _this$_point.toCartesian();

      if (this._entity) {
        this._updatePositionsHook();

        this._updateDraw();
      }
    }
    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "point",
    get: function get() {
      return this._point;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */

  }, {
    key: "coordinate",
    get: function get() {
      return this.point.toArray();
    } //文本等附加对象

  }, {
    key: "czmObjectEx",
    get: function get() {
      var arr = [];

      if (this._frustumPrimitive) {
        arr.push(this._frustumPrimitive);
      }

      if (this._entity_label) {
        arr.push(this._entity_label);
      }

      if (this._entity_outlines) {
        arr = arr.concat(this._entity_outlines);
      }

      return arr;
    }
    /**
     * 暂停或播放 视频
     * @type {Boolean}
     */

  }, {
    key: "play",
    get: function get() {
      return this._play;
    },
    set: function set(val) {
      this._play = val;

      if (!this.dom) {
        return;
      }

      try {
        if (this._play) {
          this.dom.play();
        } else {
          this.dom.pause();
        }
      } catch (e) {//规避浏览器权限异常
      }
    }
    /**
     * 多边形纹理的角度（弧度值），正北为0，逆时针旋转
     * @type {Number}
     */

  }, {
    key: "stRotation",
    get: function get() {
      return this.style.stRotation || 0;
    },
    set: function set(val) {
      this.style.stRotation = val;
      this._entity.polygon.stRotation = val;
    }
    /**
     * 相机水平张角 (弧度值)
     * @type {Number}
     */

  }, {
    key: "fov",
    get: function get() {
      return this.style.fov;
    },
    set: function set(val) {
      val = Number(val);

      if (!val || val < 0) {
        return;
      }

      this.style.fov = val;

      this._updateDraw();
    }
    /**
     * 相机水平张角(角度值，0-180度)
     * @type {Number}
     */

  }, {
    key: "fovDegree",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.fov);
    },
    set: function set(val) {
      this.fov = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val);
    }
    /**
     * 相机视野的宽高比例（垂直张角）
     * @type {Number}
     */

  }, {
    key: "aspectRatio",
    get: function get() {
      return this.style.aspectRatio;
    },
    set: function set(val) {
      val = Number(val);

      if (!val || val < 0) {
        return;
      }

      if (val < 1.0) {
        val = 1.0;
      }

      this.style.aspectRatio = val;

      this._updateDraw();
    }
    /**
     * 投射距离（单位：米）
     * @type {Number}
     */

  }, {
    key: "dis",
    get: function get() {
      return this.style.dis;
    },
    set: function set(val) {
      val = Number(val);

      if (!val || val < 0) {
        return;
      }

      this.style.dis = val;

      this._updateDraw();
    }
    /**
     * 是否显示视椎体框线
     * @type {Boolean}
     */

  }, {
    key: "showFrustum",
    get: function get() {
      return this._frustumShow;
    },
    set: function set(val) {
      this._frustumShow = val;
      this._frustumPrimitive.show = val;
    }
    /**
     * 将矢量数据的坐标、样式及属性等信息导出为对象，可以用于存储。
     * @return {Object} 导出的坐标、样式及属性等信息
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        position: this.coordinate,
        style: {
          camera: {
            direction: this.style.camera.direction,
            up: this.style.camera.up,
            right: this.style.camera.right
          },
          dis: this.dis,
          fovDegree: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.fov),
          aspectRatio: this.aspectRatio,
          stRotationDegree: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.stRotation)
        },
        showFrustum: this.showFrustum
      };
    }
  }, {
    key: "_updateDraw",
    value: function _updateDraw() {
      if (!this._entity) {
        return;
      }

      this._removedHook();

      this._mountedHook(true);

      this._addedHook();
    } //默认值

  }, {
    key: "_initStyleDefVal",
    value: function _initStyleDefVal() {
      if (!this.style.aspectRatio) {
        this.style.aspectRatio = this._map.scene.context.drawingBufferWidth / this._map.scene.context.drawingBufferHeight;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.style.fovDegree)) {
        this.style.fov = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.style.fovDegree);
        delete this.style.fovDegree;
      }

      this.style.fov = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.fov, this._map.scene.camera.frustum.fov);

      if (!this.style.camera) {
        var camera = this._map.scene.camera;
        this.style.camera = {};
        this.style.camera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.direction);
        this.style.camera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.up);
        this.style.camera.right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.right);
      }
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook(noInit) {
      if (!noInit) {
        this._initStyleDefVal();
      }

      if (!this.position) {
        this.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._map.camera.position);
      } //计算视频面的边界顶点


      this.positions = this._computedPositions();

      get_default()(getPrototypeOf_default()(Video2D.prototype), "_mountedHook", this).call(this);

      if (this.dom) {
        this._entity.polygon.material = this.dom;
      }

      this._frustumPrimitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
          id: this.uuid,
          geometry: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FrustumOutlineGeometry"]({
            frustum: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerspectiveFrustum"]({
              fov: this.fov,
              aspectRatio: this.aspectRatio,
              near: 0.1,
              far: this.dis
            }),
            orientation: this._getOrientation(this.style.camera),
            origin: this.position
          }),
          attributes: {
            color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].AZURE)
          }
        }),
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"]({
          flat: true
        }),
        show: this.showFrustum
      });
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.scene.primitives.add(this._frustumPrimitive);

      this.dataSource.entities.add(this._entity);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.primitives.remove(this._frustumPrimitive);

      delete this._frustumPrimitive;
      this.dataSource.entities.remove(this._entity);
      delete this._entity;
    } //计算视频面的边界顶点

  }, {
    key: "_computedPositions",
    value: function _computedPositions() {
      var vpos = this.position,
          dis = this.dis,
          fov = this.fov,
          kgb = this.aspectRatio,
          camera = this.style.camera;
      var vdir = camera.direction;
      var vright = camera.right;
      var vup = camera.up;
      var vray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](vpos, vdir);
      var vmbpos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(vray, dis, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var halfFov = fov / 2.0;
      var tanres = Math.tan(halfFov);
      var horiDis = dis * tanres;
      var vertDis = horiDis / kgb;
      var xbDis = Math.sqrt(horiDis * horiDis + vertDis * vertDis);
      var ysj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var rightRay = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](vmbpos, vright);
      var rightPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(rightRay, horiDis, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var upRay = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](rightPos, vup);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(upRay, vertDis, ysj);
      var yxj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var fvup = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(vup, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var fupRay = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](rightPos, fvup);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(fupRay, vertDis, yxj);
      var zxj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var djdir1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(vmbpos, ysj, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var djRay1 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](vmbpos, djdir1);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(djRay1, xbDis, zxj);
      var zsj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var djdir2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(vmbpos, yxj, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var djRay2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](vmbpos, djdir2);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(djRay2, xbDis, zsj);

      if (this.options.reverse) {
        return [zxj, zsj, ysj, yxj].reverse();
      }

      return [zxj, zsj, ysj, yxj];
    }
  }, {
    key: "_getOrientation",
    value: function _getOrientation(camera) {
      if (!camera) {
        return;
      }

      var direction = camera.direction;
      var up = camera.up;
      var right = camera.right;
      var scratchRight = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var scratchRotation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();
      var scratchOrientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"](); // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());

      right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(right, scratchRight);
      var rotation = scratchRotation;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 0, right, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 1, up, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 2, direction, rotation); //计算视锥姿态

      var orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"].fromRotationMatrix(rotation, scratchOrientation);
      return orientation;
    }
    /**
     * 定位至相机的第一视角
     * @return {void}  无
     */

  }, {
    key: "flyTo",
    value: function flyTo() {
      if (!this._map) {
        return;
      }

      this._map.camera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.direction);
      this._map.camera.right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.right);
      this._map.camera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.up);
      this._map.camera.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.position);
    }
    /**
     * 旋转相机
     *
     * @param {Video2D.RatateDirection} axis  旋转的方向
     * @param {number} [rotateDegree=0.05] 旋转的角度
     * @return {void}  无
     */

  }, {
    key: "rotateCamera",
    value: function rotateCamera(axis) {
      var rotateDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.05;

      switch (axis) {
        default:
        case RatateDirection.LEFT:
          break;

        case RatateDirection.RIGHT:
          rotateDegree *= -1;
          break;

        case RatateDirection.TOP:
          break;

        case RatateDirection.BOTTOM:
          rotateDegree *= -1;
          break;

        case RatateDirection.ALONG:
          break;

        case RatateDirection.INVERSE:
          rotateDegree *= -1;
          break;
      }

      var newObj = this._computedNewViewDir(axis, rotateDegree);

      this.style.camera.direction = newObj.direction;
      this.style.camera.up = newObj.up;
      this.style.camera.right = newObj.right;

      this._updateDraw();
    } //计算新视点

  }, {
    key: "_computedNewViewDir",
    value: function _computedNewViewDir(axis, deg) {
      deg = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(deg);
      var oldDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.direction);
      var oldRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.right);
      var oldTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.style.camera.up);
      var mat3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();

      switch (axis) {
        default:
        case RatateDirection.LEFT:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(deg, mat3);
          break;

        case RatateDirection.RIGHT:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(deg, mat3);
          break;

        case RatateDirection.TOP:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(deg, mat3);
          break;

        case RatateDirection.BOTTOM:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(deg, mat3);
          break;

        case RatateDirection.ALONG:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(deg, mat3);
          break;

        case RatateDirection.INVERSE:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(deg, mat3);
          break;
      }

      var localToWorld_Matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this.position);
      var worldToLocal_Matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(localToWorld_Matrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      var localDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      return {
        direction: newDir,
        right: newRight,
        up: newTop
      };
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {Video2D} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new Video2D(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return Video2D;
}(PolygonEntity_PolygonEntity);
/**
 * 旋转的方向
 * @property {String} 	LEFT 绕Z轴旋转
 * @property {String} 	RIGHT 绕Z轴反向旋转
 * @property {String} 	TOP 绕Y轴旋转
 * @property {String} 	BOTTOM 绕Y轴反向旋转
 * @property {String} 	ALONG 绕X轴旋转
 * @property {String} 	INVERSE 绕X轴反向旋转
 * @enum
 */

Video2D_Video2D.RatateDirection = RatateDirection; //注册下

Object(GraphicUtil["register"])("video2D", Video2D_Video2D);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/AlgorithmUtil.js


 //基本计算方法

var AlgorithmUtil_AlgorithmUtil = /*#__PURE__*/function () {
  function AlgorithmUtil() {
    classCallCheck_default()(this, AlgorithmUtil);

    this.HALF_PI = Math.PI / 2;
    this.ZERO_TOLERANCE = 0.0001;
  }

  createClass_default()(AlgorithmUtil, [{
    key: "toRadians",
    value: function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    } //获取第三点

  }, {
    key: "getThirdPoint",
    value: function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
      var azimuth = this.getAzimuth(startPnt, endPnt);
      var alpha = clockWise ? azimuth + angle : azimuth - angle;
      var dx = distance * Math.cos(alpha);
      var dy = distance * Math.sin(alpha);
      return [endPnt[0] + dx, endPnt[1] + dy];
    } //计算夹角(弧度值)

  }, {
    key: "getAzimuth",
    value: function getAzimuth(startPoint, endPoint) {
      var azimuth = 0;
      var angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / this.MathDistance(startPoint, endPoint));

      if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = angle + Math.PI;
      } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = Math.PI * 2 - angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = Math.PI - angle;
      }

      return azimuth;
    }
  }, {
    key: "MathDistance",
    value: function MathDistance(pnt1, pnt2) {
      return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
    } //计算闭合曲面上的点

  }, {
    key: "isClockWise",
    value: function isClockWise(pnt1, pnt2, pnt3) {
      if (!pnt3) {
        return false;
      }

      return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
    }
  }, {
    key: "getBisectorNormals",
    value: function getBisectorNormals(t, pnt1, pnt2, pnt3) {
      var normal = this.getNormal(pnt1, pnt2, pnt3);
      var bisectorNormalRight = null,
          bisectorNormalLeft = null,
          dt = null,
          x = null,
          y = null;
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var uX = normal[0] / dist;
      var uY = normal[1] / dist;
      var d1 = this.MathDistance(pnt1, pnt2);
      var d2 = this.MathDistance(pnt2, pnt3);

      if (dist > this.ZERO_TOLERANCE) {
        if (this.isClockWise(pnt1, pnt2, pnt3)) {
          dt = t * d1;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalLeft = [x, y];
        } else {
          dt = t * d1;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalLeft = [x, y];
        }
      } else {
        x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
        bisectorNormalRight = [x, y];
        x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
        bisectorNormalLeft = [x, y];
      }

      return [bisectorNormalRight, bisectorNormalLeft];
    }
  }, {
    key: "getCubicValue",
    value: function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
      t = Math.max(Math.min(t, 1), 0);
      var tp = 1 - t,
          t2 = t * t;
      var t3 = t2 * t;
      var tp2 = tp * tp;
      var tp3 = tp2 * tp;
      var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
      var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
      return [x, y];
    }
  }, {
    key: "getNormal",
    value: function getNormal(pnt1, pnt2, pnt3) {
      var dX1 = pnt1[0] - pnt2[0];
      var dY1 = pnt1[1] - pnt2[1];
      var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
      dX1 /= d1;
      dY1 /= d1;
      var dX2 = pnt3[0] - pnt2[0];
      var dY2 = pnt3[1] - pnt2[1];
      var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
      dX2 /= d2;
      dY2 /= d2;
      var uX = dX1 + dX2;
      var uY = dY1 + dY2;
      return [uX, uY];
    }
  }, {
    key: "getArcPoints",
    value: function getArcPoints(center, radius, startAngle, endAngle) {
      var x = null,
          y = null,
          pnts = [],
          angleDiff = endAngle - startAngle;
      angleDiff = angleDiff < 0 ? angleDiff + Math.PI * 2 : angleDiff;

      for (var i = 0; i <= 100; i++) {
        var angle = startAngle + angleDiff * i / 100;
        x = center[0] + radius * Math.cos(angle);
        y = center[1] + radius * Math.sin(angle);
        pnts.push([x, y]);
      }

      return pnts;
    }
  }, {
    key: "getPointByAngleAndLen",
    value: function getPointByAngleAndLen(center, radius, angle) {
      var x = center[0] + radius * Math.cos(angle);
      var y = center[1] + radius * Math.sin(angle);
      return [x, y];
    }
  }, {
    key: "getBaseLength",
    value: function getBaseLength(points) {
      return Math.pow(this.wholeDistance(points), 0.99);
    } //全部距离长度

  }, {
    key: "wholeDistance",
    value: function wholeDistance(points) {
      var distance = 0;
      var that = this;

      if (points && Array.isArray(points) && points.length > 0) {
        points.forEach(function (item, index) {
          if (index < points.length - 1) {
            distance += that.MathDistance(item, points[index + 1]);
          }
        });
      }

      return distance;
    }
  }, {
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(obj) {
      if (!obj) {
        return [];
      }

      var points = obj.points;

      if (points.length < 2) {
        return [];
      }

      var tailLeft = obj.tailLeft;
      var tailRight = obj.tailRight;
      var headTailFactor = obj.headTailFactor;
      var neckWidthFactor = obj.neckWidthFactor;
      var neckHeightFactor = obj.neckHeightFactor;
      var headWidthFactor = obj.headWidthFactor;
      var headHeightFactor = obj.headHeightFactor;
      var len = this.getBaseLength(points);
      var headHeight = len * headHeightFactor;
      var headPnt = points[points.length - 1];
      len = this.MathDistance(headPnt, points[points.length - 2]);
      var tailWidth = this.MathDistance(tailLeft, tailRight);

      if (headHeight > tailWidth * headTailFactor) {
        headHeight = tailWidth * headTailFactor;
      }

      var headWidth = headHeight * headWidthFactor;
      var neckWidth = headHeight * neckWidthFactor;
      headHeight = headHeight > len ? len : headHeight;
      var neckHeight = headHeight * neckHeightFactor;
      var headEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, false);
      var headRight = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, true);
      var neckLeft = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, false);
      var neckRight = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(obj) {
      if (!obj) {
        return;
      }

      var points = obj.points;
      var tailWidthFactor = obj.tailWidthFactor;
      var swallowTailFactor = obj.swallowTailFactor;
      var allLen = this.getBaseLength(points);
      var tailWidth = allLen * tailWidthFactor;
      var tailLeft = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, false);
      var tailRight = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, true);
      var len = tailWidth * swallowTailFactor;
      var swallowTailPnt = this.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.wholeDistance(points);
      var len = this.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.MathDistance(neckLeft, neckRight);
      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }

      return leftBodyPnts.concat(rightBodyPnts);
    }
  }, {
    key: "getAngleOfThreePoints",
    value: function getAngleOfThreePoints(pntA, pntB, pntC) {
      var angle = this.getAzimuth(pntB, pntA) - this.getAzimuth(pntB, pntC);
      return angle < 0 ? angle + Math.PI * 2 : angle;
    }
  }, {
    key: "getQBSplinePoints",
    value: function getQBSplinePoints(points) {
      if (points.length <= 2) {
        return points;
      } else {
        var n = 2,
            bSplinePoints = [];
        var m = points.length - n - 1;
        bSplinePoints.push(points[0]);

        for (var i = 0; i <= m; i++) {
          for (var t = 0; t <= 1; t += 0.05) {
            var x = 0,
                y = 0;

            for (var k = 0; k <= n; k++) {
              var factor = this.getQuadricBSplineFactor(k, t);
              x += factor * points[i + k][0];
              y += factor * points[i + k][1];
            }

            bSplinePoints.push([x, y]);
          }
        }

        bSplinePoints.push(points[points.length - 1]);
        return bSplinePoints;
      }
    }
  }, {
    key: "getQuadricBSplineFactor",
    value: function getQuadricBSplineFactor(k, t) {
      var res = 0;

      if (k == 0) {
        res = Math.pow(t - 1, 2) / 2;
      } else if (k == 1) {
        res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
      } else if (k == 2) {
        res = Math.pow(t, 2) / 2;
      }

      return res;
    }
  }, {
    key: "Mid",
    value: function Mid(point1, point2) {
      return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, (point1[2] || 0 + point2[2] || 0) / 2];
    }
  }, {
    key: "getCircleCenterOfThreePoints",
    value: function getCircleCenterOfThreePoints(point1, point2, point3) {
      var height = point1[2] || 0;
      var pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, height];
      var pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0], height];
      var pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2, height];
      var pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0], height];
      return this.getIntersectPoint(pntA, pntB, pntC, pntD);
    }
  }, {
    key: "getIntersectPoint",
    value: function getIntersectPoint(pntA, pntB, pntC, pntD) {
      if (pntA[1] == pntB[1]) {
        var _f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);

        var _x = _f * (pntA[1] - pntC[1]) + pntC[0];

        var _y = pntA[1];
        return [_x, _y];
      }

      if (pntC[1] == pntD[1]) {
        var _e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);

        var _x2 = _e * (pntC[1] - pntA[1]) + pntA[0];

        var _y2 = pntC[1];
        return [_x2, _y2];
      }

      var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
      var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
      var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
      var x = e * y - e * pntA[1] + pntA[0];
      return [x, y, pntA[2] || 0];
    }
  }, {
    key: "getBezierPoints",
    value: function getBezierPoints(points) {
      if (points.length <= 2) {
        return points;
      } else {
        var bezierPoints = [];
        var n = points.length - 1;

        for (var t = 0; t <= 1; t += 0.01) {
          var x = 0,
              y = 0;

          for (var index = 0; index <= n; index++) {
            var factor = this.getBinomialFactor(n, index);
            var a = Math.pow(t, index);
            var b = Math.pow(1 - t, n - index);
            x += factor * a * b * points[index][0];
            y += factor * a * b * points[index][1];
          }

          bezierPoints.push([x, y]);
        } // bezierPoints.push(points[n]);


        return bezierPoints;
      }
    }
  }, {
    key: "getFactorial",
    value: function getFactorial(n) {
      var result = 1;

      switch (n) {
        case n <= 1:
          result = 1;
          break;

        case n == 2:
          result = 2;
          break;

        case n == 3:
          result = 6;
          break;

        case n == 24:
          result = 24;
          break;

        case n == 5:
          result = 120;
          break;

        default:
          for (var i = 1; i <= n; i++) {
            result *= i;
          }

          break;
      }

      return result;
    }
  }, {
    key: "getBinomialFactor",
    value: function getBinomialFactor(n, index) {
      return this.getFactorial(n) / (this.getFactorial(index) * this.getFactorial(n - index));
    }
  }]);

  return AlgorithmUtil;
}(); //外部使用，单例模式


var algorithmUtil = new AlgorithmUtil_AlgorithmUtil();
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/ArrowParentUtil.js



var minAnalge = algorithmUtil.toRadians(20);
var maxAnalge = algorithmUtil.toRadians(160); //箭头的父类

var ArrowParentUtil_ArrowParentUtil = /*#__PURE__*/function () {
  function ArrowParentUtil() {
    classCallCheck_default()(this, ArrowParentUtil);

    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(ArrowParentUtil, [{
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }, {
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(points, tailLeft, tailRight) {
      if (!points || points.length < 2) {
        return null;
      }

      var len = this.algorithmUtil.getBaseLength(points);
      var headHeight = len * this.headHeightFactor;
      var headPnt = points[points.length - 1];
      len = this.algorithmUtil.MathDistance(headPnt, points[points.length - 2]);
      var tailWidth = this.algorithmUtil.MathDistance(tailLeft, tailRight);

      if (headHeight > tailWidth * this.headTailFactor) {
        headHeight = tailWidth * this.headTailFactor;
      }

      var headWidth = headHeight * this.headWidthFactor;
      var neckWidth = headHeight * this.neckWidthFactor;
      headHeight = headHeight > len ? len : headHeight;
      var neckHeight = headHeight * this.neckHeightFactor;
      var headEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      var headRight = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      var neckLeft = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      var neckRight = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.algorithmUtil.wholeDistance(points); //全部距离长度

      var len = this.algorithmUtil.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.algorithmUtil.MathDistance(neckLeft, neckRight); //箭头宽度

      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.algorithmUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;

        if (angle < minAnalge) {
          angle = minAnalge;
        } else if (angle > maxAnalge) {
          angle = maxAnalge;
        }

        tempLen += this.algorithmUtil.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }

      return leftBodyPnts.concat(rightBodyPnts);
    }
  }]);

  return ArrowParentUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/AttackArrowUtil.js






function AttackArrowUtil_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrowUtil_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrowUtil_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //攻击箭头

var AttackArrowUtil_AttackArrowUtil = /*#__PURE__*/function (_ArrowParentUtil) {
  inherits_default()(AttackArrowUtil, _ArrowParentUtil);

  var _super = AttackArrowUtil_createSuper(AttackArrowUtil);

  function AttackArrowUtil() {
    var _this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AttackArrowUtil);

    _this = _super.call(this); //影响因素

    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.headTailFactor = opt.headTailFactor || 0.8;
    _this.positions = null;
    _this.algorithmUtil = algorithmUtil;
    return _this;
  }

  createClass_default()(AttackArrowUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions || positions.length == 0) {
        return positions;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts); //箭头尾巴上的2个点

      var tailLeft = pnts[0],
          tailRight = pnts[1];

      if (this.algorithmUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }

      var midTail = this.algorithmUtil.Mid(tailLeft, tailRight); //尾巴中点

      var bonePnts = [midTail].concat(pnts.slice(2)); //尾巴中点+其他点连成的直线
      //计算箭头

      var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);

      if (!headPnts || headPnts.length < 4) {
        return positions;
      }

      var neckLeft = headPnts[0],
          neckRight = headPnts[4]; //计算箭身

      var tailWidthFactor = this.algorithmUtil.MathDistance(tailLeft, tailRight) / this.algorithmUtil.getBaseLength(bonePnts);
      var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
      var count = bodyPnts.length; //左边点

      var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft); //右边点

      var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight); //计算曲线

      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts); //左边点+箭头+右边点 连接起来

      var pList = leftPnts.concat(headPnts, rightPnts.reverse());
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }]);

  return AttackArrowUtil;
}(ArrowParentUtil_ArrowParentUtil);
// CONCATENATED MODULE: ./src/graphic/entityEx/AttackArrow.js






function AttackArrow_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var attackArrowUtil = new AttackArrowUtil_AttackArrowUtil();
/**
 *  攻击箭头  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var AttackArrow_AttackArrow = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(AttackArrow, _PolygonEntity);

  var _super = AttackArrow_createSuper(AttackArrow);

  function AttackArrow() {
    classCallCheck_default()(this, AttackArrow);

    return _super.apply(this, arguments);
  }

  createClass_default()(AttackArrow, [{
    key: "hasClosure",
    get: //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    function get() {
      return false;
    }
  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return attackArrowUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {AttackArrow} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new AttackArrow(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return AttackArrow;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("attackArrow", AttackArrow_AttackArrow);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/AttackArrowPWUtil.js






function AttackArrowPWUtil_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrowPWUtil_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrowPWUtil_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //攻击箭头（燕尾）

var AttackArrowPWUtil_AttackArrowPWUtil = /*#__PURE__*/function (_ArrowParentUtil) {
  inherits_default()(AttackArrowPWUtil, _ArrowParentUtil);

  var _super = AttackArrowPWUtil_createSuper(AttackArrowPWUtil);

  function AttackArrowPWUtil() {
    var _this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AttackArrowPWUtil);

    _this = _super.call(this); //影响因素

    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    _this.positions = null;
    _this.algorithmUtil = algorithmUtil;
    return _this;
  }

  createClass_default()(AttackArrowPWUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) {
        return positions;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var tailPnts = this.getTailPoints(pnts);
      var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);

      if (!headPnts || headPnts.length < 4) {
        return positions;
      }

      var neckLeft = headPnts[0];
      var neckRight = headPnts[4];
      var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      var _count = bodyPnts.length;
      var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse());
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(points) {
      var allLen = this.algorithmUtil.getBaseLength(points);
      var tailWidth = allLen * this.tailWidthFactor;
      var tailLeft = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      var tailRight = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      return [tailLeft, tailRight];
    }
  }]);

  return AttackArrowPWUtil;
}(ArrowParentUtil_ArrowParentUtil);
// CONCATENATED MODULE: ./src/graphic/entityEx/AttackArrowPW.js






function AttackArrowPW_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrowPW_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrowPW_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var attackArrowPWUtil = new AttackArrowPWUtil_AttackArrowPWUtil();
/**
 *  攻击箭头(平尾)  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var AttackArrowPW_AttackArrowPW = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(AttackArrowPW, _PolygonEntity);

  var _super = AttackArrowPW_createSuper(AttackArrowPW);

  function AttackArrowPW() {
    classCallCheck_default()(this, AttackArrowPW);

    return _super.apply(this, arguments);
  }

  createClass_default()(AttackArrowPW, [{
    key: "hasClosure",
    get: //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    function get() {
      return false;
    }
  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return attackArrowPWUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {AttackArrowPW} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new AttackArrowPW(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return AttackArrowPW;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("attackArrowPW", AttackArrowPW_AttackArrowPW);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/AttackArrowYWUtil.js






function AttackArrowYWUtil_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrowYWUtil_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrowYWUtil_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //攻击箭头（燕尾）

var AttackArrowYWUtil_AttackArrowYWUtil = /*#__PURE__*/function (_ArrowParentUtil) {
  inherits_default()(AttackArrowYWUtil, _ArrowParentUtil);

  var _super = AttackArrowYWUtil_createSuper(AttackArrowYWUtil);

  function AttackArrowYWUtil() {
    var _this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, AttackArrowYWUtil);

    _this = _super.call(this); //影响因素

    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    _this.headTailFactor = opt.headTailFactor || 0.8;
    _this.swallowTailFactor = opt.swallowTailFactor || 1;
    _this.positions = null;
    _this.algorithmUtil = algorithmUtil;
    return _this;
  }

  createClass_default()(AttackArrowYWUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) {
        return positions;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var _ref = [pnts[0], pnts[1]],
          tailLeft = _ref[0],
          tailRight = _ref[1];

      if (this.algorithmUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }

      var midTail = this.algorithmUtil.Mid(tailLeft, tailRight);
      var bonePnts = [midTail].concat(pnts.slice(2));
      var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);

      if (!headPnts || headPnts.length < 4) {
        return positions;
      }

      var _ref2 = [headPnts[0], headPnts[4]],
          neckLeft = _ref2[0],
          neckRight = _ref2[1];
      var tailWidth = this.algorithmUtil.MathDistance(tailLeft, tailRight);
      var allLen = this.algorithmUtil.getBaseLength(bonePnts);
      var len = allLen * this.tailWidthFactor * this.swallowTailFactor;
      var swallowTailPnt = this.algorithmUtil.getThirdPoint(bonePnts[1], bonePnts[0], 0, len, true);
      var factor = tailWidth / allLen;
      var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, factor);
      var count = bodyPnts.length;
      var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [swallowTailPnt, leftPnts[0]]);
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }]);

  return AttackArrowYWUtil;
}(ArrowParentUtil_ArrowParentUtil);
// CONCATENATED MODULE: ./src/graphic/entityEx/AttackArrowYW.js






function AttackArrowYW_createSuper(Derived) { var hasNativeReflectConstruct = AttackArrowYW_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function AttackArrowYW_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var AttackArrowYW_attackArrowUtil = new AttackArrowYWUtil_AttackArrowYWUtil();
/**
 *  攻击箭头（燕尾）  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var AttackArrowYW_AttackArrowYW = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(AttackArrowYW, _PolygonEntity);

  var _super = AttackArrowYW_createSuper(AttackArrowYW);

  function AttackArrowYW() {
    classCallCheck_default()(this, AttackArrowYW);

    return _super.apply(this, arguments);
  }

  createClass_default()(AttackArrowYW, [{
    key: "hasClosure",
    get: //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    function get() {
      return false;
    }
  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 3) {
        return positions;
      }

      return AttackArrowYW_attackArrowUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {AttackArrowYW} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new AttackArrowYW(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return AttackArrowYW;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("attackArrowYW", AttackArrowYW_AttackArrowYW);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/CloseCurveUtil.js




 //闭合曲面

var CloseCurveUtil_CloseCurveUtil = /*#__PURE__*/function () {
  function CloseCurveUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CloseCurveUtil);

    //影响因素
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(CloseCurveUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      pnts.push(pnts[0], pnts[1]);
      var normals = [];
      var pList = [];

      for (var i = 0; i < pnts.length - 2; i++) {
        var normalPoints = this.algorithmUtil.getBisectorNormals(0.3, pnts[i], pnts[i + 1], pnts[i + 2]);
        normals = normals.concat(normalPoints);
      }

      var count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));

      for (var _i = 0; _i < pnts.length - 2; _i++) {
        var pnt1 = pnts[_i];
        var pnt2 = pnts[_i + 1];
        pList.push(pnt1);

        for (var t = 0; t <= 100; t++) {
          var pnt = this.algorithmUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(pnt);
        }

        pList.push(pnt2);
      }

      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return CloseCurveUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/CloseVurve.js






function CloseVurve_createSuper(Derived) { var hasNativeReflectConstruct = CloseVurve_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CloseVurve_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var closeCurveUtil = new CloseCurveUtil_CloseCurveUtil();
/**
 * 闭合曲面(3个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var CloseVurve_CloseVurve = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(CloseVurve, _PolygonEntity);

  var _super = CloseVurve_createSuper(CloseVurve);

  function CloseVurve() {
    classCallCheck_default()(this, CloseVurve);

    return _super.apply(this, arguments);
  }

  createClass_default()(CloseVurve, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return closeCurveUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {CloseVurve} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new CloseVurve(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return CloseVurve;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("closeVurve", CloseVurve_CloseVurve);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/DoubleArrowUtil.js




 //计算钳击箭头坐标

var DoubleArrowUtil_DoubleArrowUtil = /*#__PURE__*/function () {
  function DoubleArrowUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DoubleArrowUtil);

    //影响因素
    this.headHeightFactor = opt.headHeightFactor || 0.25;
    this.headWidthFactor = opt.headWidthFactor || 0.3;
    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(DoubleArrowUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions || positions.length < 3) {
        return positions;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var _ref = [pnts[0], pnts[1], pnts[2]];
      var pnt1 = _ref[0];
      var pnt2 = _ref[1];
      var pnt3 = _ref[2];
      var count = this.positions.length;
      var tempPoint4;
      var connPoint;

      if (count == 3) {
        tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
        connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
      } else if (count == 4) {
        tempPoint4 = pnts[3];
        connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
      } else {
        var len1 = this.algorithmUtil.MathDistance(pnts[3], pnts[4]); //最后2个点

        var len2 = this.algorithmUtil.MathDistance(pnts[2], pnts[3]); //2个箭头间的距离

        if (len1 < len2 * 0.1) {
          tempPoint4 = pnts[3];
          connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
        } else {
          tempPoint4 = pnts[3];
          connPoint = pnts[4];
        }
      }

      var leftArrowPnts = undefined,
          rightArrowPnts = undefined;

      if (this.algorithmUtil.isClockWise(pnt1, pnt2, pnt3)) {
        leftArrowPnts = this.getArrowPoints(pnt1, connPoint, tempPoint4, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt2, pnt3, true);
      } else {
        leftArrowPnts = this.getArrowPoints(pnt2, connPoint, pnt3, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt1, tempPoint4, true);
      }

      var m = leftArrowPnts.length;
      var t = (m - 5) / 2;
      var llBodyPnts = leftArrowPnts.slice(0, t);
      var lArrowPnts = leftArrowPnts.slice(t, t + 5);
      var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
      var rlBodyPnts = rightArrowPnts.slice(0, t);
      var rArrowPnts = rightArrowPnts.slice(t, t + 5);
      var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
      rlBodyPnts = this.algorithmUtil.getBezierPoints(rlBodyPnts);
      var bodyPnts = this.algorithmUtil.getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
      lrBodyPnts = this.algorithmUtil.getBezierPoints(lrBodyPnts);
      var newPnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);
      var returnArr = PointTrans["mercators2cartesians"](newPnts, maxHeight);
      return returnArr;
    }
  }, {
    key: "getTempPoint4",
    value: function getTempPoint4(linePnt1, linePnt2, point) {
      var midPnt = this.algorithmUtil.Mid(linePnt1, linePnt2);
      var len = this.algorithmUtil.MathDistance(midPnt, point);
      var angle = this.algorithmUtil.getAngleOfThreePoints(linePnt1, midPnt, point);
      var symPnt = undefined,
          distance1 = undefined,
          distance2 = undefined,
          mid = undefined;

      if (angle < Math.PI / 2) {
        distance1 = len * Math.sin(angle);
        distance2 = len * Math.cos(angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else if (angle >= Math.PI / 2 && angle < Math.PI) {
        distance1 = len * Math.sin(Math.PI - angle);
        distance2 = len * Math.cos(Math.PI - angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      } else if (angle >= Math.PI && angle < Math.PI * 1.5) {
        distance1 = len * Math.sin(angle - Math.PI);
        distance2 = len * Math.cos(angle - Math.PI);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else {
        distance1 = len * Math.sin(Math.PI * 2 - angle);
        distance2 = len * Math.cos(Math.PI * 2 - angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      }

      return symPnt;
    }
  }, {
    key: "getArrowPoints",
    value: function getArrowPoints(pnt1, pnt2, pnt3, clockWise) {
      var midPnt = this.algorithmUtil.Mid(pnt1, pnt2);
      var len = this.algorithmUtil.MathDistance(midPnt, pnt3);
      var midPnt1 = this.algorithmUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
      var midPnt2 = this.algorithmUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
      midPnt1 = this.algorithmUtil.getThirdPoint(midPnt, midPnt1, Math.PI / 2, len / 5, clockWise);
      midPnt2 = this.algorithmUtil.getThirdPoint(midPnt, midPnt2, Math.PI / 2, len / 4, clockWise);
      var points = [midPnt, midPnt1, midPnt2, pnt3];
      var arrowPnts = this.getArrowHeadPoints(points);

      if (arrowPnts && Array.isArray(arrowPnts) && arrowPnts.length > 3) {
        var _ref2 = [arrowPnts[0], arrowPnts[4]],
            neckLeftPoint = _ref2[0],
            neckRightPoint = _ref2[1];
        var tailWidthFactor = this.algorithmUtil.MathDistance(pnt1, pnt2) / this.algorithmUtil.getBaseLength(points) / 2;
        var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);

        if (bodyPnts) {
          var n = bodyPnts.length;
          var lPoints = bodyPnts.slice(0, n / 2);
          var rPoints = bodyPnts.slice(n / 2, n);
          lPoints.push(neckLeftPoint);
          rPoints.push(neckRightPoint);
          lPoints = lPoints.reverse();
          lPoints.push(pnt2);
          rPoints = rPoints.reverse();
          rPoints.push(pnt1);
          return lPoints.reverse().concat(arrowPnts, rPoints);
        }
      } else {
        console.log("getArrowPoints:插值出错", arrowPnts);
      }
    }
  }, {
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(points) {
      if (!points || points.length < 2) {
        return [];
      }

      var len = this.algorithmUtil.getBaseLength(points);
      var headHeight = len * this.headHeightFactor;
      var headPnt = points[points.length - 1];
      var headWidth = headHeight * this.headWidthFactor;
      var neckWidth = headHeight * this.neckWidthFactor;
      var neckHeight = headHeight * this.neckHeightFactor;
      var headEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      var headRight = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      var neckLeft = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      var neckRight = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.algorithmUtil.wholeDistance(points);
      var len = this.algorithmUtil.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.algorithmUtil.MathDistance(neckLeft, neckRight);
      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.algorithmUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.algorithmUtil.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }

      return leftBodyPnts.concat(rightBodyPnts);
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return DoubleArrowUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/DoubleArrow.js






function DoubleArrow_createSuper(Derived) { var hasNativeReflectConstruct = DoubleArrow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DoubleArrow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var doubleArrowUtil = new DoubleArrowUtil_DoubleArrowUtil();
/**
 *  双箭头（钳击）  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var DoubleArrow_DoubleArrow = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(DoubleArrow, _PolygonEntity);

  var _super = DoubleArrow_createSuper(DoubleArrow);

  function DoubleArrow() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DoubleArrow);

    _this = _super.call(this, options);
    _this._minPointNum = 3; //至少需要点的个数

    _this._maxPointNum = 5; //最多允许点的个数

    return _this;
  }

  createClass_default()(DoubleArrow, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions;
      }

      return doubleArrowUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {DoubleArrow} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DoubleArrow(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return DoubleArrow;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("doubleArrow", DoubleArrow_DoubleArrow);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/FineArrowUtil.js




 //计算粗单尖直箭头坐标

var FineArrowUtil_FineArrowUtil = /*#__PURE__*/function () {
  function FineArrowUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FineArrowUtil);

    //影响因素
    this.headAngle = opt.headAngle || Math.PI / 8.5;
    this.neckAngle = opt.neckAngle || Math.PI / 13;
    this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    this.neckWidthFactor = opt.neckWidthFactor || 0.2;
    this.headWidthFactor = opt.headWidthFactor || 0.25;
    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(FineArrowUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) {
        return;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var _ref = [pnts[0], pnts[1]],
          pnt1 = _ref[0],
          pnt2 = _ref[1];
      var len = this.algorithmUtil.getBaseLength(pnts);
      var tailWidth = len * this.tailWidthFactor;
      var neckWidth = len * this.neckWidthFactor;
      var headWidth = len * this.headWidthFactor;
      var tailLeft = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      var tailRight = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      var headLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      var headRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      var neckLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      var neckRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return FineArrowUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/FineArrow.js






function FineArrow_createSuper(Derived) { var hasNativeReflectConstruct = FineArrow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FineArrow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var fineArrowUtil = new FineArrowUtil_FineArrowUtil();
/**
 * 直箭头(2个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var FineArrow_FineArrow = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(FineArrow, _PolygonEntity);

  var _super = FineArrow_createSuper(FineArrow);

  function FineArrow() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FineArrow);

    _this = _super.call(this, options);
    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    return _this;
  }

  createClass_default()(FineArrow, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return fineArrowUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {FineArrow} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new FineArrow(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return FineArrow;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("fineArrow", FineArrow_FineArrow);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/FineArrowYWUtil.js






function FineArrowYWUtil_createSuper(Derived) { var hasNativeReflectConstruct = FineArrowYWUtil_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FineArrowYWUtil_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //计算粗单尖直箭头(带燕尾)坐标

var FineArrowYWUtil_FineArrowYWUtil = /*#__PURE__*/function (_ArrowParentUtil) {
  inherits_default()(FineArrowYWUtil, _ArrowParentUtil);

  var _super = FineArrowYWUtil_createSuper(FineArrowYWUtil);

  function FineArrowYWUtil() {
    var _this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FineArrowYWUtil);

    _this = _super.call(this, opt); //影响因素

    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    _this.swallowTailFactor = opt.swallowTailFactor || 1;
    _this.positions = null;
    _this.algorithmUtil = algorithmUtil;
    return _this;
  }

  createClass_default()(FineArrowYWUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) {
        return positions;
      }

      this.positions = positions;
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var tailPnts = this.getTailPoints(pnts);
      var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);

      if (!headPnts || headPnts.length < 4) {
        return positions;
      }

      var neckLeft = headPnts[0];
      var neckRight = headPnts[4];
      var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      var _count = bodyPnts.length;
      var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(points) {
      var allLen = this.algorithmUtil.getBaseLength(points);
      var tailWidth = allLen * this.tailWidthFactor;
      var tailLeft = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      var tailRight = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      var len = tailWidth * this.swallowTailFactor;
      var swallowTailPnt = this.algorithmUtil.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight];
    }
  }]);

  return FineArrowYWUtil;
}(ArrowParentUtil_ArrowParentUtil);
// CONCATENATED MODULE: ./src/graphic/entityEx/FineArrowYW.js






function FineArrowYW_createSuper(Derived) { var hasNativeReflectConstruct = FineArrowYW_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FineArrowYW_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var fineArrowYWUtil = new FineArrowYWUtil_FineArrowYWUtil();
/**
 * 燕尾直箭头(2个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var FineArrowYW_FineArrowYW = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(FineArrowYW, _PolygonEntity);

  var _super = FineArrowYW_createSuper(FineArrowYW);

  function FineArrowYW() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FineArrowYW);

    _this = _super.call(this, options);
    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    return _this;
  }

  createClass_default()(FineArrowYW, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return fineArrowYWUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {FineArrowYW} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new FineArrowYW(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return FineArrowYW;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("fineArrowYW", FineArrowYW_FineArrowYW);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/GatheringPlaceUtil.js




 //集结地

var GatheringPlaceUtil_GatheringPlaceUtil = /*#__PURE__*/function () {
  function GatheringPlaceUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GatheringPlaceUtil);

    //影响因素
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(GatheringPlaceUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var mid = this.algorithmUtil.Mid(pnts[0], pnts[2]);
      pnts.push(mid, pnts[0], pnts[1]);
      var normals = [],
          pnt1 = undefined,
          pnt2 = undefined,
          pnt3 = undefined,
          pList = [];

      for (var i = 0; i < pnts.length - 2; i++) {
        pnt1 = pnts[i];
        pnt2 = pnts[i + 1];
        pnt3 = pnts[i + 2];
        var normalPoints = this.algorithmUtil.getBisectorNormals(0.4, pnt1, pnt2, pnt3);
        normals = normals.concat(normalPoints);
      }

      var count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));

      for (var _i = 0; _i < pnts.length - 2; _i++) {
        pnt1 = pnts[_i];
        pnt2 = pnts[_i + 1];
        pList.push(pnt1);

        for (var t = 0; t <= 100; t++) {
          var _pnt = this.algorithmUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);

          pList.push(_pnt);
        }

        pList.push(pnt2);
      }

      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return GatheringPlaceUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/GatheringPlace.js






function GatheringPlace_createSuper(Derived) { var hasNativeReflectConstruct = GatheringPlace_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GatheringPlace_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var gatheringPlaceUtil = new GatheringPlaceUtil_GatheringPlaceUtil();
/**
 * 集结地(3个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var GatheringPlace_GatheringPlace = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(GatheringPlace, _PolygonEntity);

  var _super = GatheringPlace_createSuper(GatheringPlace);

  function GatheringPlace() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GatheringPlace);

    _this = _super.call(this, options);
    _this._minPointNum = 3; //至少需要点的个数

    _this._maxPointNum = 3; //最多允许点的个数

    return _this;
  }

  createClass_default()(GatheringPlace, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions;
      }

      return gatheringPlaceUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {GatheringPlace} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new GatheringPlace(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return GatheringPlace;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("gatheringPlace", GatheringPlace_GatheringPlace);
// CONCATENATED MODULE: ./src/graphic/entityEx/IsosTriangle.js






function IsosTriangle_createSuper(Derived) { var hasNativeReflectConstruct = IsosTriangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function IsosTriangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 等腰三角形(3个点)  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var IsosTriangle_IsosTriangle = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(IsosTriangle, _PolygonEntity);

  var _super = IsosTriangle_createSuper(IsosTriangle);

  function IsosTriangle() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, IsosTriangle);

    _this = _super.call(this, options);
    _this._minPointNum = 3; //至少需要点的个数

    _this._maxPointNum = 3; //最多允许点的个数

    return _this;
  }

  createClass_default()(IsosTriangle, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions;
      } //p1 p2 用于控制腰的高度 p3用于控制夹角


      var p1 = positions[0];
      var p2 = positions[1];
      var p3 = positions[2];
      var midpoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(p1, p2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var angle1 = getAngle(midpoint, p2);
      var angle2 = getAngle(midpoint, p3);
      var angle = angle1 - angle2 - 90;
      var newPoint2 = Object(PointUtil["getRotateCenterPoint"])(midpoint, p3, angle);
      return [p1, p2, newPoint2];
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {IsosTriangle} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new IsosTriangle(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return IsosTriangle;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("isosTriangle", IsosTriangle_IsosTriangle);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/LuneUtil.js




 //弓形面

var LuneUtil_LuneUtil = /*#__PURE__*/function () {
  function LuneUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LuneUtil);

    //影响因素
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(LuneUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var _ref = [pnts[0], pnts[1], pnts[2], undefined, undefined],
          pnt1 = _ref[0],
          pnt2 = _ref[1],
          pnt3 = _ref[2],
          startAngle = _ref[3],
          endAngle = _ref[4];
      var center = this.algorithmUtil.getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
      var radius = this.algorithmUtil.MathDistance(pnt1, center);
      var angle1 = this.algorithmUtil.getAzimuth(pnt1, center);
      var angle2 = this.algorithmUtil.getAzimuth(pnt2, center);

      if (this.algorithmUtil.isClockWise(pnt1, pnt2, pnt3)) {
        startAngle = angle2;
        endAngle = angle1;
      } else {
        startAngle = angle1;
        endAngle = angle2;
      }

      pnts = this.algorithmUtil.getArcPoints(center, radius, startAngle, endAngle);
      pnts.push(pnts[0]);
      var returnArr = PointTrans["mercators2cartesians"](pnts, maxHeight);
      return returnArr;
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return LuneUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/Lune.js






function Lune_createSuper(Derived) { var hasNativeReflectConstruct = Lune_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Lune_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var luneUtil = new LuneUtil_LuneUtil();
/**
 * 弓形面(3个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var Lune_Lune = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(Lune, _PolygonEntity);

  var _super = Lune_createSuper(Lune);

  function Lune() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Lune);

    _this = _super.call(this, options);
    _this._minPointNum = 3; //至少需要点的个数

    _this._maxPointNum = 3; //最多允许点的个数

    return _this;
  }

  createClass_default()(Lune, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions;
      }

      return luneUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {Lune} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new Lune(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return Lune;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("lune", Lune_Lune);
// CONCATENATED MODULE: ./src/graphic/entityEx/edit/EditRegular.js






function EditRegular_createSuper(Derived) { var hasNativeReflectConstruct = EditRegular_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditRegular_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var EditRegular_EditRegular = /*#__PURE__*/function (_EditPolygon) {
  inherits_default()(EditRegular, _EditPolygon);

  var _super = EditRegular_createSuper(EditRegular);

  function EditRegular() {
    classCallCheck_default()(this, EditRegular);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditRegular, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions; //中心点

      var positionMove = this.updatePositionsHeightByAttr(positions[0]);
      var dragger = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: function onDrag(dragger, position) {
          position = _this.updatePositionsHeightByAttr(position);
          dragger.position = position; //记录差值

          var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, positionMove, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          positionMove = position;

          _this.positions.forEach(function (pos, index, arr) {
            var newPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(pos, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
            _this.positions[index] = newPos;
          });

          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(_this.draggers[i].position, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          }
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger); //各顶点

      var startAnglePt = Object(PointUtil["getPositionByDirectionAndLen"])(positionMove, this.style.startAngle, this.style.radius);
      positions[1] = startAnglePt;
      var dragger1 = this.createDragger({
        position: this.updatePositionsHeightByAttr(startAnglePt),
        onDrag: function onDrag(dragger, position) {
          position = _this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          _this.positions[dragger.index] = position;
          _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position);
          _this.style.startAngle = getAngle(positions[0], position);
        },
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      dragger1.index = 1;
      this.draggers.push(dragger1); //创建高度拖拽点

      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }
  }]);

  return EditRegular;
}(EditPolygon_EditPolygon);
// CONCATENATED MODULE: ./src/graphic/entityEx/Regular.js







function Regular_createSuper(Derived) { var hasNativeReflectConstruct = Regular_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Regular_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 *  正多边形  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。,除父类样式外，还包括：
 * @param {Number} [options.style.border=3] 边数量
 * @param {Number} options.style.radius 区域的半径（单位：米）
 * @param {Number} [options.style.startAngle=0] 区域的开始角度(正东方向为0,顺时针到360度)
 *
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var Regular_Regular = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(Regular, _PolygonEntity);

  var _super = Regular_createSuper(Regular);

  function Regular() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Regular);

    _this = _super.call(this, options);
    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.radius, 1000);
    _this.style.startAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.startAngle, 0);

    if (options.position) {
      _this.positions = [options.position];
    }

    return _this;
  }
  /**
   * 编辑处理类
   * @type {EditRegular}
   * @readonly
   */


  createClass_default()(Regular, [{
    key: "EditClass",
    get: function get() {
      return EditRegular_EditRegular;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      var _this$_positions_draw;

      if (!isEditing && ((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 1) {
        var center = this._positions_draw[0];
        this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(center, this._positions_draw[1]);
        this.style.startAngle = getAngle(center, this._positions_draw[1]);
      }

      get_default()(getPrototypeOf_default()(Regular.prototype), "updateAttrForDrawing", this).call(this, isEditing);
    }
  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 1) {
        return positions;
      }

      var center = positions[0];
      var num = this.style.border || 3; //边数量

      var radius = this.style.radius || 1000;
      var startAngle = this.style.startAngle || 0;
      var addAngle = 360 / num;
      var arr = [];

      for (var i = 0; i <= num; i++) {
        var thisAngle = startAngle + addAngle * i;
        arr.push(Object(PointUtil["getPositionByDirectionAndLen"])(center, thisAngle, radius));
      }

      return arr;
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {Regular} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new Regular(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return Regular;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("regular", Regular_Regular);
// CONCATENATED MODULE: ./src/graphic/entityEx/edit/EditSector.js






function EditSector_createSuper(Derived) { var hasNativeReflectConstruct = EditSector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditSector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var EditSector_EditSector = /*#__PURE__*/function (_EditPolygon) {
  inherits_default()(EditSector, _EditPolygon);

  var _super = EditSector_createSuper(EditSector);

  function EditSector() {
    classCallCheck_default()(this, EditSector);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditSector, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var positions = this.positions; //中心点

      var positionMove = this.updatePositionsHeightByAttr(positions[0]);
      var dragger = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: function onDrag(dragger, position) {
          position = _this.updatePositionsHeightByAttr(position);
          dragger.position = position; //记录差值

          var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, positionMove, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          positionMove = position;

          _this.positions.forEach(function (pos, index, arr) {
            var newPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(pos, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
            _this.positions[index] = newPos;
          });

          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(_this.draggers[i].position, diff, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          }
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger); //各顶点

      var startAnglePt = Object(PointUtil["getPositionByDirectionAndLen"])(positionMove, this.style.startAngle, this.style.radius);
      positions[1] = startAnglePt;
      var dragger1 = this.createDragger({
        position: this.updatePositionsHeightByAttr(startAnglePt),
        onDrag: function onDrag(dragger, position) {
          position = _this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          _this.positions[dragger.index] = position;
          _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position);
          _this.style.startAngle = getAngle(positions[0], position);
          positions[2] = Object(PointUtil["getPositionByDirectionAndLen"])(positions[0], _this.style.endAngle, _this.style.radius);
        },
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      dragger1.index = 1;
      this.draggers.push(dragger1); //各顶点

      var endAnglePt = Object(PointUtil["getPositionByDirectionAndLen"])(positionMove, this.style.endAngle, this.style.radius);
      positions[2] = endAnglePt;
      var dragger2 = this.createDragger({
        position: this.updatePositionsHeightByAttr(endAnglePt),
        onDrag: function onDrag(dragger, position) {
          position = _this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          _this.positions[dragger.index] = position;
          _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], position);
          _this.style.endAngle = getAngle(positions[0], position);
          positions[1] = Object(PointUtil["getPositionByDirectionAndLen"])(positions[0], _this.style.startAngle, _this.style.radius);
        },
        onDragStart: function onDragStart(dragger, position) {
          for (var i = 0, len = _this.draggers.length; i < len; i++) {
            _this.draggers[i].show = false;
          }
        },
        onDragEnd: function onDragEnd(dragger, position) {
          _this.updateDraggers();
        }
      });
      dragger2.index = 2;
      this.draggers.push(dragger2); //创建高度拖拽点

      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }
  }]);

  return EditSector;
}(EditPolygon_EditPolygon);
// CONCATENATED MODULE: ./src/graphic/entityEx/Sector.js







function Sector_createSuper(Derived) { var hasNativeReflectConstruct = Sector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Sector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 *  扇形(3个点)  Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。,额外扩展了：
 * @param {Number} options.style.radius 扇形区域的半径（单位：米）
 * @param {Number} options.style.startAngle 扇形区域的开始角度(正东方向为0,顺时针到360度)
 * @param {Number} options.style.endAngle 扇形区域的结束角度(正东方向为0,顺时针到360度)
 *
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var Sector_Sector = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(Sector, _PolygonEntity);

  var _super = Sector_createSuper(Sector);

  function Sector() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Sector);

    _this = _super.call(this, options);
    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 3; //最多允许点的个数

    _this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.radius, 1000);
    _this.style.startAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.startAngle, 0);
    _this.style.endAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.endAngle, 0);

    if (options.position) {
      _this.positions = [options.position];
    }

    return _this;
  }
  /**
   * 编辑处理类
   * @type {EditSector}
   * @readonly
   */


  createClass_default()(Sector, [{
    key: "EditClass",
    get: function get() {
      return EditSector_EditSector;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {
      var _this$_positions_draw;

      if (!isEditing && ((_this$_positions_draw = this._positions_draw) === null || _this$_positions_draw === void 0 ? void 0 : _this$_positions_draw.length) > 1) {
        var _this$_positions_draw2;

        var center = this._positions_draw[0];
        this.style.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(center, this._positions_draw[1]);
        this.style.startAngle = getAngle(center, this._positions_draw[1]);

        if (((_this$_positions_draw2 = this._positions_draw) === null || _this$_positions_draw2 === void 0 ? void 0 : _this$_positions_draw2.length) > 2) {
          this.style.endAngle = getAngle(center, this._positions_draw[2]);
        } else {
          this.style.endAngle = this.style.startAngle;
        }
      }

      get_default()(getPrototypeOf_default()(Sector.prototype), "updateAttrForDrawing", this).call(this, isEditing);
    }
  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 1) {
        return positions;
      }

      var center = positions[0];
      var radius = this.style.radius;
      var startAngle = this.style.startAngle;
      var endAngle = this.style.endAngle;

      if (endAngle <= startAngle) {
        endAngle += 360;
      }

      var arr = [center];

      for (var i = startAngle; i <= endAngle; i++) {
        arr.push(Object(PointUtil["getPositionByDirectionAndLen"])(center, i, radius));
      }

      arr.push(center);
      return arr;
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {Sector} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new Sector(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return Sector;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("sector", Sector_Sector);
// CONCATENATED MODULE: ./src/graphic/entityEx/algorithm/StraightArrowUtil.js




 //计算粗直箭头坐标

var StraightArrowUtil_StraightArrowUtil = /*#__PURE__*/function () {
  function StraightArrowUtil() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, StraightArrowUtil);

    //影响因素
    this.tailWidthFactor = opt.tailWidthFactor || 0.05;
    this.neckWidthFactor = opt.neckWidthFactor || 0.1;
    this.headWidthFactor = opt.headWidthFactor || 0.15;
    this.headAngle = Math.PI / 4;
    this.neckAngle = Math.PI * 0.17741;
    this.positions = null;
    this.algorithmUtil = algorithmUtil;
  }

  createClass_default()(StraightArrowUtil, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = PointTrans["cartesians2mercators"](positions);
      var maxHeight = this.getMaxHeight(pnts);
      var _ref = [pnts[0], pnts[1]],
          pnt1 = _ref[0],
          pnt2 = _ref[1];
      var len = this.algorithmUtil.getBaseLength(pnts);
      var tailWidth = len * this.tailWidthFactor;
      var neckWidth = len * this.neckWidthFactor;
      var headWidth = len * this.headWidthFactor;
      var tailLeft = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      var tailRight = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      var headLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      var headRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      var neckLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      var neckRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];
      var returnArr = PointTrans["mercators2cartesians"](pList, maxHeight);
      return returnArr;
    }
  }, {
    key: "getMaxHeight",
    value: function getMaxHeight(pnts) {
      var maxHeight = pnts[0][2] || 0;

      for (var i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }

      return maxHeight;
    }
  }]);

  return StraightArrowUtil;
}();
// CONCATENATED MODULE: ./src/graphic/entityEx/StraightArrow.js






function StraightArrow_createSuper(Derived) { var hasNativeReflectConstruct = StraightArrow_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function StraightArrow_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 //主要算法

var straightArrowUtil = new StraightArrowUtil_StraightArrowUtil();
/**
 * 直箭头(3个点)   Entity矢量数据
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty} options.positions 坐标位置
 * @param {PolygonEntity.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
 * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
 *
 * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
 * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
 * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
 * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
 * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
 *
 * @extends {PolygonEntity}
 * @see [支持的事件类型]{@link BaseEntity.EventType}
 */

var StraightArrow_StraightArrow = /*#__PURE__*/function (_PolygonEntity) {
  inherits_default()(StraightArrow, _PolygonEntity);

  var _super = StraightArrow_createSuper(StraightArrow);

  function StraightArrow() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, StraightArrow);

    _this = _super.call(this, options);
    _this._minPointNum = 2; //至少需要点的个数

    _this._maxPointNum = 2; //最多允许点的个数

    return _this;
  }

  createClass_default()(StraightArrow, [{
    key: "getShowPositions",
    value: function getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions;
      }

      return straightArrowUtil.startCompute(positions);
    } //==================静态方法=================

    /**
     * 通过标绘 来创建矢量对象
     *
     * @static
     * @param {GraphicLayer} layer 图层
     * @param {Object} options 矢量对象的构造参数
     * @return {StraightArrow} 矢量对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new StraightArrow(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return StraightArrow;
}(PolygonEntity_PolygonEntity); //注册下

Object(GraphicUtil["register"])("straightArrow", StraightArrow_StraightArrow);
// CONCATENATED MODULE: ./src/graphic/primitive/BillboardPrimitive.js






function BillboardPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = BillboardPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BillboardPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 图标点 Primitive矢量数据 支持的样式信息
 *
 * @typedef {Object} BillboardPrimitive.StyleOptions
 *
 * @property {BillboardEntity.StyleOptions} [所有] 与 BillboardEntity 相同
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 * @see Cesium.Billboard
 * @see BillboardEntity.StyleOptions
 */

/**
 * 图标点 Primitive矢量数据
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {BillboardPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class BillboardPrimitive
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var BillboardPrimitive_BillboardPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(BillboardPrimitive, _BasePointPrimitive);

  var _super = BillboardPrimitive_createSuper(BillboardPrimitive);

  function BillboardPrimitive() {
    classCallCheck_default()(this, BillboardPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(BillboardPrimitive, [{
    key: "primitiveCollection",
    get:
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.BillboardCollection}
     * @readonly
     */
    function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.billboardCollection;
    }
    /**
     * 图像、URI或Canvas
     * @type {string | HTMLCanvasElement}
     */

  }, {
    key: "image",
    get: function get() {
      return this.style.image;
    },
    set: function set(val) {
      this.style.image = val;

      if (this._primitive) {
        this._primitive.image = val;
      }
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var addattr = BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.style, {
        show: this.show,
        position: this.position
      });
      this._primitive = this.primitiveCollection.add(addattr); //同时加文字

      if (this.style.label) {
        this._addLabel();
      }
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.style, this.primitive);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._primitive.position = this.position;
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return BillboardStyleConver_BillboardStyleConver.toJSON(czmStyle, styleJson);
    }
  }]);

  return BillboardPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("billboardP", BillboardPrimitive_BillboardPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/LabelPrimitive.js






function LabelPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = LabelPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LabelPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 文字 支持的样式信息（与LabelEntity相同）
 *
 * @typedef {Object} LabelPrimitive.StyleOptions
 * @property {LabelEntity.StyleOptions} [所有] 与LabelEntity相同
 *
 * @see LabelEntity.StyleOptions
 * @see Cesium.Label
 */

/**
 *  文字 Primitive矢量数据
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {LabelPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class LabelPrimitive
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var LabelPrimitive_LabelPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(LabelPrimitive, _BasePointPrimitive);

  var _super = LabelPrimitive_createSuper(LabelPrimitive);

  function LabelPrimitive() {
    classCallCheck_default()(this, LabelPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(LabelPrimitive, [{
    key: "primitiveCollection",
    get:
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.LabelCollection}
     * @readonly
     */
    function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.labelCollection;
    }
    /**
     * 文本内容
     * @type {String}
     * @readonly
     */

  }, {
    key: "text",
    get: function get() {
      return this.style.text;
    },
    set: function set(value) {
      this.style.text = value;

      if (this._primitive) {
        this._primitive.text = value;
      }
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var addattr = LabelStyleConver_LabelStyleConver.toCesiumVal(this.style, {
        show: this.show,
        position: this.position
      }, {}, this.attr);
      this._primitive = this.primitiveCollection.add(addattr);
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      LabelStyleConver_LabelStyleConver.toCesiumVal(this.style, this.primitive, this.attr);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._primitive.position = this.position;
    }
  }]);

  return LabelPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("labelP", LabelPrimitive_LabelPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/ModelPrimitive.js







function ModelPrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ModelPrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ModelPrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ModelPrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ModelPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = ModelPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * gltf小模型 支持的样式信息
 *
 * @typedef {Object} ModelPrimitive.StyleOptions
 *
 *
 * @property {String| Cesium.Resource} [url] glTF模型的URI的字符串或资源属性。
 * @property {Number} [scale = 1] 整体缩放比例
 *
 * @property {Number} [scaleX = 1] X轴方向缩放比例
 * @property {Number} [scaleY = 1] Y轴方向缩放比例
 * @property {Number} [scaleZ = 1] Z轴方向缩放比例
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {number} [minimumPixelSize=0.0] 指定模型的近似最小像素大小，而不考虑缩放。
 * @property {number} [maximumScale] 模型的最大比例尺寸。minimumPixelSize的上限。
 *
 * @property {Boolean} [fill = false] 是否填充，指定与模型渲染颜色混合
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Cesium.ColorBlendMode} [colorBlendMode=ColorBlendMode.HIGHLIGHT] 指定颜色如何与模型混合。
 * @property {number} [colorBlendAmount=0.5] 当colorBlendMode为MIX时指定颜色强度的数字属性。0.0的值表示模型渲染的颜色，1.0的值表示纯色，任何介于两者之间的值表示两者的混合。
 *
 * @property {Boolean} [silhouette = false] 是否轮廓
 * @property {String|Cesium.Color} [silhouetteColor = "#ffffff"] 轮廓颜色
 * @property {Number} [silhouetteSize = 2] 轮廓宽度
 * @property {Number} [silhouetteAlpha = 0.8] 轮廓透明度
 *
 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = true] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
 *
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
 *
 * @property {boolean} [incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
 * @property {boolean} [runAnimations=true]  指定模型中指定的glTF动画是否应该启动。
 * @property {boolean} [clampAnimations=true]  指定在没有关键帧的情况下，glTF动画是否应该保持最后一个姿势。
 *
 * @property {Cesium.Cartesian2} [imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] 指定来自基于图像的漫反射和镜面照明的贡献。
 * @property {Color} [lightColor]  在为模型着色时指定光的颜色的属性。当undefined场景的浅色被使用代替。
 * @property {Cesium.PropertyBag | Object.<string, Cesium.TranslationRotationScale>} [nodeTransformations] 一个对象，其中键是节点的名称，值是{@link TranslationRotationScale}属性，描述要应用到该节点的转换。该转换是在节点的现有转换之后(如glTF中指定的那样)应用的，并且不会替换节点的现有转换。
 * @property {Cesium.PropertyBag | Object.<string, number>} [articulations] An object, where keys are composed of an articulation name, a single space, and a stage name, and the values are numeric properties.
 * @property {Cesium.ClippingPlaneCollection} [clippingPlanes]  用于裁剪模型的Plane平面集合
 *
 *
 * @property {Boolean} [allowPicking=true] 当true时，每个glTF和Primitive都可以用{@link Cesium.Scene#pick}来拾取。
 * @property {Boolean} [asynchronous=true] 确定模型WebGL资源创建是否将分散在几个帧或块上，直到所有glTF文件加载完成。
 * @property {Boolean} [dequantizeInShader=true] 确定一个{@link https://github.com/google/draco|Draco}编码的模型是否在GPU上被去量化。这减少了编码模型的总内存使用量。
 * @property {Boolean} [backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除是由材料的双面属性决定的;当为false时，禁用背面剔除。如果{@link Model#color}是半透明的，或者{@link Model#silhouette}大于0.0，则背面不会被剔除。
 * @property {Boolean} [debugShowBoundingVolume=false] 仅供调试。查看模型的包围边界球。
 * @property {Boolean} [debugWireframe=false] 仅供调试。查看模型的三角网线框图。
 *
 * //以下是 以下是 模型动画相关
 * @property {Cesium.JulianDate} [startTime] 场景时间开始播放动画。当undefined时，动画从下一帧开始。
 * @property {Number} [delay=0.0] 从startTime开始播放的延迟，以秒为单位。
 * @property {JulianDate} [stopTime] 场景时间停止播放动画。当这是undefined，动画播放它的整个持续时间。
 * @property {Boolean} [removeOnStop=false] 当true时，动画在停止播放后被删除。
 * @property {Number} [multiplier=1.0] 大于1.0的值增加动画播放的速度相对于场景时钟的速度;小于1.0会降低速度。
 * @property {Boolean} [reverse=false] 当true时，动画会反向播放。
 * @property {Cesium.ModelAnimationLoop} [loop=Cesium.ModelAnimationLoop.REPEAT] 决定动画是否循环以及如何循环。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 * @typedef {Object} ModelPrimitive.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BasePrimitive.EventType} 通用 支持的父类的事件类型
 * @property {String} load 完成加载，执行所有内部处理后
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.load, function (event) {
 *   console.log('模型加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 *
 * gltf小模型 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {ModelPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
 * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
 *
 * @extends {BasePointPrimitive}
 *
 * @see [支持的模型事件类型]{@link ModelPrimitive.EventType}
 */

var ModelPrimitive_ModelPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(ModelPrimitive, _BasePointPrimitive);

  var _super = ModelPrimitive_createSuper(ModelPrimitive);

  function ModelPrimitive() {
    classCallCheck_default()(this, ModelPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(ModelPrimitive, [{
    key: "scale",
    get:
    /**
     * 模型整体的缩放比例
     * @type {Number}
     */
    function get() {
      var _this$style$scale;

      return (_this$style$scale = this.style.scale) !== null && _this$style$scale !== void 0 ? _this$style$scale : 1;
    },
    set: function set(val) {
      this.style.scale = val;

      this._updateStyleHook();
    }
    /**
     * X轴方向缩放比例
     * @type {Number}
     */

  }, {
    key: "scaleX",
    get: function get() {
      var _this$style$scaleX;

      return (_this$style$scaleX = this.style.scaleX) !== null && _this$style$scaleX !== void 0 ? _this$style$scaleX : 1;
    },
    set: function set(val) {
      this.style.scaleX = val;
      this.updateModelMatrix();
    }
    /**
     * Y轴方向缩放比例
     * @type {Number}
     */

  }, {
    key: "scaleY",
    get: function get() {
      var _this$style$scaleY;

      return (_this$style$scaleY = this.style.scaleY) !== null && _this$style$scaleY !== void 0 ? _this$style$scaleY : 1;
    },
    set: function set(val) {
      this.style.scaleY = val;
      this.updateModelMatrix();
    }
    /**
     * Z轴方向缩放比例
     * @type {Number}
     */

  }, {
    key: "scaleZ",
    get: function get() {
      var _this$style$scaleZ;

      return (_this$style$scaleZ = this.style.scaleZ) !== null && _this$style$scaleZ !== void 0 ? _this$style$scaleZ : 1;
    },
    set: function set(val) {
      this.style.scaleZ = val;
      this.updateModelMatrix();
    }
    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "modelMatrix",
    get: function get() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix;
      }

      if (!this.position) {
        return undefined;
      }

      if (this.property && this._orientation) {
        //是addDynamicPosition场景下使用
        var matrix4 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();
        var matrix3Scratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();

        var orientation = this._orientation.getValue(this._map.clock.currentTime);

        var _modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromQuaternion(orientation, matrix3Scratch), this.position, matrix4);

        return _modelMatrix;
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll);
      var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollToFixedFrame(this.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll));
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByScale(modelMatrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](this.scaleX, this.scaleY, this.scaleZ), modelMatrix);
      return modelMatrix;
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this = this;

      var addattr = ModelStyleConver_ModelStyleConver.toCesiumVal(this.style);
      this._primitive = this.primitiveCollection.add(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Model"].fromGltf(ModelPrimitive_objectSpread({
        modelMatrix: this.modelMatrix,
        scene: this._map.scene
      }, addattr)));

      this._primitive.readyPromise.then(function (model) {
        //加载完成后直接启动所有动画
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.runAnimations, true)) {
          model.activeAnimations.addAll(ModelPrimitive_objectSpread({
            loop: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ModelAnimationLoop"].REPEAT
          }, _this.style));
        }

        _this.fire(EventType.load, {
          drawtype: _this.type,
          model: model,
          graphic: _this
        }, true);
      })["catch"](function (error) {
        Object(Log["logError"])("ModelPrimitive:模型加载出错", error);
      }); //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
  }, {
    key: "_updateStyleHook",
    value: function _updateStyleHook(newStyle) {
      ModelStyleConver_ModelStyleConver.toCesiumVal(this.style, this.primitive);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._primitive.modelMatrix = this.modelMatrix;
    }
  }]);

  return ModelPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("modelP", ModelPrimitive_ModelPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/CirclePrimitive.js







function CirclePrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CirclePrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CirclePrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CirclePrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CirclePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = CirclePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CirclePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 圆 支持的样式信息
 *
 * @typedef {Object} CirclePrimitive.StyleOptions
 *
 * @property {Number} [radius = 100] 半径
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Number} [diffHeight = 100] 高度差（圆柱本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定圆的挤压面相对于椭球面的高度。
 *
 * @property {Number} [stRotation = 0] 椭圆纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 椭圆纹理的角度（度数值，0-360度），与stRotation二选一
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定椭圆上各点之间的角距离。
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=Cesium.MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * @property {String} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 *
 * 圆 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {CirclePrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var CirclePrimitive_CirclePrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(CirclePrimitive, _BasePointPrimitive);

  var _super = CirclePrimitive_createSuper(CirclePrimitive);

  function CirclePrimitive() {
    classCallCheck_default()(this, CirclePrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(CirclePrimitive, [{
    key: "distance",
    get: //距离长度（单位：米）
    function get() {
      return Math.PI * 2 * this.radius;
    } //面积（单位：平方米）

  }, {
    key: "area",
    get: function get() {
      var radius = this.radius;
      return Math.PI * radius * radius;
    }
    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */

  }, {
    key: "radius",
    get: function get() {
      return this.style.radius;
    } //转换style

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return CircleStyleConver_CircleStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      addattr.height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](addattr.height, this.point.alt);
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CircleOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CircleGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(CirclePrimitive_objectSpread({
          center: this.position
        }, addattr)),
        attributes: this.options.attributes
      });
    } //定位至数据区域

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      options.radius = this.radius * (options.scale || 1.8);

      if (this._map) {
        this._map.flyToPoint(this.position, options);
      }
    }
    /**
     * 判断点是否在圆内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在圆内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      position = LatLngPoint["a" /* LatLngPoint */].parse(position).toCartesian();
      position = Object(PointUtil["setPositionsHeight"])(position, this.height);
      var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this.position, position);
      return len <= this.radius; //小于半径的说明在圆内
    }
  }]);

  return CirclePrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("circleP", CirclePrimitive_CirclePrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/PlanePrimitive.js






function PlanePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = PlanePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PlanePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 平面 支持的样式信息
 *
 * @typedef {Object} PlanePrimitive.StyleOptions
 *
 * @property {Cesium.Cartesian2} [dimensions] 指定平面的宽度和高度。
 * @property {Number} [dimensions_x = 100] 长度
 * @property {Number} [dimensions_y = 100] 宽度
 *
 *  @property {String} [plane_normal = "z"] 方向 ,可选项：x (解释：X轴),y (解释：Y轴),z (解释：Z轴),
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 * @property {MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 *
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 *
 * 平面 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {PlanePrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PlanePrimitive_PlanePrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(PlanePrimitive, _BasePointPrimitive);

  var _super = PlanePrimitive_createSuper(PlanePrimitive);

  function PlanePrimitive() {
    classCallCheck_default()(this, PlanePrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(PlanePrimitive, [{
    key: "modelMatrix",
    get:
    /**
     *  用于指定位置的矩阵
     * @type {Cesium.Matrix4}
     * @readonly
     */
    function get() {
      var _addattr$dimensions$x, _addattr$dimensions, _addattr$dimensions$y, _addattr$dimensions2;

      if (this.options.modelMatrix) {
        return this.options.modelMatrix;
      }

      var addattr = PlaneStyleConver_PlaneStyleConver.toCesiumVal(this.style);
      var translateMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this.position);
      var scaleMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromScale(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]((_addattr$dimensions$x = (_addattr$dimensions = addattr.dimensions) === null || _addattr$dimensions === void 0 ? void 0 : _addattr$dimensions.x) !== null && _addattr$dimensions$x !== void 0 ? _addattr$dimensions$x : 1, (_addattr$dimensions$y = (_addattr$dimensions2 = addattr.dimensions) === null || _addattr$dimensions2 === void 0 ? void 0 : _addattr$dimensions2.y) !== null && _addattr$dimensions$y !== void 0 ? _addattr$dimensions$y : 1, 1));
      var modelMatrix = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();

      if (addattr.plane_normal == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_X) {
        var rotationXMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(90.0)));
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(translateMatrix, rotationXMatrix, modelMatrix);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(modelMatrix, scaleMatrix, modelMatrix);
      } else if (addattr.plane_normal == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Y) {
        var rotationYMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(90.0)));
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(translateMatrix, rotationYMatrix, modelMatrix);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(modelMatrix, scaleMatrix, modelMatrix);
      } else {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(translateMatrix, scaleMatrix, modelMatrix);
      }

      return modelMatrix;
    } //转换style

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return PlaneStyleConver_PlaneStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PlaneOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PlaneGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass({
          vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"].VERTEX_FORMAT
        }),
        modelMatrix: this.modelMatrix,
        attributes: this.options.attributes
      });
    }
  }]);

  return PlanePrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("planeP", PlanePrimitive_PlanePrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/BoxPrimitive.js






function BoxPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = BoxPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BoxPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 盒子 支持的样式信息
 *
 * @typedef {Object} BoxPrimitive.StyleOptions
 *
 * @property {Cesium.Cartesian3} [dimensions] 指定盒子的长度、宽度和高度。
 * @property {Number} [dimensions_x = 100] 盒子长度
 * @property {Number} [dimensions_y = 100] 盒子宽度
 * @property {Number} [dimensions_z = 100] 盒子高度
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 */

/**
 *
 * 盒子 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {BoxPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @export
 * @class BoxPrimitive
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var BoxPrimitive_BoxPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(BoxPrimitive, _BasePointPrimitive);

  var _super = BoxPrimitive_createSuper(BoxPrimitive);

  function BoxPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BoxPrimitive);

    _this = _super.call(this, options);
    _this.style.closed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.closed, true);
    return _this;
  } //子类需要继承实现


  createClass_default()(BoxPrimitive, [{
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return BoxStyleConver_BoxStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoxOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoxGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: GeometryClass.fromDimensions(addattr),
        modelMatrix: this.modelMatrix,
        // modelMatrix:
        //   this.options.modelMatrix ||
        //   Cesium.Matrix4.multiplyByTranslation(
        //     Cesium.Transforms.eastNorthUpToFixedFrame(this.position),
        //     new Cesium.Cartesian3(0.0, 0.0, dimensions.z * 0.5),
        //     new Cesium.Matrix4()
        //   ),
        attributes: this.options.attributes
      });
    }
  }]);

  return BoxPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("boxP", BoxPrimitive_BoxPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/CylinderPrimitive.js







function CylinderPrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CylinderPrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CylinderPrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CylinderPrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CylinderPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = CylinderPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CylinderPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 圆锥 支持的样式信息
 *
 * @typedef {Object} CylinderPrimitive.StyleOptions
 *
 * @property {Number} [topRadius = 0] 顶部半径，指定圆柱体顶部的半径，当为0时即为圆锥。
 * @property {Number} [bottomRadius = 100] 底部半径，指定圆柱体底部半径。
 * @property {Number} [length = 100] 高度，柱面长度。
 * @property {number} [slices=128] 圆柱体周长周围的边数。
 *
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 *
 * 圆锥 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {CylinderPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var CylinderPrimitive_CylinderPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(CylinderPrimitive, _BasePointPrimitive);

  var _super = CylinderPrimitive_createSuper(CylinderPrimitive);

  function CylinderPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CylinderPrimitive);

    _this = _super.call(this, options);
    _this.style.closed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.closed, true);
    return _this;
  } //转换style


  createClass_default()(CylinderPrimitive, [{
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return CylinderStyleConver_CylinderStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CylinderOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CylinderGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(CylinderPrimitive_objectSpread({}, addattr)),
        modelMatrix: this.modelMatrix,
        attributes: this.options.attributes
      });
    }
  }]);

  return CylinderPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("cylinderP", CylinderPrimitive_CylinderPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/EllipsoidPrimitive.js







function EllipsoidPrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function EllipsoidPrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { EllipsoidPrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { EllipsoidPrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function EllipsoidPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = EllipsoidPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EllipsoidPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 球体 支持的样式信息
 *
 * @typedef {Object} EllipsoidPrimitive.StyleOptions
 *
 * @property {Cesium.Cartesian3} [radii] 指定椭球半径。
 * @property {Number} [radii_x = 100] X半径
 * @property {Number} [radii_y = 100] Y半径
 * @property {Number} [radii_z = 100] Z半径
 * @property {Cesium.Cartesian3} [innerRadii] 指定椭球的内半径。
 * @property {Number} [innerRadii_x = 0] 内部X半径
 * @property {Number} [innerRadii_y = 0] 内部Y半径
 * @property {Number} [innerRadii_z = 0] 内部Z半径
 *
 * @property {Number} [minimumClock = 0] 最小时钟角度（弧度值）
 * @property {Number} [minimumClockDegree = 0] 最小时钟角度（度数值，0-360度），与minimumClock二选一
 * @property {Number} [maximumClock = 360] 最大时钟角度（弧度值）
 * @property {Number} [maximumClockDegree = 360] 最大时钟角度（度数值，0-360度），与maximumClock二选一
 * @property {Number} [minimumCone = 0] 最小锥角（弧度值）
 * @property {Number} [minimumConeDegree = 0] 最小锥角（度数值，0-360度），与minimumCone二选一
 * @property {Number} [maximumCone = 180] 最大圆锥角（弧度值）
 * @property {Number} [maximumConeDegree = 180] 最大圆锥角（度数值，0-360度），与maximumCone二选一
 *
 * @property {number} [stackPartitions=64] 指定竖向划分数量
 * @property {number} [slicePartitions=64] 指定横向划分数量
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 * @property {MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 *
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 *
 * 球体 Primitive图元矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {EllipsoidPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 *
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var EllipsoidPrimitive_EllipsoidPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(EllipsoidPrimitive, _BasePointPrimitive);

  var _super = EllipsoidPrimitive_createSuper(EllipsoidPrimitive);

  function EllipsoidPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EllipsoidPrimitive);

    _this = _super.call(this, options);
    _this.style.closed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.closed, true);
    return _this;
  } //转换style


  createClass_default()(EllipsoidPrimitive, [{
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return EllipsoidStyleConver_EllipsoidStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(EllipsoidPrimitive_objectSpread({}, addattr)),
        modelMatrix: this.modelMatrix,
        // modelMatrix:
        //   this.options.modelMatrix ||
        //   Cesium.Matrix4.multiplyByTranslation(
        //     Cesium.Transforms.eastNorthUpToFixedFrame(this.position),
        //     new Cesium.Cartesian3(0.0, 0.0, this.style.radii.z), //几何的x,y,z空间偏移
        //     new Cesium.Matrix4()
        //   ),
        attributes: this.options.attributes
      });
    }
  }]);

  return EllipsoidPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("ellipsoidP", EllipsoidPrimitive_EllipsoidPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/PolylinePrimitive.js







function PolylinePrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolylinePrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolylinePrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolylinePrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolylinePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = PolylinePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylinePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 线 Primitive图元 支持的样式信息
 *
 * @typedef {Object} PolylinePrimitive.StyleOptions
 *
 * @property {Number} [width = 4] 线宽
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Boolean} [randomColor = false] 是否随机颜色
 *
 * @property {Boolean} [closure = false] 是否闭合

 * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
 * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 *
 * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 * @property {PolylinePrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示 ，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 */

/**
 * 线 Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {PolylinePrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PolylinePrimitive_PolylinePrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(PolylinePrimitive, _BasePolyPrimitive);

  var _super = PolylinePrimitive_createSuper(PolylinePrimitive);

  function PolylinePrimitive() {
    classCallCheck_default()(this, PolylinePrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylinePrimitive, [{
    key: "_conversionStyle",
    value: //
    function _conversionStyle() {
      return PolylineStyleConver_PolylineStyleConver.toCesiumVal(this.style);
    } //子类需要继承实现

  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = addattr.clampToGround ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GroundPolylineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(PolylinePrimitive_objectSpread(PolylinePrimitive_objectSpread({}, addattr), {}, {
          positions: this.positions
        })),
        attributes: this.options.attributes
      });
    }
  }, {
    key: "_createAppearance",
    value: function _createAppearance(addattr, primitiveOpts) {
      //存在材质时
      if (addattr.material && !addattr.classification) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineMaterialAppearance"](PolylinePrimitive_objectSpread({}, addattr));
      } //纯色时


      primitiveOpts.geometryInstances.geometry.vertexFormat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineColorAppearance"].VERTEX_FORMAT;
      primitiveOpts.geometryInstances.attributes = primitiveOpts.geometryInstances.attributes || {};
      primitiveOpts.geometryInstances.attributes.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](addattr.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW));
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineColorAppearance"](PolylinePrimitive_objectSpread({}, addattr));
    }
  }]);

  return PolylinePrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("polylineP", PolylinePrimitive_PolylinePrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/WallPrimitive.js






function WallPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = WallPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WallPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 墙  Primitive图元 支持的样式信息
 *
 * @typedef {Object} WallPrimitive.StyleOptions
 *
 * @property {Number} [diffHeight = 100] 墙高
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定折线是投射还是接收来自光源的阴影。
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示 ，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 */

/**
 * 墙 Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {WallPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var WallPrimitive_WallPrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(WallPrimitive, _BasePolyPrimitive);

  var _super = WallPrimitive_createSuper(WallPrimitive);

  function WallPrimitive() {
    classCallCheck_default()(this, WallPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(WallPrimitive, [{
    key: "_createGeometryInstance",
    value: //子类需要继承实现
    function _createGeometryInstance(addattr, outline) {
      var _this$positions;

      var points = this.points;
      var len = points.length;
      var positions;
      var minimumHeights = new Array(len);
      var maximumHeights = new Array(len);

      for (var i = 0; i < len; i++) {
        var height = points[i].alt;
        minimumHeights[i] = height;
        maximumHeights[i] = height + Number(this.style.diffHeight || 100);
      }

      if (this.style.closure && ((_this$positions = this.positions) === null || _this$positions === void 0 ? void 0 : _this$positions.length) > 0) {
        positions = this.positions.concat(this.positions[0]);
        minimumHeights = minimumHeights.concat(minimumHeights[0]);
        maximumHeights = maximumHeights.concat(maximumHeights[0]);
      } else {
        positions = this.positions;
      }

      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WallOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WallGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass({
          positions: positions,
          maximumHeights: maximumHeights,
          minimumHeights: minimumHeights
        }),
        attributes: this.options.attributes
      });
    } //

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return WallStyleConver_WallStyleConver.toCesiumVal(this.style);
    }
  }]);

  return WallPrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("wallP", WallPrimitive_WallPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/CorridorPrimitive.js







function CorridorPrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CorridorPrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CorridorPrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CorridorPrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CorridorPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = CorridorPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CorridorPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 走廊  Primitive图元 支持的样式信息
 *
 * @typedef {Object} CorridorPrimitive.StyleOptions
 *
 *
 * @property {Number} [width = 100] 走廊宽度，指定走廊边缘之间的距离。
 * @property {String|Cesium.CornerType} [cornerType = "ROUNDED"] 指定边角的样式。String可选项：ROUNDED (解释：圆滑),MITERED (解释：斜接),BEVELED (解释：斜切),
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。

 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
 *
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 * 走廊  Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {CorridorPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var CorridorPrimitive_CorridorPrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(CorridorPrimitive, _BasePolyPrimitive);

  var _super = CorridorPrimitive_createSuper(CorridorPrimitive);

  function CorridorPrimitive() {
    classCallCheck_default()(this, CorridorPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(CorridorPrimitive, [{
    key: "_createGeometryInstance",
    value: //子类需要继承实现
    function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CorridorOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CorridorGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(CorridorPrimitive_objectSpread({
          positions: this.positions
        }, addattr)),
        attributes: this.options.attributes
      });
    } //

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return CorridorStyleConver_CorridorStyleConver.toCesiumVal(this.style);
    }
  }]);

  return CorridorPrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("corridorP", CorridorPrimitive_CorridorPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/PolylineVolumePrimitive.js







function PolylineVolumePrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolylineVolumePrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolylineVolumePrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolylineVolumePrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolylineVolumePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = PolylineVolumePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineVolumePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 *  管道线 Primitive图元 支持的样式信息
 *
 * @typedef {Object} PolylineVolumePrimitive.StyleOptions
 *
 * @property {String|Array<Cesium.Cartesian2>} [shape = "pipeline"] 形状类型 或 定义要挤压的形状。类型可选项：pipeline (解释：空心管),circle (解释：实心管),star (解释：星状管),
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Cesium.CornerType} [cornerType=CornerType.ROUNDED] 指定边角的样式。
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 * 管道线  Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {PolylineVolumePrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PolylineVolumePrimitive_PolylineVolumePrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(PolylineVolumePrimitive, _BasePolyPrimitive);

  var _super = PolylineVolumePrimitive_createSuper(PolylineVolumePrimitive);

  function PolylineVolumePrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, PolylineVolumePrimitive);

    _this = _super.call(this, options);
    _this.style.closed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.closed, true);
    return _this;
  } //子类需要继承实现


  createClass_default()(PolylineVolumePrimitive, [{
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineVolumeOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineVolumeGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(PolylineVolumePrimitive_objectSpread(PolylineVolumePrimitive_objectSpread({}, addattr), {}, {
          polylinePositions: this.positions,
          shapePositions: addattr.shape
        })),
        attributes: this.options.attributes
      });
    } //

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return PolylineVolumeStyleConver_PolylineVolumeStyleConver.toCesiumVal(this.style);
    }
  }]);

  return PolylineVolumePrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("polylineVolumeP", PolylineVolumePrimitive_PolylineVolumePrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/RectanglePrimitive.js







function RectanglePrimitive_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function RectanglePrimitive_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RectanglePrimitive_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RectanglePrimitive_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RectanglePrimitive_createSuper(Derived) { var hasNativeReflectConstruct = RectanglePrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RectanglePrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 矩形   Primitive图元 支持的样式信息
 *
 * @typedef {Object} RectanglePrimitive.StyleOptions
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {String} [image] 当为贴图时，贴图的url
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
 *
 * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
 * @property {Number} [stRotation = 0] 矩形纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 矩形纹理的角度（度数值，0-360度），与stRotation二选一
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
 *
 * @property {Number} [setHeight=0] 指定坐标高度值（常用于图层中配置）
 * @property {Number} [addHeight=0] 在现有坐标基础上增加的高度值（常用于图层中配置）
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
 *
 */

/**
 * 矩形  Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {RectanglePrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var RectanglePrimitive_RectanglePrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(RectanglePrimitive, _BasePolyPrimitive);

  var _super = RectanglePrimitive_createSuper(RectanglePrimitive);

  function RectanglePrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RectanglePrimitive);

    _this = _super.call(this, options);

    if (options.rectangle) {
      _this.rectangle = options.rectangle;
    }

    return _this;
  }
  /**
   * 坐标数据对应的矩形边界对象
   * @type {Cesium.Rectangle}
   */


  createClass_default()(RectanglePrimitive, [{
    key: "rectangle",
    get: function get() {
      if (!this._rectangle && this.positions) {
        this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
      }

      return this._rectangle;
    },
    set: function set(value) {
      this._rectangle = value; // if (this._primitive) {
      //   this.geometryInstanceAttributes.rectangle = value
      // }
    }
  }, {
    key: "outlinePositions",
    get: function get() {
      var arr = getRectangleOuterPositions({
        rectangle: this.rectangle,
        rotation: this.style.rotation,
        height: this.style.height
      });
      return arr;
    } //面积（单位：平方米）

  }, {
    key: "area",
    get: function get() {
      return getArea(this.outlinePositions);
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this.rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(this.positions);
    } //子类需要继承实现

  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RectangleGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(RectanglePrimitive_objectSpread({
          rectangle: this.rectangle
        }, addattr)),
        attributes: this.options.attributes
      });
    } //

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return RectangleStyleConver_RectangleStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Polygon",
        coordinates: [this.coordinates]
      };
    }
    /**
     * 判断点是否在矩形内
     *
     * @param {Cesium.Cartesian3|LatLngPoint} position 需要判断的点
     * @return {Boolean} 是否在矩形内
     */

  }, {
    key: "isInPoly",
    value: function isInPoly(position) {
      var isInRectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].contains(this.rectangle, LatLngPoint["a" /* LatLngPoint */].parse(position).toCartographic());
      return isInRectangle;
    }
  }]);

  return RectanglePrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("rectangleP", RectanglePrimitive_RectanglePrimitive);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/set.js
var helpers_set = __webpack_require__(63);
var set_default = /*#__PURE__*/__webpack_require__.n(helpers_set);

// CONCATENATED MODULE: ./src/graphic/primitive/PolygonPrimitive.js







function PolygonPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = PolygonPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolygonPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








var PolygonPrimitive_nullColor = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.01);
/**
 * 面   Primitive图元 支持的样式信息
 *
 * @typedef {Object} PolygonPrimitive.StyleOptions
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Boolean} [randomColor = false] 是否随机颜色
 * @property {String} [image] 当为贴图时，贴图的url
 *
 * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
 * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
 * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
 * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
 *
 * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE]  指定每个纬度点和经度点之间的角距离。
 * @property {Boolean | boolean} [closeTop=true]  当为false时，离开一个挤压多边形的顶部打开。
 * @property {Boolean | boolean} [closeBottom=true]  当为false时，离开挤压多边形的底部打开。
 * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  多边形的边缘必须遵循的线条类型。
 *
 * @property {Boolean} [hasShadows = false] 是否阴影
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
 *
 * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
 *
 * //以下是 这是MaterialAppearance的参数
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
 * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示 ，额外支持：
 * @property {String|LatLngPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
 * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
 *
 */

/**
 *  面  Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {PolygonPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PolygonPrimitive_PolygonPrimitive = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(PolygonPrimitive, _BasePolyPrimitive);

  var _super = PolygonPrimitive_createSuper(PolygonPrimitive);

  function PolygonPrimitive() {
    classCallCheck_default()(this, PolygonPrimitive);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolygonPrimitive, [{
    key: "center",
    get: //中心点坐标，覆盖父类
    function get() {
      return this.centerOfMass;
    }
    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(value) {
      if (!value) {
        return;
      } //判断是否为存在holes的面


      if (value.length > 0 && Array.isArray(value[0]) && value[0].length > 0 && Array.isArray(value[0][0]) && Object(Util["isNumber"])(value[0][0][0])) {
        this._hierarchy = getPolygonHierarchy(value);
        value = this._hierarchy.positions;
      }

      set_default()(getPrototypeOf_default()(PolygonPrimitive.prototype), "positions", value, this, true);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      if (this._hierarchy) {
        addattr.polygonHierarchy = this._hierarchy;
      } else {
        addattr.polygonHierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](this.positions);
      }

      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      });
    } //

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      var addattr = PolygonStyleConver_PolygonStyleConver.toCesiumVal(this.style);
      addattr = this._bindExType(addattr);
      return addattr;
    } //是特殊的面类型的处理

  }, {
    key: "_bindExType",
    value: function _bindExType(addattr) {
      //是建筑物时
      var buildings = this.options.buildings || this._layer.options.buildings;

      if (buildings) {
        if (buildings.bottomHeight) {
          var _bottomHeight = Number(this.attr[buildings.bottomHeight] || 0); //底部高度


          addattr.height = _bottomHeight;
        }

        var floor = Number(this.attr[buildings.cloumn] || 1); //层数

        var height; //层高

        if (Object(Util["isNumber"])(buildings.height)) {
          height = buildings.height;
        } else if (Object(Util["isString"])(buildings.height)) {
          height = this.attr[buildings.height] || height;
        } else {
          height = 3.5; //默认值
        }

        var bottomHeight = addattr.height || 0;
        addattr.extrudedHeight = bottomHeight + floor * height; //顶部高度
      } //是建筑物单体化时


      var dthCfg = this.options.dth || this._layer.options.dth;

      if (dthCfg) {
        if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](addattr.color)) {
          addattr.color = PolygonPrimitive_nullColor;
        }

        addattr.classification = true; // addattr.perPositionHeight = false

        addattr.zIndex = 99;
      } //如果是行政区域反选遮罩层


      var maskCfg = this.options.mask || this._layer.options.mask;

      if (maskCfg) {
        var extent = {
          xmin: 73.0,
          xmax: 136.0,
          ymin: 3.0,
          ymax: 59.0
        };

        if (Object(Util["isObject"])(maskCfg) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.xmin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.xmax) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.ymin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maskCfg.ymax)) {
          extent = maskCfg;
        }

        var outPositions = Object(PointTrans["lonlats2cartesians"])([[extent.xmin, extent.ymax], [extent.xmin, extent.ymin], [extent.xmax, extent.ymin], [extent.xmax, extent.ymax], [extent.xmin, extent.ymax]]);
        this._hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](outPositions, [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](this._positions)]);
      }

      return addattr;
    } //更新高度

  }, {
    key: "updateHeight",
    value: function updateHeight(height) {
      var eRadis = 6378137;

      for (var i = 0, len = this.primitiveCollection.length; i < len; i++) {
        var primitive = this.primitiveCollection.get(i);
        var n = (eRadis + height) / (eRadis + this.style.height);
        var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromScale(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](n, n, n));
        primitive.modelMatrix = modelMatrix;
      }
    } //转换style为可以导出的json

  }, {
    key: "_style2Json",
    value: function _style2Json(czmStyle, styleJson) {
      return PolygonStyleConver_PolygonStyleConver.toJSON(czmStyle, styleJson);
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Polygon",
        coordinates: [this.coordinates]
      };
    }
  }]);

  return PolygonPrimitive;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("polygonP", PolygonPrimitive_PolygonPrimitive);
// CONCATENATED MODULE: ./src/graphic/primitive/FrustumPrimitive.js






function FrustumPrimitive_createSuper(Derived) { var hasNativeReflectConstruct = FrustumPrimitive_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FrustumPrimitive_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 四棱锥体 支持的样式信息
 *
 * @typedef {Object} FrustumPrimitive.StyleOptions
 *
 * @property {Number} [angle] 四棱锥体张角（角度值，取值范围 0.01-89.99）
 * @property {Number} [angle2=angle] 四棱锥体张角2，（角度值，取值范围 0.01-89.99）
 *
 * @property {Number} [length = 100]   长度值（单位：米），没有指定targetPosition时有效
 * @property {Number} [heading = 0] 方向角 （度数值，0-360度），没有指定targetPosition时有效
 * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度），没有指定targetPosition时有效
 * @property {Number} [roll = 0] 翻滚角（度数值，0-360度），没有指定targetPosition时有效
 *
 * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
 * @property {*} [material材质参数] 根据具体{@link MaterialType}来确定
 * @property {Material} [material] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
 *
 * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
 * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
 *
 * @property {Boolean} [outline = false] 是否边框
 * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
 * @property {Number} [outlineOpacity = 0.6] 边框透明度
 *
 * @property {MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
 *
 * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
 * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
 * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
 * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
 * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
 * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
 * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
 *
 *
 * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
 */

/**
 * 四棱锥体  Primitive图元矢量对象
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 *  @param {LatLngPoint|Cesium.Cartesian3} [options.targetPosition] 追踪的目标位置
 *
 * @param {FrustumPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class FrustumPrimitive
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var FrustumPrimitive_FrustumPrimitive = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(FrustumPrimitive, _BasePointPrimitive);

  var _super = FrustumPrimitive_createSuper(FrustumPrimitive);

  function FrustumPrimitive() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FrustumPrimitive);

    _this = _super.call(this, options);

    if (options.targetPosition) {
      _this.targetPosition = options.targetPosition;
    }

    return _this;
  }
  /**
   * 圆锥追踪的目标(确定了方向和距离)
   * @type {Cesium.Cartesian3}
   */


  createClass_default()(FrustumPrimitive, [{
    key: "targetPosition",
    get: function get() {
      return this._targetPosition;
    },
    set: function set(value) {
      this._targetPoint = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._targetPosition = this._targetPoint.toCartesian();

      if (this.isAdded && this.show) {
        this._removedHook();

        this._addedHook();
      }
    }
    /**
     * 圆锥追踪的目标位置坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "targetPoint",
    get: function get() {
      return this._targetPoint;
    }
    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */

  }, {
    key: "angle",
    get: function get() {
      return this.style.angle;
    },
    set: function set(val) {
      this.style.angle = val;
    }
    /**
     * 夹角2，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */

  }, {
    key: "angle2",
    get: function get() {
      var _this$style$angle;

      return (_this$style$angle = this.style.angle2) !== null && _this$style$angle !== void 0 ? _this$style$angle : this.style.angle;
    },
    set: function set(val) {
      this.style.angle2 = val;
    }
    /**
     * 求当前位置射线与地球相交点
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "groundPosition",
    get: function get() {
      return Object(PointUtil["getRayEarthPosition"])(this.position, this._orientation);
    }
  }, {
    key: "updateModelMatrix",
    value: function updateModelMatrix() {} //覆盖父类
    //转换style

  }, {
    key: "_conversionStyle",
    value: function _conversionStyle() {
      return CylinderStyleConver_CylinderStyleConver.toCesiumVal(this.style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(addattr, outline) {
      this._update();

      var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FrustumOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FrustumGeometry"];
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new GeometryClass({
          origin: this.position,
          orientation: this._orientation,
          frustum: this._frustum
        }),
        attributes: this.options.attributes
      });
    }
  }, {
    key: "_update",
    value: function _update(time) {
      var position = Object(PointUtil["getPositionValue"])(this.position, time);

      if (!position) {
        this._cylinderPosition = undefined;
        return;
      }

      var targetPosition = Object(PointUtil["getPositionValue"])(this.targetPosition, time);

      if (targetPosition) {
        this._frustumFar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(position, targetPosition);
        var hpr = Object(PointUtil["getHeadingPitchRollForLine"])(position, targetPosition);
        this.heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(hpr.heading);
        this.pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(hpr.pitch);
        this.roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(hpr.roll);
        this._orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr);
      } else {
        this._frustumFar = -this.style.length;

        var _hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll));

        this._orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, _hpr);
      }

      this._frustum = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerspectiveFrustum"]({
        fov: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.angle * 2 || 0.01),
        //视场角
        aspectRatio: this.angle2 / this.angle,
        //视锥的宽度与高度的纵横比。
        near: 0.01,
        //近平面的距离。
        far: this._frustumFar //远平面的距离。

      });
    }
    /**
     * 获取射线向地面与地球的4个交点坐标
     *
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] 指定的时间值
     * @return {Cesium.Cartesian3[]} 坐标数组
     */

  }, {
    key: "getRayEarthPositions",
    value: function getRayEarthPositions(time) {
      var position = Object(PointUtil["getPositionValue"])(this.position, time);
      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.heading);
      var pitch1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch + this.angle2);
      var pitch2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.pitch - this.angle2);
      var roll1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll + this.angle);
      var roll2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.roll - this.angle);
      var pt1 = Object(PointUtil["getRayEarthPosition"])(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch1, roll1), true);
      var pt2 = Object(PointUtil["getRayEarthPosition"])(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch1, roll2), true);
      var pt3 = Object(PointUtil["getRayEarthPosition"])(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch2, roll2), true);
      var pt4 = Object(PointUtil["getRayEarthPosition"])(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch2, roll1), true);
      return [pt1, pt2, pt3, pt4];
    }
  }]);

  return FrustumPrimitive;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("frustum", FrustumPrimitive_FrustumPrimitive);
// CONCATENATED MODULE: ./src/graphic/combine/BaseCombine.js






function BaseCombine_createSuper(Derived) { var hasNativeReflectConstruct = BaseCombine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseCombine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 大数据合并渲染Primitive对象基类
 *
 * @export
 * @class BaseCombine
 * @extends {BasePrimitive}
 */

var BaseCombine_BaseCombine = /*#__PURE__*/function (_BasePrimitive) {
  inherits_default()(BaseCombine, _BasePrimitive);

  var _super = BaseCombine_createSuper(BaseCombine);

  function BaseCombine() {
    classCallCheck_default()(this, BaseCombine);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseCombine, [{
    key: "instances",
    get:
    /**
     * 数据集合数组
     * @type {Object[]}
     */
    function get() {
      return this.options.instances || [];
    },
    set: function set(val) {
      this.options.instances = val;

      this._updateDraw();
    }
    /**
     * 根据 pickId 获取对应绑定的数据据对象
     *
     * @param {String} pickId 单个对象的pickid
     * @return {Object} 对应绑定的数据对象
     */

  }, {
    key: "getPickedObject",
    value: function getPickedObject(pickId) {
      var arr = pickId.split("#");

      if (arr.length != 2) {
        return null;
      }

      var index = Number(arr[1]);
      return this.instances[index];
    }
  }, {
    key: "createPickId",
    value: function createPickId(id) {
      return this.uuid + "#" + id;
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(globeAttr, outline) {
      if (this.options.geometryInstances) {
        return this.options.geometryInstances;
      }

      var instances = [];
      var arr = this.options.instances || [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        item.id = this.createPickId(i);
        instances.push(item);
      }

      return instances;
    }
  }]);

  return BaseCombine;
}(BasePrimitive_BasePrimitive);
// CONCATENATED MODULE: ./src/graphic/combine/ModelCombine.js







function ModelCombine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ModelCombine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ModelCombine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ModelCombine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ModelCombine_createSuper(Derived) { var hasNativeReflectConstruct = ModelCombine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelCombine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * @typedef {Object} ModelCombine.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BasePrimitive.EventType} 通用 支持的父类的事件类型
 * @property {String} load 完成加载，执行所有内部处理后
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.load, function (event) {
 *   console.log('模型加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 大数据 gltf小模型集合 (合并渲染) Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {Cesium.Resource|String} [options.url] glTF模型的URI的字符串或资源属性。
 *
 * @param {Object[]} [options.instances] 集合信息数组，单个对象包括：
 * @param {LatLngPoint|Cesium.Cartesian3} options.instances.position 坐标位置
 * @param {ModelPrimitive.StyleOptions} [options.instances.style] 样式信息(目前仅支持方向和比例参数)
 * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
 *
 *
 * @param {Cesium3DTileBatchTable} [options.batchTable] 实例化的3D贴图的批处理表。
 *
 * @param {Object} [options.requestType] 请求类型，用于确定请求的优先级
 * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] 一个glTF JSON对象，或者一个二进制的glTF缓冲区。
 * @param {Cesium.Resource|String} [options.basePath=''] glTF JSON中路径相对的基本路径。
 * @param {Boolean} [options.dynamic=false] 提示实例模型矩阵是否会频繁更新。
 * @param {Boolean} [options.allowPicking=true] 当true时，每个glTF和Primitive都可以用{@link Cesium.Scene#pick}来拾取。
 * @param {Boolean} [options.asynchronous=true]  确定模型WebGL资源创建是否将分散在几个帧或块上，直到所有glTF文件加载完成。
 * @param {Boolean} [options.incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
 * @param {Cesium.ShadowMode} [options.shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
 * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] 指定来自基于图像的漫反射和镜面照明的贡献。
 * @param {Cartesian3} [options.lightColor] 光的颜色当遮光模型。当undefined场景的浅色被使用代替。
 * @param {Number} [options.luminanceAtZenith=0.2] 太阳在天顶的亮度，单位是千坎德拉每平方米，用于这个模型的程序环境地图。
 * @param {Cesium.Cartesian3[]} [options.sphericalHarmonicCoefficients] 三阶球面调和系数用于基于图像的漫射色彩照明。
 * @param {String} [options.specularEnvironmentMaps] 一个KTX文件的URL，该文件包含高光照明的立方体映射和复杂的高光mipmaps。
 * @param {Boolean} [options.backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;当为false时，禁用背面剔除。
 * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。查看模型的包围边界球。
 * @param {Boolean} [options.debugWireframe=false] 仅供调试。查看模型的三角网线框图。
 *
 *
 * //以下是 模型动画相关
 * @param {Cesium.JulianDate} [options.startTime] 场景时间开始播放动画。当undefined时，动画从下一帧开始。
 * @param {Number} [options.delay=0.0] 从startTime开始播放的延迟，以秒为单位。
 * @param {JulianDate} [options.stopTime] 场景时间停止播放动画。当这是undefined，动画播放它的整个持续时间。
 * @param {Boolean} [options.removeOnStop=false] 当true时，动画在停止播放后被删除。
 * @param {Number} [options.multiplier=1.0] 大于1.0的值增加动画播放的速度相对于场景时钟的速度;小于1.0会降低速度。
 * @param {Boolean} [options.reverse=false] 当true时，动画会反向播放。
 * @param {Cesium.ModelAnimationLoop} [options.loop=Cesium.ModelAnimationLoop.REPEAT] 决定动画是否循环以及如何循环。
 *
 * @export
 * @class ModelCombine
 * @extends {BaseCombine}
 *
 * @see [支持的事件类型]{@link ModelCombine.EventType}
 */

var ModelCombine_ModelCombine = /*#__PURE__*/function (_BaseCombine) {
  inherits_default()(ModelCombine, _BaseCombine);

  var _super = ModelCombine_createSuper(ModelCombine);

  function ModelCombine() {
    classCallCheck_default()(this, ModelCombine);

    return _super.apply(this, arguments);
  }

  createClass_default()(ModelCombine, [{
    key: "_addedHook",
    value:
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    function _addedHook() {
      var _this = this;

      var arr = this.instances;
      var instances = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var modelMatrix = this.getModelMatrix(item.position, item.style);
        instances.push({
          batchId: this.createPickId(i),
          modelMatrix: modelMatrix
        });
      }

      this._primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ModelInstanceCollection"](ModelCombine_objectSpread(ModelCombine_objectSpread({}, this.options), {}, {
        instances: instances
      })));

      this._primitive.readyPromise.then(function (collection) {
        collection.activeAnimations.addAll(ModelCombine_objectSpread({
          loop: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ModelAnimationLoop"].REPEAT
        }, _this.style));
        _this.loadOk = true;

        _this.fire(EventType.load, {
          drawtype: _this.type,
          model: collection,
          graphic: _this
        }, true);
      })["catch"](function (error) {
        Object(Log["logError"])("ModelCombine:模型加载出错", error);
      });
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(point, style) {
      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(style.heading || 0);
      var pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(style.pitch || 0);
      var roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(style.roll || 0);
      var position = LatLngPoint["a" /* LatLngPoint */].parse(point).toCartesian();
      var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollToFixedFrame(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](heading, pitch, roll));

      if (style.scale) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByUniformScale(modelMatrix, style.scale, modelMatrix);
      }

      return modelMatrix;
    }
  }]);

  return ModelCombine;
}(BaseCombine_BaseCombine); //注册下

Object(GraphicUtil["register"])("modelCombine", ModelCombine_ModelCombine);
// CONCATENATED MODULE: ./src/graphic/combine/PolygonCombine.js







function PolygonCombine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolygonCombine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolygonCombine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolygonCombine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolygonCombine_createSuper(Derived) { var hasNativeReflectConstruct = PolygonCombine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolygonCombine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 大数据面集合 (合并渲染) Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.instances.positions 坐标位置
 * @param {PolygonPrimitive.StyleOptions} [options.instances.style] 样式信息
 * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
 *
 * @param {PolygonPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
 *
 * @extends {BaseCombine}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PolygonCombine_PolygonCombine = /*#__PURE__*/function (_BaseCombine) {
  inherits_default()(PolygonCombine, _BaseCombine);

  var _super = PolygonCombine_createSuper(PolygonCombine);

  function PolygonCombine() {
    classCallCheck_default()(this, PolygonCombine);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolygonCombine, [{
    key: "style",
    get:
    /**
     * 样式信息
     * @type {Object}
     * @readonly
     */
    function get() {
      var _this$options$instanc;

      if (((_this$options$instanc = this.options.instances) === null || _this$options$instanc === void 0 ? void 0 : _this$options$instanc.length) > 0 && this.options.instances[0].style) {
        return PolygonCombine_objectSpread(PolygonCombine_objectSpread({}, this.options.style || {}), this.options.instances[0].style);
      }

      return this.options.style;
    },
    set: function set(style) {
      this.setStyle(style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(globeAttr, outline) {
      this._rectangle = null;
      this.translucent = false;
      var arr = this.options.instances || [];
      var instances = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        if (item instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]) {
          item.id = this.createPickId(i);
          instances.push(item);
        } else {
          var GeometryClass = outline ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonOutlineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"];

          var _hierarchy = void 0;

          var positions = void 0;

          if (item.positions.length > 0 && Array.isArray(item.positions[0]) && item.positions[0].length > 0 && Array.isArray(item.positions[0][0]) && Object(Util["isNumber"])(item.positions[0][0][0])) {
            _hierarchy = getPolygonHierarchy(item.positions);
            positions = _hierarchy.positions;
          } else {
            positions = LatLngArray_LatLngArray.toCartesians(item.positions);
            _hierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](positions);
          }

          var rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(positions);

          if (this._rectangle) {
            this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].union(rectangle, this._rectangle);
          } else {
            this._rectangle = rectangle;
          }

          var addattr = PolygonStyleConver_PolygonStyleConver.toCesiumVal(PolygonCombine_objectSpread(PolygonCombine_objectSpread({}, this.style), item.style || {}));
          addattr.polygonHierarchy = _hierarchy;

          if (!globeAttr.material) {
            addattr.vertexFormat = globeAttr.vertexFormat;
          }

          var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](outline ? addattr.outlineColor : addattr.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW.withAlpha(0.5));

          if (color.alpha != 1) {
            this.translucent = true;
          }

          var instance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
            id: this.createPickId(i),
            geometry: new GeometryClass(addattr),
            attributes: {
              color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(color)
            }
          });
          instances.push(instance);
        }
      }

      return instances;
    } //飞行定位至图层数据所在的视角

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (!this._map) {
        return;
      }

      this._map.flyToExtent(this._rectangle, options);

      return this;
    }
  }]);

  return PolygonCombine;
}(BaseCombine_BaseCombine); //注册下

Object(GraphicUtil["register"])("polygonCombine", PolygonCombine_PolygonCombine);
// CONCATENATED MODULE: ./src/graphic/combine/PolylineCombine.js







function PolylineCombine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function PolylineCombine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PolylineCombine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PolylineCombine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PolylineCombine_createSuper(Derived) { var hasNativeReflectConstruct = PolylineCombine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PolylineCombine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 大数据线集合 (合并渲染) Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {Object[]} [options.instances] 线信息 数组，单个对象包括：
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.instances.positions 坐标位置
 * @param {PolylinePrimitive.StyleOptions} [options.instances.style] 样式信息
 * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
 *
 * @param {PolylinePrimitive.StyleOptions} [options.style] 所有线的公共样式信息
 *
 * @extends {BaseCombine}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var PolylineCombine_PolylineCombine = /*#__PURE__*/function (_BaseCombine) {
  inherits_default()(PolylineCombine, _BaseCombine);

  var _super = PolylineCombine_createSuper(PolylineCombine);

  function PolylineCombine() {
    classCallCheck_default()(this, PolylineCombine);

    return _super.apply(this, arguments);
  }

  createClass_default()(PolylineCombine, [{
    key: "style",
    get:
    /**
     * 样式信息
     * @type {Object}
     * @readonly
     */
    function get() {
      var _this$options$instanc;

      if (((_this$options$instanc = this.options.instances) === null || _this$options$instanc === void 0 ? void 0 : _this$options$instanc.length) > 0 && this.options.instances[0].style) {
        return PolylineCombine_objectSpread(PolylineCombine_objectSpread({}, this.options.style || {}), this.options.instances[0].style);
      }

      return this.options.style;
    },
    set: function set(style) {
      this.setStyle(style);
    }
  }, {
    key: "_createGeometryInstance",
    value: function _createGeometryInstance(globeAttr, outline) {
      this._rectangle = null;
      var arr = this.options.instances || [];
      var instances = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        if (item instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]) {
          item.id = this.createPickId(i);
          instances.push(item);
        } else {
          var positions = LatLngArray_LatLngArray.toCartesians(item.positions);
          var rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartesianArray(positions);

          if (this._rectangle) {
            this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].union(rectangle, this._rectangle);
          } else {
            this._rectangle = rectangle;
          }

          var addattr = PolylineStyleConver_PolylineStyleConver.toCesiumVal(PolylineCombine_objectSpread(PolylineCombine_objectSpread({}, this.style), item.style || {}));
          addattr.positions = positions;

          if (!addattr.material) {
            addattr.vertexFormat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineColorAppearance"].VERTEX_FORMAT;
          }

          var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](addattr.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].YELLOW.withAlpha(0.5));
          var GeometryClass = addattr.clampToGround ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GroundPolylineGeometry"] : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineGeometry"];
          var instance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
            id: this.createPickId(i),
            geometry: new GeometryClass(addattr),
            attributes: {
              color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(color)
            }
          });
          instances.push(instance);
        }
      }

      return instances;
    }
  }, {
    key: "_createAppearance",
    value: function _createAppearance(addattr, primitiveOpts) {
      //存在材质时
      if (addattr.material && !addattr.classification) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineMaterialAppearance"](PolylineCombine_objectSpread({}, addattr));
      } //纯色时


      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineColorAppearance"](PolylineCombine_objectSpread({}, addattr));
    } //飞行定位至图层数据所在的视角

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (!this._map) {
        return;
      }

      this._map.flyToExtent(this._rectangle, options);

      return this;
    }
  }]);

  return PolylineCombine;
}(BaseCombine_BaseCombine); //注册下

Object(GraphicUtil["register"])("polylineCombine", PolylineCombine_PolylineCombine);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(20);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./src/shaders/FlatBillboardFS.glsl
var FlatBillboardFS = __webpack_require__(33);
var FlatBillboardFS_default = /*#__PURE__*/__webpack_require__.n(FlatBillboardFS);

// EXTERNAL MODULE: ./src/shaders/FlatBillboardVS.glsl
var FlatBillboardVS = __webpack_require__(34);
var FlatBillboardVS_default = /*#__PURE__*/__webpack_require__.n(FlatBillboardVS);

// CONCATENATED MODULE: ./src/graphic/combine/FlatBillboard.js








function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function FlatBillboard_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function FlatBillboard_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FlatBillboard_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FlatBillboard_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function FlatBillboard_createSuper(Derived) { var hasNativeReflectConstruct = FlatBillboard_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FlatBillboard_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var FlatBillboard_DEF_STYLE = {
  width: 50
};
/**
 * 平放的图标 单个数据对象
 *
 * @typedef {Object} FlatBillboard.DataOptions
 *
 * @property {String} image 图标URL
 * @property {Cesium.Cartesian3} position 位置坐标
 * @property {Number} [angle=0] 图标的角度（角度值，0-360）
 *
 */

/**
 * 平放的图标 数据集合 (多个图标一起合并渲染)
 *
 * @param {Object} options 参数对象，包括以下：
 *
 * @param {FlatBillboard.DataOptions[]} options.instances 数据集合数组
 * @param {Object}options.style 样式信息
 * @param {Number} [options.style.width = 50] 图标宽度
 * @param {Number} [options.style.height = width] 图标高度
 * @param {Cesium.DistanceDisplayCondition} [options.style.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(0, 5000000)] 指定数据将显示在与摄像机的多大距离
 *
 * @param {Number} [options.scale3d=0.8] 二维和三维模式切换后图标的缩放比例。因为二三维模式使用不同渲染方式，可能存在大小偏差，可以该参数调优。
 *
 * @export
 * @class FlatBillboard
 * @extends {BaseCombine}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var FlatBillboard_FlatBillboard = /*#__PURE__*/function (_BaseCombine) {
  inherits_default()(FlatBillboard, _BaseCombine);

  var _super = FlatBillboard_createSuper(FlatBillboard);

  function FlatBillboard() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FlatBillboard);

    options.style = FlatBillboard_objectSpread(FlatBillboard_objectSpread({}, FlatBillboard_DEF_STYLE), options.style || {});
    _this = _super.call(this, options);
    _this.distanceDisplayCondition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.style.distanceDisplayCondition, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayCondition"](0, 5000000));
    _this.scale3d = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.scale3d, 0.8);
    return _this;
  } //========== 对外属性 ==========


  createClass_default()(FlatBillboard, [{
    key: "billboardCollection",
    get: function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.billboardCollection;
    }
    /**
     * 数据集合数组
     * @type {FlatBillboard.DataOptions[]}
     */

  }, {
    key: "instances",
    get: function get() {
      return this.options.instances;
    },
    set: function set(val) {
      this.options.instances = val;

      this._updateDraw();
    }
    /**
     * 指定数据将显示在与摄像机的多大距离
     * @type {Cesium.DistanceDisplayCondition}
     */

  }, {
    key: "distanceDisplayCondition",
    get: function get() {
      return this._distanceDisplayCondition;
    },
    set: function set(val) {
      this._distanceDisplayCondition = val;
      this._distanceDisplayConditionCartesian2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](val.near, val.far);
    } //========== 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this.textures = {};
      this.textureDef = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: this._map.scene.context,
        width: 500,
        height: 500
      }); // this._pickId = this._map.scene.context.createPickId({
      //   id: 'FlatBillboard',
      //   primitive: this,
      // })

      this.pickCommands = [];

      if (this.options.instances) {
        this.instances = this.options.instances;
      } //切换场景后事件


      this._map.on(EventType.morphComplete, this._onMorphComplete, this);

      this.primitiveCollection.add(this);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      //切换场景后事件
      this._map.off(EventType.morphComplete, this._onMorphComplete, this);

      this.clear();
      this.textureDef.destroy();
      this.primitiveCollection.remove(this);
    }
    /**
     * 清除数据
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this.billboardCollection) {
        this.billboardCollection.removeAll();
      }

      this._removeCollectionBy3D();
    } //渲染数据

  }, {
    key: "_updateDraw",
    value: function _updateDraw() {
      if (!this._map) {
        return;
      }

      this.clear();

      if (this._map.scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        this._initCollectionBy3D();
      } else {
        this._initCollectionBy2D();
      }
    }
  }, {
    key: "_onMorphComplete",
    value: function _onMorphComplete(e) {
      this._updateDraw();
    }
  }, {
    key: "update",
    value: function update(frameState) {
      if (!this._map) {
        return;
      }

      if (!this.show) {
        if (this.billboardCollection) {
          this.billboardCollection.removeAll();
        }

        return;
      } //三维模式下


      var commandList = frameState.commandList;

      if (frameState.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        if (frameState.passes.render) {
          if (commandList && this.commands) {
            commandList.push.apply(commandList, toConsumableArray_default()(this.commands));
          }
        } else {
          if (commandList && this.pickCommands) {
            commandList.push.apply(commandList, toConsumableArray_default()(this.pickCommands));
          }
        }
      } else {
        if (!this.billboardCollection) {
          this._initCollectionBy2D();
        }
      }
    } //二维模式下的处理

  }, {
    key: "_initCollectionBy2D",
    value: function _initCollectionBy2D() {
      var arrdata = this.instances;

      if (!arrdata) {
        return;
      }

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];
        var billboard = this.billboardCollection.add({
          position: item.position,
          image: item.image,
          rotation: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(item.angle || 0),
          scale: 1,
          width: this.style.width,
          height: this.style.height || this.style.width
        });
        this.bindPickId(billboard);
      }
    } //三维模式下的处理

  }, {
    key: "_initCollectionBy3D",
    value: function _initCollectionBy3D() {
      var arrdata = this.instances;

      if (!arrdata) {
        return;
      } //按图片分组


      var imaObj = {};

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];
        item.index = i;

        if (!imaObj[item.image]) {
          imaObj[item.image] = [];
        }

        imaObj[item.image].push(item);
      }

      var commands = [];

      for (var key in imaObj) {
        var arr = imaObj[key];
        var image = key; //加载图片

        this.prepareTexture(image); //生成Command

        var _iterator = _createForOfIteratorHelper(arr),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var point = _step.value;
            var VAO = this.prepareVAO([point]);
            var command = this.prepareCommand(VAO, image, point);
            commands.push(command);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      this.commands = commands;
    }
  }, {
    key: "_removeCollectionBy3D",
    value: function _removeCollectionBy3D() {
      if (this.commands) {
        delete this.commands;
      }

      if (this.pickCommands) {
        this.pickCommands = [];
      }

      for (var key in this.textures) {
        if (this.textures[key]) {
          this.textures[key].destroy();
        }
      }

      this.textures = {};
    }
  }, {
    key: "prepareTexture",
    value: function prepareTexture(imgUrl) {
      var _this2 = this;

      var image = new Image();

      image.onload = function (e) {
        var texture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
          context: _this2._map.scene.context,
          source: image
        });
        _this2.textures[imgUrl] = texture;
      };

      image.src = imgUrl;
    }
  }, {
    key: "prepareVAO",
    value: function prepareVAO(points) {
      var vertexs_H = [];
      var vertexs_L = [];
      var indexs = [];
      var uvs = [];
      var colors = [];

      for (var i = 0, len = points.length; i < len; i++) {
        var currP = points[i];
        var currCar = currP.position;
        var angle = currP.angle || 0;
        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 2);
        indexs.push(i * 4 + 1);
        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 3);
        indexs.push(i * 4 + 2); // 伪造双精度数据

        var currDF = new Float32Array(6);
        currDF[0] = currCar.x;
        currDF[1] = currCar.x - currDF[0];
        currDF[2] = currCar.y;
        currDF[3] = currCar.y - currDF[2];
        currDF[4] = currCar.z;
        currDF[5] = currCar.z - currDF[4];
        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);
        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);
        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);
        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);
        uvs.push(0, 0);
        uvs.push(0, 1);
        uvs.push(1, 1);
        uvs.push(1, 0);
        var trans = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(currCar);
        var mz = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(angle));
        var rotationZ = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(mz);
        var currMat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(trans, rotationZ, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
        var heightScale = this.style.height ? this.style.height / this.style.width : 1;
        var zxj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-1, -heightScale, 0);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(currMat, zxj, zxj);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(zxj, zxj);
        colors.push(zxj.x, zxj.y, zxj.z);
        var zsj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-1, heightScale, 0);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(currMat, zsj, zsj);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(zsj, zsj);
        colors.push(zsj.x, zsj.y, zsj.z);
        var ysj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](1, heightScale, 0);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(currMat, ysj, ysj);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(ysj, ysj);
        colors.push(ysj.x, ysj.y, ysj.z);
        var yxj = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](1, -heightScale, 0);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(currMat, yxj, yxj);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(yxj, yxj);
        colors.push(yxj.x, yxj.y, yxj.z);
      }

      return {
        index: new Uint16Array(indexs),
        vertex_H: {
          values: new Float32Array(vertexs_H),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        vertex_L: {
          values: new Float32Array(vertexs_L),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        uv: {
          values: new Float32Array(uvs),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 2
        },
        color: {
          values: new Float32Array(colors),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 3
        }
      };
    }
  }, {
    key: "prepareCommand",
    value: function prepareCommand(VAO, imgUrl, item) {
      var context = this._map.scene.context;
      var width = context.drawingBufferWidth;
      var height = context.drawingBufferHeight;
      var sp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"].fromCache({
        context: context,
        vertexShaderSource: FlatBillboardVS_default.a,
        fragmentShaderSource: FlatBillboardFS_default.a,
        attributeLocations: {
          position3DHigh: 0,
          position3DLow: 1,
          color: 2,
          st: 3
        }
      });
      var indexBuffer = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"].createIndexBuffer({
        context: context,
        typedArray: VAO.index,
        usage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW,
        indexDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["IndexDatatype"].UNSIGNED_SHORT
      });
      var va = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexArray"]({
        context: context,
        attributes: [{
          index: 0,
          vertexBuffer: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"].createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_H.values,
            usage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 1,
          vertexBuffer: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"].createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_L.values,
            usage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 2,
          vertexBuffer: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"].createVertexBuffer({
            context: context,
            typedArray: VAO.color.values,
            usage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 3,
          vertexBuffer: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Buffer"].createVertexBuffer({
            context: context,
            typedArray: VAO.uv.values,
            usage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW
          }),
          componentsPerAttribute: 2
        }],
        indexBuffer: indexBuffer
      });
      var rs = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"].fromCache();
      var that = this;
      var bs = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromVertices(VAO.vertex_H.values);
      bs.radius = 1000000; // rs.depthMask = true;

      var command = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"]({
        primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
        shaderProgram: sp,
        vertexArray: va,
        modelMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY,
        pickOnly: true,
        renderState: rs,
        boundingVolume: bs,
        uniformMap: {
          mm: function mm() {
            // return that._map.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;
            if (that._map.scene.camera.frustum._offCenterFrustum) {
              return that._map.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;
            } else {
              return that._map.scene.camera.frustum._orthographicMatrix;
            }
          },
          vv: function vv() {
            return that._map.scene.camera._viewMatrix;
          },
          resolution: function resolution() {
            return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](width, height);
          },
          billWidth: function billWidth() {
            return that.style.width * that.scale3d * 2;
          },
          billImg: function billImg() {
            return that.textures[imgUrl] || that.textureDef;
          },
          u_distanceDisplayCondition: function u_distanceDisplayCondition() {
            return that._distanceDisplayConditionCartesian2;
          },
          u_eyePos: function u_eyePos() {
            return that._map.scene.camera.positionWC;
          }
        },
        castShadows: false,
        receiveShadows: false,
        pass: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Pass"].TRANSLUCENT,
        pickCommand: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"]({
          owner: this,
          pickOnly: true
        })
      }); // command.data = item

      this.bindPickId(command);
      var pickCommand = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"]({
        owner: command,
        primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
        pickOnly: true
      });
      pickCommand.vertexArray = va;
      pickCommand.renderState = rs;
      var sp1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"].fromCache({
        context: context,
        vertexShaderSource: FlatBillboardVS_default.a,
        fragmentShaderSource: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderSource"].createPickFragmentShaderSource(FlatBillboardFS_default.a, "uniform"),
        attributeLocations: {
          position3DHigh: 0,
          position3DLow: 1,
          color: 2,
          st: 3
        }
      });
      command.pickId = context.createPickId({
        primitive: command,
        id: this.createPickId(item.index)
      });
      pickCommand.shaderProgram = sp1;
      pickCommand.uniformMap = command.uniformMap;

      pickCommand.uniformMap.czm_pickColor = function () {
        return command.pickId.color;
      };

      pickCommand.pass = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Pass"].TRANSLUCENT;
      pickCommand.boundingVolume = bs;
      pickCommand.modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY;
      this.pickCommands.push(pickCommand);
      return command;
    }
  }]);

  return FlatBillboard;
}(BaseCombine_BaseCombine); //注册下

Object(GraphicUtil["register"])("flatBillboard", FlatBillboard_FlatBillboard);
// EXTERNAL MODULE: ./src/shaders/Materials/ConeGlowCircleOuterMaterial.glsl
var ConeGlowCircleOuterMaterial = __webpack_require__(64);
var ConeGlowCircleOuterMaterial_default = /*#__PURE__*/__webpack_require__.n(ConeGlowCircleOuterMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ConeGlowCylinderGaussMaterial.glsl
var ConeGlowCylinderGaussMaterial = __webpack_require__(65);
var ConeGlowCylinderGaussMaterial_default = /*#__PURE__*/__webpack_require__.n(ConeGlowCylinderGaussMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ConeGlowGradientMaterial.glsl
var ConeGlowGradientMaterial = __webpack_require__(66);
var ConeGlowGradientMaterial_default = /*#__PURE__*/__webpack_require__.n(ConeGlowGradientMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ConeGlowRingScanMaterial.glsl
var ConeGlowRingScanMaterial = __webpack_require__(67);
var ConeGlowRingScanMaterial_default = /*#__PURE__*/__webpack_require__.n(ConeGlowRingScanMaterial);

// CONCATENATED MODULE: ./src/graphic/primitive/LightCone.js







function LightCone_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function LightCone_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LightCone_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LightCone_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function LightCone_createSuper(Derived) { var hasNativeReflectConstruct = LightCone_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LightCone_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










var LightCone_DEF_STYLE = {
  height: 1000,
  radius: 100,
  color: "#00ffff"
}; //粒子图对象

var particleImage = new Image();
particleImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";

particleImage.onload = function () {// console.log('加载particleImage成功')
};
/**
 * 光锥体 支持的样式信息
 *
 * @typedef {Object} LightCone.StyleOptions
 *
 * @property {String|Cesium.Color} [color = '#00ffff'] 颜色
 * @property {Number} [radius = 100] 锥体底部半径。(单位：米)
 * @property {Number} [height = 1000] 锥体高度，相对于椭球面的高度。(单位：米)
 *
 */

/**
 * 光锥体
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {LightCone.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class LightCone
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */


var LightCone_LightCone = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(LightCone, _BasePointPrimitive);

  var _super = LightCone_createSuper(LightCone);

  function LightCone() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LightCone);

    options.style = LightCone_objectSpread(LightCone_objectSpread({}, LightCone_DEF_STYLE), options.style || {});
    _this = _super.call(this, options);
    _this.primitive1 = null; //外圈

    _this.primitive2 = null; //内圈

    _this.primitive3 = null; //底部圆

    _this.primitive4 = null; //底部放大圆环

    _this._color = Object(Util["getColorByStyle"])(_this.style);
    return _this;
  } //========== 对外属性 ==========


  createClass_default()(LightCone, [{
    key: "czmObject",
    get: function get() {
      return this.primitive1;
    } //文本等附加对象

  }, {
    key: "czmObjectEx",
    get: function get() {
      return [this.primitive2, this.primitive3, this.primitive4];
    }
    /**
     * 颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(val) {
      this.style.color = val;
      this._color = Object(Util["getColorByStyle"])(this.style);
    } //========== 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var radius = this.style.radius; //计算其他参数

      this.topRadius = radius / 100.0;
      this.topRadius = this.topRadius > 1.0 ? 1.0 : this.topRadius;
      this.inner_controlPoints = getCirclePosition(this.position, radius * 0.7);
      this.outer_controlPoints = getCirclePosition(this.position, radius); //计算底部外圈

      this.circular_clone_topPoints = getCirclePosition(this.position, this.topRadius); //计算顶部

      this.circlePoints_2 = getCirclePosition(this.position, radius * 2); //计算顶部

      this.ringCanvas = this.drawRingCanvas();
      this.gradientCircleCanvas = this.cirdrawGradientCircleCanvas();
      this.image = this.drawCanvas(particleImage);
      this.addInner(); //内圈

      this.addOuter(); //外圈

      this.addCircle(); //底部圆

      this.addRing(); //底部放大钰圆环
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this.primitive1) {
        this.primitiveCollection.remove(this.primitive1);
        delete this.primitive1;
      }

      if (this.primitive2) {
        this.primitiveCollection.remove(this.primitive2);
        delete this.primitive2;
      }

      if (this.primitive3) {
        this.primitiveCollection.remove(this.primitive3);
        delete this.primitive3;
      }

      if (this.primitive4) {
        this.primitiveCollection.remove(this.primitive4);
        delete this.primitive4;
      }
    } //添加绘制内圈圆柱闪烁效果

  }, {
    key: "addInner",
    value: function addInner() {
      var side_instances = createCylinderInstance(this.inner_controlPoints, this.circular_clone_topPoints, {
        height: this.style.height,
        color: this.color,
        distanceDisplayCondition: this.style.distanceDisplayCondition
      });
      var a = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidSurfaceAppearance"]({
        material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
          fabric: {
            uniforms: {
              u_color: this._color
            },
            source: ConeGlowCylinderGaussMaterial_default.a
          },
          translucent: function translucent(material) {
            return material.uniforms.u_color.alpha < 1.0;
          }
        })
      });
      this.primitive1 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: side_instances,
        appearance: a,
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this.primitive1);
    } //添加绘制外圈粒子效果

  }, {
    key: "addOuter",
    value: function addOuter() {
      var side_instances = createCylinderInstance(this.outer_controlPoints, this.circular_clone_topPoints, {
        height: this.style.height,
        distanceDisplayCondition: this.style.distanceDisplayCondition,
        color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.5, 0.8, 1.0, 2)
      });
      this.primitive2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: side_instances,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidSurfaceAppearance"]({
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.image
              },
              source: ConeGlowCircleOuterMaterial_default.a
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this.primitive2);
    } //绘制底部圆

  }, {
    key: "addCircle",
    value: function addCircle() {
      var carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this.position);
      var instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: carto.height >= 1,
        distanceDisplayCondition: this.style.distanceDisplayCondition
      });
      this.primitive3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: instance,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidSurfaceAppearance"]({
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.gradientCircleCanvas
              },
              source: ConeGlowGradientMaterial_default.a
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this.primitive3);
    } //添加绘制底部扩散圆环

  }, {
    key: "addRing",
    value: function addRing() {
      var instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: this.point.alt >= 1,
        distanceDisplayCondition: this.style.distanceDisplayCondition
      });
      this.primitive4 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: instance,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidSurfaceAppearance"]({
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.ringCanvas
              },
              source: ConeGlowRingScanMaterial_default.a
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this.primitive4);
    } //================材质贴图Canvas ====================
    //画粒子图

  }, {
    key: "getParticleImage",
    value: function getParticleImage(callback) {
      var image = new Image();
      image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";

      image.onload = function () {
        if (callback) {
          callback();
        }
      };
    }
  }, {
    key: "drawCanvas",
    value: function drawCanvas(image) {
      var canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 256;
      var ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 64, 256);
      ctx.drawImage(image, 0, 0);
      ctx.drawImage(image, 33, 0);
      return canvas;
    } //画圆环图

  }, {
    key: "drawRingCanvas",
    value: function drawRingCanvas() {
      var canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      var ctx = canvas.getContext("2d"); //ctx.clearRect(0,0,512,512);

      ctx.fillStyle = "rgba(255,255,255,0)";
      ctx.strokeStyle = "rgba(255, 255, 255,255)";
      ctx.setLineDash([50, 50]);
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.arc(256, 256, 150, 0, Math.PI * 2, true);
      ctx.stroke();
      ctx.restore();
      return canvas;
    } //画渐变圆

  }, {
    key: "cirdrawGradientCircleCanvas",
    value: function cirdrawGradientCircleCanvas() {
      var canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      var ctx = canvas.getContext("2d");
      var gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      gradient.addColorStop(0.1, "rgba(255, 255, 255, 1.0)");
      gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.3, "rgba(255, 255, 255, 0.9)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.9, "rgba(255, 255, 255, 0.2)");
      gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");
      ctx.clearRect(0, 0, 512, 512);
      ctx.beginPath();
      ctx.arc(256, 256, 256, 0, Math.PI * 2, true);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
      return canvas;
    }
  }]);

  return LightCone;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("lightCone", LightCone_LightCone); //创建 圆 效果

function createCircleInstance(pos, options) {
  var polygon = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"]({
    polygonHierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](pos),
    perPositionHeight: options.perPositionHeight
  });
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
    geometry: polygon,
    attributes: {
      distanceDisplayCondition: options.distanceDisplayCondition || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayConditionGeometryInstanceAttribute"]()
    }
  });
} //创建 圆锥柱体 效果


function createCylinderInstance(pts, topPts, options) {
  var height = options.height,
      color = options.color;
  var newpts = pts.slice();
  var length = pts.length;
  var len_2 = 2 * length;
  var sts = [];
  var st_interval = 1.0 / (length - 1);
  var define_indices = [];
  var ep = [];

  for (var i = 0; i < length; i++) {
    ep.push(Object(PointUtil["addPositionsHeight"])(topPts[i], height));
    sts.push(i * st_interval);
    sts.push(0);
    var i_1 = i + 1;
    var i_11 = (i + 1) % length;
    var len_2_i_1 = len_2 - i_1;
    define_indices.push.apply(define_indices, [len_2_i_1 - 1, len_2_i_1, i]); //用materialAppearance贴纹理正确

    define_indices.push.apply(define_indices, [i, i_11, len_2_i_1 - 1]);
  }

  for (var _i = 0; _i < ep.length; _i++) {
    newpts.push(ep[length - _i - 1]);
    sts.push(1 - _i * st_interval);
    sts.push(1);
  }

  var polygon = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"]({
    polygonHierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](newpts),
    perPositionHeight: true
  });
  polygon = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].createGeometry(polygon);
  polygon.indices = define_indices;
  polygon.attributes.st.values = sts;
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
    geometry: polygon,
    attributes: {
      color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(color),
      distanceDisplayCondition: options.distanceDisplayCondition || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DistanceDisplayConditionGeometryInstanceAttribute"]()
    }
  });
} //计算圆坐标


function getCirclePosition(center, radius) {
  var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120;
  var res = [];
  var mm = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(center);
  var interval = 2 * Math.PI / length;
  var startPos = 2 * Math.PI * 270 / 360;

  for (var i = 0; i < length; i++) {
    var a = startPos - interval * i;
    var p = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](Math.sin(a) * radius, Math.cos(a) * radius, 0);
    res.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(mm, p, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()));
  }

  res.push(res[0]);
  return res;
}
// CONCATENATED MODULE: ./src/graphic/primitive/Water.js






function Water_createSuper(Derived) { var hasNativeReflectConstruct = Water_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Water_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 水域面 Primitive图元 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {PolygonPrimitive.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class Water
 * @extends {PolygonPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var Water_Water = /*#__PURE__*/function (_PolygonPrimitive) {
  inherits_default()(Water, _PolygonPrimitive);

  var _super = Water_createSuper(Water);

  function Water() {
    classCallCheck_default()(this, Water);

    return _super.apply(this, arguments);
  }

  createClass_default()(Water, [{
    key: "_addedHook",
    value:
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    function _addedHook() {
      var addattr = this._conversionStyle();

      var primitiveOpts = {
        geometryInstances: this._createGeometryInstance(addattr),
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidSurfaceAppearance"]({
          aboveGround: false,
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            fabric: {
              type: "Water",
              uniforms: {
                normalMap: addattr.normalMap,
                //水正常扰动的法线图。
                frequency: addattr.frequency || 8000.0,
                //控制波数的数字。
                animationSpeed: addattr.animationSpeed || 0.03,
                //控制水的动画速度的数字。
                amplitude: addattr.amplitude || 5.0,
                //控制水波振幅的数字。
                specularIntensity: this.style.specularIntensity || 0.8,
                //控制镜面反射强度的数字。
                baseWaterColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(this.style.baseWaterColor || "#123e59"),
                //rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
                blendColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(this.style.blendColor || "#123e59") //从水中混合到非水域时使用的rgba颜色对象。

              }
            }
          }),
          fragmentShaderSource: Water.getWaterShader(this.style.opacity)
        }),
        show: this.show
      };

      if (this.style.clampToGround) {
        primitiveOpts.classificationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.classificationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClassificationType"].TERRAIN);
        this._primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GroundPrimitive"](primitiveOpts));
      } else {
        this._primitive = this.primitiveCollection.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"](primitiveOpts));
      } //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    } // 水面shader

  }], [{
    key: "getWaterShader",
    value: function getWaterShader(opacity) {
      opacity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](opacity, 0.5);
      return "\n      varying vec3 v_positionMC;\n      varying vec3 v_positionEC;\n      varying vec2 v_st;\n\n      void main()\n      {\n          czm_materialInput materialInput;\n          vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n          #ifdef FACE_FORWARD\n              normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n          #endif\n              materialInput.s = v_st.s;\n              materialInput.st = v_st;\n              materialInput.str = vec3(v_st, 0.0);\n              materialInput.normalEC = normalEC;\n              materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n              vec3 positionToEyeEC = -v_positionEC;\n              materialInput.positionToEyeEC = positionToEyeEC;\n              czm_material material = czm_getMaterial(materialInput);\n          #ifdef FLAT\n              gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n          #else\n              gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n              gl_FragColor.a = ".concat(opacity, ";\n          #endif\n      }");
    }
  }]);

  return Water;
}(PolygonPrimitive_PolygonPrimitive); //注册下

Object(GraphicUtil["register"])("water", Water_Water);
// EXTERNAL MODULE: ./src/shaders/DiffuseWallGlowVS.glsl
var DiffuseWallGlowVS = __webpack_require__(68);
var DiffuseWallGlowVS_default = /*#__PURE__*/__webpack_require__.n(DiffuseWallGlowVS);

// EXTERNAL MODULE: ./src/shaders/DiffuseWallGlowFS.glsl
var DiffuseWallGlowFS = __webpack_require__(69);
var DiffuseWallGlowFS_default = /*#__PURE__*/__webpack_require__.n(DiffuseWallGlowFS);

// CONCATENATED MODULE: ./src/graphic/primitive/DiffuseWall.js







function DiffuseWall_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DiffuseWall_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DiffuseWall_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DiffuseWall_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DiffuseWall_createSuper(Derived) { var hasNativeReflectConstruct = DiffuseWall_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DiffuseWall_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










var DiffuseWall_DEF_STYLE = {
  diffHeight: 1000,
  speed: 10
};
/**
 *  立体面(或圆)散射效果  支持的样式信息
 *
 * @typedef {Object} DiffuseWall.StyleOptions
 *
 * @property {Number} [diffHeight = 100] 墙高
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 * @property {Number} [speed = 10] 扩散的速度，值越大越快
 *
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 *
 */

/**
 * 立体面(或圆)散射效果 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置数组（多边形时）
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置数组（圆形时），与positions二选一
 * @param {DiffuseWall.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var DiffuseWall_DiffuseWall = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(DiffuseWall, _BasePolyPrimitive);

  var _super = DiffuseWall_createSuper(DiffuseWall);

  function DiffuseWall() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DiffuseWall);

    options.style = DiffuseWall_objectSpread(DiffuseWall_objectSpread({}, DiffuseWall_DEF_STYLE), options.style || {});
    _this = _super.call(this, options);

    if (options.positions) {
      //多边形时
      _this.center = _this.centerOfMass;
    } else {
      //圆形时
      _this.center = LatLngPoint["a" /* LatLngPoint */].parse(options.position).toCartesian();
      _this.positions = getEllipseOuterPositions({
        position: _this.center,
        radius: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.radius, 100),
        //半径
        count: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.count, 50) //共返回(count*4)个点

      });
    } //内部变量


    _this._mScale = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromUniformScale(1.0);
    _this._xyScale = 2;
    return _this;
  } //========== 对外属性 ==========


  createClass_default()(DiffuseWall, [{
    key: "czmObject",
    get: function get() {
      return this._primitive;
    } //中心点坐标，覆盖父类

  }, {
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(value) {
      this._center = value;
    } //========== 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var cps = this.positions;
      var up = Object(PointUtil["addPositionsHeight"])(this.positions, this.style.diffHeight); //计算位置

      var pos = []; //坐标

      var sts = []; //纹理

      var indices = []; //索引

      var normal = []; //法向量

      for (var i = 0, count = cps.length; i < count; i++) {
        var ni = (i + 1) % count;
        pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
        pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
        pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

        var ii = i * 4;
        var i1 = ii + 1;
        var i2 = ii + 2;
        var i3 = ii + 3;
        indices.push.apply(indices, [i2, i3, ii, ii, i1, i2]);
      }

      var positions = new Float64Array(pos);
      var gi = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Geometry"]({
          attributes: {
            position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              // 使用double类型的position进行计算
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].DOUBLE,
              //componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
          boundingSphere: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromVertices(positions)
        })
      });
      var color = Object(Util["getColorByStyle"])(this.style);
      var translucent = true; // color.alpha < 1 //透明时打开透明度

      this._primitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: gi,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialAppearance"]({
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            translucent: translucent,
            fabric: {
              uniforms: {
                u_color: color
              },
              source: this.getShader(translucent)
            }
          }),
          vertexShaderSource: DiffuseWallGlowVS_default.a,
          fragmentShaderSource: DiffuseWallGlowFS_default.a
        }),
        asynchronous: false,
        shadows: this.style.shadows,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive);
      this.primitiveCollection.add(this);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      this.primitiveCollection.remove(this);
    }
  }, {
    key: "update",
    value: function update(frameState) {
      if (this._primitive && this._show) {
        var time = frameState.frameNumber / 1000.0 * this.style.speed;
        var tt = time - Math.floor(time);
        tt = tt < 0.01 ? 0.01 : tt;
        this._mScale[0] = this._mScale[5] = tt * this._xyScale;
        this._mScale[10] = 1.1 - tt;
        this._primitive.modelMatrix = scaleXYZ(this.center, this._mScale);
      }
    } //片源着色器

  }, {
    key: "getShader",
    value: function getShader(t) {
      var fs = "    uniform vec4 u_color;\n" + "    vec4 xh_getMaterial(vec2 st){" + "    float alpha = pow(1. - st.t, 4.);\n";

      if (t) {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, alpha);";
      } else {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, 1.);";
      }

      fs += "    return color;\n" + "}\n";
      return fs;
    }
  }]);

  return DiffuseWall;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("diffuseWall", DiffuseWall_DiffuseWall);

function scaleXYZ(point, _mScale) {
  var m = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(point);
  var inverse = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(m, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
  var tt = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(_mScale, inverse, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(m, tt, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
}
// EXTERNAL MODULE: ./src/shaders/ScrollWallGlowVS.glsl
var ScrollWallGlowVS = __webpack_require__(70);
var ScrollWallGlowVS_default = /*#__PURE__*/__webpack_require__.n(ScrollWallGlowVS);

// EXTERNAL MODULE: ./src/shaders/ScrollWallGlowFS.glsl
var ScrollWallGlowFS = __webpack_require__(71);
var ScrollWallGlowFS_default = /*#__PURE__*/__webpack_require__.n(ScrollWallGlowFS);

// EXTERNAL MODULE: ./src/shaders/Materials/ScrollWallGlowMaterial.glsl
var ScrollWallGlowMaterial = __webpack_require__(72);
var ScrollWallGlowMaterial_default = /*#__PURE__*/__webpack_require__.n(ScrollWallGlowMaterial);

// EXTERNAL MODULE: ./src/shaders/Materials/ScrollWallGlowMaterial2.glsl
var ScrollWallGlowMaterial2 = __webpack_require__(73);
var ScrollWallGlowMaterial2_default = /*#__PURE__*/__webpack_require__.n(ScrollWallGlowMaterial2);

// CONCATENATED MODULE: ./src/graphic/primitive/ScrollWall.js







function ScrollWall_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ScrollWall_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ScrollWall_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ScrollWall_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ScrollWall_createSuper(Derived) { var hasNativeReflectConstruct = ScrollWall_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ScrollWall_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










var ScrollWall_DEF_STYLE = {
  diffHeight: 100,
  speed: 10,
  style: 1
};
/**
 *  走马灯围墙效果 支持的样式信息
 *
 * @typedef {Object} ScrollWall.StyleOptions
 *
 * @property {Number} [diffHeight = 100] 墙高
 * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
 *
 * @property {Number} [speed = 10] 速度，值越大越快
 * @property {Boolean} [reverse = false] 方向：true往上、false往下
 * @property {Number} [style = 1] 样式，可选值：1、2
 *
 * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
 *
 */

/**
 *  走马灯围墙效果 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {ScrollWall.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var ScrollWall_ScrollWall = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(ScrollWall, _BasePolyPrimitive);

  var _super = ScrollWall_createSuper(ScrollWall);

  function ScrollWall() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ScrollWall);

    options.style = ScrollWall_objectSpread(ScrollWall_objectSpread({}, ScrollWall_DEF_STYLE), options.style || {});
    return _super.call(this, options);
  }

  createClass_default()(ScrollWall, [{
    key: "czmObject",
    get: function get() {
      return this._primitive;
    } //========== 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var cps = this.positions;
      var up = Object(PointUtil["addPositionsHeight"])(cps, this.style.diffHeight); //计算位置

      var pos = []; //坐标

      var sts = []; //纹理

      var indices = []; //索引

      var normal = []; //法向量

      for (var i = 0, len = cps.length; i < len; i++) {
        var ni = i + 1;

        if (ni == len) {
          ni = 0;
        }

        pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
        pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
        pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

        var ii = i * 4;
        var i1 = ii + 1;
        var i2 = ii + 2;
        var i3 = ii + 3;
        indices.push.apply(indices, [ii, i1, i2, i2, i3, ii]);
      }

      var positions = new Float64Array(pos);
      var gi = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Geometry"]({
          attributes: {
            position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              // 使用double类型的position进行计算
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].DOUBLE,
              //componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
          boundingSphere: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromVertices(positions)
        })
      });
      var color = Object(Util["getColorByStyle"])(this.style);
      var translucent = true; //color.alpha < 1 //透明时打开透明度

      this._primitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: gi,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialAppearance"]({
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            translucent: translucent,
            fabric: {
              uniforms: {
                u_color: color,
                speed: this.style.speed,
                direction: this.style.reverse ? 1 : -1
              },
              source: this.createShader()
            }
          }),
          vertexShaderSource: ScrollWallGlowVS_default.a,
          fragmentShaderSource: ScrollWallGlowFS_default.a
        }),
        asynchronous: false,
        shadows: this.style.shadows,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }
    }
  }, {
    key: "createShader",
    value: function createShader() {
      if (this.style.style == 1) {
        return ScrollWallGlowMaterial_default.a;
      } else {
        return ScrollWallGlowMaterial2_default.a;
      }
    }
  }]);

  return ScrollWall;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("scrollWall", ScrollWall_ScrollWall);
// EXTERNAL MODULE: ./src/shaders/DynamicRiverFS.glsl
var DynamicRiverFS = __webpack_require__(74);
var DynamicRiverFS_default = /*#__PURE__*/__webpack_require__.n(DynamicRiverFS);

// EXTERNAL MODULE: ./src/shaders/DynamicRiverVS.glsl
var DynamicRiverVS = __webpack_require__(75);
var DynamicRiverVS_default = /*#__PURE__*/__webpack_require__.n(DynamicRiverVS);

// EXTERNAL MODULE: ./src/shaders/Materials/DynamicRiverMaterial.glsl
var DynamicRiverMaterial = __webpack_require__(76);
var DynamicRiverMaterial_default = /*#__PURE__*/__webpack_require__.n(DynamicRiverMaterial);

// CONCATENATED MODULE: ./src/graphic/primitive/DynamicRiver.js







function DynamicRiver_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DynamicRiver_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DynamicRiver_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DynamicRiver_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DynamicRiver_createSuper(Derived) { var hasNativeReflectConstruct = DynamicRiver_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DynamicRiver_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









var DynamicRiver_DEF_STYLE = {
  opacity: 0.5,
  //透明度
  width: 10.0,
  //宽度(单位：米)
  height: 0.0,
  //海拔高数值(单位：米)
  speed: 10.0,
  //流动速度
  axisY: false,
  //uv交换（图片横竖切换）
  move: true,
  //是否开启流动效果
  direction: true,
  //设置流动方向
  moveVar: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](50, 1, 100) //流动动画参数，不建议调整该参数

};
/**
 * 动态河流 支持的样式信息
 *
 * @typedef {Object} DynamicRiver.StyleOptions
 *
 * @property {String} image 图片材质URL
 * @property {Number} [opacity = 0.5] 透明度，取值范围：0.0-1.0
 * @property {Number} [width = 20] 河流宽度。(单位：米)
 * @property {Number} [height = 0] 海拔高度，相对于椭球面的高度。(单位：米)
 * @property {Number} [speed = 10] 流动速度，值越大越快
 *
 * @property {Boolean} [axisY = false] 是否uv交换（图片横竖切换）
 * @property {Boolean} [move = true] 是否开启流动效果
 * @property {Boolean} [direction = true] 设置流动方向
 *
 */

/**
 * 动态河流 矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {DynamicRiver.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BaseGraphic.EventType}
 */

var DynamicRiver_DynamicRiver = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(DynamicRiver, _BasePolyPrimitive);

  var _super = DynamicRiver_createSuper(DynamicRiver);

  //========== 构造方法 ==========
  function DynamicRiver() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DynamicRiver);

    options.style = DynamicRiver_objectSpread(DynamicRiver_objectSpread({}, DynamicRiver_DEF_STYLE), options.style || {});
    return _super.call(this, options);
  } //========== 对外属性 ==========


  createClass_default()(DynamicRiver, [{
    key: "czmObject",
    get: function get() {
      return this._primitive;
    }
    /**
     * 图片材质URL
     * @type {String}
     */

  }, {
    key: "image",
    get: function get() {
      return this.style.image;
    },
    set: function set(str) {
      this.style.image = str;
      this._material.uniforms.image = str;
    }
    /**
     * 宽度 (单位：米)
     * @type {Number}
     */

  }, {
    key: "width",
    get: function get() {
      return this.style.width;
    },
    set: function set(val) {
      val = Number(val) || 1;
      this.style.width = val;

      this._update();
    }
    /**
     * 海拔高度，相对于椭球面的高度。(单位：米)
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      return this.style.height;
    },
    set: function set(val) {
      this.style.height = val;

      this._update();
    }
    /**
     * 透明度 0.0-1.0
     * @type {Number}
     */

  }, {
    key: "opacity",
    get: function get() {
      return this.style.opacity;
    },
    set: function set(val) {
      this.style.opacity = Number(val);
      this._material.uniforms.alpha = val;
    }
    /**
     * 设置流动方向
     * @type {Boolean}
     */

  }, {
    key: "direction",
    get: function get() {
      return this.style.direction;
    },
    set: function set(val) {
      val = Boolean(val);
      this.style.direction = val;
      this._material.uniforms.reflux = val ? -1 : 1;
    }
    /**
     * 流动速度
     * @type {Number}
     */

  }, {
    key: "speed",
    get: function get() {
      return this.style.speed;
    },
    set: function set(val) {
      val = Number(val) || 1;
      this.style.speed = val;
      this._material.uniforms.speed = val;
    }
    /**
     * 是否开启流动效果
     * @type {Boolean}
     */

  }, {
    key: "move",
    get: function get() {
      return this.style.move;
    },
    set: function set(val) {
      val = Boolean(val);
      this.style.move = val;
      this._material.uniforms.move = val;
    }
    /**
     * 是否uv交换（图片横竖切换）
     * @type {Boolean}
     */

  }, {
    key: "axisY",
    get: function get() {
      return this.style.axisY;
    },
    set: function set(val) {
      val = Boolean(val);
      this.style.axisY = val;
      this._material.uniforms.flipY = val;
    } //流动动画参数，不建议调整该参数

  }, {
    key: "moveVar",
    get: function get() {
      return this.style.moveVar;
    },
    set: function set(val) {
      this.style.moveVar = val;
      this._material.uniforms.moveVar = val;
    } //========== 方法 ==========

  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._update();
    }
  }, {
    key: "_update",
    value: function _update() {
      if (!this._primitive) {
        return;
      }

      this._removedHook();

      this._addedHook();
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._sideRes = Lines2Plane(this.positions, this.width, this.height);

      if (!this._sideRes) {
        return;
      }

      this._material = this.prepareMaterial();
      this._primitive = this.createPrimitive();
      this.primitiveCollection.add(this._primitive);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this.dhEvent) {
        this._map.off(EventType.clockTick, this.dhEvent, this);

        delete this.dhEvent;
      }

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      if (this._material) {
        this._material.destroy();

        delete this._material;
      }
    }
  }, {
    key: "prepareMaterial",
    value: function prepareMaterial() {
      var _material;

      if (this.image) {
        _material = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
          fabric: {
            uniforms: {
              image: this.image,
              alpha: this.opacity,
              moveVar: this.moveVar,
              reflux: this.direction ? -1 : 1,
              speed: this.speed,
              move: this.move,
              flipY: this.axisY
            },
            source: DynamicRiverMaterial_default.a
          }
        });
      } else {
        _material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("Color");
        _material.uniforms.color = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 0.0, this.opacity);
      }

      return _material;
    }
  }, {
    key: "createPrimitive",
    value: function createPrimitive() {
      //创建图元
      var sides = this._sideRes;
      var positions = new Float64Array(sides.vertexs);
      var attributes = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttributes"]();
      attributes.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
        componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].DOUBLE,
        componentsPerAttribute: 3,
        values: positions
      });
      attributes.st = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
        componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
        componentsPerAttribute: 2,
        values: sides.uvs
      });
      var geometry = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Geometry"]({
        attributes: attributes,
        indices: sides.indexs,
        primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
        boundingSphere: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromVertices(positions)
      }); // geometry._workerName = ""

      var instance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
        id: this.uuid,
        geometry: geometry
      });
      var renderState = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"]();
      renderState.depthTest.enabled = true;
      var primitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: instance,
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Appearance"]({
          material: this._material,
          renderState: renderState,
          vertexShaderSource: DynamicRiverVS_default.a,
          fragmentShaderSource: DynamicRiverFS_default.a //czm_lightDirectionEC在cesium1.66开始加入的

        })
      });
      return primitive;
    }
    /**
     * 执行升高或降低高度的动画效果
     *
     * @param {Number} height 升高或降低的相对高度（单位：米），负数代表降低
     * @param {Number} time  动画时长（单位：秒）
     * @return {void}  无
     */

  }, {
    key: "offsetHeight",
    value: function offsetHeight(height, time) {
      if (!height || !time || !this._primitive) {
        return;
      }

      var currH = 0;
      var avgF = 20; //平均每帧20毫秒，即每秒50帧；

      var avgH = height / (time * avgF);
      var selfV = this._sideRes.self;
      var totalN = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();

      for (var i = 0, len = selfV.length; i < len; i++) {
        //求平均的法线
        var currN = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(selfV[i], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(totalN, currN, totalN);
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(totalN, totalN);
      var initM = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._primitive.modelMatrix);

      this.dhEvent = function () {
        if (!this._primitive || !this._map) {
          return;
        }

        if (Math.abs(currH) <= Math.abs(height)) {
          //可以升高，可以降低，height可以为负值
          var currNor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(totalN, currH, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          this._primitive.modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByTranslation(initM, currNor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
        } else {
          if (this.dhEvent) {
            this._map.off(EventType.clockTick, this.dhEvent, this);

            delete this.dhEvent;
          }
        }

        currH += avgH;
      };

      this._map.on(EventType.clockTick, this.dhEvent, this);
    }
  }]);

  return DynamicRiver;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("dynamicRiver", DynamicRiver_DynamicRiver);

function Lines2Plane(lineArr, width, height) {
  if (!lineArr || lineArr.length <= 1 || !width || width == 0) {
    Object(Log["logError"])("请确认参数符合规则：数组长度大于1，宽高不能为0！", lineArr);
    return;
  }

  var len = lineArr.length;
  var leftPots = [];
  var rightPots = [];
  var halfW = width / 2.0;

  for (var i = 0; i < len; i++) {
    var prevP = void 0;
    var currP = void 0;
    var nextP = void 0;
    var leftPot = void 0;
    var rightPot = void 0;

    if (i == 0) {
      prevP = lineArr[i];
      currP = lineArr[i];
      nextP = lineArr[i + 1];
    } else if (i == len - 1) {
      prevP = lineArr[i - 1];
      currP = lineArr[i];
      nextP = lineArr[i - 1];
    } else {
      prevP = lineArr[i - 1];
      currP = lineArr[i];
      nextP = lineArr[i + 1];
    }

    if (height != 0) {
      prevP = RaisePoint(prevP, height);
      currP = RaisePoint(currP, height);
      nextP = RaisePoint(nextP, height);
    }

    if (prevP && currP && nextP) {
      var sides = GetSide2(prevP, currP, nextP, halfW);
      leftPot = sides.left;
      rightPot = sides.right;
      leftPots.push(rightPot);
      rightPots.push(leftPot);
    }
  }

  var leftPotsRes = leftPots;
  var rightPotsRes = rightPots;
  var uvs = [];
  var vertexs = [];
  var vertexsH = [];
  var vertexsL = [];
  var indexs = []; //先记录右边点，后记录左边点、记录2遍为了分离UV

  for (var _i = 0; _i < len; _i++) {
    var encodeRes = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EncodedCartesian3"].fromCartesian(rightPotsRes[_i]);
    vertexs.push(rightPotsRes[_i].x);
    vertexs.push(rightPotsRes[_i].y);
    vertexs.push(rightPotsRes[_i].z);
    vertexsH.push(encodeRes.high.x);
    vertexsH.push(encodeRes.high.y);
    vertexsH.push(encodeRes.high.z);
    vertexsL.push(encodeRes.low.x);
    vertexsL.push(encodeRes.low.y);
    vertexsL.push(encodeRes.low.z);
    uvs.push(1, 1); //记录索引以及UV

    if (_i < len - 1) {
      indexs.push(_i + len * 2);
      indexs.push(_i + 1);
      indexs.push(_i + 1 + len);
      indexs.push(_i + len * 2);
      indexs.push(_i + 1 + len);
      indexs.push(len + _i + len * 2);
    }
  }

  for (var _i2 = 0; _i2 < len; _i2++) {
    var _encodeRes = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EncodedCartesian3"].fromCartesian(leftPotsRes[_i2]);

    vertexs.push(leftPotsRes[_i2].x);
    vertexs.push(leftPotsRes[_i2].y);
    vertexs.push(leftPotsRes[_i2].z);
    vertexsH.push(_encodeRes.high.x);
    vertexsH.push(_encodeRes.high.y);
    vertexsH.push(_encodeRes.high.z);
    vertexsL.push(_encodeRes.low.x);
    vertexsL.push(_encodeRes.low.y);
    vertexsL.push(_encodeRes.low.z);
    uvs.push(1, 0);
  }

  for (var _i3 = 0; _i3 < len; _i3++) {
    var _encodeRes2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EncodedCartesian3"].fromCartesian(rightPotsRes[_i3]);

    vertexs.push(rightPotsRes[_i3].x);
    vertexs.push(rightPotsRes[_i3].y);
    vertexs.push(rightPotsRes[_i3].z);
    vertexsH.push(_encodeRes2.high.x);
    vertexsH.push(_encodeRes2.high.y);
    vertexsH.push(_encodeRes2.high.z);
    vertexsL.push(_encodeRes2.low.x);
    vertexsL.push(_encodeRes2.low.y);
    vertexsL.push(_encodeRes2.low.z);
    uvs.push(0, 1);
  }

  for (var _i4 = 0; _i4 < len; _i4++) {
    var _encodeRes3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EncodedCartesian3"].fromCartesian(leftPotsRes[_i4]);

    vertexs.push(leftPotsRes[_i4].x);
    vertexs.push(leftPotsRes[_i4].y);
    vertexs.push(leftPotsRes[_i4].z);
    vertexsH.push(_encodeRes3.high.x);
    vertexsH.push(_encodeRes3.high.y);
    vertexsH.push(_encodeRes3.high.z);
    vertexsL.push(_encodeRes3.low.x);
    vertexsL.push(_encodeRes3.low.y);
    vertexsL.push(_encodeRes3.low.z);
    uvs.push(0, 0);
  }

  return {
    left: leftPotsRes,
    right: rightPotsRes,
    self: lineArr,
    vertexs: new Float32Array(vertexs),
    vertexsH: new Float32Array(vertexsH),
    vertexsL: new Float32Array(vertexsL),
    indexs: new Uint16Array(indexs),
    uvs: new Float32Array(uvs)
  };
}

function RaisePoint(pot, height) {
  if (!(pot instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"])) {
    Object(Log["logError"])("请确认点是Cartesian3类型！");
    return;
  }

  if (!height || height == 0) {
    Object(Log["logError"])("请确认高度是非零数值！");
    return;
  }

  var dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(pot, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
  var ray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](pot, dir);
  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(ray, height);
}

function GetSide2(prevP, currP, nextP, halfW) {
  var leftPot, rightPot;

  if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].equals(prevP, currP)) {
    var dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(nextP, currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var nor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var leftDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(nor, dir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var rightDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(dir, nor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var leftray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, leftDir);
    var rightray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, rightDir);
    leftPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(leftray, halfW);
    rightPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(rightray, halfW);
  } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].equals(nextP, currP)) {
    var _dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(currP, prevP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

    var _nor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

    var _leftDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(_nor, _dir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

    var _rightDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(_dir, _nor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

    var _leftray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _leftDir);

    var _rightray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _rightDir);

    leftPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_leftray, halfW);
    rightPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_rightray, halfW);
  } else {
    var prevDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(currP, prevP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var nextDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(nextP, currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    var avgDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(prevDir, nextDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].equals(avgDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]())) {
      var _dir2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(currP, prevP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _nor2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _leftDir2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(_nor2, _dir2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _rightDir2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(_dir2, _nor2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _leftray2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _leftDir2);

      var _rightray2 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _rightDir2);

      leftPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_leftray2, halfW);
      rightPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_rightray2, halfW);
    } else {
      var avgDir_nor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(avgDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _nor3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(currP, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _leftDir3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(_nor3, avgDir_nor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _rightDir3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(avgDir_nor, _nor3, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

      var _leftray3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _leftDir3);

      var _rightray3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](currP, _rightDir3);

      var dirAng_dot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].dot(prevDir, nextDir);
      var mo_prev = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].magnitude(prevDir);
      var mo_next = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].magnitude(nextDir);
      var dirAng_cos = dirAng_dot / mo_prev / mo_next;
      var dirAng_deg = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(Math.acos(dirAng_cos));
      var halfAng_deg = dirAng_deg / 2; // console.log(dirAng_deg)

      var halfAng_cos = Math.cos(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(halfAng_deg));
      var disMid = halfW * 2.0 / halfAng_cos;
      leftPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_leftray3, disMid / 2);
      rightPot = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(_rightray3, disMid / 2);
    }
  }

  return {
    left: leftPot,
    right: rightPot
  };
}
// CONCATENATED MODULE: ./src/graphic/primitive/Road.js






function Road_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Road_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Road_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Road_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Road_createSuper(Derived) { var hasNativeReflectConstruct = Road_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Road_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



var Road_DEF_STYLE = {
  opacity: 1,
  //透明度
  move: false,
  //是否开启流动效果
  axisY: true //uv交换（图片横竖切换）

};
/**
 * 道路 支持的样式信息
 *
 * @typedef {Object} Road.StyleOptions
 *
 * @property {String} image 图片材质URL
 * @property {Number} [width = 20] 道路 宽度。(单位：米)
 * @property {Number} [height = 0] 道路 高度，相对于椭球面的高度。(单位：米)
 *
 * @property {Boolean} [axisY = true] 是否uv交换（图片横竖切换）
 *
 */

/**
 * 道路  矢量对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {Road.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @export
 * @class Road
 * @extends {DynamicRiver}
 * @see [支持的事件类型]{@link BaseGraphic.EventType}
 */

var Road_Road = /*#__PURE__*/function (_DynamicRiver) {
  inherits_default()(Road, _DynamicRiver);

  var _super = Road_createSuper(Road);

  function Road() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Road);

    options.style = Road_objectSpread(Road_objectSpread({}, Road_DEF_STYLE), options.style || {});
    return _super.call(this, options);
  }

  return Road;
}(DynamicRiver_DynamicRiver); //注册下

Object(GraphicUtil["register"])("road", Road_Road);
// CONCATENATED MODULE: ./src/graphic/primitive/core/PitWallGeometry.js



var PitWallGeometry_PitWallGeometry = /*#__PURE__*/function () {
  function PitWallGeometry() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, PitWallGeometry);

    options = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"].EMPTY_OBJECT);
    var min = options.minimumArr;
    var max = options.maximumArr;
    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Check"].defined('dingmian', max);
    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Check"].defined('dimianmian', min);
    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Check"].typeOf.number.greaterThanOrEquals('dingmian.length', max.length, 3);
    external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Check"].typeOf.number.greaterThanOrEquals('dimian.length', min.length, 3);
    var vertexFormat = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexFormat"]({
      st: true,
      position: true,
      bitangent: false,
      normal: false,
      color: false,
      tangent: false
    });
    this._minimumArr = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](min);
    this._maximumArr = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](max);
    this._vertexFormat = vertexFormat;
    this._workerName = '';
  }

  createClass_default()(PitWallGeometry, [{
    key: "createGeometry",
    value: function createGeometry(_PitWallGeometry, topHeights, bottomHeight) {
      var maxHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var min = _PitWallGeometry._minimumArr;
      var max = _PitWallGeometry._maximumArr;
      var vertexFormat = _PitWallGeometry._vertexFormat;
      var attributes = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttributes"]();
      var indices;
      var positions;
      var min_pos, max_pos;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](vertexFormat.position) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](vertexFormat.st)) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](vertexFormat.position)) {
          // 8 corner points.  Duplicated 3 times each for each incident edge/face.
          positions = new Float64Array(max.length * 4 * 3);

          for (var i = 0; i < max.length; i++) {
            if (i == max.length - 1) {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;
              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;
              positions[i * 12 + 9] = min[0].x;
              positions[i * 12 + 10] = min[0].y;
              positions[i * 12 + 11] = min[0].z;
              positions[i * 12 + 6] = max[0].x;
              positions[i * 12 + 7] = max[0].y;
              positions[i * 12 + 8] = max[0].z;
            } else {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;
              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;
              positions[i * 12 + 9] = min[i + 1].x;
              positions[i * 12 + 10] = min[i + 1].y;
              positions[i * 12 + 11] = min[i + 1].z;
              positions[i * 12 + 6] = max[i + 1].x;
              positions[i * 12 + 7] = max[i + 1].y;
              positions[i * 12 + 8] = max[i + 1].z;
            }
          }

          attributes.position = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
            componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          });
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](vertexFormat.st)) {
          var texCoords = new Float32Array(max.length * 4 * 2);
          var maxLen = max.length;

          for (var _i = 0; _i < max.length; _i++) {
            var currX = _i / maxLen;
            var currMaxHeight = topHeights && topHeights[_i] || 0;
            var currY = (currMaxHeight - bottomHeight) / (maxHeight - bottomHeight);
            var nextIndex = _i + 1;
            var nextMaxHeight = topHeights && topHeights[nextIndex] || 0;
            var nextX = nextIndex / maxLen;
            var nextY = (nextMaxHeight - bottomHeight) / (maxHeight - bottomHeight);
            texCoords[_i * 8 + 0] = currX;
            texCoords[_i * 8 + 1] = currY - 0.0;
            texCoords[_i * 8 + 2] = currX;
            texCoords[_i * 8 + 3] = currY - currY;
            texCoords[_i * 8 + 4] = nextX;
            texCoords[_i * 8 + 5] = nextY - 0.0;
            texCoords[_i * 8 + 6] = nextX;
            texCoords[_i * 8 + 7] = nextY - nextY;
          }

          attributes.st = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
            componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].FLOAT,
            componentsPerAttribute: 2,
            values: texCoords
          });
        } // 12 triangles:  6 faces, 2 triangles each.


        indices = new Uint16Array(max.length * 2 * 3);
        min_pos = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](9999999999999, 9999999999999, 9999999999999);
        max_pos = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-9999999999999, -9999999999999, -9999999999999);

        for (var _i2 = 0; _i2 < max.length; _i2++) {
          indices[_i2 * 6 + 0] = 4 * _i2 + 0;
          indices[_i2 * 6 + 1] = 4 * _i2 + 1;
          indices[_i2 * 6 + 2] = 4 * _i2 + 2;
          indices[_i2 * 6 + 3] = 4 * _i2 + 1;
          indices[_i2 * 6 + 4] = 4 * _i2 + 2;
          indices[_i2 * 6 + 5] = 4 * _i2 + 3;

          if (max[_i2].x >= max_pos.x && max[_i2].y >= max_pos.y && max[_i2].z >= max_pos.z) {
            max_pos = max[_i2];
          }

          if (min[_i2].x <= min_pos.x && min[_i2].y <= min_pos.y && min[_i2].z <= min_pos.z) {
            min_pos = min[_i2];
          }
        }
      }

      var diff = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(max_pos, min_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].magnitude(diff) * 0.5;
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Geometry"]({
        attributes: attributes,
        indices: indices,
        primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
        boundingSphere: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO, radius)
      });
    }
  }]);

  return PitWallGeometry;
}();
// CONCATENATED MODULE: ./src/graphic/primitive/Pit.js







function Pit_createSuper(Derived) { var hasNativeReflectConstruct = Pit_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Pit_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 井  支持的样式信息，
 *
 * @typedef {Object} Pit.StyleOptions
 *
 * @property {String} image   井墙面贴图URL
 * @property {String} imageBottom   井底面贴图URL
 * @property {Number} diffHeight  井下深度（单位：米）
 * @property {Number} [splitNum = 50] 井墙面每两点之间插值个数
 *
 * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
 */

/**
 * 井 矢量对象
 * 用于显示地形开挖后的开挖效果。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {BasePrimitive.ConstructorOptions} [options.通用参数P] 支持所有Primitive通用参数
 *
 * @param {LatLngPoint[]|Cesium.Cartesian3[]} options.positions 坐标位置
 * @param {Pit.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @extends {BasePolyPrimitive}
 * @see [支持的事件类型]{@link BasePrimitive.EventType}
 */

var Pit_Pit = /*#__PURE__*/function (_BasePolyPrimitive) {
  inherits_default()(Pit, _BasePolyPrimitive);

  var _super = Pit_createSuper(Pit);

  function Pit() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Pit);

    _this = _super.call(this, options);
    _this.style.diffHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.diffHeight, 10); //挖掘深度

    _this.style.splitNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.splitNum, 50); //每两点之间插值个数

    return _this;
  } //内部用，文本等附加对象


  createClass_default()(Pit, [{
    key: "czmObjectEx",
    get: function get() {
      var arr = [];

      if (this._bottomPrimitive) {
        arr.push(this._bottomPrimitive);
      }

      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }

      return arr;
    } //中心点坐标，覆盖父类

  }, {
    key: "center",
    get: function get() {
      return this.centerOfMass;
    }
    /**
     * 井下深度（单位：米）
     * @type {Number}
     */

  }, {
    key: "diffHeight",
    get: function get() {
      return this.style.diffHeight;
    },
    set: function set(val) {
      this.style.diffHeight = val;
      var bottomPositions = [];
      var bottomHeight = this._minHeight - val; //墙底部的高度

      var cartoList = this.wellData.cartoList;

      for (var i = 0, len = cartoList.length; i < len; i++) {
        var carto = cartoList[i];
        bottomPositions.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, bottomHeight));
      } //墙底部的坐标数组


      this.wellData.bottomPositions = bottomPositions;

      this._removePit();

      this._createPit(this.wellData);
    }
  }, {
    key: "_getWellData",
    value: function _getWellData() {
      if (this.positions.length == 0) {
        return;
      } //墙顶部的高度（也是绘制的坐标的最低点高度）


      this._minHeight = Object(PointUtil["getMinHeight"])(this.positions); //墙底部的高度

      var bottomHeight = this._minHeight - this.diffHeight;
      var wallTopPositions = [];
      var bottomPositions = [];
      var cartoList = [];
      var positionsNew = interPolyline({
        scene: this._map.scene,
        positions: this.positions.concat(this.positions[0]),
        splitNum: this.style.splitNum
      });

      for (var i = 0, len = positionsNew.length; i < len; i++) {
        var point = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positionsNew[i]);
        cartoList.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](point.longitude, point.latitude));
        bottomPositions.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(point.longitude, point.latitude, bottomHeight));
        wallTopPositions.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(point.longitude, point.latitude, 0)); //无地形时直接使用这个0
      }

      return {
        cartoList: cartoList,
        bottomPositions: bottomPositions,
        wallTopPositions: wallTopPositions
      };
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var wellData = this._getWellData();

      this.wellData = wellData;

      this._createPit(wellData); //同时加文字


      if (this.style.label) {
        this._addLabel();
      }
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(Pit.prototype), "_removedHook", this).call(this);

      this._removePit();
    }
  }, {
    key: "_removePit",
    value: function _removePit() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      if (this._bottomPrimitive) {
        this.primitiveCollection.remove(this._bottomPrimitive);
        delete this._bottomPrimitive;
      }
    }
  }, {
    key: "_createPit",
    value: function _createPit(wellData) {
      var _this2 = this;

      this._createBottomSurface(wellData.bottomPositions);

      if (this._map.hasTerrain) {
        var promise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["sampleTerrainMostDetailed"](this._map.terrainProvider, wellData.cartoList); //赵西洋 Cesium.when切换为promise   20220805

        promise.then(function (updatedPositions) {
          // Cesium.when(promise, (updatedPositions) => {
          var _topHeights = [];

          var _maxHeight = -9999;

          var wallTopPositions = []; //墙顶部的坐标数组

          for (var k = 0, len = updatedPositions.length; k < len; k++) {
            var carto = updatedPositions[k];

            _topHeights.push(carto.height);

            _maxHeight = Math.max(carto.height, _maxHeight);
            wallTopPositions.push(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto.longitude, carto.latitude, carto.height));
          }

          _this2._maxHeight = _maxHeight; //PitWallGeometry 使用

          _this2._topHeights = _topHeights; //PitWallGeometry 使用

          _this2._createWellWall(wellData.bottomPositions, wallTopPositions);
        });
      } else {
        this._createWellWall(wellData.bottomPositions, wellData.wallTopPositions);
      }
    } //创建井壁

  }, {
    key: "_createWellWall",
    value: function _createWellWall(bottom, top) {
      // logInfo('井高度', this._minHeight, this._maxHeight, this._topHeights)
      //墙底部的高度
      var bottomHeight = this._minHeight - this.diffHeight;
      var geo = new PitWallGeometry_PitWallGeometry({
        minimumArr: bottom,
        maximumArr: top
      });
      geo = geo.createGeometry(geo, this._topHeights, bottomHeight, this._maxHeight);
      this._primitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
          geometry: geo,
          attributes: {
            color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].GREY)
          },
          id: this.uuid
        }),
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialAppearance"]({
          translucent: false,
          flat: true,
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
            fabric: {
              type: "Image",
              uniforms: {
                image: this.style.image,
                color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(this.style.opacity || 1.0)
              }
            }
          })
        }),
        asynchronous: false
      });
      this.primitiveCollection.add(this._primitive);
      this.bindPickId(this._primitive);
    } //创建井底

  }, {
    key: "_createBottomSurface",
    value: function _createBottomSurface(bottomPositions) {
      if (!bottomPositions.length) {
        return;
      }

      this._bottomPrimitive = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
          geometry: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].fromPositions({
            vertexFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexFormat"].ALL,
            positions: bottomPositions,
            perPositionHeight: true
          })
        }),
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MaterialAppearance"]({
          material: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].ImageType, {
            image: this.style.imageBottom,
            color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(this.style.opacity || 1.0)
          })
        })
      });
      this.primitiveCollection.add(this._bottomPrimitive);
      this.bindPickId(this._bottomPrimitive);
    }
  }]);

  return Pit;
}(BasePolyPrimitive_BasePolyPrimitive); //注册下

Object(GraphicUtil["register"])("pit", Pit_Pit);
// CONCATENATED MODULE: ./src/graphic/custom/edit/EditDivGraphic.js






function EditDivGraphic_createSuper(Derived) { var hasNativeReflectConstruct = EditDivGraphic_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EditDivGraphic_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var EditDivGraphic_EditDivGraphic = /*#__PURE__*/function (_EditBase) {
  inherits_default()(EditDivGraphic, _EditBase);

  var _super = EditDivGraphic_createSuper(EditDivGraphic);

  function EditDivGraphic() {
    classCallCheck_default()(this, EditDivGraphic);

    return _super.apply(this, arguments);
  }

  createClass_default()(EditDivGraphic, [{
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this = this;

      var draggerMove = this.createDragger({
        position: this._graphic.position,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: function onDrag(dragger, position) {
          _this._graphic.position = position;
        }
      });
      this._draggerMove = draggerMove;
      this.draggers.push(draggerMove);
    }
  }]);

  return EditDivGraphic;
}(EditBase_EditBase);
// CONCATENATED MODULE: ./src/graphic/custom/DivGraphic.js







function DivGraphic_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DivGraphic_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DivGraphic_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DivGraphic_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DivGraphic_createSuper(Derived) { var hasNativeReflectConstruct = DivGraphic_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivGraphic_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






 // 赵西洋  补充修改2022-12-26






/**
 * DIV点 支持的样式信息
 *
 * @typedef {Object} DivGraphic.StyleOptions
 *
 * @property {String|Element} html Html文本
 *
 * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
 * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
 *
 * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
 * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
 *
 * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
 * @property {Number} [scaleByDistance_far = 1000000] 上限
 * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
 * @property {Number} [scaleByDistance_near = 1000] 下限
 * @property {Number} [scaleByDistance_nearValue = 1] 比例值
 * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
 * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
 * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
 * @property {Boolean} [clampToGround = false] 是否贴地
 * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
 *
 */

/**
 * @typedef {Object} DivGraphic.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 * @property {String} change 变化了
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 * @property {String} drawStart 开始绘制 标绘事件
 * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
 * @property {String} drawCreated 创建完成 标绘事件
 * @property {String} editStart 开始编辑 标绘事件
 * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
 * @property {String} editStop 停止编辑 标绘事件
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了矢量数据对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * DIV点
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {DivGraphic.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
 * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
 * @param {Boolean} [options.hasZIndex=true] 是否自动调整DIV的层级顺序，true时内部会给div设置0至9999999的zIndex值（如果与外部UI层有遮挡，外部DIV的zIndex请设置大于9999999的值），false时不设置。
 * @param {Boolean} [options.stopPropagation=false] DIV中的鼠标事件是否停止冒泡
 * @param {Boolean} [options.pointerEvents] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。默认根据是否绑定事件等自动判断。
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
 * @export
 * @class DivGraphic
 * @extends {BaseGraphic}
 *
 * @see [支持的事件类型]{@link DivGraphic.EventType}
 */

var DivGraphic_DivGraphic = /*#__PURE__*/function (_BaseGraphic) {
  inherits_default()(DivGraphic, _BaseGraphic);

  var _super = DivGraphic_createSuper(DivGraphic);

  function DivGraphic() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DivGraphic);

    _this = _super.call(this, options);
    _this.hasEdit = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.hasEdit, true); //是否允许编辑

    _this._depthTest = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.depthTest, true);
    _this._hasCache = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.hasCache, true);
    _this._hasZIndex = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.hasZIndex, true);
    _this._stopPropagation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.stopPropagation, false);
    _this._css_transform_origin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.css_transform_origin, "left bottom 0");
    _this.options.testPoint = Object(Util["merge"])({
      name: "用于与DIV点进行对比测试位置的点",
      color: "#ff0000",
      pixelSize: 8,
      distanceDisplayCondition: _this.style.distanceDisplayCondition,
      scaleByDistance: _this.style.scaleByDistance,
      clampToGround: _this.style.clampToGround,
      heightReference: _this.style.heightReference
    }, _this.options.testPoint); //坐标位置

    if (options.position) {
      _this.position = options.position;
    }

    return _this;
  } //========== 对外属性 ==========

  /**
   * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
   * @type {Cesium.Cartesian3}
   */


  createClass_default()(DivGraphic, [{
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      var _this$_point;

      this._point = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._position = (_this$_point = this._point) === null || _this$_point === void 0 ? void 0 : _this$_point.toCartesian();

      this._updateDivPosition();
    }
    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "point",
    get: function get() {
      return this._point;
    }
    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */

  }, {
    key: "coordinate",
    get: function get() {
      return this.point.toArray();
    } //中心点坐标，覆盖父类

  }, {
    key: "center",
    get: function get() {
      return this._position;
    }
    /**
     * 是否显示测试点，可以进行用于比较测试div的位置，方便调试CSS。
     * @type {Boolean}
     */

  }, {
    key: "testPoint",
    get: function get() {
      return this.debuggerPointEntity != null;
    },
    set: function set(value) {
      if (this.debuggerPointEntity) {
        this._layer.dataSource.entities.remove(this.debuggerPointEntity);

        delete this.debuggerPointEntity;
      } //添加实体


      if (value) {
        this.debuggerPointEntity = this._layer.dataSource.entities.add({
          name: this.options.testPoint.name,
          position: this.position,
          point: PointStyleConver_PointStyleConver.toCesiumVal(this.options.testPoint)
        });
      }
    }
    /**
     *  DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
     * @type {Boolean}
     */

  }, {
    key: "pointerEvents",
    get: function get() {
      return this._pointerEvents;
    },
    set: function set(value) {
      this._pointerEvents = value;

      if (this._container) {
        if (value) {
          this._container.style["pointer-events"] = "all";
        } else {
          /*加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件*/
          this._container.style["pointer-events"] = "none";
        }
      }
    }
    /**
     * 对象是否存在鼠标事件相关绑定
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasBindEvent",
    get: function get() {
      var _this$_layer, _this$_layer2, _this$_layer3;

      if (this.options.pointerEvents) {
        return true;
      }

      if (this.popup || this._layer.popup) {
        return true;
      }

      if (this.tooltip || this._layer.tooltip) {
        return true;
      }

      if (this.listens(EventType.click)) {
        return true;
      }

      if (this.listens(EventType.mouseOver)) {
        return true;
      }

      if (this.listens(EventType.mouseOut)) {
        return true;
      }

      if ((_this$_layer = this._layer) !== null && _this$_layer !== void 0 && _this$_layer.listens(EventType.click)) {
        return true;
      }

      if ((_this$_layer2 = this._layer) !== null && _this$_layer2 !== void 0 && _this$_layer2.listens(EventType.mouseOver)) {
        return true;
      }

      if ((_this$_layer3 = this._layer) !== null && _this$_layer3 !== void 0 && _this$_layer3.listens(EventType.mouseOut)) {
        return true;
      }

      return false;
    }
    /**
     * 是否打开深度判断（true时判断是否在球背面）
     * @type {Boolean}
     */

  }, {
    key: "depthTest",
    get: function get() {
      return this._depthTest;
    },
    set: function set(value) {
      this._depthTest = value;
      this._camera_cache = null;
    }
    /**
     * 是否贴地
     * @type {Boolean}
     */

  }, {
    key: "clampToGround",
    get: function get() {
      return this.style.clampToGround;
    },
    set: function set(value) {
      this.style.clampToGround = value;
    }
    /**
     * 对应的DOM元素
     * @type {Element}
     * @readonly
     */

  }, {
    key: "container",
    get: function get() {
      return this._container;
    }
    /**
     * 对应的DOM元素的id
     * @type {String}
     * @readonly
     */

  }, {
    key: "containerId",
    get: function get() {
      return this._container.id;
    }
    /**
     * 设置或获取当前对象对应的Html
     * @type {String|Element}
     */

  }, {
    key: "html",
    get: function get() {
      return this._container.innerHTML;
    },
    set: function set(content) {
      this.style.html = content;

      if (!this._container || !content) {
        return;
      }

      if (Object(Util["isString"])(content)) {
        this._container.innerHTML = content;
      } else if (content instanceof Element) {
        empty(this._container);

        this._container.appendChild(content);
      }

      this._camera_cache = null;
    }
  }, {
    key: "divWidth",
    get: function get() {
      var _this$_container;

      return (_this$_container = this._container) === null || _this$_container === void 0 ? void 0 : _this$_container.offsetWidth;
    }
  }, {
    key: "divHeight",
    get: function get() {
      var _this$_container2;

      return (_this$_container2 = this._container) === null || _this$_container2 === void 0 ? void 0 : _this$_container2.offsetHeight;
    } //========== 方法 ==========

  }, {
    key: "_showHook",
    value: function _showHook(val) {
      if (!this._container) {
        return;
      }

      if (val) {
        this._camera_cache = null;
        this._container.style.display = "block";
      } else {
        this.hide();
      }

      if (this.debuggerPointEntity) {
        this.debuggerPointEntity.show = val;
      }
    }
  }, {
    key: "_onEventHook",
    value: function _onEventHook() {
      this.pointerEvents = this.hasBindEvent;
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      DivGraphicStyleConver_DivGraphicStyleConver.toCesiumVal(this.style, this);
      this._container = create("div", "tudou3d-div-graphic ", this._layer.container);
      this._container.id = this.uuid; //添加html

      if (this.style.html) {
        this.html = this.style.html;
      } //单击事件


      this._container.addEventListener("click", function (e) {
        if (_this2._stopPropagation) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        }

        var result = {
          mouseEvent: e,
          cartesian: _this2.position,
          windowPosition: {
            x: e.clientX,
            y: e.clientY
          },
          sourceTarget: _this2,
          graphic: _this2,
          layer: _this2._layer
        };

        if (_this2.hasPopup()) {
          _this2.openPopup(_this2.position, {
            event: result
          });
        } else {
          var _this2$_layer;

          (_this2$_layer = _this2._layer) === null || _this2$_layer === void 0 ? void 0 : _this2$_layer.openPopup(_this2.position, {
            event: result
          });
        }

        _this2.fire(EventType.click, result);

        if (!_this2._stopPropagation) {
          var _this2$_layer2;

          (_this2$_layer2 = _this2._layer) === null || _this2$_layer2 === void 0 ? void 0 : _this2$_layer2.fire(EventType.click, result, true);
        }
      }); //右击事件


      this._container.addEventListener("mousedown", function (e) {
        if (e.button != 2) {
          return;
        } //非右击时 跳出


        if (_this2._stopPropagation) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        }

        var result = {
          mouseEvent: e,
          cartesian: _this2.position,
          windowPosition: {
            x: e.clientX,
            y: e.clientY
          },
          sourceTarget: _this2,
          graphic: _this2,
          layer: _this2._layer
        };

        _this2.fire(EventType.rightClick, result);

        if (!_this2._stopPropagation) {
          var _this2$_layer3;

          (_this2$_layer3 = _this2._layer) === null || _this2$_layer3 === void 0 ? void 0 : _this2$_layer3.fire(EventType.rightClick, result, true);
        }

        if (_this2.hasContextMenu()) {
          _this2.openContextMenu(_this2.position, {
            event: result
          });
        } else if (!_this2._stopPropagation) {
          var _this2$_layer4;

          (_this2$_layer4 = _this2._layer) === null || _this2$_layer4 === void 0 ? void 0 : _this2$_layer4.openContextMenu(_this2.position, {
            event: result
          });
        }
      }); //鼠标移入移出


      var cacheTarget;

      this._container.addEventListener("mousemove", function (e) {
        if (_this2._stopPropagation) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        } //缓存，提高效率


        if (cacheTarget == _this2.uuid) {
          return;
        }

        cacheTarget = _this2.uuid;

        if (_this2.hasTooltip()) {
          _this2.openTooltip();
        } else if (!_this2._stopPropagation) {
          var _this2$_layer5;

          (_this2$_layer5 = _this2._layer) === null || _this2$_layer5 === void 0 ? void 0 : _this2$_layer5.openTooltip(_this2.position);
        }

        var result = {
          mouseEvent: e,
          cartesian: _this2.position,
          windowPosition: {
            x: e.clientX,
            y: e.clientY
          },
          sourceTarget: _this2,
          graphic: _this2,
          layer: _this2._layer
        };

        _this2.fire(EventType.mouseOver, result);

        if (!_this2._stopPropagation) {
          var _this2$_layer6;

          (_this2$_layer6 = _this2._layer) === null || _this2$_layer6 === void 0 ? void 0 : _this2$_layer6.fire(EventType.mouseOver, result, true);
        }
      });

      this._container.addEventListener("mouseout", function (e) {
        if (_this2._stopPropagation) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        } //缓存，提高效率


        cacheTarget = null;

        if (_this2.hasTooltip()) {
          _this2.closeTooltip();
        } else if (!_this2._stopPropagation) {
          var _this2$_layer7;

          (_this2$_layer7 = _this2._layer) === null || _this2$_layer7 === void 0 ? void 0 : _this2$_layer7.closeTooltip();
        }

        var result = {
          mouseEvent: e,
          cartesian: _this2.position,
          windowPosition: {
            x: e.clientX,
            y: e.clientY
          },
          sourceTarget: _this2,
          graphic: _this2,
          layer: _this2._layer
        };

        _this2.fire(EventType.mouseOut, result);

        if (!_this2._stopPropagation) {
          var _this2$_layer8;

          (_this2$_layer8 = _this2._layer) === null || _this2$_layer8 === void 0 ? void 0 : _this2$_layer8.fire(EventType.mouseOut, result, true);
        }
      });

      this.pointerEvents = this.hasBindEvent;
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this3 = this;

      this._layer.container.appendChild(this._container);

      this.hide(); //异步处理贴地坐标 start

      var position = this.position;

      if (position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"] && (this.style.clampToGround || this.style.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND || this.style.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].RELATIVE_TO_GROUND)) {
        Object(PointUtil["getSurfaceHeight"])(this._map.scene, position, {
          asyn: true,
          //是否异步求准确高度
          has3dtiles: this.options.has3dtiles,
          callback: function callback(newHeight, cartOld) {
            if (_this3.style.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].RELATIVE_TO_GROUND) {
              newHeight += cartOld.height;
            }

            _this3.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
            delete _this3.style.clampToGround;
            delete _this3.style.heightReference;
          }
        });
      } //异步处理贴地坐标 end


      this._map.on(EventType.postRender, this._onPostRenderHandler, this);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.postRender, this._onPostRenderHandler, this);

      this.testPoint = false;
      remove(this._container);
    }
    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */

  }, {
    key: "_updateStyleBaseHook",
    value: function _updateStyleBaseHook(newStyle) {
      if (newStyle.html) {
        this.html = newStyle.html;
      }

      DivGraphicStyleConver_DivGraphicStyleConver.toCesiumVal(this.style, this);
      this._camera_cache = null;

      this._updateDivPosition();

      return this;
    }
    /**
     * 更新刷新下DIV的位置，可以外部主动驱动来更新。
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "updateDivPosition",
    value: function updateDivPosition() {
      this._camera_cache = null;

      this._updateDivPosition();

      return this;
    }
  }, {
    key: "_onPostRenderHandler",
    value: function _onPostRenderHandler(event) {
      this._updateDivPosition();
    } //图层中的postRender事件中来调用

  }, {
    key: "_updateDivPosition",
    value: function _updateDivPosition() {
      var _this$_map;

      if (!this.show || !this._map) {
        return false;
      }

      var scene = this._map.scene;
      var camera = this._map.camera;

      var _position = Object(PointUtil["getPositionValue"])(this.position, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime);

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_position)) {
        this.hide();
        return false;
      } //如果视角和位置都没有变化，直接返回


      if (this._hasCache) {
        var _thiscache = {
          x: _position.x,
          y: _position.y,
          z: _position.z,
          p1: this._map.container.clientWidth,
          p2: this._map.container.clientHeight,
          p3: camera.positionWC.x,
          p4: camera.positionWC.y,
          p5: camera.positionWC.z,
          p6: camera.heading,
          p7: camera.pitch,
          p8: camera.roll
        };

        if (this._camera_cache && _thiscache.x == this._camera_cache.x && _thiscache.x == this._camera_cache.x && _thiscache.y == this._camera_cache.y && _thiscache.z == this._camera_cache.z && _thiscache.p1 == this._camera_cache.p1 && _thiscache.p2 == this._camera_cache.p2 && _thiscache.p3 == this._camera_cache.p3 && _thiscache.p4 == this._camera_cache.p4 && _thiscache.p5 == this._camera_cache.p5 && _thiscache.p6 == this._camera_cache.p6 && _thiscache.p7 == this._camera_cache.p7 && _thiscache.p8 == this._camera_cache.p8) {
          return true;
        }

        this._camera_cache = _thiscache;
      } //如果视角和位置都没有变化，直接返回
      //贴地计算影响性能！！


      if (this.style.clampToGround || this.style.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND) {
        _position = Object(PointUtil["getSurfacePosition"])(this._map, _position);
      } else if (this.style.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].RELATIVE_TO_GROUND) {
        _position = Object(PointUtil["getSurfacePosition"])(this._map, _position, {
          relativeHeight: true
        });
      }

      var windowPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneTransforms"].wgs84ToWindowCoordinates(scene, _position);
      var camera_distance;

      if (scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        camera_distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_position, camera.positionWC);
      } else {
        camera_distance = camera.positionCartographic.height;
      }

      if (windowPosition == null || this.distanceDisplayCondition && (this.distanceDisplayCondition.near > camera_distance || this.distanceDisplayCondition.far < camera_distance)) {
        if (this._container.style.display == "block") {
          //如果node是显示则隐藏
          this.hide();
        }

        return false;
      } //判断是否在球的背面


      if (this.depthTest && scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        //三维模式下
        var occluder = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidalOccluder"](scene.globe.ellipsoid, scene.camera.positionWC);
        var show = occluder.isPointVisible(_position); //地球椭球体背面判断处理
        //visible为true说明点在球的正面，否则点在球的背面。
        //需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true

        if (!show) {
          if (this._container.style.display == "block") {
            //如果node是显示则隐藏
            this.hide();
          }

          return false;
        }
      } //判断是否在球的背面


      if (this._container.style.display != "block") {
        //如果node是隐藏的则显示node元素
        this._camera_cache = null;
        this._container.style.display = "block";
      } //求xy位置


      var height = this.divHeight; //需要是显示状态，才有值

      var width = this.divWidth;
      var x;
      var y;

      switch (this.horizontalOrigin) {
        default:
        case "LEFT":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT:
          x = windowPosition.x;
          break;

        case "CENTER":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER:
          x = windowPosition.x - width / 2;
          break;

        case "RIGHT":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].RIGHT:
          x = windowPosition.x - width;
          break;
      }

      switch (this.verticalOrigin) {
        case "TOP":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].TOP:
          y = windowPosition.y;
          break;

        case "CENTER":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].CENTER:
          y = windowPosition.y - height / 2;
          break;

        default:
        case "BOTTOM":
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM:
          y = windowPosition.y - height;
          break;
      }

      if (this.style.anchor) {
        x += this.style.anchor[0];
        y += this.style.anchor[1];
      } else {
        if (this.style.offsetX) {
          x += this.style.offsetX;
        }

        if (this.style.offsetY) {
          y += this.style.offsetY;
        }
      } //求缩放比例


      var scale = 1;

      if (this.scaleByDistance) {
        var sc = this.scaleByDistance; //Cesium.NearFarScalar

        if (camera_distance <= sc.near) {
          scale = sc.nearValue;
        } else if (camera_distance > sc.near && camera_distance < sc.far) {
          // near 10000, nearValue  1.0,, far 100000, farValue  0.1
          scale = sc.nearValue + (sc.farValue - sc.nearValue) * (camera_distance - sc.near) / (sc.far - sc.near);
        } else {
          scale = sc.farValue;
        }
      }

      var css_transform = "matrix(" + scale + ",0,0," + scale + "," + x + "," + y + ")";
      var css_transform_origin = this._css_transform_origin;
      var zIndex = "auto";

      if (this._hasZIndex) {
        zIndex = Math.round(9999999 - camera_distance);

        if (zIndex <= 0) {
          zIndex = 9999999;
        }
      }

      Object(Util["merge"])(this._container.style, {
        transform: css_transform,
        "transform-origin": css_transform_origin,
        "-ms-transform": css_transform
        /* IE 9 */
        ,
        "-ms-transform-origin": css_transform_origin,
        "-webkit-transform": css_transform
        /* Safari 和 Chrome */
        ,
        "-webkit-transform-origin": css_transform_origin,
        "-moz-transform": css_transform
        /* Firefox */
        ,
        "-moz-transform-origin": css_transform_origin,
        "-o-transform": css_transform
        /* Opera */
        ,
        "-o-transform-origin": css_transform_origin,
        "z-index": zIndex
      });
      this.fire(EventType.change, {
        position: _position,
        windowPosition: windowPosition,
        distance: camera_distance,
        x: x,
        y: y,
        height: height,
        width: width,
        scale: scale
      }, true);
    }
    /**
     * 隐藏当前对象
     * @return {void}  无
     */

  }, {
    key: "hide",
    value: function hide() {
      this._container.style.display = "none";
      this._camera_cache = null;
    }
  }, {
    key: "_getGeoJsonGeometry",
    value: function _getGeoJsonGeometry() {
      return {
        type: "Point",
        coordinates: this.coordinate
      };
    }
    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LatLngPoint|Cesium.Cartesian3} point 指定位置坐标
     * @param {Cesium.JulianDate|String|Number} [currTime=Cesium.JulianDate.now()] 指定时间, 默认为当前时间5秒后。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addDynamicPosition",
    value: function addDynamicPosition(point, currTime) {
      if (!this.property) {
        var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
        property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.forwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
        property.backwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.backwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);

        if (!this.options.orientation) {
          this.options.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](property);

          if (this._entity) {
            this._entity.orientation = this.getOrientation();
          }
        }

        this.property = property;
        this.position = property;
        this._cacheTimes = [];
        this._maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxCacheCount, 50); //保留的坐标点数量
      } else if (this.property !== this.position) {
        this.position = this.property;
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now();
      } else if (Object(Util["isNumber"])(currTime)) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now(), currTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      } else if (Object(Util["isString"])(currTime)) {
        if (currTime.indexOf("Z") == -1) {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(currTime));
        } else {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(currTime);
        }
      } else if (currTime instanceof Date) {
        currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(currTime);
      }

      var pt = LatLngPoint["a" /* LatLngPoint */].parse(point).toCartesian();
      this.position.addSample(currTime, pt);
      this._lastTime = currTime;

      this._cacheTimes.push(this._lastTime);

      return this;
    }
  }, {
    key: "_removeDynamicPosition",
    value: function _removeDynamicPosition() {
      var duoyu = this._cacheTimes.length - this._maxCacheCount;

      if (duoyu > 0) {
        var start = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(this._cacheTimes[0], -0.1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
        var stop = this._cacheTimes[duoyu - 1];
        this.position.removeSamples(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
          start: start,
          stop: stop
        }));

        this._cacheTimes.splice(0, duoyu);
      }
    } //==================Draw绘制相关=================

    /**
     * 开始绘制创建矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {DivLayer} layer 图层
     * @return {void}  无
     */

  }, {
    key: "startDraw",
    value: function startDraw(layer) {
      if (this._enabledDraw) {
        return this;
      }

      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }

      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map");
      }

      this._map.setCursor(true);

      this.enableControl(false);

      this._startDrawHook();

      this.fire(EventType.drawStart, {
        drawtype: this.type,
        graphic: this
      }, true);
    }
    /**
     * 停止绘制，如有未完成的绘制会自动删除
     * @return {void}  无
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      if (!this._enabledDraw) {
        return this;
      }

      this._stopDrawHook();

      this._map.setCursor(false);

      this.enableControl(true);

      this._map.closeSmallTooltip();

      this._enabledDraw = false;
      this.fire(EventType.drawCreated, {
        drawtype: this.type,
        graphic: this
      }, true);
    }
  }, {
    key: "_startDrawHook",
    value: function _startDrawHook() {
      this.pointerEvents = false;

      this._map.on(EventType.mouseMove, this._onMouseMoveHandler_point, this);

      this._map.on(EventType.click, this._onClickHandler_point, this);
    }
  }, {
    key: "_stopDrawHook",
    value: function _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler_point, this);

      this._map.off(EventType.click, this._onClickHandler_point, this);

      this.pointerEvents = this.hasBindEvent;
    }
  }, {
    key: "_onMouseMoveHandler_point",
    value: function _onMouseMoveHandler_point(event) {
      var point = event.cartesian;

      if (point) {
        this.position = point;
      }

      this._map.openSmallTooltip(event.endPosition, this._draw_tooltip || this._map.getLangText("_单击完成绘制"));

      this.fire(EventType.drawMouseMove, DivGraphic_objectSpread(DivGraphic_objectSpread({}, event), {}, {
        drawtype: this.type,
        graphic: this
      }), true);
    }
  }, {
    key: "_onClickHandler_point",
    value: function _onClickHandler_point(event) {
      var point = event.cartesian;

      if (point) {
        this.position = point;
      }

      this.stopDraw();
    }
  }, {
    key: "_setPositionsToCallback",
    value: function _setPositionsToCallback() {}
    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {void}  无
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (!this._enabledDraw) {
        return this;
      } //点数不够


      if (this._positions_draw.length < this._minPointNum) {
        return;
      }

      this.updateAttrForDrawing(false);
      this.stopDraw();
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isEditing) {}
    /**
     * 启用或禁用popup、tooltip、contextmenu内部控件，
     * 主要用于标绘时来关闭避免交互冲突。
     * @param {Boolean} value 是否启用
     * @return {void}  无
     */

  }, {
    key: "enableControl",
    value: function enableControl(value) {
      this._map.mouseEvent.enabledMoveTarget = value;

      if (this._map.popup) {
        this._map.popup.enabled = value;
      }

      if (this._map.tooltip) {
        this._map.tooltip.enabled = value;
      }

      if (this._map.contextmenu) {
        this._map.contextmenu.enabled = value;
      }
    } //==================Draw编辑相关=================

    /**
     * 开始编辑对象
     * @return {void}  无
     */

  }, {
    key: "startEditing",
    value: function startEditing() {
      if (this._enabledEdit) {
        return this;
      }

      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到图层，并且图层已添加到Map");
      }

      this.pointerEvents = false;
      this._draw_tooltip = this._map.getLangText("_释放后完成修改");
      this.enableControl(false);

      if (!this.editing) {
        this.editing = new EditDivGraphic_EditDivGraphic(this);
      }

      if (this.editing.activate) {
        this.editing.activate();
      }
    }
    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */

  }, {
    key: "stopEditing",
    value: function stopEditing() {
      var _this$editing;

      if (!this._enabledEdit) {
        return this;
      }

      if ((_this$editing = this.editing) !== null && _this$editing !== void 0 && _this$editing.disable) {
        this.editing.disable();
      }

      this.enableControl(true);

      this._map.closeSmallTooltip();

      this.pointerEvents = this.hasBindEvent;
      this._enabledEdit = false;
    } //==================静态方法=================

    /**
     * 通过标绘 来创建DivGraphic
     *
     * @static
     * @param {DivLayer} layer 图层
     * @param {Object} options DivGraphic的构造参数
     * @return {DivGraphic} DIV点对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DivGraphic(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return DivGraphic;
}(BaseGraphic_BaseGraphic); //对类是否为点状数据的判断,GraphicUtil内用到

DivGraphic_DivGraphic.isPoint = true; //注册下

Object(GraphicUtil["register"])("div", DivGraphic_DivGraphic);
// CONCATENATED MODULE: ./src/graphic/custom/DivBoderLabel.js







function DivBoderLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DivBoderLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DivBoderLabel_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DivBoderLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DivBoderLabel_createSuper(Derived) { var hasNativeReflectConstruct = DivBoderLabel_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivBoderLabel_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 动态边框文本 支持的样式信息
 *
 * @typedef {Object} DivBoderLabel.StyleOptions
 *
 * @property {String} text 文本内容
 * @property {Number} [font_size = 15] 字体大小
 * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
 * @property {String} [color = "#ccc"] 文本CSS颜色
 * @property {String} [boderColor = "rgb(21, 209, 242)"] 边框CSS颜色
 * @property {Number} [width] 面板宽度（px像素值），默认根据文本内容和字体大小自动计算
 * @property {Number} [height] 面板高度（px像素值），默认根据文本内容和字体大小自动计算
 *
 * @property {DivGraphic.StyleOptions} [其他] 支持父类的其他样式
 *
 */

var DivBoderLabel_DEF_STYLE = {
  font_size: 15,
  font_family: "楷体",
  color: "#ccc",
  boderColor: "rgb(21, 209, 242)",
  horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
  verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].CENTER
};
/**
 * 动态边框文本 DIV点
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {DivBoderLabel.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
 * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
 * @param {Boolean} [options.stopPropagation=false] DIV中的鼠标事件是否停止冒泡
 * @param {Boolean} [options.pointerEvents] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
 *
 * @export
 * @class DivBoderLabel
 * @extends {DivGraphic}
 * @see [支持的事件类型]{@link DivGraphic.EventType}
 */

var DivBoderLabel_DivBoderLabel = /*#__PURE__*/function (_DivGraphic) {
  inherits_default()(DivBoderLabel, _DivGraphic);

  var _super = DivBoderLabel_createSuper(DivBoderLabel);

  function DivBoderLabel() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DivBoderLabel);

    options.style = DivBoderLabel_objectSpread(DivBoderLabel_objectSpread({}, DivBoderLabel_DEF_STYLE), options.style || {});
    var color = options.style.color;
    var boderColor = options.style.boderColor;
    var shadowColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(boderColor).withAlpha(0.56).toCssColorString();
    var font_size = options.style.font_size;
    var width = options.style.width || Object(Util["getStrLength"])(options.style.text) * font_size * 0.6;
    var height = options.style.height || font_size * 2;
    options.style.html = "\n     <div class=\"tudou3d-divBoderLabel\" style=\"\n     --text-font-size: ".concat(font_size, "px;\n     --boder-width: ").concat(width, "px;\n     --clip-width-1: ").concat(width + font_size, "px;\n     --clip-width-2: ").concat(width + font_size - 2, "px;\n     --boder-height: ").concat(height, "px;\n     --clip-height-1: ").concat(height + 10, "px;\n     --clip-height-2: ").concat(height + 8, "px;\n     --text-color: ").concat(color, ";\n     --border-color: ").concat(boderColor, ";\n     --box-shadow-color: ").concat(shadowColor, ";\">\n        <div class=\"tudou3d-divBoderLabel-boder\">\n          <span class=\"tudou3d-divBoderLabel-text\" style=\"font-family:").concat(options.style.font_family, ";\">").concat(options.style.text, "</span>\n        </div>\n     </div> ");
    _this = _super.call(this, options);
    _this._divWidth = width;
    _this._divHeight = height;
    return _this;
  }

  createClass_default()(DivBoderLabel, [{
    key: "divWidth",
    get: function get() {
      return this._divWidth;
    }
  }, {
    key: "divHeight",
    get: function get() {
      return this._divHeight;
    } //==================静态方法=================

    /**
     * 通过标绘 来创建DivGraphic
     *
     * @static
     * @param {DivLayer} layer 图层
     * @param {Object} options DivGraphic的构造参数
     * @return {DivGraphic} DIV点对象
     */

  }], [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DivBoderLabel(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return DivBoderLabel;
}(DivGraphic_DivGraphic); //注册下

Object(GraphicUtil["register"])("divBoderLabel", DivBoderLabel_DivBoderLabel);
// CONCATENATED MODULE: ./src/graphic/custom/DivLightPoint.js







function DivLightPoint_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DivLightPoint_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DivLightPoint_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DivLightPoint_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DivLightPoint_createSuper(Derived) { var hasNativeReflectConstruct = DivLightPoint_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivLightPoint_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 动画的扩散div点 支持的样式信息
 *
 * @typedef {Object} DivLightPoint.StyleOptions
 *
 * @property {String} [color='#f33349'] CSS颜色
 * @property {DivGraphic.StyleOptions} [其他] 支持父类的其他样式
 *
 */

var DivLightPoint_DEF_STYLE = {
  color: "#f33349",
  horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
  verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].CENTER
};
/**
 * 动画的扩散div点
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {DivLightPoint.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
 * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
 * @param {Boolean} [options.stopPropagation=false] DIV中的鼠标事件是否停止冒泡
 * @param {Boolean} [options.pointerEvents] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
 *
 * @export
 * @class DivLightPoint
 * @extends {DivGraphic}
 * @see [支持的事件类型]{@link DivGraphic.EventType}
 */

var DivLightPoint_DivLightPoint = /*#__PURE__*/function (_DivGraphic) {
  inherits_default()(DivLightPoint, _DivGraphic);

  var _super = DivLightPoint_createSuper(DivLightPoint);

  function DivLightPoint() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DivLightPoint);

    options.style = DivLightPoint_objectSpread(DivLightPoint_objectSpread({}, DivLightPoint_DEF_STYLE), options.style || {});
    options.style.html = "<div class=\"tudou3d-animation-point\" style=\"color:".concat(options.style.color, ";\"><p></p></div>");
    return _super.call(this, options);
  } //==================静态方法=================

  /**
   * 通过标绘 来创建DivGraphic
   *
   * @static
   * @param {DivLayer} layer 图层
   * @param {Object} options DivGraphic的构造参数
   * @return {DivGraphic} DIV点对象
   */


  createClass_default()(DivLightPoint, null, [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DivLightPoint(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return DivLightPoint;
}(DivGraphic_DivGraphic); //注册下

Object(GraphicUtil["register"])("divLightPoint", DivLightPoint_DivLightPoint);
// CONCATENATED MODULE: ./src/graphic/custom/DivUpLabel.js







function DivUpLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DivUpLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DivUpLabel_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DivUpLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DivUpLabel_createSuper(Derived) { var hasNativeReflectConstruct = DivUpLabel_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivUpLabel_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 竖立的文本 支持的样式信息
 *
 * @typedef {Object} DivUpLabel.StyleOptions
 *
 * @property {String} text 文本内容
 * @property {String} [color = "white"] 文本CSS颜色
 * @property {Number} [font_size = 15] 字体大小
 * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
 * @property {Number} [lineHeight = 100] 底部线的高度值（单位：px像素）
 * @property {Number} [circleSize = 10] 底部圆圈的大小（单位：px像素）
 *
 * @property {DivGraphic.StyleOptions} [其他] 支持父类的其他样式
 *
 */

var DivUpLabel_DEF_STYLE = {
  color: "white",
  font_family: "楷体",
  font_size: 15,
  lineHeight: 100,
  circleSize: 10,
  horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
  verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
};
/**
 * 竖立的文本 DIV点
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {DivUpLabel.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
 * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
 * @param {Boolean} [options.stopPropagation=false] DIV中的鼠标事件是否停止冒泡
 * @param {Boolean} [options.pointerEvents] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
 * @param {Boolean} [options.hasEdit=true] 是否允许编辑
 *
 * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
 *
 * @export
 * @class DivUpLabel
 * @extends {DivGraphic}
 * @see [支持的事件类型]{@link DivGraphic.EventType}
 */

var DivUpLabel_DivUpLabel = /*#__PURE__*/function (_DivGraphic) {
  inherits_default()(DivUpLabel, _DivGraphic);

  var _super = DivUpLabel_createSuper(DivUpLabel);

  function DivUpLabel() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DivUpLabel);

    options.style = DivUpLabel_objectSpread(DivUpLabel_objectSpread({}, DivUpLabel_DEF_STYLE), options.style || {});
    var color = options.style.color;
    var circleSize = options.style.circleSize;
    options.style.html = "\n    <div class=\"tudou3d-divUpLabel\" style=\"color: ".concat(color, ";\">\n      <div class=\"tudou3d-divUpLabel-text\" style=\"font-family:").concat(options.style.font_family, ";font-size: ").concat(options.style.font_size, "px;\">").concat(options.style.text, "</div>\n      <div class=\"tudou3d-divUpLabel-line\"  style=\"\n          height: ").concat(options.style.lineHeight, "px;\n          background-color: ").concat(color, ";\"></div>\n      <div style=\"border-radius: 50%;\n          width: ").concat(circleSize, "px;\n          height: ").concat(circleSize, "px;\n          margin-left: calc(50% - ").concat(circleSize / 2, "px);\n          background-color: ").concat(color, ";\"></div>\n    </div> ");
    return _super.call(this, options);
  } //==================静态方法=================

  /**
   * 通过标绘 来创建DivGraphic
   *
   * @static
   * @param {DivLayer} layer 图层
   * @param {Object} options DivGraphic的构造参数
   * @return {DivGraphic} DIV点对象
   */


  createClass_default()(DivUpLabel, null, [{
    key: "fromDraw",
    value: function fromDraw(layer, options) {
      var graphic = new DivUpLabel(options);
      graphic.startDraw(layer);
      return graphic;
    }
  }]);

  return DivUpLabel;
}(DivGraphic_DivGraphic); //注册下

Object(GraphicUtil["register"])("divUpLabel", DivUpLabel_DivUpLabel);
// CONCATENATED MODULE: ./src/graphic/custom/ParticleSystem.js







function ParticleSystem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ParticleSystem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ParticleSystem_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ParticleSystem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ParticleSystem_createSuper(Derived) { var hasNativeReflectConstruct = ParticleSystem_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ParticleSystem_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var ParticleSystem_DEF_STYLE = {
  startColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].LIGHTCYAN.withAlpha(0.3),
  //粒子出生时的颜色
  endColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(0.0),
  //当粒子死亡时的颜色
  imageSize: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](25, 25),
  //粒子图片的Size大小（单位：像素）
  // scale:1.0,//粒子的比例
  startScale: 2.0,
  //粒子在出生时的比例（单位：相对于imageSize大小的倍数）
  endScale: 4.0,
  //粒子在死亡时的比例（单位：相对于imageSize大小的倍数）
  // particleLife:1.1, //粒子存在的时间（单位：秒）
  minimumParticleLife: 1.1,
  //粒子可能存在的最短寿命时间，实际寿命将随机生成（单位：秒）
  maximumParticleLife: 3.1,
  //粒子可能存在的最长寿命时间，实际寿命将随机生成（单位：秒）
  // speed:1.0,//粒子初速度
  minimumSpeed: 1.0,
  //粒子初速度的最小界限，超过该最小界限，随机选择粒子的实际速度。（单位：米/秒）
  maximumSpeed: 2.0,
  //粒子初速度的最大界限，超过该最大界限，随机选择粒子的实际速度。（单位：米/秒）
  emissionRate: 100,
  //粒子发射器的发射速率 （单位：次/秒）
  loop: true,
  //是否循环
  lifetime: 16.0,
  //生命周期（单位：秒）
  // bursts: [//而粒子会在5s、10s、15s时分别进行一次粒子大爆发
  //     new Cesium.ParticleBurst({ time: 5.0, minimum: 10, maximum: 100 }),  // 当在5秒时，发射的数量为10-100
  //     new Cesium.ParticleBurst({ time: 10.0, minimum: 50, maximum: 100 }), // 当在10秒时，发射的数量为50-100
  //     new Cesium.ParticleBurst({ time: 15.0, minimum: 200, maximum: 300 })  // 当在15秒时，发射的数量为200-300
  // ],
  emitter: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CircleEmitter"](2.0) //此系统的粒子发射器(指定方向)，  共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类

};
/**
 * 粒子效果 支持的样式信息
 *
 * @typedef {Object} ParticleSystem.StyleOptions
 *
 * @property {String} [image] 粒子的图片URL
 * @property {ParticleEmitter} [emitter=new CircleEmitter(2.0)]  系统的粒子发射器。
 * @property {Number} [emissionRate=5] 每秒发射的粒子数。
 * @property {ParticleBurst[]} [bursts] {@link ParticleBurst}的数组，周期性地发射粒子爆发。
 * @property {Boolean} [loop=true] 粒子系统完成后是否应该循环爆发。
 *
 * @property {Number} [particleSize=25] 粒子图片的Size大小（单位：像素）
 * @property {Cartesian2} [imageSize=new Cartesian2(1.0, 1.0)] 粒子图片的Size大小（单位：像素），与particleSize二选一。
 * @property {Cartesian2} [minimumImageSize] 设置最小边界，宽度和高度，在此之上随机缩放粒子图像的像素尺寸。
 * @property {Cartesian2} [maximumImageSize] 设置最大边界，宽度和高度，在其以下随机缩放粒子图像的像素尺寸。
 * @property {Boolean} [sizeInMeters] 设置粒子的大小是米还是像素。true以米为单位设置粒子的大小;否则，大小以像素为单位。
 * @property {Number} [scale=1.0] 设置在粒子生命周期内应用于粒子图像的比例。
 * @property {Number} [startScale] 粒子在出生时的比例（单位：相对于imageSize大小的倍数）
 * @property {Number} [endScale] 粒子在死亡时的比例（单位：相对于imageSize大小的倍数）
 * @property {Color} [color=Color.WHITE] 设置一个粒子在其生命周期内的颜色。
 * @property {Color} [startColor] 粒子出生时的颜色
 * @property {Color} [endColor] 当粒子死亡时的颜色
 * @property {Number} [speed=1.0] 如果设置，则使用此值覆盖最小速度和最大速度输入。
 * @property {Number} [minimumSpeed] 设定以每秒米为单位的最小范围，超过这个范围粒子的实际速度将被随机选择。
 * @property {Number} [maximumSpeed] 设定以每秒米为单位的最大范围，低于这个范围粒子的实际速度将被随机选择。
 * @property {Number} [lifetime=Number.MAX_VALUE] 粒子系统释放粒子的时间，单位是秒。
 * @property {Number} [particleLife=5.0]  如果设置了这个值，将覆盖minimumParticleLife和maximumParticleLife输入。
 * @property {Number} [minimumParticleLife] 设定一个粒子生命可能持续时间的最小界限(以秒为单位)，在此之上一个粒子的实际生命将被随机选择。
 * @property {Number} [maximumParticleLife] 设置一个粒子生命可能持续时间的最大界限(以秒为单位)，低于这个时间的粒子的实际生命将被随机选择。
 * @property {Number} [mass=1.0] 设定粒子的最小和最大质量，单位为千克。
 * @property {Number} [minimumMass] 设定粒子质量的最小边界，单位为千克。一个粒子的实际质量将被选为高于这个值的随机数量。
 * @property {Number} [maximumMass] 设置粒子的最大质量，单位为千克。一个粒子的实际质量将被选为低于这个值的随机数量。
 *
 * @property {ParticleSystem.updateCallback} [updateCallback] 每一帧调用一个回调函数来更新一个粒子。
 *
 */

/**
 * 粒子效果 对象
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 坐标位置
 * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
 * @param {ParticleSystem.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 *
 * @param {Number} [options.gravity=0] 重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）
 * @param {Cesium.Cartesian3} [options.target=new Cesium.Cartesian3(0, 0, 0)] 粒子的方向，粒子喷射的目标方向。
 * @param {Number} [options.transZ=0] 离地高度，Z轴方向上的偏离距离（单位：米）
 * @param {Number} [options.transX=0] X轴方向上的偏离距离（单位：米）
 * @param {Number} [options.transY=0] Y轴方向上的偏离距离（单位：米）
 * @param {Number} [options.maxHeight=5000] 最大视角高度（单位：米），超出该高度不显示粒子效果
 * @param {Boolean} [options.hasDefUpdate=true] 是否内部自动处理 updateCallback
 *
 * @export
 * @class ParticleSystem
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BaseGraphic.EventType}
 */

var ParticleSystem_ParticleSystem = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(ParticleSystem, _BasePointPrimitive);

  var _super = ParticleSystem_createSuper(ParticleSystem);

  function ParticleSystem() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ParticleSystem);

    options.style = ParticleSystem_objectSpread(ParticleSystem_objectSpread({}, ParticleSystem_DEF_STYLE), options.style || {});
    _this = _super.call(this, options);
    _this.options.maxHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.maxHeight, 5000);
    _this.options.target = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.target, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0)); //内部数据

    _this.emitterModelMatrix = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();
    _this.translation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
    _this.rotation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"]();
    _this.hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"]();
    _this.trs = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TranslationRotationScale"]();
    return _this;
  } //========== 对外属性 ==========


  createClass_default()(ParticleSystem, [{
    key: "czmObject",
    get: function get() {
      return this._particleSystem;
    }
    /**
     * 最大视角高度（单位：米），超出该高度不显示粒子效果
     * @type {Number}
     */

  }, {
    key: "maxHeight",
    get: function get() {
      return this.options.maxHeight || 0;
    },
    set: function set(val) {
      this.options.maxHeight = val;
    }
    /**
     * 重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）
     * @type {Number}
     */

  }, {
    key: "gravity",
    get: function get() {
      return this.options.gravity || 0;
    },
    set: function set(val) {
      this.options.gravity = val;
    }
    /**
     * X轴方向上的偏离距离（单位：米）
     * @type {Number}
     */

  }, {
    key: "transX",
    get: function get() {
      return this.options.transX || 0;
    },
    set: function set(val) {
      this.options.transX = val;
    }
    /**
     * Y轴方向上的偏离距离（单位：米）
     * @type {Number}
     */

  }, {
    key: "transY",
    get: function get() {
      return this.options.transY || 0;
    },
    set: function set(val) {
      this.options.transY = val;
    }
    /**
     * 离地高度，Z轴方向上的偏离距离（单位：米）
     * @type {Number}
     */

  }, {
    key: "transZ",
    get: function get() {
      return this.options.transZ || 0;
    },
    set: function set(val) {
      this.options.transZ = val;
    }
    /**
     *  粒子的方向，粒子喷射的目标方向。
     * @type {Cesium.Cartesian3}
     */

  }, {
    key: "target",
    get: function get() {
      return this.options.target;
    },
    set: function set(val) {
      this.options.target = val;
    }
    /**
     *  粒子图片的Size大小（单位：像素）
     * @type {Number}
     */

  }, {
    key: "particleSize",
    get: function get() {
      return this.style.particleSize || 25;
    },
    set: function set(val) {
      this.style.particleSize = val;

      if (this._particleSystem) {
        this._particleSystem.minimumImageSize.x = val;
        this._particleSystem.minimumImageSize.y = val;
        this._particleSystem.maximumImageSize.x = val;
        this._particleSystem.maximumImageSize.y = val;
      }
    } //========== 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      //默认值
      var psOptions = ParticleSystem_objectSpread(ParticleSystem_objectSpread({
        imageSize: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](this.particleSize, this.particleSize),
        //粒子图片的Size大小（单位：像素）
        modelMatrix: this.options.modelMatrix || this._computeModelMatrix(this._map.clock.currentTime),
        // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标
        emitterModelMatrix: this.options.emitterModelMatrix || this._computeEmitterModelMatrix(this)
      }, this.style), {}, {
        show: this.show
      });

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.hasDefUpdate, true)) {
        var that = this; //回调函数，参数是(particle,dt)，分别是单个粒子的属性和两次发射之间的时间间隔(单位:s)

        psOptions.updateCallback = function (particle, dt) {
          var translatCar3 = that.target.clone();
          var position = particle.position;
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(particle.position, translatCar3, particle.position);
          var gravityScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(position, gravityScratch);
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(gravityScratch, that.gravity * dt, gravityScratch);
          particle.velocity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(particle.velocity, gravityScratch, particle.velocity);
        };
      } //构造粒子对象


      this._particleSystem = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ParticleSystem"](psOptions);
      this.primitiveCollection.add(this._particleSystem);

      this._map.on(EventType.preUpdate, this._scene_preUpdateHandler, this);

      this._map.on(EventType.cameraChanged, this._camera_changedHandler, this);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.preUpdate, this._scene_preUpdateHandler, this);

      this._map.off(EventType.cameraChanged, this._camera_changedHandler, this);

      this.primitiveCollection.remove(this._particleSystem);
    }
  }, {
    key: "_scene_preUpdateHandler",
    value: function _scene_preUpdateHandler(scene, time) {
      if (!this._particleSystem) {
        return;
      }

      this._particleSystem.modelMatrix = this._computeModelMatrix(time);
      this._particleSystem.emitterModelMatrix = this._computeEmitterModelMatrix(this);
    }
  }, {
    key: "_computeModelMatrix",
    value: function _computeModelMatrix(time) {
      if (this.position) {
        var modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this.position); // var hprRotation = Cesium.Matrix3.fromHeadingPitchRoll(new Cesium.HeadingPitchRoll(2.619729, 0.0, 0.0));
        // var hpr = Cesium.Matrix4.fromRotationTranslation(hprRotation, new Cesium.Cartesian3(0.0, 0.0, -2.0));
        // Cesium.Matrix4.multiply(modelMatrix, hpr, modelMatrix);

        return modelMatrix;
      } else if (this.options.modelMatrix) {
        return this.options.modelMatrix(time);
      }
    }
  }, {
    key: "_computeEmitterModelMatrix",
    value: function _computeEmitterModelMatrix(that) {
      that.hpr = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"].fromDegrees(0, 0, 0, that.hpr);
      that.trs.translation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromElements(that.transX, that.transY, that.transZ, that.translation);
      that.trs.rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"].fromHeadingPitchRoll(that.hpr, that.rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromTranslationRotationScale(that.trs, that.emitterModelMatrix); // var translatCar3 = new Cesium.Cartesian3(-2, -2, 2);
      // Cesium.Matrix4.multiplyByTranslation(that.emitterModelMatrix, translatCar3, that.emitterModelMatrix);

      return that.emitterModelMatrix;
    }
  }, {
    key: "_camera_changedHandler",
    value: function _camera_changedHandler(event) {
      //加控制，只在相机高度低于一定高度时才开启本效果
      if (this._map.camera.positionCartographic.height < this.maxHeight) {
        if (this._particleSystem.show != this.show) {
          this._particleSystem.show = this.show;
        }
      } else {
        if (this._particleSystem.show) {
          this._particleSystem.show = false;
        }
      }
    }
  }]);

  return ParticleSystem;
}(BasePointPrimitive_BasePointPrimitive); //注册下

Object(GraphicUtil["register"])("particleSystem", ParticleSystem_ParticleSystem);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Video3D.glsl
var PostProcessStage_Video3D = __webpack_require__(77);
var Video3D_default = /*#__PURE__*/__webpack_require__.n(PostProcessStage_Video3D);

// CONCATENATED MODULE: ./src/graphic/custom/Video3D.js







function Video3D_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Video3D_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Video3D_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Video3D_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Video3D_createSuper(Derived) { var hasNativeReflectConstruct = Video3D_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Video3D_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








var Video3DType = {
  Color: 1,
  Image: 2,
  Video: 3,
  Text: 4
};
var Video3D_RatateDirection = {
  LEFT: "Z",
  RIGHT: "-Z",
  TOP: "Y",
  BOTTOM: "-Y",
  ALONG: "X",
  INVERSE: "-X"
};
var Video3D_DEF_STYLE = {
  opacity: 1.0 //透明度

};
/**
 * 视频融合（投射3D，贴物体表面） 支持的样式信息
 *
 * @typedef {Object} Video3D.StyleOptions
 *
 * @property {Number} opacity 混合系数 0.0 - 1.0
 * @property {Object} camera 相机方向参数
 * @property {Cesium.Cartesian3} camera.direction direction方向
 * @property {Cesium.Cartesian3} camera.up up方向
 * @property {Cesium.Cartesian3} camera.right right方向
 * @property {Number} aspectRatio 相机视野的宽高比例（垂直张角）
 * @property {Number} fov 张角(弧度值)
 * @property {Number} fovDegree 张角(角度值，0-180度)
 * @property {Cesium.Color} [hiddenAreaColor=new Cesium.Color(0, 0, 0, 0.5)] 无视频投影区域的颜色
 *
 *
 * @property {Cesium.Color} [color] 当type为颜色时的，投射的颜色值
 *
 * @property {String} [text] 当为text文本时的，传入的文本内容
 * @property {Object} [textStyles] 当为text文本时的，文本样式，包括:
 * @property {String} [textStyles.font='23px 楷体'] 使用的CSS字体。
 * @property {String} [textStyles.textBaseline='top'] 文本的基线。
 * @property {Boolean} [textStyles.fill=true] 是否填充文本。
 * @property {Boolean} [textStyles.stroke=true] 是否描边文本。
 * @property {Cesium.Color} [textStyles.fillColor=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 填充颜色。
 * @property {Cesium.Color} [textStyles.strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
 * @property {Number} [textStyles.strokeWidth=2] 描边的宽度。
 * @property {vColor} [textStyles.backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
 * @property {Number} [textStyles.padding=10] 要在文本周围添加的填充的像素大小。
 *
 */

/**
 * 视频融合（投射3D，贴物体表面）
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 视点位置
 * @param {LatLngPoint|Cesium.Cartesian3} options.cameraPosition 相机位置
 *
 *
 * @param {Video3D.Type} options.type 投射的类型
 * @param {Video3D.StyleOptions}options.style 样式信息
 * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
 * @param {String} [options.url] 当为图片或视频类型时，传入的图片或视频的路径
 * @param {HTMLElement|Object} [options.dom] 当为视频类型时，传入了视频容器DOM，与url二选一
 * @param {Boolean} [options.showFrustum=true] 是否显示视椎体框线
 *
 * @export
 * @class Video3D
 * @extends {BasePointPrimitive}
 * @see [支持的事件类型]{@link BaseGraphic.EventType}
 */

var Video3D_Video3D = /*#__PURE__*/function (_BasePointPrimitive) {
  inherits_default()(Video3D, _BasePointPrimitive);

  var _super = Video3D_createSuper(Video3D);

  //原理：在可视域的基础上，着色器里传入纹理，再计算UV进行贴图
  //========== 构造方法 ==========
  function Video3D() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Video3D);

    options.style = Video3D_objectSpread(Video3D_objectSpread({}, Video3D_DEF_STYLE), options.style || {});
    _this = _super.call(this, options);
    _this.cameraPosition = options.cameraPosition; //相机位置

    if (!_this.cameraPosition || !_this.position) {
      Object(Log["logError"])("初始化失败：请确认相机位置与视点位置正确！");
      return possibleConstructorReturn_default()(_this);
    }

    _this._videoPlay = true;
    _this._showFrustum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.showFrustum, true); //显示视椎体

    _this._clearBlack = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.clearBlack, false); //消除鱼眼视频的黑色

    _this._hiddenAreaColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.style.hiddenAreaColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 0, 0, 0.5)); //无视频投影区域的颜色
    //style

    if (_this.style.fov) {
      _this.fov = _this.style.fov;
    } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this.style.fovDegree)) {
      _this.fovDegree = _this.style.fovDegree;
    }

    if (_this.style.camera) {
      _this._camera = _this.style.camera;
    } //传入了DOM


    if (options.dom) {
      _this.dom = options.dom;

      if (_this.dom instanceof HTMLElement) {
        _this.dom = options.dom;
      }

      if (options.dom instanceof Object && options.dom.length) {
        _this.dom = options.dom[0];
      }
    } //传入了URL


    _this.url = options.url; //url

    return _this;
  } //========== 对外属性 ==========


  createClass_default()(Video3D, [{
    key: "czmObject",
    get: function get() {
      return this._postProcess;
    }
    /**
     * 相机位置(笛卡尔坐标)
     * @type {Cesium.Cartesian3}
     */

  }, {
    key: "cameraPosition",
    get: function get() {
      return this._cameraPosition;
    },
    set: function set(value) {
      var _this$_cameraPoint;

      this._cameraPoint = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._cameraPosition = (_this$_cameraPoint = this._cameraPoint) === null || _this$_cameraPoint === void 0 ? void 0 : _this$_cameraPoint.toCartesian();

      this._updateDraw(true);
    }
    /**
     * 相机位置
     * @type {LatLngPoint}
     */

  }, {
    key: "cameraPoint",
    get: function get() {
      return this._cameraPoint;
    }
    /**
     * 相机位置 (数组对象)，示例[113.123456,31.123456,30.1]
     * @type {LatLngPoint}
     */

  }, {
    key: "cameraCoordinate",
    get: function get() {
      return this._cameraPoint.toArray();
    }
    /**
     * 混合系数0-1
     * @type {Number}
     */

  }, {
    key: "opacity",
    get: function get() {
      return this.style.opacity;
    },
    set: function set(val) {
      this.style.opacity = val;
    }
    /**
     * 相机视野的宽高比例（垂直张角）
     * @type {Number}
     */

  }, {
    key: "aspectRatio",
    get: function get() {
      return this._aspectRatio;
    },
    set: function set(val) {
      this._aspectRatio = val;

      this._updateDraw();
    }
    /**
     * 相机水平张角 (弧度值)
     * @type {Number}
     */

  }, {
    key: "fov",
    get: function get() {
      return this.style.fov || 0;
    },
    set: function set(val) {
      this.style.fov = val;

      this._updateDraw();
    }
    /**
     * 相机水平张角(角度值，0-180度)
     * @type {Number}
     */

  }, {
    key: "fovDegree",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.fov);
    },
    set: function set(val) {
      this.fov = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val);
    }
    /**
     * 是否显示视椎体框线
     * @type {Boolean}
     */

  }, {
    key: "showFrustum",
    get: function get() {
      return this._showFrustum;
    },
    set: function set(val) {
      this._showFrustum = val;
      this.cameraFrustum.show = val;
    }
    /**
     * 暂停或播放 视频
     * @type {Boolean}
     */

  }, {
    key: "play",
    get: function get() {
      return this._videoPlay;
    },
    set: function set(val) {
      this._videoPlay = Boolean(val);

      if (this.videoElement) {
        try {
          if (this.videoPlay) {
            this.videoElement.play();
          } else {
            this.videoElement.pause();
          }
        } catch (e) {//规避浏览器权限异常
        }
      }
    }
    /**
     * 无视频投影区域的颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "hiddenAreaColor",
    get: function get() {
      return this._hiddenAreaColor;
    },
    set: function set(color) {
      if (!color) {
        return;
      }

      this._hiddenAreaColor = color;

      if (!color.a && color.a != 0) {
        this._hiddenAreaColor.a = 1.0;
      }
    }
    /**
     * 当type为颜色时的，投射的颜色值
     * @type {Cesium.Color}
     */

  }, {
    key: "color",
    get: function get() {
      return this.style.color;
    },
    set: function set(val) {
      this.style.color = val;
    }
    /**
     * 相机
     * @type {Cesium.Color}
     * @readonly
     */

  }, {
    key: "camera",
    get: function get() {
      return this._viewShadowMap._lightCamera;
    } //========== 方法 ==========

    /**
     * 将矢量数据的坐标、样式及属性等信息导出为对象，可以用于存储。
     * @return {Object} 导出的坐标、样式及属性等信息
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var viewJson = {
        type: this.options.type,
        position: this.coordinate,
        cameraPosition: this.cameraCoordinate,
        style: {
          opacity: this.opacity,
          camera: this._camera,
          aspectRatio: this.aspectRatio,
          fovDegree: this.fovDegree
        },
        showFrustum: this.showFrustum
      };

      switch (this.options.type) {
        default:
        case Video3DType.Video:
        case Video3DType.Image:
          viewJson.url = this.url;
          break;

        case Video3DType.Color:
          viewJson.style.color = this.color;
          break;

        case Video3DType.Text:
          viewJson.style.text = this.text;
          break;
      }

      return viewJson;
    }
  }, {
    key: "_clearAll",
    value: function _clearAll() {
      if (!this._map) {
        return;
      }

      if (this._postProcess) {
        this._map.scene.postProcessStages.remove(this._postProcess);

        delete this._postProcess;
      }

      if (this.cameraFrustum) {
        this.primitiveCollection.remove(this.cameraFrustum);
        delete this.cameraFrustum;
      }

      if (this._viewShadowMap) {
        this._viewShadowMap.destroy();

        delete this._viewShadowMap;
      }
    }
  }, {
    key: "_updateDraw",
    value: function _updateDraw(reset) {
      if (!this._map) {
        return;
      }

      this._clearAll();

      this._createShadowMap(reset);

      this._getOrientation();

      this._addCameraFrustum();

      this._addPostProcess();
    }
  }, {
    key: "_showHook",
    value: function _showHook() {
      if (this.show) {
        this._updateDraw(true);
      } else {
        this._clearAll();
      }
    }
  }, {
    key: "_updatePositionsHook",
    value: function _updatePositionsHook() {
      this._updateDraw(true);
    }
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //宽高比
      if (this.style.aspectRatio) {
        this._aspectRatio = this.style.aspectRatio;
      } else {
        //获取canvas宽高
        this._aspectRatio = this._map.scene.canvas.clientWidth / this._map.scene.canvas.clientHeight;
      }

      if (!this.fov) {
        //相机水平张角
        this.fov = this._map.scene.camera.frustum.fov;
      }

      this.videoTexture = this.options.texture || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        //默认材质
        context: this._map.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([255, 255, 255, 255])
        },
        flipY: false
      });

      switch (this.options.type) {
        default:
          break;

        case Video3DType.Video:
          this.activeVideo(this.url);
          break;

        case Video3DType.Image:
          this.activePicture(this.url);
          this.deActiveVideo();
          break;

        case Video3DType.Color:
          this.activeColor(this.color);
          this.deActiveVideo();
          break;

        case Video3DType.Text:
          this.activeText(this.style.text);
          this.deActiveVideo();
          break;
      }
    }
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._createShadowMap();

      this._getOrientation();

      this._addCameraFrustum();

      this._addPostProcess();

      this.primitiveCollection.add(this);
    }
    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      var _this$videoElement;

      this._clearAll();

      this.deActiveVideo();

      if ((_this$videoElement = this.videoElement) !== null && _this$videoElement !== void 0 && _this$videoElement.parentNode) {
        this.videoElement.parentNode.removeChild(this.videoElement);
      }

      this.primitiveCollection.remove(this);
    } //投射视频

  }, {
    key: "activeVideo",
    value: function activeVideo(videoSrc) {
      //在可视域添加视频
      var videoElement;

      if (this.dom) {
        videoElement = this.dom;
      } else {
        videoElement = this._createVideoEle(videoSrc);
      }

      var that = this;

      if (videoElement) {
        this.options.type = Video3DType.Video;
        videoElement.addEventListener("canplaythrough", function () {
          if (!that._map) {
            return;
          }

          that._map.on(EventType.clockTick, that._onClockTickHandler, that);
        });
        this.videoElement = videoElement;
      }
    }
  }, {
    key: "_onClockTickHandler",
    value: function _onClockTickHandler() {
      try {
        if (this._videoPlay && this.videoElement.paused) {
          this.videoElement.play();
        }
      } catch (e) {//规避浏览器权限异常
      }

      if (!this.videoElement || !this._map) {
        return;
      }

      this.videoTexture && this.videoTexture.destroy();
      this.videoTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: this._map.scene.context,
        source: this.videoElement,
        pixelFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelFormat"].RGBA,
        pixelDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelDatatype"].UNSIGNED_BYTE
      });
    } //删除视频播放监听

  }, {
    key: "deActiveVideo",
    value: function deActiveVideo() {
      this._map.off(EventType.clockTick, this._onClockTickHandler, this);
    } //投射图片

  }, {
    key: "activePicture",
    value: function activePicture(picSrc) {
      var _this2 = this;

      var image = new Image();

      image.onload = function (e) {
        _this2.options.type = Video3DType.Image;
        _this2.videoTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
          context: _this2._map.scene.context,
          source: image
        });
      };

      image.onerror = function (e) {
        Object(Log["logError"])("图片加载失败：" + picSrc, e);
      };

      image.src = picSrc;
    } //投射颜色

  }, {
    key: "activeColor",
    value: function activeColor(color) {
      //在可视域添加纯色
      var that = this;
      this.options.type = Video3DType.Color;
      var r, g, b, a;

      if (color) {
        r = color.red * 255;
        g = color.green * 255;
        b = color.blue * 255;
        a = color.alpha * 255;
      } else {
        r = Math.random() * 255;
        g = Math.random() * 255;
        b = Math.random() * 255;
        a = Math.random() * 255;
      }

      that.videoTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: that._map.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([r, g, b, a])
        },
        flipY: false
      });
    } //投射文本

  }, {
    key: "activeText",
    value: function activeText(text) {
      var that = this;
      this.options.type = Video3DType.Text;

      if (!text) {
        return;
      }

      var textStyles = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.style.textStyles, {
        font: "50px 楷体",
        fill: true,
        fillColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 0.0, 1.0),
        stroke: true,
        strokeWidth: 2,
        strokeColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.8),
        backgroundColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 0.1),
        textBaseline: "top",
        padding: 40
      });
      textStyles.textBaseline = "top";
      this.textCanvas = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["writeTextToCanvas"](text, textStyles);
      that.videoTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: that._map.scene.context,
        source: this.textCanvas,
        flipY: true
      });
    } //获取四元数

  }, {
    key: "_getOrientation",
    value: function _getOrientation() {
      var cpos = this.cameraPosition;
      var position = this.position;
      var direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, cpos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(cpos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var camera = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Camera"](this._map.scene);
      camera.position = cpos;
      camera.direction = direction;
      camera.up = up;
      direction = camera.directionWC;
      up = camera.upWC;
      var right = camera.rightWC;
      var scratchRight = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var scratchRotation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();
      var scratchOrientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"](); // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());

      right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(right, scratchRight);
      var rotation = scratchRotation;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 0, right, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 1, up, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 2, direction, rotation); //计算视锥姿态

      var orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"].fromRotationMatrix(rotation, scratchOrientation);
      this.orientation = orientation;
      return orientation;
    } //创建video元素

  }, {
    key: "_createVideoEle",
    value: function _createVideoEle(src) {
      //创建可视域video DOM  元素
      var source_map4 = document.createElement("SOURCE");
      source_map4.type = "video/mp4";
      source_map4.src = src;
      var source_mov = document.createElement("SOURCE");
      source_mov.type = "video/quicktime";
      source_mov.src = src;
      var videoEle = document.createElement("video");
      videoEle.setAttribute("autoplay", true);
      videoEle.setAttribute("loop", true);
      videoEle.setAttribute("crossorigin", true);
      videoEle.appendChild(source_map4);
      videoEle.appendChild(source_mov);
      videoEle.style.display = "none";
      document.body.appendChild(videoEle);
      return videoEle;
    } //创建ShadowMap

  }, {
    key: "_createShadowMap",
    value: function _createShadowMap(reset) {
      var camera_pos = this.cameraPosition;
      var lookat_pos = this.position;
      var scene = this._map.scene;
      var camera1 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Camera"](scene);
      camera1.position = camera_pos;

      if (this._camera && !reset) {
        camera1.direction = this._camera.direction;
        camera1.right = this._camera.right;
        camera1.up = this._camera.up;
      } else {
        camera1.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(lookat_pos, camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
        camera1.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
      }

      var far = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(lookat_pos, camera_pos);
      this.viewDis = far;
      camera1.frustum = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerspectiveFrustum"]({
        fov: this.fov,
        aspectRatio: this.aspectRatio,
        near: 0.1,
        far: far * 2
      });
      var isSpotLight = true;
      this._viewShadowMap = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMap"]({
        lightCamera: camera1,
        enabled: false,
        isPointLight: !isSpotLight,
        isSpotLight: isSpotLight,
        cascadesEnabled: false,
        context: scene.context,
        pointLightRadius: far
      });
    } //添加视椎体

  }, {
    key: "_addCameraFrustum",
    value: function _addCameraFrustum() {
      if (this.cameraFrustum) {
        this.primitiveCollection.remove(this.cameraFrustum);
      }

      var that = this;
      this.cameraFrustum = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Primitive"]({
        geometryInstances: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryInstance"]({
          id: this.uuid,
          geometry: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FrustumOutlineGeometry"]({
            origin: that.cameraPosition,
            orientation: that.orientation,
            frustum: this._viewShadowMap._lightCamera.frustum,
            _drawNearPlane: true
          }),
          attributes: {
            color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].fromColor(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.5, 0.5))
          }
        }),
        appearance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerInstanceColorAppearance"]({
          translucent: false,
          flat: true
        }),
        asynchronous: false,
        show: this.showFrustum && this.show
      });
      this.primitiveCollection.add(this.cameraFrustum);
      this.bindPickId(this.cameraFrustum);
    } //添加后处理

  }, {
    key: "_addPostProcess",
    value: function _addPostProcess() {
      var that = this;
      var bias = that._viewShadowMap._isPointLight ? that._viewShadowMap._pointBias : that._viewShadowMap._primitiveBias;

      if (!this.show) {
        return;
      }

      if (this._postProcess) {
        this._map.scene.postProcessStages.remove(this._postProcess);

        delete this._postProcess;
      }

      this._postProcess = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Video3D_default.a,
        uniforms: {
          mixNum: function mixNum() {
            return that.opacity;
          },
          tudouShadow: function tudouShadow() {
            return that._viewShadowMap._shadowMapTexture;
          },
          videoTexture: function videoTexture() {
            return that.videoTexture;
          },
          _shadowMap_matrix: function _shadowMap_matrix() {
            return that._viewShadowMap._shadowMapMatrix;
          },
          shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
            return that._viewShadowMap._lightPositionEC;
          },
          shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
            var texelStepSize = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]();
            texelStepSize.x = 1.0 / that._viewShadowMap._textureSize.x;
            texelStepSize.y = 1.0 / that._viewShadowMap._textureSize.y;
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"].fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
          },
          shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"].fromElements(bias.normalOffsetScale, that._viewShadowMap._distance, that._viewShadowMap.maximumDistance, that._viewShadowMap._darkness, this.combinedUniforms2);
          },
          disViewColor: function disViewColor() {
            return that._hiddenAreaColor;
          },
          clearBlack: function clearBlack() {
            return that._clearBlack;
          }
        }
      });

      this._map.scene.postProcessStages.add(this._postProcess);
    }
  }, {
    key: "update",
    value: function update(frameState) {
      if (this._viewShadowMap) {
        frameState.shadowMaps.push(this._viewShadowMap);
      }
    }
    /**
     * 旋转相机
     *
     * @param {Video3D.RatateDirection} axis  旋转的方向
     * @param {number} [rotateDegree=0.5] 旋转的角度
     * @return {void}  无
     */

  }, {
    key: "rotateCamera",
    value: function rotateCamera(axis) {
      var rotateDegree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      switch (axis) {
        default:
        case Video3D_RatateDirection.LEFT:
          break;

        case Video3D_RatateDirection.RIGHT:
          rotateDegree *= -1;
          break;

        case Video3D_RatateDirection.TOP:
          break;

        case Video3D_RatateDirection.BOTTOM:
          rotateDegree *= -1;
          break;

        case Video3D_RatateDirection.ALONG:
          break;

        case Video3D_RatateDirection.INVERSE:
          rotateDegree *= -1;
          break;
      }

      var newDir = this._computedNewViewDir(axis, rotateDegree);

      if (!newDir || !newDir.up || !newDir.right || !newDir.direction) {
        return;
      }

      this._camera = newDir;

      this._updateDraw();
    } //计算新视点

  }, {
    key: "_computedNewViewDir",
    value: function _computedNewViewDir(axis, deg) {
      deg = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(deg);
      var camera = this._viewShadowMap._lightCamera;
      var oldDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.direction);
      var oldRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.right);
      var oldTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.up);
      var mat3 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();

      switch (axis) {
        default:
        case Video3D_RatateDirection.LEFT:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(deg, mat3);
          break;

        case Video3D_RatateDirection.RIGHT:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(deg, mat3);
          break;

        case Video3D_RatateDirection.TOP:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(deg, mat3);
          break;

        case Video3D_RatateDirection.BOTTOM:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(deg, mat3);
          break;

        case Video3D_RatateDirection.ALONG:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(deg, mat3);
          break;

        case Video3D_RatateDirection.INVERSE:
          external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(deg, mat3);
          break;
      }

      var localToWorld_Matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(camera.position);
      var worldToLocal_Matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(localToWorld_Matrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      var localDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newRight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var localNewTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].multiplyByVector(mat3, localTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var newTop = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      return {
        direction: newDir,
        right: newRight,
        up: newTop
      };
    }
    /**
     * 定位至相机的第一视角
     * @return {void}  无
     */

  }, {
    key: "flyTo",
    value: function flyTo() {
      if (!this._map) {
        return;
      }

      var camera_pos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.cameraPosition);
      this._map.camera.position = camera_pos;

      if (this._camera) {
        this._map.camera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._camera.direction);
        this._map.camera.right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._camera.right);
        this._map.camera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._camera.up);
        return;
      }

      var lookat_pos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this.position);
      this._map.camera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(lookat_pos, camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
      this._map.camera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
    }
  }]);

  return Video3D;
}(BasePointPrimitive_BasePointPrimitive);
/**
 * 类型
 * @property {Number} 	Video 视频
 * @property {Number} 	Image 图片
 * @property {Number} 	Color 纯色
 * @property {Number} 	Text 文字
 * @enum
 */

Video3D_Video3D.Type = Video3DType;
/**
 * 旋转的方向
 * @property {String} 	LEFT 绕Z轴旋转
 * @property {String} 	RIGHT 绕Z轴反向旋转
 * @property {String} 	TOP 绕Y轴旋转
 * @property {String} 	BOTTOM 绕Y轴反向旋转
 * @property {String} 	ALONG 绕X轴旋转
 * @property {String} 	INVERSE 绕X轴反向旋转
 * @enum
 */

Video3D_Video3D.RatateDirection = Video3D_RatateDirection; //注册下

Object(GraphicUtil["register"])("video3D", Video3D_Video3D);
// CONCATENATED MODULE: ./src/graphic/roam/BaseRoamLine.js







function BaseRoamLine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseRoamLine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseRoamLine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseRoamLine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseRoamLine_createSuper(Derived) { var hasNativeReflectConstruct = BaseRoamLine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseRoamLine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

















var globeLastRoam;
/**
 * 漫游路线管理类 基类
 *
 * @export
 * @class BaseRoamLine
 * @extends {BaseGraphic}
 */

var BaseRoamLine_BaseRoamLine = /*#__PURE__*/function (_BaseGraphic) {
  inherits_default()(BaseRoamLine, _BaseGraphic);

  var _super = BaseRoamLine_createSuper(BaseRoamLine);

  //========== 构造方法 ==========
  function BaseRoamLine() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseRoamLine);

    _this = _super.call(this, options);
    _this.options = Object(Util["merge"])(_this.defOptions, options);
    _this._hasCache = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.hasCache, true);
    _this._fixedFrameTransform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.fixedFrameTransform, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame); //参考系
    // this._showLastPoint = Cesium.defaultValue(this.options.showLastPoint, true)

    _this._frameRate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.frameRate, 30);
    _this.times = [];
    _this.positions = [];
    _this._clampToTilesetFrame = -1;
    /**
     * 动态时序坐标位置，
     * Cesium原生动态属性对象
     * @type {Cesium.SampledPositionProperty}
     * @readonly
     */

    _this.property = null;
    return _this;
  } //========== 对外属性 ==========


  createClass_default()(BaseRoamLine, [{
    key: "czmObject",
    get: function get() {
      return this._entity;
    }
  }, {
    key: "czmObjectEx",
    get: function get() {
      return this._arrShowingEntity;
    }
    /**
     * 加载Entity数据的内部Cesium容器
     * @type {Cesium.CustomDataSource}
     * @readonly
     */

  }, {
    key: "dataSource",
    get: function get() {
      var _this$_layer;

      return (_this$_layer = this._layer) === null || _this$_layer === void 0 ? void 0 : _this$_layer.dataSource;
    } //参数默认值

  }, {
    key: "defOptions",
    get: function get() {
      return {
        model: {
          show: false,
          scale: 1,
          minimumPixelSize: 50
        },
        label: {
          show: false,
          color: "#ffffff",
          opacity: 1,
          font_family: "楷体",
          font_size: 20,
          outline: true,
          outlineColor: "#000000",
          outlineWidth: 3,
          pixelOffsetX: 30,
          pixelOffsetY: -30,
          scaleByDistance: true,
          scaleByDistance_far: 10000000,
          scaleByDistance_farValue: 0.4,
          scaleByDistance_near: 5000,
          scaleByDistance_nearValue: 1
        },
        path: {
          show: false,
          color: "#3388ff",
          opacity: 0.5,
          width: 1
        },
        camera: {
          type: "",
          followedX: 50,
          followedZ: 10
        },
        showGroundHeight: false
      };
    }
    /**
     * 当前时间对应的坐标位置 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "position",
    get: function get() {
      var position;

      if (this.property && this._map && this._map.clock) {
        position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this.property, this._map.clock.currentTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      } //贴模型


      if (position && this.options.clampToTileset) {
        //贴模型
        this._clampToTilesetFrame++;

        if (!this._clampToTilesetHeight || this._clampToTilesetFrame % this._frameRate == 0) {
          this._clampToTilesetHeight = Object(PointUtil["getSurfaceHeight"])(this._map.scene, position, {
            objectsToExclude: this.objectsToExclude
          });
        }

        if (this._clampToTilesetHeight) {
          var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
          position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, this._clampToTilesetHeight);
        }
      } //没有数据时显示最后一个点。
      // if (position) {
      //   this._last_position = position;
      // } else {
      //   position = this._last_position;
      // }


      return position;
    }
    /**
     * 当前飞行过的positions轨迹点数组的index顺序
     * @type {Number}
     * @readonly
     */

  }, {
    key: "currIndex",
    get: function get() {
      return this._flyok_point_index;
    }
    /**
     * 贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities 等
     * @type {Object[]|undefined}
     * @readonly
     */

  }, {
    key: "objectsToExclude",
    get: function get() {
      var _this$_entity;

      if (this.options.objectsToExclude) {
        return this.options.objectsToExclude;
      }

      if ((_this$_entity = this._entity) !== null && _this$_entity !== void 0 && _this$_entity.model) {
        return [this._entity];
      }

      return undefined;
    }
    /**
     * 中心点坐标（笛卡尔坐标）,popup/tooltip等功能会使用
     * @type {Cesium.SampledPositionProperty}
     * @readonly
     */

  }, {
    key: "center",
    get: function get() {
      return this.property;
    }
    /**
     * 获取三维空间中的旋转。
     * @type {Cesium.Quaternion}
     * @readonly
     */

  }, {
    key: "orientation",
    get: function get() {
      var _orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Property"].getValueOrUndefined(this.velocityOrientation, this._map.clock.currentTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"]());

      return _orientation;
    }
    /**
     * 获取当前hpr角度。
     * @type {Cesium.HeadingPitchRoll}
     * @readonly
     */

  }, {
    key: "hpr",
    get: function get() {
      var position = this.position; //当前点

      var _orientation = this.orientation; //获取当前角度

      if (!position || !_orientation) {
        return null;
      }

      var autoHpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, _orientation, this._map.scene.globe.ellipsoid, this._fixedFrameTransform);
      return autoHpr;
    }
    /**
     * 获取当前转换计算模型矩阵。如果方向或位置未定义，则返回undefined。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "modelMatrix",
    get: function get() {
      return this.computeModelMatrix();
    }
    /**
     * 获取当前转换计算模型矩阵。如果方向或位置未定义，则返回undefined。
     * 同 modelMatrix
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "matrix",
    get: function get() {
      return this.computeModelMatrix();
    }
    /**
     * 四周方向角，弧度值
     * @type {Number}
     * @readonly
     */

  }, {
    key: "headingRadians",
    get: function get() {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._heading)) {
        var hpr = this.hpr;

        if (hpr) {
          this._heading = hpr.heading;
        }
      }

      return this._heading;
    }
    /**
     * 四周方向角，0-360度角度值
     * @type {Number}
     * @readonly
     */

  }, {
    key: "heading",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.headingRadians);
    }
    /**
     * 俯仰角，上下摇摆的角度，弧度值
     * @type {Number}
     * @readonly
     */

  }, {
    key: "pitchRadians",
    get: function get() {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._pitch)) {
        var hpr = this.hpr;

        if (hpr) {
          this._pitch = hpr.pitch;
        }
      }

      return this._pitch;
    },
    set: function set(val) {
      this._pitch = val || 0;
      this.updateAngle(false);
    }
    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "pitch",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.pitchRadians);
    },
    set: function set(val) {
      this._pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val || 0);
      this.updateAngle(false);
    }
    /**
     * 滚转角，左右摆动的角度，弧度值
     * @type {Number}
     * @readonly
     */

  }, {
    key: "rollRadians",
    get: function get() {
      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._roll)) {
        var hpr = this.hpr;

        if (hpr) {
          this._roll = hpr.roll;
        }
      }

      return this._roll;
    },
    set: function set(val) {
      this._roll = val || 0;
      this.updateAngle(false);
    }
    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */

  }, {
    key: "roll",
    get: function get() {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this.rollRadians);
    },
    set: function set(val) {
      this._roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val || 0);
      this.updateAngle(false);
    }
    /**
     * 求当前位置射线与地球相交点
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "groundPosition",
    get: function get() {
      return Object(PointUtil["getRayEarthPositionByMatrix"])(this.modelMatrix, true, this._map.scene.globe.ellipsoid);
    }
    /**
     * 倍速
     * @type {Number}
     */

  }, {
    key: "multiplier",
    get: function get() {
      var _this$_map;

      return (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.multiplier;
    },
    set: function set(val) {
      if (this._map) {
        this._map.clock.multiplier = val;
      }
    }
    /**
     * 是否暂停状态
     * @type {Boolean}
     */

  }, {
    key: "isPause",
    get: function get() {
      var _this$_map2;

      return !((_this$_map2 = this._map) !== null && _this$_map2 !== void 0 && _this$_map2.clock.shouldAnimate);
    },
    set: function set(val) {
      if (this._map) {
        this._map.clock.shouldAnimate = !val;
      }
    } //========== 方法 ==========

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this._entity) {
        if (this._map.trackedEntity == this._entity) {
          this._map.trackedEntity = undefined;
        }

        this.dataSource.entities.remove(this._entity);
      }

      if (this._arrShowingEntity) {
        for (var i = 0, len = this._arrShowingEntity.length; i < len; i++) {
          this.dataSource.entities.remove(this._arrShowingEntity[i]);
        }
      }
    }
  }, {
    key: "_getPopupPosition",
    value: function _getPopupPosition() {
      return this.property;
    }
    /**
     * 获取当前矩阵
     * @param {Object} offest 偏移值
     * @param {Number} offest.x X轴方向偏移值,单位：米
     * @param {Number} offest.y Y轴方向偏移值,单位：米
     * @param {Number} offest.z Z轴方向偏移值,单位：米
     * @return {Cesium.Matrix4}  当前矩阵
     */

  }, {
    key: "computeModelMatrix",
    value: function computeModelMatrix(offest) {
      var matrix4 = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]();
      var matrix3Scratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();
      var position = this.position;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](position)) {
        return undefined;
      }

      if (offest) {
        var hpr = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](this._heading, this._pitch, this._roll);
        position = Object(PointUtil["getPositionByHprAndOffset"])(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](offest.x || 0, offest.y || 0, offest.z || 0), hpr);
      }

      var result;
      var orientation = this.orientation;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](orientation)) {
        result = this._fixedFrameTransform(position, undefined, matrix4);
      } else {
        result = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromQuaternion(orientation, matrix3Scratch), position, matrix4);
      }

      return result;
    } //在start前创建静态的模型等

  }, {
    key: "_createStaticModel",
    value: function _createStaticModel() {
      var _this$_map3, _this$_map3$scene;

      if (!this.positions || this.positions.length < 2) {
        return;
      }

      var position = this.positions[0];
      var hpr = Object(PointUtil["getHeadingPitchRollForLine"])(position, this.positions[1]);
      hpr.pitch = 0;
      hpr.roll = 0;
      var entityAttr = {
        name: this.name || this.id,
        position: position,
        orientation: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr, (_this$_map3 = this._map) === null || _this$_map3 === void 0 ? void 0 : (_this$_map3$scene = _this$_map3.scene) === null || _this$_map3$scene === void 0 ? void 0 : _this$_map3$scene.globe.ellipsoid)
      };

      if (this.options.label && this.options.label.show) {
        this.options.label.text = this.options.label.text || this.name;
        entityAttr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.options.label, {}, this);
      }

      if (this.options.billboard && this.options.billboard.show) {
        entityAttr.billboard = BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.options.billboard, {}, true);
      }

      if (this.options.point && this.options.point.show) {
        entityAttr.point = PointStyleConver_PointStyleConver.toCesiumVal(this.options.point, {}, true);
      }

      if (this.options.model && this.options.model.show) {
        entityAttr.model = ModelStyleConver_ModelStyleConver.toCesiumVal(this.options.model, {}, true);
      }

      if (this.options.circle && this.options.circle.show) {
        entityAttr.ellipse = CircleStyleConver_CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }

      if (this._entity) {
        this.dataSource.entities.remove(this._entity);
      }

      this._entity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"](entityAttr));
      this.bindPickId(this._entity);
    }
  }, {
    key: "_createEntity",
    value: function _createEntity() {
      var _this2 = this;

      var entityAttr = {
        name: this.name || this.id,
        position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
          return _this2.position;
        }, false),
        orientation: this.velocityOrientation,
        point: {
          //必须有对象，否则 map.trackedEntity无法跟随(无model时使用)
          show: !(this.options.model && this.options.model.show),
          color: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(0.01),
          pixelSize: 1
        }
      };

      if (this.options.label && this.options.label.show) {
        this.options.label.text = this.options.label.text || this.name;
        entityAttr.label = LabelStyleConver_LabelStyleConver.toCesiumVal(this.options.label, {}, this);
      }

      if (this.options.billboard && this.options.billboard.show) {
        entityAttr.billboard = BillboardStyleConver_BillboardStyleConver.toCesiumVal(this.options.billboard, {}, true);
      }

      if (this.options.point && this.options.point.show) {
        entityAttr.point = PointStyleConver_PointStyleConver.toCesiumVal(this.options.point, {}, true);
      }

      if (this.options.model && this.options.model.show) {
        entityAttr.model = ModelStyleConver_ModelStyleConver.toCesiumVal(this.options.model, {}, true);

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.model.heading)) {
          //由于模型不是标准的方向时的处理
          var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.options.model.heading);
          entityAttr.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            var _this2$_map, _this2$_map$scene;

            var position = _this2.position;

            var orientation = _this2.velocityOrientation.getValue(time);

            var hpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, orientation);
            hpr.heading += heading;
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, hpr, (_this2$_map = _this2._map) === null || _this2$_map === void 0 ? void 0 : (_this2$_map$scene = _this2$_map.scene) === null || _this2$_map$scene === void 0 ? void 0 : _this2$_map$scene.globe.ellipsoid);
          }, false);
        }
      }

      if (this.options.path && this.options.path.show) {
        var pathAttr = PathStyleConver_PathStyleConver.toCesiumVal(this.options.path, {}, true);

        if (!pathAttr.isAll) {
          pathAttr.leadTime = 0; //只显示飞过的路线

          pathAttr.trailTime = this.alltimes * 10;
        }

        entityAttr.path = pathAttr;
        entityAttr.position = this.property; //path时需要为直接property
      }

      if (this.options.circle && this.options.circle.show) {
        entityAttr.ellipse = CircleStyleConver_CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }

      if (this._entity) {
        this.dataSource.entities.remove(this._entity);
      }

      this._entity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"](entityAttr));
      this.bindPickId(this._entity);
    }
    /**
     * 更新角度
     *
     * @param {Boolean} isAuto 是否基于轨迹自动计算角度
     * @param {Object} [opts] isAuto为false时，赋值的新角度值
     * @param {Number} [opts.pitch]  俯仰角，上下摇摆的角度，0-360度角度值
     * @param {Number} [opts.roll]  滚转角，左右摆动的角度，0-360度角度值
     * @return {void}  无
     */

  }, {
    key: "updateAngle",
    value: function updateAngle(isAuto, opts) {
      if (isAuto) {
        this._entity.orientation = this.velocityOrientation; //基于移动位置自动计算方位

        this._heading = null;
        this._pitch = null;
        this._roll = null;
      } else {
        opts = opts || {};
        var position = this.position; //当前点

        var _orientation = this.orientation; //获取当前角度

        if (!position || !_orientation) {
          return null;
        }

        var autoHpr = Object(PointUtil["getHeadingPitchRollByOrientation"])(position, _orientation, this._map.scene.globe.ellipsoid, this._fixedFrameTransform);
        this._heading = autoHpr.heading; //重新赋值新角度

        if (opts.pitch) {
          this._pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(Number(opts.pitch || 0.0));
        }

        if (opts.roll) {
          this._roll = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(Number(opts.roll || 0.0));
        }

        this._entity.orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].headingPitchRollQuaternion(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](this._heading, this._pitch, this._roll), this._map.scene.globe.ellipsoid, this._fixedFrameTransform);
      }
    }
    /**
     * 更新视角模式
     * @param {Object} cameraOptions 参数，包括：
     * @param {String} cameraOptions.type  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
     * @param {Number} [cameraOptions.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
     * @param {Number} [cameraOptions.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [cameraOptions.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360 *
     * @param {Number} [cameraOptions.followedX=50] 'dy'锁定第一视角时，距离运动点的距离（后方）
     * @param {followedZ} [cameraOptions.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
     * @return {void}  无
     */

  }, {
    key: "setCameraOptions",
    value: function setCameraOptions(cameraOptions) {
      var _globeLastRoam, _globeLastRoam$option, _globeLastRoam$option2;

      if ((_globeLastRoam = globeLastRoam) !== null && _globeLastRoam !== void 0 && (_globeLastRoam$option = _globeLastRoam.options) !== null && _globeLastRoam$option !== void 0 && (_globeLastRoam$option2 = _globeLastRoam$option.camera) !== null && _globeLastRoam$option2 !== void 0 && _globeLastRoam$option2.type) {
        globeLastRoam.options.camera.type = "";
      }

      globeLastRoam = null;
      this.options.camera = Object(Util["merge"])(this.options.camera, cameraOptions);

      if (this.options.camera.type != "") {
        globeLastRoam = this;
      }

      if (cameraOptions.type == "gs" && cameraOptions.radius) {
        this.flyToPoint(BaseRoamLine_objectSpread(BaseRoamLine_objectSpread({}, cameraOptions), {}, {
          duration: 0
        }));
      }
    } //获取已飞行完成的点的位置
    //JulianDate.compare(left, right), 如果left小于right，则为负值；如果left大于right，则为正值；如果left和right相等，则为零。

  }, {
    key: "getCurrIndex",
    value: function getCurrIndex() {
      var lineLength = this.times.length - 1;

      if (lineLength < 0) {
        return -1;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].compare(this._map.clock.currentTime, this.times[0]) <= 0) {
        this._flyok_point_index = 0;
      }

      if (this._flyok_point_index < 0 || this._flyok_point_index >= lineLength) {
        this._flyok_point_index = 0;
      }

      for (var i = this._flyok_point_index; i <= lineLength; i++) {
        var time = this.times[i];

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].compare(this._map.clock.currentTime, time) <= 0) {
          return i - 1;
        }
      }

      for (var _i = 0; _i <= lineLength; _i++) {
        var _time = this.times[_i];

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].compare(this._map.clock.currentTime, _time) <= 0) {
          return _i - 1;
        }
      }

      return lineLength;
    } //================投影的处理======================
    //加投影等额外的entity对象

  }, {
    key: "_addArrShading",
    value: function _addArrShading() {
      this._arrShowingEntity = [];

      for (var i = 0, len = this.options.shadow.length; i < len; i++) {
        var item = this.options.shadow[i];

        if (!item.show) {
          continue;
        }

        this.addShading(item);
      }
    }
  }, {
    key: "_updateArrShading",
    value: function _updateArrShading(position) {
      if (this._flyok_point_index < 0 || this.positions.length == 0) {
        return;
      }

      for (var i = 0, len = this.options.shadow.length; i < len; i++) {
        var item = this.options.shadow[i];

        if (!item.show) {
          continue;
        }

        var positions = void 0;

        switch (item.type) {
          default:
            break;

          case "wall":
            positions = this.positions.slice(0, this._flyok_point_index + 1);

            if (!Object(PointUtil["isRepeatPoint"])(positions[positions.length - 1], position)) {
              positions.push(position);
            }

            if (item.maxDistance) {
              positions = sliceByMaxDistance(positions, item.maxDistance);
            }

            this.updateWallShading(positions, item);
            break;

          case "polyline":
            positions = this.positions.slice(0, this._flyok_point_index + 1);

            if (!Object(PointUtil["isRepeatPoint"])(positions[positions.length - 1], position)) {
              positions.push(position);
            }

            if (item.maxDistance) {
              positions = sliceByMaxDistance(positions, item.maxDistance);
            }

            this._passed_positions = positions;
            break;

          case "polylineGoing":
            positions = [position].concat(this.positions.slice(this._flyok_point_index + 1));
            this._going_positions = positions;
            break;
        }
      }
    }
    /**
     * 获取飞过的路线坐标数组
     * @return {Cesium.Cartesian3[]} 坐标数组
     */

  }, {
    key: "getOverPositions",
    value: function getOverPositions() {
      var positions = this.positions.slice(0, this._flyok_point_index + 1);
      var position = this.position;

      if (position && !Object(PointUtil["isRepeatPoint"])(positions[positions.length - 1], position)) {
        positions.push(position);
      }

      return positions;
    }
    /**
     * 按类型 添加单个投影
     *
     * @param {Object} item 参数，按类型分别支持：
     * @param {BaseRoamLine.WallShadingOptions} [item.wall] wall类型所支持的参数
     * @param {BaseRoamLine.CylinderShadingOptions} [item.cylinder] cylinder类型所支持的参数
     * @param {BaseRoamLine.CircleShadingOptions} [item.circle] circle类型所支持的参数
     * @param {BaseRoamLine.PolylineShadingOptions} [item.polyline] polyline类型所支持的参数
     * @param {BaseRoamLine.PolylineGoingShadingOptions} [item.polylineGoing] polylineGoing类型所支持的参数
     *
     * @return {Cesium.Entity|undefined} 构造完成的投影对象
     */

  }, {
    key: "addShading",
    value: function addShading(item) {
      var entity;

      switch (item.type) {
        case "wall":
          entity = this.addWallShading(item);
          break;

        case "cylinder":
          entity = this.addCylinderShading(item);
          break;

        case "circle":
          entity = this.addCircleShading(item);
          break;

        case "polyline":
        case "polylineGoing":
          entity = this.addPolylineShading(item);
          break;

        default:
          Object(Log["logWarn"])("存在未标识type的无效shadow配置", item);
          break;
      }

      if (entity) {
        entity.data = item;

        this._arrShowingEntity.push(entity);
      }

      return entity;
    }
    /**
     * 移除单个投影
     *
     * @param {Cesium.Entity|String|null} entity 可以  构造的投影矢量对象 或 传入type类型 ，未传入时删除最后添加的一个投影
     * @return {void}  无
     */

  }, {
    key: "removeShading",
    value: function removeShading(entity) {
      if (entity == null) {
        if (this._arrShowingEntity.length == 0) {
          return;
        } //为空时，默认删除最后一个。


        var index = this._arrShowingEntity.length - 1;
        this.dataSource.entities.remove(this._arrShowingEntity[index]);

        this._arrShowingEntity.splice(index, 1);
      } else if (Object(Util["isString"])(entity)) {
        //删除指定类型的
        for (var i = 0, len = this._arrShowingEntity.length; i < len; i++) {
          if (this._arrShowingEntity[i].data.type == entity) {
            this.dataSource.entities.remove(this._arrShowingEntity[i]);

            this._arrShowingEntity.splice(i, 1);

            break;
          }
        }

        return;
      } else {
        //删除传入的entity
        this.dataSource.entities.remove(entity);

        if (this._arrShowingEntity) {
          for (var _i2 = 0, _len = this._arrShowingEntity.length; _i2 < _len; _i2++) {
            if (this._arrShowingEntity[_i2] == entity) {
              this._arrShowingEntity.splice(_i2, 1);

              break;
            }
          }
        }
      }
    }
    /**
     * 添加wall 轨迹墙投影
     *
     * @param {BaseRoamLine.WallShadingOptions} options 投影构造参数
     * @return {Cesium.Entity|undefined} 构造完成的投影对象
     */

  }, {
    key: "addWallShading",
    value: function addWallShading(options) {
      var _this3 = this;

      this._wall_positions = [];
      this._wall_minimumHeights = [];
      this._wall_maximumHeights = [];
      options = BaseRoamLine_objectSpread({
        color: "#00ff00",
        outline: false,
        opacity: 0.3
      }, options);
      var wallattr = WallStyleConver_WallStyleConver.toCesiumVal(options, {}, true);
      wallattr.minimumHeights = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this3._wall_minimumHeights;
      }, false);
      wallattr.maximumHeights = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this3._wall_maximumHeights;
      }, false);
      wallattr.positions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return _this3._wall_positions;
      }, false);
      var wallEntity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
        wall: wallattr
      }));
      this.bindPickId(wallEntity);
      return wallEntity;
    }
  }, {
    key: "updateWallShading",
    value: function updateWallShading(positions, options) {
      var newposition = [];
      var minimumHeights = [];
      var maximumHeights = [];

      for (var i = 0; i < positions.length; i++) {
        var point = positions[i].clone();

        if (!point) {
          continue;
        }

        newposition.push(point);
        var carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(point);
        maximumHeights.push(carto.height);

        if (options.surface) {
          var _positions$i$hbgd;

          positions[i].hbgd = (_positions$i$hbgd = positions[i].hbgd) !== null && _positions$i$hbgd !== void 0 ? _positions$i$hbgd : Object(PointUtil["getSurfaceHeight"])(this._map.scene, point);
          minimumHeights.push(positions[i].hbgd);
        } else {
          minimumHeights.push(0);
        }
      }

      this._wall_positions = newposition;
      this._wall_minimumHeights = minimumHeights;
      this._wall_maximumHeights = maximumHeights;
    }
    /**
     * 添加cylinder 圆锥立体投影
     *
     * @param {BaseRoamLine.CylinderShadingOptions} options 投影构造参数
     * @return {Cesium.Entity|undefined} 构造完成的投影对象
     */

  }, {
    key: "addCylinderShading",
    value: function addCylinderShading(options) {
      var _this4 = this;

      var bottomRadiusNow = 100;
      var lengthNow = 100;
      options = BaseRoamLine_objectSpread(BaseRoamLine_objectSpread({}, {
        color: "#00ff00",
        outline: false,
        opacity: 0.3
      }), options);
      var wallattr = CylinderStyleConver_CylinderStyleConver.toCesiumVal(options, {}, true); //主要是颜色值等属性

      wallattr.length = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return lengthNow;
      }, false);
      wallattr.topRadius = 0;
      wallattr.bottomRadius = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        return bottomRadiusNow;
      }, false);
      wallattr.numberOfVerticalLines = 0;
      var cylinderEntity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
        position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
          var position = _this4.position;

          if (!position) {
            return null;
          }

          var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
          var newPoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, car.height / 2);
          lengthNow = car.height;
          bottomRadiusNow = lengthNow * 0.3; //地面圆半径

          return newPoint;
        }, false),
        cylinder: wallattr
      }));
      this.bindPickId(cylinderEntity);
      return cylinderEntity;
    }
    /**
     * 添加circle扩散圆投影
     *
     * @param {BaseRoamLine.CircleShadingOptions} options 投影构造参数
     * @return {Cesium.Entity|undefined} 构造完成的投影对象
     */

  }, {
    key: "addCircleShading",
    value: function addCircleShading(options) {
      var attr = CircleStyleConver_CircleStyleConver.toCesiumVal(options, {}, true);
      var entity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
        position: this.property,
        ellipse: attr
      }));
      this.bindPickId(entity);
      return entity;
    }
    /**
     * 添加 polyline 或 polylineGoing 路线 投影
     *
     * @param {BaseRoamLine.PolylineShadingOptions |BaseRoamLine.PolylineGoingShadingOptions} options 投影构造参数
     * @return {Cesium.Entity|undefined} 构造完成的投影对象
     */

  }, {
    key: "addPolylineShading",
    value: function addPolylineShading(options) {
      var _this5 = this;

      var attr = PolylineStyleConver_PolylineStyleConver.toCesiumVal(options, {}, true);
      attr.positions = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
        if (options.type == "polylineGoing") {
          return _this5._going_positions;
        } else {
          return _this5._passed_positions;
        }
      }, false);
      var entity = this.dataSource.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
        polyline: attr
      }));
      this.bindPickId(entity);
      return entity;
    } //================视角定位======================

    /**
     * 视角定位至路线范围
     *
     * @param {Object} [options={}] 参数对象:
     *
     * @param {Number} options.radius 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.8] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (this._map) {
        this._map.flyToPositions(this.positions, options);
      }
    }
    /**
     * 定位至当前时间所在的位置 (非相机位置)
     *
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} options.radius 相机距离目标点的距离（单位：米）
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToPoint",
    value: function flyToPoint() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      var position = this.position;

      if (!position) {
        return;
      }

      if (this._map.scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        this._map.clock.shouldAnimate = false;
        setTimeout(function () {
          var _this6$hpr;

          if (options.duration === 0) {
            options.duration = 0.01;
          }

          var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(((_this6$hpr = _this6.hpr) === null || _this6$hpr === void 0 ? void 0 : _this6$hpr.heading) || 0) + external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.heading, 0);

          _this6._map.flyToPoint(position, BaseRoamLine_objectSpread(BaseRoamLine_objectSpread({}, options), {}, {
            heading: heading,
            complete: function complete() {
              if (_this6._map) {
                _this6._map.clock.shouldAnimate = true;
              }
            }
          }));
        }, 10);
      } else {
        //二维模式下
        if (this._entity) {
          this._map.flyTo(this._entity);
        }
      }
    } //================暂停继续=====================

    /**
     * 暂停
     * @return {void}  无
     */

  }, {
    key: "pause",
    value: function pause() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;

        if (this._map.trackedEntity == this._entity) {
          this._map.trackedEntity = undefined;
        }
      }
    }
    /**
     * 继续
     * @return {void}  无
     */

  }, {
    key: "proceed",
    value: function proceed() {
      if (this._map) {
        this._map.clock.shouldAnimate = true;
      }
    }
    /**
     * 将轨迹数据转换为CZML格式数据
     * @return {Object}  CZML格式数据
     */

  }, {
    key: "toCZML",
    value: function toCZML() {
      //时间
      var currentTime = this.times[0].toString();
      var stopTime = this.times[this.times.length - 1].toString(); //路径位置点

      var cartographicDegrees = [];

      for (var i = 0, length = this.positions.length; i < length; i++) {
        var item = LatLngPoint["a" /* LatLngPoint */].fromCartesian(this.positions[i]);
        var second = i == 0 ? 0 : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this.times[i], this.times[i - 1]);
        cartographicDegrees.push(second);
        cartographicDegrees.push(item.lng);
        cartographicDegrees.push(item.lat);
        cartographicDegrees.push(item.alt);
      }

      var czmlLine = {
        id: this.name,
        description: this.options.remark,
        availability: currentTime + "/" + stopTime,
        orientation: {
          //方向
          velocityReference: "#position"
        },
        position: {
          //位置
          epoch: currentTime,
          cartographicDegrees: cartographicDegrees
        }
      };

      if (this.options.interpolation) {
        czmlLine.position.interpolationAlgorithm = "LAGRANGE"; //插值时使用的插值算法,有效值为“LINEAR”，“LAGRANGE”和“HERMITE”。

        czmlLine.position.interpolationDegree = this.options.interpolationDegree || 2; //插值时使用的插值程度。
      }

      if (this.options.label.show) {
        //是否显示注记
        czmlLine.label = {
          show: true,
          outlineWidth: 2,
          text: this.name,
          font: "12pt 微软雅黑 Console",
          outlineColor: {
            rgba: [0, 0, 0, 255]
          },
          horizontalOrigin: "LEFT",
          fillColor: {
            rgba: [213, 255, 0, 255]
          }
        };
      }

      if (this.options.path.show) {
        //是否显示路线
        czmlLine.path = {
          //路线
          show: true,
          material: {
            solidColor: {
              color: {
                rgba: [255, 0, 0, 255]
              }
            }
          },
          width: 5,
          resolution: 1,
          leadTime: 0,
          trailTime: this.alltimes
        };
      } //漫游对象(模型)


      if (this.options.model.show) {
        //是否显示模型
        czmlLine.model = this.options.model;
      }

      var czml = [{
        version: "1.0",
        id: "document",
        clock: {
          interval: currentTime + "/" + stopTime,
          currentTime: currentTime,
          multiplier: 1
        }
      }, czmlLine];
      return czml;
    }
  }]);

  return BaseRoamLine;
}(BaseGraphic_BaseGraphic);
/**
 * wall 类型shading 支持的参数，
 * 效果是飞机飞行轨迹线下的投射墙体效果。
 *
 * @typedef {Object} BaseRoamLine.WallShadingOptions
 *
 * @property {String} [type='wall']  类型
 * @property {WallEntity.StyleOptions} [通用参数] wall墙体对象支持的所有参数
 * @property {Number} [maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹
 *
 */

/**
 *  cylinder 类型shading 支持的参数，
 * 效果是飞机飞行时的圆锥体投射效果。
 *
 * @typedef {Object} BaseRoamLine.CylinderShadingOptions
 * @property {String} [type='cylinder']  类型
 * @property {CylinderEntity.StyleOptions} [通用参数] 圆锥对象支持的所有参数
 *
 */

/**
 *  circle 类型shading 支持的参数，
 *  比如步行时的人员所在位置的扩散圆圈效果
 *
 * @typedef {Object} BaseRoamLine.CircleShadingOptions
 * @property {String} [type='circle']  类型
 * @property {CircleEntity.StyleOptions} [通用参数] 圆锥对象支持的所有参数
 *
 */

/**
 *  polyline 类型shading  支持的参数，
 *  【历史】走过的轨迹线，可以替代本身的path来设置贴地线的效果
 *
 * @typedef {Object} BaseRoamLine.PolylineShadingOptions
 * @property {String} [type='polyline']  类型
 * @property {PolylineEntity.StyleOptions} [通用参数]  线对象支持的所有参数
 * @property {Number} [maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹
 *
 */

/**
 *  polylineGoing 类型shading  支持的参数，
 *  【将来】将要走的轨迹线，可以替代本身的path来设置贴地线的效果
 *
 * @typedef {Object} BaseRoamLine.PolylineGoingShadingOptions
 * @property {String} [type='polylineGoing']  类型
 * @property {PolylineEntity.StyleOptions} [通用参数] 线对象支持的所有参数
 */
// CONCATENATED MODULE: ./src/graphic/roam/DynamicRoamLine.js








function DynamicRoamLine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function DynamicRoamLine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DynamicRoamLine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DynamicRoamLine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DynamicRoamLine_createSuper(Derived) { var hasNativeReflectConstruct = DynamicRoamLine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DynamicRoamLine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * @typedef {Object} DynamicRoamLine.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 *
 * @property {String} change 变化了
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.change, function (event) {
 *   console.log('坐标发生了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 动态漫游路线管理类 【动态传入的数据】
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {Number} [options.maxCacheCount=50] 保留的坐标点数量
 *
 * @param {Boolean} [options.hasCache=true]  是否记录缓存，提高效率
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [options.fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 *
 * @param {LabelEntity.StyleOptions} [options.label]  设置是否显示 文本 和对应的样式
 * @param {ModelEntity.StyleOptions} [options.model]  设置是否显示 gltf模型 和对应的样式
 * @param {BillboardEntity.StyleOptions} [options.billboard]  设置是否显示 图标 和对应的样式，如果不设置gltf模型时，可以选择该项。
 * @param {PointEntity.StyleOptions} [options.point]  设置是否显示 图标 和对应的样式，如果不设置gltf模型时，可以选择该项。
 * @param {CircleEntity.StyleOptions} [options.circle]  设置是否显示 圆对象 和对应的样式
 *
 * @param {Object[]} [options.shadow] 设置投影或附加的对象，支持类型：
 * @param {BaseRoamLine.WallShadingOptions} [options.shadow.wall] wall类型所支持的参数
 * @param {BaseRoamLine.CylinderShadingOptions} [options.shadow.cylinder] cylinder类型所支持的参数
 * @param {BaseRoamLine.CircleShadingOptions} [options.shadow.circle] circle类型所支持的参数
 * @param {BaseRoamLine.PolylineShadingOptions} [options.shadow.polyline] polyline类型所支持的参数
 * @param {BaseRoamLine.PolylineGoingShadingOptions} [options.shadow.polylineGoing] polylineGoing类型所支持的参数
 *
 * @param {Object} [options.camera] 视角模式设置，包括：
 * @param {String} [options.camera.type]  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
 * @param {Number} [options.camera.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
 * @param {Number} [options.camera.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
 * @param {Number} [options.camera.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360
 * @param {Number} [options.camera.followedX=50] 锁定第一视角时，距离运动点的距离（后方）
 * @param {Number} [options.camera.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
 * @param {Number} [options.camera.offsetX=0] 'dy'锁定第一视角时，锁定点的本身的X轴方向（前后）偏移值
 * @param {Number} [options.camera.offsetY=0] 'dy'锁定第一视角时，锁定点的本身的Y轴方向（横向）偏移值
 * @param {Number} [options.camera.offsetZ=0] 'dy'锁定第一视角时，锁定点的本身的Z轴方向（高度）偏移值
 *
 * @param {Cesium.ExtrapolationType} [forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
 * @param {Cesium.ExtrapolationType} [backwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
 *
 * @param {Boolean} [options.clampToTileset=false]  是否贴3dtiles模型上（贴模型效率较慢，按需开启）
 * @param {Number} [options.frameRate=30] 当clampToTileset：true时，控制贴模型的效率，多少帧计算一次贴模型高度,
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities, 或 3D Tiles features
 *
 *
 * @export
 * @class DynamicRoamLine
 * @extends {BaseRoamLine}
 * @see [支持的事件类型]{@link DynamicRoamLine.EventType}
 */

var DynamicRoamLine_DynamicRoamLine = /*#__PURE__*/function (_BaseRoamLine) {
  inherits_default()(DynamicRoamLine, _BaseRoamLine);

  var _super = DynamicRoamLine_createSuper(DynamicRoamLine);

  function DynamicRoamLine() {
    classCallCheck_default()(this, DynamicRoamLine);

    return _super.apply(this, arguments);
  }

  createClass_default()(DynamicRoamLine, [{
    key: "defOptions",
    get: //参数默认值
    function get() {
      return {
        model: {
          show: false,
          scale: 1,
          minimumPixelSize: 50
        },
        label: {
          show: false,
          color: "#ffffff",
          opacity: 1,
          font_family: "楷体",
          font_size: 20,
          outline: true,
          outlineColor: "#000000",
          outlineWidth: 3,
          pixelOffsetX: 30,
          pixelOffsetY: -30,
          scaleByDistance: true,
          scaleByDistance_far: 10000000,
          scaleByDistance_farValue: 0.4,
          scaleByDistance_near: 5000,
          scaleByDistance_nearValue: 1
        },
        camera: {
          type: "",
          followedX: 50,
          followedZ: 10
        }
      };
    } //========== 方法 ==========

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      get_default()(getPrototypeOf_default()(DynamicRoamLine.prototype), "_mountedHook", this).call(this);

      this._maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxCacheCount, 50); //保留的坐标点数量

      this.property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
      this.property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.forwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
      this.property.backwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.backwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
      this.velocityOrientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](this.property); //基于移动位置自动计算方位

      delete this.options.path; //动态时非直接property，但path需要property，所以去掉path，可以用 "shadow": [{ "show": true, "type": "polyline", "color": "#ff0000" }]

      this._createEntity();

      this._entity.show = true;
      this._map.clock.shouldAnimate = true; //加投影

      if (this.options.shadow && this.options.shadow.length > 0) {
        this._addArrShading();
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(DynamicRoamLine.prototype), "_addedHook", this).call(this);

      this._map.on(EventType.preRender, this._onPreRenderHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.preRender, this._onPreRenderHandler, this);

      get_default()(getPrototypeOf_default()(DynamicRoamLine.prototype), "_removedHook", this).call(this);
    } //实时监控事件

  }, {
    key: "_onPreRenderHandler",
    value: function _onPreRenderHandler(e) {
      if (this.positions.length == 0) {
        return;
      } //当前点


      var _position = this.position;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_position)) {
        //如果位置都没有变化，直接返回
        if (this._hasCache) {
          var _thiscache = "".concat(_position.x, "-").concat(_position.y, "-").concat(_position.z);

          if (_thiscache == this._position_cache) {
            return;
          }

          this._position_cache = _thiscache;
        } //如果位置都没有变化，直接返回
        //视角处理


        switch (this.options.camera && this.options.camera.type) {
          default:
            //无
            if (this._map.trackedEntity == this._entity) {
              this._map.trackedEntity = undefined;
            }

            break;

          case "gs":
            //跟随视角
            if (this._map.trackedEntity != this._entity) {
              this._map.trackedEntity = this._entity;
              this.flyToPoint(DynamicRoamLine_objectSpread(DynamicRoamLine_objectSpread({}, this.options.camera), {}, {
                duration: 0
              }));
            }

            break;

          case "dy":
            {
              //锁定第一视角
              if (this._map.trackedEntity != this._entity) {
                this._map.trackedEntity = this._entity;
              }

              var transformX = this.options.camera.followedX; //距离运动点的距离（后方）

              var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）

              if (transformX === 0 && transformZ === 0) {
                transformX = 0.1;
              }

              var offset;

              if (this.options.camera.offsetX) {
                offset = offset || {};
                offset.x = this.options.camera.offsetX;
              }

              if (this.options.camera.offsetY) {
                offset = offset || {};
                offset.y = this.options.camera.offsetY;
              }

              if (this.options.camera.offsetZ) {
                offset = offset || {};
                offset.z = this.options.camera.offsetZ;
              }

              this._map.scene.camera.lookAtTransform(this.computeModelMatrix(offset), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-transformX, 0, transformZ));

              break;
            }

          case "sd":
            {
              //锁定上帝视角
              if (this._map.trackedEntity != this._entity) {
                this._map.trackedEntity = this._entity;
              }

              this._map.scene.camera.lookAtTransform(this.computeModelMatrix(), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-1, 0, this.options.camera.followedZ) //followedZ距离运动点的高度（上方）
              );
            }
            break;
        } //实时监控


        if (this._map.clock.shouldAnimate) {
          this._updateRealTimePosition(_position);
        }
      }
    }
  }, {
    key: "_updateRealTimePosition",
    value: function _updateRealTimePosition(position) {
      this._flyok_point_index = this.getCurrIndex(); //计算投影线用的

      if (this.options.shadow && this.options.shadow.length > 0) {
        //投影
        this._updateArrShading(position);
      }

      this.fire(EventType.change, {
        position: position
      });
    }
    /**
     * 将轨迹数据转换为CZML格式数据
     * @param {Object[]} points 轨迹点数据数组，包含时间、经度、纬度值 即可。
     * @param {Object} [options={}] 参数对象:
     * @param {Object} [options.timeColumn='time'] 时间字段的名称
     * @param {Function} [options.getPosition] 构造单条数据内的构造坐标点的回调方法，如果points数据中已有position或lat\lng\alt字段也可以不传回调方法。
     * @return {void}  无
     * @example
    //更新车辆的轨迹
    let path = [{"lng":117.086419,"lat":31.803459,"time":"2020-11-25 10:00:00"},{"lng":117.061666,"lat":31.812281,"time":"2020-11-25 10:01:02"}]
    car.updatePath(path)
    //或
    let path = [{"longitude":117.086419,"latitude":31.803459,"datetime":"2020-11-25 10:00:00"},{"longitude":117.061666,"latitude":31.812281,"datetime":"2020-11-25 10:01:02"}]
    car.updatePath(path, {
    timeColumn: 'datetime',
    getPosition: function (item) {
      return Cesium.Cartesian3.fromDegrees(parseFloat(item.longitude), parseFloat(item.lat), 0)
    },
    })
    */

  }, {
    key: "updatePath",
    value: function updatePath(points) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!points || points.length == 0) {
        return;
      }

      if (!this.property) {
        this.property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
        this._entity.orientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](this.property); // 方向

        this._entity.show = true;
      }

      this._removeDynamicPosition();

      var position, currTime;

      for (var i = 0, len = points.length; i < len; i++) {
        var item = points[i];
        currTime = item[options.timeColumn || "time"];

        if (!currTime) {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now();
          Object(Log["logError"])("时间未能识别", item);
        } else if (Object(Util["isNumber"])(currTime)) {
          currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now(), currTime, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
        } else if (Object(Util["isString"])(currTime)) {
          if (currTime.indexOf("Z") == -1) {
            currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(currTime));
          } else {
            currTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(currTime);
          }
        }

        if (options.getPosition) {
          position = options.getPosition(item, i);
        } else if (item.position) {
          position = item.position;
        } else if (item.lat && item.lng) {
          position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(parseFloat(item.lon), parseFloat(item.lat), parseFloat(item.alt || 0));
        }

        if (!position) {
          continue;
        }

        this.property.addSample(currTime, position);
        this.positions.push(position);
        this.times.push(currTime);
      }

      this.lastItem = {
        position: position,
        time: currTime
      };
    }
  }, {
    key: "_removeDynamicPosition",
    value: function _removeDynamicPosition() {
      var duoyu = this.times.length - this._maxCacheCount;

      if (duoyu > 0) {
        var _starttime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(this.times[0], -0.2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());

        var _endtime = this.times[duoyu - 1];

        if (!_starttime || !_endtime) {
          return;
        }

        this.property.removeSamples(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TimeInterval"]({
          start: _starttime,
          stop: _endtime
        }));
        this.positions.splice(0, duoyu);
        this.times.splice(0, duoyu);
      }
    }
  }]);

  return DynamicRoamLine;
}(BaseRoamLine_BaseRoamLine);
// CONCATENATED MODULE: ./src/graphic/roam/RoamLine.js








function RoamLine_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function RoamLine_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RoamLine_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RoamLine_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RoamLine_createSuper(Derived) { var hasNativeReflectConstruct = RoamLine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RoamLine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











/**
 * @typedef {Object} RoamLine.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphic.EventType} 通用 支持的父类的事件类型
 * @property {String} start 开始
 * @property {String} change 变化了
 * @property {String} endItem 完成points其中一个点时的回调事件
 * @property {String} end 完成所有漫游的回调事件
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 * @example
 * //绑定监听事件
 * graphic.on(tudou3d.EventType.change, function (event) {
 *   console.log('坐标发生了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 飞行漫游路线管理类 【静态一次性传入的数据】
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphic.ConstructorOptions} [options.通用参数] 支持所有Graphic通用参数
 *
 * @param {Array[]|LatLngPoint[]} options.positions 轨迹的 坐标数组
 * @param {Array[]|Number} options.speed 轨迹的 速度( 单位：千米/小时)
 * @param {String} [options.timeField='time']  当points数组中已有时间值，请传入该值的字段名称，同时speed将失效，已实际传入时间字段为准。
 *
 * @param {Number} [options.offsetHeight=0]  轨迹偏移增加的高度
 * @param {String|Cesium.JulianDate} [options.startTime=clock.currentTime]  轨迹的开始时间
 * @param {Number|Function} [options.pauseTime=0]  每个点的停留时长（单位：秒）
 * @param {Number} [options.multiplier=1] 轨迹播放的倍率
 * @param {Boolean} [options.hasCache=true]  是否记录缓存，提高效率
 * @param {Cesium.Transforms.LocalFrameToFixedFrame} [options.fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
 * @param {Boolean} [options.interpolation=false]  是否LagrangePolynomialApproximation插值，对轨迹进行圆弧状插值
 * @param {Boolean} [options.interpolationDegree=2] 当interpolation为true时，使用的插值程度。
 *
 *
 *
 * @param {LabelEntity.StyleOptions} [options.label]  设置是否显示 文本 和对应的样式
 * @param {Boolean} [options.showGroundHeight=false]  是否求准确的 地面海拔 和 离地高度 (没有此需求时可以关闭，提高效率)
 * @param {ModelEntity.StyleOptions} [options.model]  设置是否显示 gltf模型 和对应的样式
 * @param {BillboardEntity.StyleOptions} [options.billboard]  设置是否显示 图标 和对应的样式，如果不设置gltf模型时，可以选择该项。
 * @param {PointEntity.StyleOptions} [options.point]  设置是否显示 图标 和对应的样式，如果不设置gltf模型时，可以选择该项。
 * @param {PathEntity.StyleOptions} [options.path]  设置是否显示 轨迹路线 和对应的样式
 * @param {CircleEntity.StyleOptions} [options.circle]  设置是否显示 圆对象 和对应的样式
 *
 * @param {Object[]} [options.shadow] 设置投影或附加的对象，支持类型：
 * @param {BaseRoamLine.WallShadingOptions} [options.shadow.wall] wall类型所支持的参数
 * @param {BaseRoamLine.CylinderShadingOptions} [options.shadow.cylinder] cylinder类型所支持的参数
 * @param {BaseRoamLine.CircleShadingOptions} [options.shadow.circle] circle类型所支持的参数
 * @param {BaseRoamLine.PolylineShadingOptions} [options.shadow.polyline] polyline类型所支持的参数
 * @param {BaseRoamLine.PolylineGoingShadingOptions} [options.shadow.polylineGoing] polylineGoing类型所支持的参数
 *
 *
 * @param {Object} [options.camera] 视角模式设置，包括：
 * @param {String} [options.camera.type]  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
 * @param {Number} [options.camera.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
 * @param {Number} [options.camera.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
 * @param {Number} [options.camera.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360 *
 * @param {Number} [options.camera.followedX=50] 锁定第一视角时，距离运动点的距离（后方）
 * @param {Number} [options.camera.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
 * @param {Number} [options.camera.offsetX=0] 'dy'锁定第一视角时，锁定点的本身的X轴方向（前后）偏移值
 * @param {Number} [options.camera.offsetY=0] 'dy'锁定第一视角时，锁定点的本身的Y轴方向（横向）偏移值
 * @param {Number} [options.camera.offsetZ=0] 'dy'锁定第一视角时，锁定点的本身的Z轴方向（高度）偏移值
 *
 * @param {Cesium.ClockRange} [options.clockRange]  指定播放的模式
 * @param {Boolean} [options.clockLoop=false]  是否循环播放，等价于clockRange:Cesium.ClockRange.LOOP_STOP
 *
 * @param {Cesium.ExtrapolationType} [forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
 * @param {Cesium.ExtrapolationType} [backwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
 * @param {Boolean} [options.showStop=false]  是否在start前或stop后显示模型等对象
 * @param {Boolean} [options.autoStop=false]  是否自动停止
 *
 * //以下是 clampToGround中使用的
 * @param {Number} [options.splitNum=100] 当clampToGround计算时，插值数，等比分割的个数
 * @param {Number} [options.minDistance=null] 当clampToGround计算时，插值最小间隔(单位：米)，优先级高于splitNum
 * @param {Number} [options.offset=0]  当clampToGround计算时，可以按需增加偏移高度（单位：米），便于可视
 *
 * @param {Boolean} [options.clampToTileset=false]  是否贴3dtiles模型上（贴模型效率较慢，按需开启）
 * @param {Number} [options.frameRate=30] 当clampToTileset：true时，控制贴模型的效率，多少帧计算一次贴模型高度,
 * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities, 或 3D Tiles features
 *
 *
 *
 * @export
 * @class RoamLine
 * @extends {BaseRoamLine}
 * @see [支持的事件类型]{@link RoamLine.EventType}
 */

var RoamLine_RoamLine = /*#__PURE__*/function (_BaseRoamLine) {
  inherits_default()(RoamLine, _BaseRoamLine);

  var _super = RoamLine_createSuper(RoamLine);

  function RoamLine() {
    classCallCheck_default()(this, RoamLine);

    return _super.apply(this, arguments);
  }

  createClass_default()(RoamLine, [{
    key: "isStart",
    get: //========== 对外属性 ==========

    /**
     * 是否已启动
     * @type {Boolean}
     * @readonly
     */
    function get() {
      return this._isStart;
    }
    /**
     * 当前实时信息
     * @type {Object}
     * @readonly
     */

  }, {
    key: "info",
    get: function get() {
      return this._timeinfo;
    } //========== 方法 ==========

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._isStart = false;

      if (this.options.positions) {
        this.createPath(this.options.positions, this.options);
      } else if (this.options.points) {
        this.createPath(this.options.points, this.options); //兼容points
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.stop();

      get_default()(getPrototypeOf_default()(RoamLine.prototype), "_removedHook", this).call(this);
    } //创建并计算飞行时间及坐标

  }, {
    key: "createPath",
    value: function createPath(arrPoint) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!arrPoint || arrPoint.length < 2) {
        Object(Log["logError"])("路线无坐标数据，无法漫游！", arrPoint);
        return;
      }

      this.points = LatLngArray_LatLngArray.toPoints(arrPoint); //坐标

      var offsetHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.offsetHeight, 0);
      var startTime; //飞行开始时间

      var stopTime; //飞行结束时间

      if (options.startTime) {
        if (Object(Util["isString"])(options.startTime)) {
          if (options.startTime.indexOf("Z") == -1) {
            startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(options.startTime));
          } else {
            startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(options.startTime);
          }
        } else {
          startTime = options.startTime;
        }
      } else {
        if (options.timeField) {
          var strTime = this.points[0][options.timeField];
          startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(strTime));
        } else {
          startTime = this._map.clock.currentTime;
        }
      }

      var arrSpeed = options.speed;
      var isSpeedArray = !Object(Util["isNumber"])(arrSpeed);

      if (this.points.length == 2) {
        //2个点时，需要插值，否则穿地
        var startPt = this.points[0];
        var endPt = this.points[1];
        var centerPt = new LatLngPoint["a" /* LatLngPoint */]((startPt.lng + endPt.lng) / 2, (startPt.lat + endPt.lat) / 2, (startPt.alt + endPt.alt) / 2);
        this.points.splice(1, 0, centerPt);

        if (arrSpeed && isSpeedArray) {
          arrSpeed.splice(1, 0, arrSpeed[0]);
        }
      }

      var property = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SampledPositionProperty"]();
      property.forwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.forwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
      property.backwardExtrapolationType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.backwardExtrapolationType, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExtrapolationType"].HOLD);
      this.positions = [];
      this.times = [];
      var defSpeed = 100; //无速度值时的 默认速度  单位：千米/小时

      var speedsNew = [];
      var alltimes = 0; //总时长,单位：秒

      var alllen = 0; //总长度,单位：米

      var stepLen = {}; //每一步的距离长度

      var stepTime = {}; //每一步的时长

      var lastPoint;
      var julianDate;

      for (var i = 0, length = this.points.length; i < length; i++) {
        var point = this.points[i];
        var item = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(point.lng, point.lat, point.alt + offsetHeight);
        item.point = point;

        if (i == 0) {
          //起点
          julianDate = startTime.clone();
          item.time = julianDate;
          item.second = alltimes;
          property.addSample(julianDate, item);
        } else {
          var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(item, lastPoint);

          if (len == 0) {
            continue;
          }

          var timeSecond = void 0;

          if (options.timeField) {
            var _strTime = point[options.timeField];
            var thisTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(_strTime));
            timeSecond = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(thisTime, julianDate);
            julianDate = thisTime;
            speedsNew.push(3.6 * len / timeSecond);
            alltimes += timeSecond;
          } else {
            var speed = isSpeedArray ? arrSpeed ? arrSpeed[i - 1] : defSpeed : arrSpeed || defSpeed;
            speedsNew.push(speed);
            speed = speed / 3.6; //速度：km/h换算m/s

            timeSecond = len / speed;

            if (timeSecond < 0.01) {
              //限定为最小值，防止速度值设置太大时，为0的错误
              timeSecond = 0.01;
            }

            alltimes += timeSecond;
            julianDate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(startTime, alltimes, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
          }

          alllen += len;
          item.time = julianDate;
          item.second = alltimes;
          property.addSample(julianDate, item);

          if (options.pauseTime) {
            if (typeof options.pauseTime == "function") {
              alltimes += options.pauseTime(i, item);
            } else {
              alltimes += options.pauseTime;
            }

            julianDate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(startTime, alltimes, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
            property.addSample(julianDate, Object(PointUtil["getOnLinePointByLen"])(lastPoint, item, 0.01, true));
          }
        }

        lastPoint = item;
        this.positions.push(item);
        this.times.push(julianDate);
        stepLen[i] = alllen;
        stepTime[i] = alltimes;
      }

      this.arrSpeed = speedsNew;
      this.lastItem = {
        position: this.positions[this.positions.length - 1],
        time: this.times[this.times.length - 1]
      };
      stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addSeconds(startTime, alltimes, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      this.alltimes = alltimes;
      this.alllen = alllen;
      this.stepLen = stepLen;
      this.stepTime = stepTime;
      this.startTime = startTime;
      this.stopTime = stopTime;
      this.property = property;
      this.velocityOrientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VelocityOrientationProperty"](this.property); //基于移动位置自动计算方位
      //插值，使折线边平滑 ,并且长距离下不穿地

      if (options.interpolation) {
        this.property.setInterpolationOptions({
          interpolationDegree: options.interpolationDegree || 2,
          interpolationAlgorithm: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LagrangePolynomialApproximation"] //HermitePolynomialApproximation

        });
      }

      if (options.showStop) {
        this._createStaticModel();
      }
    }
    /**
     * 开始飞行漫游
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start() {
      var _this$options$model,
          _this = this;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.positions) || this.positions.length == 0) {
        Object(Log["logError"])("没有坐标数据，飞行路线启动失败", this.positions);
        return;
      }

      if (!this._map) {
        return;
      }

      if (this._isStart) {
        this.stop();
      }

      this._isStart = true;

      this._createEntity(); //等模型加载完成后


      if ((_this$options$model = this.options.model) !== null && _this$options$model !== void 0 && _this$options$model.show && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ExpandByTudou"]) {
        this._map.clock.shouldAnimate = false;
        this._map.clock.currentTime = this.startTime.clone(); //等模型加载好再飞行

        this._entity.readyPromise = function (entity, model) {
          _this._start();
        };
      } else {
        this._start();
      }
    } //开始

  }, {
    key: "_start",
    value: function _start() {
      //=====================绑定clock timeline====================
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.multiplier)) {
        //飞行速度
        this._bak_multiplier = this._map.clock.multiplier;
        this._map.clock.multiplier = this.options.multiplier;
      }

      this._map.clock.shouldAnimate = true;
      this._map.clock.currentTime = this.startTime.clone();

      if (this.options.clockRange || this.options.clockLoop) {
        //循环播放
        this._bak_clockRange = this._map.clock.clockRange;
        this._bak_startTime = this._map.clock.startTime;
        this._bak_stopTime = this._map.clock.stopTime; //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放

        this._map.clock.clockRange = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.clockRange, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClockRange"].LOOP_STOP);
        this._map.clock.startTime = this.startTime.clone();
        this._map.clock.stopTime = this.stopTime.clone();
      }

      if (this._map.viewer.timeline) {
        this._map.viewer.timeline.zoomTo(this.startTime, this.stopTime);
      } //加投影


      if (this.options.shadow && this.options.shadow.length > 0) {
        this._addArrShading();
      }

      this._flyok_point_index = 0; //优化查询效率，飞行过的点id

      this.fire(EventType.endItem, {
        index: this._flyok_point_index,
        counts: this.positions.length
      });
      this.fire(EventType.start);

      this._map.on(EventType.preRender, this._onPreRenderHandler, this);
    }
    /**
     * 停止飞行漫游
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this._isStart || !this._map) {
        return;
      }

      this._map.trackedEntity = undefined;

      this._map.off(EventType.preRender, this._onPreRenderHandler, this);

      if (this._entity) {
        this.dataSource.entities.remove(this._entity);
        delete this._entity;
      }

      if (this._arrShowingEntity) {
        for (var i = 0, len = this._arrShowingEntity.length; i < len; i++) {
          this.dataSource.entities.remove(this._arrShowingEntity[i]);
        }

        delete this._arrShowingEntity;
      }

      if (this._bak_startTime) {
        this._map.clock.startTime = this._bak_startTime;
        delete this._bak_startTime;
      }

      if (this._bak_stopTime) {
        this._map.clock.stopTime = this._bak_stopTime;
        delete this._bak_stopTime;
      }

      if (this._bak_multiplier) {
        this._map.clock.multiplier = this._bak_multiplier;
        delete this._bak_multiplier;
      }

      if (this._bak_clockRange) {
        this._map.clock.clockRange = this._bak_clockRange;
        delete this._bak_clockRange;
      }

      this._flyok_point_index = 0;

      if (this.options.showStop) {
        this._createStaticModel();
      }

      this._isStart = false;
      this.fire(EventType.end);
    } //实时监控事件

  }, {
    key: "_onPreRenderHandler",
    value: function _onPreRenderHandler(e) {
      if (!this._isStart || this._entity == null || !this._map) {
        return;
      }

      if (this._map.clock.shouldAnimate && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].greaterThanOrEquals(this._map.clock.currentTime, this.stopTime)) {
        this._flyok_point_index = this.positions.length - 1; //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放

        if (!this._onStepTempBS) {
          this.fire(EventType.endItem, {
            index: this._flyok_point_index,
            counts: this.positions.length
          });
          this.fire(EventType.end);
          this._onStepTempBS = true; //为了标识只回调一次
        }

        if (this.options.autoStop) {
          this.stop();
        }

        return;
      } //当前点


      var _position = this.position;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_position)) {
        //如果位置都没有变化，直接返回
        if (this._hasCache) {
          var _thiscache = "".concat(_position.x, "-").concat(_position.y, "-").concat(_position.z);

          if (_thiscache == this._position_cache) {
            return;
          }

          this._position_cache = _thiscache;
        } //如果位置都没有变化，直接返回


        switch (this.options.camera.type) {
          default:
            //无
            if (this._map.trackedEntity == this._entity) {
              this._map.trackedEntity = undefined;
            }

            break;

          case "gs":
            //跟随视角
            if (this._map.clock.shouldAnimate && this._map.trackedEntity != this._entity) {
              this._map.trackedEntity = this._entity;
              this.flyToPoint(RoamLine_objectSpread(RoamLine_objectSpread({}, this.options.camera), {}, {
                duration: 0
              }));
            }

            break;

          case "dy":
            //锁定第一视角
            {
              if (this._map.trackedEntity != this._entity) {
                this._map.trackedEntity = this._entity;
              }

              var transformX = this.options.camera.followedX; //距离运动点的距离（后方）

              var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）

              if (transformX === 0 && transformZ === 0) {
                transformX = 0.1;
              }

              var offset;

              if (this.options.camera.offsetX) {
                offset = offset || {};
                offset.x = this.options.camera.offsetX;
              }

              if (this.options.camera.offsetY) {
                offset = offset || {};
                offset.y = this.options.camera.offsetY;
              }

              if (this.options.camera.offsetZ) {
                offset = offset || {};
                offset.z = this.options.camera.offsetZ;
              }

              this._map.scene.camera.lookAtTransform(this.computeModelMatrix(offset), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-transformX, 0, transformZ));
            }
            break;

          case "sd":
            //锁定上帝视角
            if (this._map.trackedEntity != this._entity) {
              this._map.trackedEntity = this._entity;
            }

            this._map.scene.camera.lookAtTransform(this.computeModelMatrix(), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-1, 0, this.options.camera.followedZ) //followedZ 距离运动点的高度（上方）
            );

            break;
        } //实时监控


        if (this._map.clock.shouldAnimate) {
          this._updateRealTimePosition(_position);
        }
      }
    }
  }, {
    key: "_updateRealTimePosition",
    value: function _updateRealTimePosition(position) {
      var _this2 = this;

      if (!this._map || !this._isStart) {
        return;
      }

      var time = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this._map.clock.currentTime, this.startTime); //已飞行时间

      var point = LatLngPoint["a" /* LatLngPoint */].fromCartesian(position);
      var currIndex = this.getCurrIndex();
      var lineLength = this.positions.length; // if (currIndex < 0) currIndex = 0;
      // if (currIndex >= lineLength) currIndex = lineLength - 1;

      var thislen = this.stepLen[currIndex];
      var lastPosition = this.positions[currIndex];

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](lastPosition)) {
        thislen += external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(position, lastPosition);
      }

      if (thislen >= this.alllen) {
        currIndex = lineLength - 1;
        thislen = this.alllen;
      }

      if (currIndex != this._flyok_point_index) {
        this.fire(EventType.endItem, {
          index: currIndex,
          counts: lineLength
        });
      }

      this._flyok_point_index = currIndex;
      this._timeinfo = {
        time: time,
        //已飞行时间
        len: thislen,
        //已飞行距离
        lng: point.lng,
        lat: point.lat,
        alt: point.alt
      }; //求概略的 地面海拔 和 离地高度

      var carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);

      var heightTerrain = this._map.scene.globe.getHeight(carto); //地形高度


      if (heightTerrain != null && heightTerrain > 0) {
        position.hbgd = heightTerrain; //updateWallShading中直接用

        this._timeinfo.hbgd = heightTerrain;
        this._timeinfo.ldgd = point.alt - heightTerrain;
      } //求准确的 地面海拔 和 离地高度 (没有此需求时可以关闭，提高效率)


      if (this.options.showGroundHeight) {
        computeSurfaceLine({
          map: this._map,
          positions: [position, position],
          callback: function callback(raisedPositions, noHeight) {
            if (raisedPositions == null || raisedPositions.length == 0 || noHeight) {
              return;
            }

            var hbgd = LatLngPoint["a" /* LatLngPoint */].fromCartesian(raisedPositions[0]).alt; //地面高程

            var ldgd = point.alt - hbgd; //离地高度

            if (_this2._timeinfo) {
              var _this2$_entity;

              _this2._timeinfo.hbgd = hbgd;
              _this2._timeinfo.ldgd = ldgd;

              if ((_this2$_entity = _this2._entity) !== null && _this2$_entity !== void 0 && _this2$_entity.label) {
                var fxgd_str = formatDistance(_this2._timeinfo.alt);
                var ldgd_str = formatDistance(_this2._timeinfo.ldgd);
                _this2._entity.label.text = _this2.name + "\n" + "漫游高程：" + fxgd_str + "\n离地距离：" + ldgd_str;
              }
            }
          }
        });
      } //投影


      if (this.options.shadow && this.options.shadow.length > 0) {
        this._updateArrShading(position);
      }

      this.fire(EventType.change, RoamLine_objectSpread(RoamLine_objectSpread({}, this._timeinfo), {}, {
        time: time,
        position: position,
        index: this._flyok_point_index
      }));
    }
    /**
     * 计算贴地线
     * @param {Function} callback 计算完成的回调方法
     * @return {void}  无
     */

  }, {
    key: "clampToGround",
    value: function clampToGround(callback) {
      var _this3 = this;

      //贴地线
      var lonlats = this.points;
      var arrSpeed = this.arrSpeed || this.options.speed;
      var lonlatsNew = [];
      var speedsNew = []; //剖面的数据

      var alllen = 0;
      var arrLength = [];
      var arrHbgd = [];
      var arrFxgd = [];
      var arrPoint = [];
      computeStepSurfaceLine({
        map: this._map,
        positions: this.positions,
        splitNum: this.options.splitNum,
        minDistance: this.options.minDistance,
        has3dtiles: this.options.clampToTileset || this.options.has3dtiles,
        objectsToExclude: this.objectsToExclude,
        offset: this.options.offset,
        //计算每个分段后的回调方法
        endItem: function endItem(raisedPositions, noHeight, index) {
          var _lonlats$index, _lonlats;

          if (!_this3._map) {
            return;
          }

          var speed = arrSpeed[index];

          if (noHeight) {
            lonlatsNew.push(lonlats[index].toArray());
            speedsNew.push(speed);
          } else {
            for (var i = 0; i < raisedPositions.length; i++) {
              var position = raisedPositions[i];
              var carto = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position);
              lonlatsNew.push([external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(carto.longitude), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(carto.latitude), carto.height]);
              speedsNew.push(speed);
            }
          } //剖面的数据


          var h1 = ((_lonlats$index = lonlats[index]) === null || _lonlats$index === void 0 ? void 0 : _lonlats$index.alt) || 0;
          var h2 = ((_lonlats = lonlats[index + 1]) === null || _lonlats === void 0 ? void 0 : _lonlats.alt) || 0;
          var hstep = (h2 - h1) / raisedPositions.length;

          for (var _i = 0; _i < raisedPositions.length; _i++) {
            //已飞行长度
            if (_i != 0) {
              alllen += external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(raisedPositions[_i], raisedPositions[_i - 1]);
            }

            arrLength.push(Number(alllen.toFixed(1))); //坐标

            var point = LatLngPoint["a" /* LatLngPoint */].fromCartesian(raisedPositions[_i]);
            arrPoint.push(point); //海拔高度

            var hbgd = noHeight ? 0 : point.alt;
            arrHbgd.push(hbgd); //飞行高度

            var fxgd = Number((h1 + hstep * _i).toFixed(1));
            arrFxgd.push(fxgd);
          }
        },
        //计算全部完成的回调方法
        end: function end() {
          if (!_this3._map) {
            return;
          } //剖面的数据(记录下，提高效率，避免多次计算)


          _this3.terrainHeight = {
            arrLength: arrLength,
            arrFxgd: arrFxgd,
            arrHbgd: arrHbgd,
            arrPoint: arrPoint
          };

          _this3.createPath(lonlatsNew, RoamLine_objectSpread(RoamLine_objectSpread({}, _this3.options), {}, {
            speed: speedsNew
          }));

          if (callback) {
            callback({
              lonlats: lonlatsNew,
              speed: speedsNew
            });
          }
        }
      });
    }
    /**
     * 获取剖面数据
     *
     * @param {Function} callback 计算完成的回调方法
     * @return {void}  无
     */

  }, {
    key: "getTerrainHeight",
    value: function getTerrainHeight(callback) {
      var _this4 = this;

      if (this.terrainHeight) {
        callback(this.terrainHeight);
        return this.terrainHeight;
      } else {
        var lonlats = this.points; //剖面的数据

        var alllen = 0;
        var arrLength = [];
        var arrHbgd = [];
        var arrFxgd = [];
        var arrPoint = [];
        computeStepSurfaceLine({
          map: this._map,
          positions: this.positions,
          splitNum: this.options.splitNum,
          offset: this.options.offset,
          has3dtiles: this.options.clampToTileset || this.options.has3dtiles,
          objectsToExclude: this.objectsToExclude,
          //计算每个分段后的回调方法
          endItem: function endItem(raisedPositions, noHeight, index) {
            //剖面的数据
            var h1 = lonlats[index].alt;
            var h2 = lonlats[index + 1].alt;
            var hstep = (h2 - h1) / raisedPositions.length;

            for (var i = 0; i < raisedPositions.length; i++) {
              //已飞行长度
              if (i != 0) {
                alllen += external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(raisedPositions[i], raisedPositions[i - 1]);
              }

              arrLength.push(Number(alllen.toFixed(1))); //坐标

              var point = LatLngPoint["a" /* LatLngPoint */].fromCartesian(raisedPositions[i]);
              arrPoint.push(point); //海拔高度

              var hbgd = noHeight ? 0 : point.alt;
              arrHbgd.push(hbgd); //飞行高度

              var fxgd = Number((h1 + hstep * i).toFixed(1));
              arrFxgd.push(fxgd);
            }
          },
          //计算全部完成的回调方法
          end: function end() {
            //剖面的数据(记录下，提高效率，避免多次计算)
            _this4.terrainHeight = {
              arrLength: arrLength,
              arrFxgd: arrFxgd,
              arrHbgd: arrHbgd,
              arrPoint: arrPoint
            };
            callback(_this4.terrainHeight);
          }
        });
      }
    }
  }]);

  return RoamLine;
}(BaseRoamLine_BaseRoamLine);
// CONCATENATED MODULE: ./src/graphic/index.js






 //基础entity





















 //扩展的entity


 //polygon扩展的entity













 //基础primitive





















 //扩展的primitive







 //自定义扩展的DIV




 //其他自定义扩展的





// CONCATENATED MODULE: ./src/layer/tileLayer/provider/XyzImageryProvider.js





function XyzImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = XyzImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function XyzImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

 //标准XYZ地图

var XyzImageryProvider_XyzImageryProvider = /*#__PURE__*/function (_Cesium$UrlTemplateIm) {
  inherits_default()(XyzImageryProvider, _Cesium$UrlTemplateIm);

  var _super = XyzImageryProvider_createSuper(XyzImageryProvider);

  function XyzImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, XyzImageryProvider);

    options.customTags = options.customTags || {}; //对同域的一些url的支持

    options.customTags["host"] = function (imageryProvider, x, y, level) {
      return location.host;
    };

    options.customTags["hostname"] = function (imageryProvider, x, y, level) {
      return location.hostname;
    }; //对EPSG:4490支持


    options.customTags["z4490"] = function (imageryProvider, x, y, level) {
      return level + 1;
    };

    return _super.call(this, options);
  }

  return XyzImageryProvider;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["UrlTemplateImageryProvider"]);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/TdtImageryProvider.js







function TdtImageryProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function TdtImageryProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TdtImageryProvider_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TdtImageryProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TdtImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = TdtImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TdtImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var TdtImageryProvider_TdtImageryProvider = /*#__PURE__*/function (_Cesium$WebMapTileSer) {
  inherits_default()(TdtImageryProvider, _Cesium$WebMapTileSer);

  var _super = TdtImageryProvider_createSuper(TdtImageryProvider);

  function TdtImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TdtImageryProvider);

    var _layer;

    var _key;

    var maxLevel = 18;

    switch (options.layer) {
      default:
      case "vec_d":
        _layer = "vec";
        break;

      case "vec_z":
        _layer = "cva";
        break;

      case "img_d":
        _layer = "img";
        break;

      case "img_z":
        _layer = "cia";
        break;

      case "ter_d":
        _layer = "ter";
        maxLevel = 14;
        break;

      case "ter_z":
        _layer = "cta";
        maxLevel = 14;
        break;
    }

    if (options.key == null || options.key.length == 0) {
      options.key = tiandituArr;
    }

    _key = Object(Util["getArrayRandomOne"])(options.key);

    var _url;

    if (options.crs == CRS["a" /* CRS */].EPSG4490 || options.crs == CRS["a" /* CRS */].EPSG4326) {
      //wgs84
      _url = "https://t{s}.tianditu.gov.cn/" + _layer + "_c/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" + _layer + "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" + _key;

      if (options.proxy || options.headers || options.queryParameters) {
        //存在代理等参数时
        _url = Object(Util["getUrlResource"])({
          url: _url.replace("{s}", "0"),
          proxy: options.proxy,
          headers: options.headers,
          queryParameters: options.queryParameters
        });
      }

      options = TdtImageryProvider_objectSpread(TdtImageryProvider_objectSpread({
        subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
        maximumLevel: maxLevel
      }, options), {}, {
        url: _url,
        layer: _layer,
        style: "default",
        format: "tiles",
        tileMatrixSetID: "c",
        tileMatrixLabels: toConsumableArray_default()(Array(20).keys()).map(function (level) {
          return (level + 1).toString();
        }),
        tilingScheme: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeographicTilingScheme"]()
      });
    } else {
      //墨卡托
      _url = "https://t{s}.tianditu.gov.cn/" + _layer + "_w/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" + _layer + "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" + _key;

      if (options.proxy || options.headers || options.queryParameters) {
        //存在代理等参数时
        _url = Object(Util["getUrlResource"])({
          url: _url.replace("{s}", "0"),
          proxy: options.proxy,
          headers: options.headers,
          queryParameters: options.queryParameters
        });
      }

      options = TdtImageryProvider_objectSpread(TdtImageryProvider_objectSpread({
        subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
        maximumLevel: maxLevel
      }, options), {}, {
        url: _url,
        layer: _layer,
        style: "default",
        format: "tiles",
        tileMatrixSetID: "w",
        tileMatrixLabels: toConsumableArray_default()(Array(20).keys()).map(function (level) {
          return level.toString();
        }),
        tilingScheme: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMercatorTilingScheme"]()
      });
    }

    return _super.call(this, options);
  }

  return TdtImageryProvider;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMapTileServiceImageryProvider"]);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/GaodeImageryProvider.js






function GaodeImageryProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GaodeImageryProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GaodeImageryProvider_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GaodeImageryProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GaodeImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = GaodeImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GaodeImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //高德地图

var GaodeImageryProvider_GaodeImageryProvider = /*#__PURE__*/function (_XyzImageryProvider) {
  inherits_default()(GaodeImageryProvider, _XyzImageryProvider);

  var _super = GaodeImageryProvider_createSuper(GaodeImageryProvider);

  function GaodeImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GaodeImageryProvider);

    var _url;

    switch (options.layer) {
      default:
        _url = options.url;
        break;

      case "vec":
        //style=7是立体的，style=8是灰色平面的
        _url = "https://" + (options.bigfont ? "wprd" : "webrd") + "0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}";
        break;

      case "img_d":
        _url = "https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}";
        break;

      case "img_z":
        _url = "https://webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8";
        break;

      case "time":
        {
          var time = new Date().getTime();
          _url = "https://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&&t=" + time;
          break;
        }
    }

    if (options.proxy || options.headers || options.queryParameters) {
      //存在代理等参数时
      _url = Object(Util["getUrlResource"])({
        url: _url.replace("{s}", "1"),
        proxy: options.proxy,
        headers: options.headers,
        queryParameters: options.queryParameters
      });
    }

    return _super.call(this, GaodeImageryProvider_objectSpread(GaodeImageryProvider_objectSpread({
      subdomains: ["1", "2", "3", "4"],
      maximumLevel: 18
    }, options), {}, {
      url: _url
    }));
  }

  return GaodeImageryProvider;
}(XyzImageryProvider_XyzImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/crs/BaiduMercatorProjection.js


var EARTH_RADIUS = 6370996.81;
var MC_BAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];
var LL_BAND = [75, 60, 45, 30, 15, 0];
var MC2LL = [[1.410526172116255e-8, 8.98305509648872e-6, -1.9939833816331, 2.009824383106796e2, -1.872403703815547e2, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 1.73379812e7], [-7.435856389565537e-9, 8.983055097726239e-6, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486e7], [-3.030883460898826e-8, 8.98305509983578e-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6.85681737e6], [-1.981981304930552e-8, 8.983055099779535e-6, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4.48277706e6], [3.09191371068437e-9, 8.983055096812155e-6, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2.5551644e6], [2.890871144776878e-9, 8.983055095805407e-6, -0.00000003068298, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 8.260885e5]];
var LL2MC = [[-0.0015702102444, 1.113207020616939e5, 1.704480524535203e15, -1.033898737604234e16, 2.611266785660388e16, -3.51496691766537e16, 2.659570071840392e16, -1.072501245418824e16, 1.800819912950474e15, 82.5], [8.277824516172526e-4, 1.113207020463578e5, 6.477955746671608e8, -4.082003173641316e9, 1.077490566351142e10, -1.517187553151559e10, 1.205306533862167e10, -5.124939663577472e9, 9.133119359512032e8, 67.5], [0.00337398766765, 1.113207020202162e5, 4.481351045890365e6, -2.339375119931662e7, 7.968221547186455e7, -1.159649932797253e8, 9.723671115602145e7, -4.366194633752821e7, 8.477230501135234e6, 52.5], [0.00220636496208, 1.113207020209128e5, 5.175186112841131e4, 3.796837749470245e6, 9.920137397791013e5, -1.22195221711287e6, 1.340652697009075e6, -6.209436990984312e5, 1.444169293806241e5, 37.5], [-3.441963504368392e-4, 1.113207020576856e5, 2.782353980772752e2, 2.485758690035394e6, 6.070750963243378e3, 5.482118345352118e4, 9.540606633304236e3, -2.71055326746645e3, 1.405483844121726e3, 22.5], [-3.218135878613132e-4, 1.113207020701615e5, 0.00369383431289, 8.237256402795718e5, 0.46104986909093, 2.351343141331292e3, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];
var BaiduMercatorProjection_BaiduMercatorProjection = /*#__PURE__*/function () {
  function BaiduMercatorProjection() {
    classCallCheck_default()(this, BaiduMercatorProjection);

    this.isWgs84 = false;
  }

  createClass_default()(BaiduMercatorProjection, [{
    key: "getDistanceByMC",
    value: function getDistanceByMC(point1, point2) {
      if (!point1 || !point2) {
        return 0;
      }

      point1 = this.convertMC2LL(point1);

      if (!point1) {
        return 0;
      }

      var x1 = this.toRadians(point1["lng"]);
      var y1 = this.toRadians(point1["lat"]);
      point2 = this.convertMC2LL(point2);

      if (!point2) {
        return 0;
      }

      var x2 = this.toRadians(point2["lng"]);
      var y2 = this.toRadians(point2["lat"]);
      return this.getDistance(x1, x2, y1, y2);
    }
  }, {
    key: "getDistanceByLL",
    value: function getDistanceByLL(point1, point2) {
      if (!point1 || !point2) {
        return 0;
      }

      point1["lng"] = this.getLoop(point1["lng"], -180, 180);
      point1["lat"] = this.getRange(point1["lat"], -74, 74);
      point2["lng"] = this.getLoop(point2["lng"], -180, 180);
      point2["lat"] = this.getRange(point2["lat"], -74, 74);
      var x1 = this.toRadians(point1["lng"]);
      var y1 = this.toRadians(point1["lat"]);
      var x2 = this.toRadians(point2["lng"]);
      var y2 = this.toRadians(point2["lat"]);
      return this.getDistance(x1, x2, y1, y2);
    }
  }, {
    key: "convertMC2LL",
    value: function convertMC2LL(point) {
      if (!point) {
        return {
          lng: 0,
          lat: 0
        };
      }

      var lnglat = {};

      if (this.isWgs84) {
        lnglat.lng = point.lng / 20037508.34 * 180;
        var mmy = point.lat / 20037508.34 * 180;
        lnglat.lat = 180 / Math.PI * (2 * Math.atan(Math.exp(mmy * Math.PI / 180)) - Math.PI / 2);
        return {
          lng: lnglat["lng"].toFixed(6),
          lat: lnglat["lat"].toFixed(6)
        };
      }

      var temp = {
        lng: Math.abs(point["lng"]),
        lat: Math.abs(point["lat"])
      };
      var factor = undefined;

      for (var i = 0; i < MC_BAND.length; i++) {
        if (temp["lat"] >= MC_BAND[i]) {
          factor = MC2LL[i];
          break;
        }
      }

      lnglat = this.convertor(point, factor);
      return {
        lng: lnglat["lng"].toFixed(6),
        lat: lnglat["lat"].toFixed(6)
      };
    } // /**
    //  * The latitude and longitude coordinates are converted to plane cartesian coordinates
    //  * @param point
    //  * @returns {{lng: number, lat: number}|*}
    //  */

  }, {
    key: "convertLL2MC",
    value: function convertLL2MC(point) {
      if (!point) {
        return {
          lng: 0,
          lat: 0
        };
      }

      if (point["lng"] > 180 || point["lng"] < -180 || point["lat"] > 90 || point["lat"] < -90) {
        return point;
      }

      if (this.isWgs84) {
        var mercator = {};
        var earthRad = 6378137.0;
        mercator.lng = point.lng * Math.PI / 180 * earthRad;
        var a = point.lat * Math.PI / 180;
        mercator.lat = earthRad / 2 * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));
        return {
          lng: parseFloat(mercator["lng"].toFixed(2)),
          lat: parseFloat(mercator["lat"].toFixed(2))
        };
      }

      point["lng"] = this.getLoop(point["lng"], -180, 180);
      point["lat"] = this.getRange(point["lat"], -74, 74);
      var temp = {
        lng: point["lng"],
        lat: point["lat"]
      };
      var factor = undefined;

      for (var i = 0; i < LL_BAND.length; i++) {
        if (temp["lat"] >= LL_BAND[i]) {
          factor = LL2MC[i];
          break;
        }
      }

      if (!factor) {
        for (var _i = 0; _i < LL_BAND.length; _i++) {
          if (temp["lat"] <= -LL_BAND[_i]) {
            factor = LL2MC[_i];
            break;
          }
        }
      }

      var mc = this.convertor(point, factor);
      return {
        lng: parseFloat(mc["lng"].toFixed(2)),
        lat: parseFloat(mc["lat"].toFixed(2))
      };
    } // /**
    //  *
    //  * @param fromPoint
    //  * @param factor
    //  * @returns {{lng: *, lat: *}}
    //  */

  }, {
    key: "convertor",
    value: function convertor(fromPoint, factor) {
      if (!fromPoint || !factor) {
        return {
          lng: 0,
          lat: 0
        };
      }

      var x = factor[0] + factor[1] * Math.abs(fromPoint["lng"]);
      var temp = Math.abs(fromPoint["lat"]) / factor[9];
      var y = factor[2] + factor[3] * temp + factor[4] * temp * temp + factor[5] * temp * temp * temp + factor[6] * temp * temp * temp * temp + factor[7] * temp * temp * temp * temp * temp + factor[8] * temp * temp * temp * temp * temp * temp;
      x *= fromPoint["lng"] < 0 ? -1 : 1;
      y *= fromPoint["lat"] < 0 ? -1 : 1;
      return {
        lng: x,
        lat: y
      };
    }
  }, {
    key: "getDistance",
    value: function getDistance(x1, x2, y1, y2) {
      return EARTH_RADIUS * Math.acos(Math.sin(y1) * Math.sin(y2) + Math.cos(y1) * Math.cos(y2) * Math.cos(x2 - x1));
    }
  }, {
    key: "toRadians",
    value: function toRadians(deg) {
      return Math.PI * deg / 180;
    }
  }, {
    key: "toDegrees",
    value: function toDegrees(rad) {
      return 180 * rad / Math.PI;
    }
  }, {
    key: "getRange",
    value: function getRange(v, a, b) {
      if (a != null) {
        v = Math.max(v, a);
      }

      if (b != null) {
        v = Math.min(v, b);
      }

      return v;
    }
  }, {
    key: "getLoop",
    value: function getLoop(v, a, b) {
      while (v > b) {
        v -= b - a;
      }

      while (v < a) {
        v += b - a;
      }

      return v;
    }
  }, {
    key: "lngLatToMercator",
    value: function lngLatToMercator(point) {
      return this.convertLL2MC(point);
    }
  }, {
    key: "lngLatToPoint",
    value: function lngLatToPoint(point) {
      var mercator = this.convertLL2MC(point);
      return {
        x: mercator["lng"],
        y: mercator["lat"]
      };
    } // /**
    //  * WebMercator transforms to latitude and longitude
    //  * @param point
    //  * @returns {Point|{lng: number, lat: number}}
    //  */

  }, {
    key: "mercatorToLngLat",
    value: function mercatorToLngLat(point) {
      return this.convertMC2LL(point);
    }
  }, {
    key: "pointToLngLat",
    value: function pointToLngLat(point) {
      var mercator = {
        lng: point.x,
        lat: point.y
      };
      return this.convertMC2LL(mercator);
    }
  }, {
    key: "pointToPixel",
    value: function pointToPixel(point, zoom, mapCenter, mapSize) {
      if (!point) {
        return {
          x: 0,
          y: 0
        };
      }

      point = this.lngLatToMercator(point);
      var zoomUnits = this.getZoomUnits(zoom);
      var x = Math.round((point["lng"] - mapCenter["lng"]) / zoomUnits + mapSize.width / 2);
      var y = Math.round((mapCenter["lat"] - point["lat"]) / zoomUnits + mapSize.height / 2);
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "pixelToPoint",
    value: function pixelToPoint(pixel, zoom, mapCenter, mapSize) {
      if (!pixel) {
        return {
          lng: 0,
          lat: 0
        };
      }

      var zoomUnits = this.getZoomUnits(zoom);
      var lng = mapCenter["lng"] + zoomUnits * (pixel.x - mapSize.width / 2);
      var lat = mapCenter["lat"] - zoomUnits * (pixel.y - mapSize.height / 2);
      var point = {
        lng: lng,
        lat: lat
      };
      return this.mercatorToLngLat(point);
    }
  }, {
    key: "getZoomUnits",
    value: function getZoomUnits(zoom) {
      return Math.pow(2, 18 - zoom);
    }
  }]);

  return BaiduMercatorProjection;
}();
// CONCATENATED MODULE: ./src/layer/tileLayer/crs/BaiduMercatorTilingScheme.js






function BaiduMercatorTilingScheme_createSuper(Derived) { var hasNativeReflectConstruct = BaiduMercatorTilingScheme_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaiduMercatorTilingScheme_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var BaiduMercatorTilingScheme_BaiduMercatorTilingScheme = /*#__PURE__*/function (_Cesium$WebMercatorTi) {
  inherits_default()(BaiduMercatorTilingScheme, _Cesium$WebMercatorTi);

  var _super = BaiduMercatorTilingScheme_createSuper(BaiduMercatorTilingScheme);

  function BaiduMercatorTilingScheme(options) {
    var _this;

    classCallCheck_default()(this, BaiduMercatorTilingScheme);

    _this = _super.call(this, options);
    var dstCoordType = options.mapChinaCRS || ChinaCRS["a" /* ChinaCRS */].WGS84; //map地图的坐标系

    var srcCoordType = ChinaCRS["a" /* ChinaCRS */].BAIDU; //layer图层的坐标系（默认与地图一致）

    var Map2CrsLayerCrs = Object(PointUtil["getTransFun"])(dstCoordType, srcCoordType);
    var LayerCrs2MapCrs = Object(PointUtil["getTransFun"])(srcCoordType, dstCoordType);
    var projection = new BaiduMercatorProjection_BaiduMercatorProjection();

    _this._projection.project = function (cartographic, result) {
      result = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(cartographic.longitude), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(cartographic.latitude)];

      if (Map2CrsLayerCrs) {
        result = Map2CrsLayerCrs(result);
      }

      result[0] = Math.min(result[0], 180);
      result[0] = Math.max(result[0], -180);
      result[1] = Math.min(result[1], 74.000022);
      result[1] = Math.max(result[1], -71.988531);
      result = projection.lngLatToPoint({
        lng: result[0],
        lat: result[1]
      });
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](result.x, result.y);
    };

    _this._projection.unproject = function (cartesian, result) {
      result = projection.mercatorToLngLat({
        lng: cartesian.x,
        lat: cartesian.y
      });
      result = [result.lng, result.lat];

      if (LayerCrs2MapCrs) {
        result = LayerCrs2MapCrs(result);
      }

      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(result[0]), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(result[1]));
    };

    _this.resolutions = options.resolutions || [];
    return _this;
  }

  createClass_default()(BaiduMercatorTilingScheme, [{
    key: "tileXYToNativeRectangle",
    value: function tileXYToNativeRectangle(x, y, level, result) {
      var tileWidth = this.resolutions[level];
      var west = x * tileWidth;
      var east = (x + 1) * tileWidth;
      var north = ((y = -y) + 1) * tileWidth;
      var south = y * tileWidth;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"](west, south, east, north);
      }

      result.west = west;
      result.south = south;
      result.east = east;
      result.north = north;
      return result;
    }
  }, {
    key: "positionToTileXY",
    value: function positionToTileXY(position, level, result) {
      var rectangle = this._rectangle;

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].contains(rectangle, position)) {
        return undefined;
      }

      var projection = this._projection;
      var webMercatorPosition = projection.project(position);

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](webMercatorPosition)) {
        return undefined;
      }

      var tileWidth = this.resolutions[level];
      var xTileCoordinate = Math.floor(webMercatorPosition.x / tileWidth);
      var yTileCoordinate = -Math.floor(webMercatorPosition.y / tileWidth);

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
        return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](xTileCoordinate, yTileCoordinate);
      }

      result.x = xTileCoordinate;
      result.y = yTileCoordinate;
      return result;
    }
  }]);

  return BaiduMercatorTilingScheme;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMercatorTilingScheme"]);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/BaiduImageryProvider.js


//百度地图


var BaiduImageryProvider_BaiduImageryProvider = /*#__PURE__*/function () {
  function BaiduImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaiduImageryProvider);

    var url;

    switch (options.layer) {
      default:
        url = options.url;
        break;

      case "vec":
        url = "https://maponline{s}.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=" + (options.bigfont ? "ph" : "pl") + "&scaler=2&udt=&from=jsapi2_0";
        break;

      case "img_d":
        url = "http://shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46";
        break;

      case "img_z":
        url = "http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=" + (options.bigfont ? "sh" : "sl") + "&v=020";
        break;

      case "custom":
        //Custom 各种自定义样式
        //可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
        options.style = options.style || "midnight";
        url = "http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=" + options.style;
        break;

      case "time":
        //实时路况
        url = "http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=".concat(new Date().getTime(), "&label=").concat(options.label || "web2D", "&v=017");
        break;

      case "streetview":
        //街景
        url = "https://gss0.bdstatic.com/5LUZemja_QUU8t7mm9GUKT-xh_/tile/?udt=20150114&qt=tile&styles=pl&x={x}&y={y}&z={z}";
        break;
    }

    this._url = url;
    this._tileWidth = 256;
    this._tileHeight = 256;
    this._maximumLevel = 18;
    var resolutions = [];

    for (var i = 0; i < 19; i++) {
      resolutions[i] = 256 * Math.pow(2, 18 - i);
    }

    this._tilingScheme = new BaiduMercatorTilingScheme_BaiduMercatorTilingScheme({
      resolutions: resolutions,
      rectangleSouthwestInMeters: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](-20037726.37, -12474104.17),
      rectangleNortheastInMeters: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](20037726.37, 12474104.17),
      mapChinaCRS: options.mapChinaCRS
    });
    this._rectangle = this._tilingScheme.rectangle;
    this._credit = undefined;
    this._token = undefined;
    this._readyPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defer"]();
  }

  createClass_default()(BaiduImageryProvider, [{
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "token",
    get: function get() {
      return this._token;
    }
  }, {
    key: "tileWidth",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("tileWidth must not be called before the imagery provider is ready.");
      }

      return this._tileWidth;
    }
  }, {
    key: "tileHeight",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("tileHeight must not be called before the imagery provider is ready.");
      }

      return this._tileHeight;
    }
  }, {
    key: "maximumLevel",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("maximumLevel must not be called before the imagery provider is ready.");
      }

      return this._maximumLevel;
    }
  }, {
    key: "minimumLevel",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("minimumLevel must not be called before the imagery provider is ready.");
      }

      return 0;
    }
  }, {
    key: "tilingScheme",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("tilingScheme must not be called before the imagery provider is ready.");
      }

      return this._tilingScheme;
    }
  }, {
    key: "rectangle",
    get: function get() {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("rectangle must not be called before the imagery provider is ready.");
      }

      return this._rectangle;
    }
  }, {
    key: "ready",
    get: function get() {
      return !!this._url;
    }
  }, {
    key: "readyPromise",
    get: function get() {
      return this._readyPromise;
    }
  }, {
    key: "credit",
    get: function get() {
      return this._credit;
    }
  }, {
    key: "hasAlphaChannel",
    get: function get() {
      return true;
    }
  }, {
    key: "getTileCredits",
    value: function getTileCredits(x, y, level) {}
  }, {
    key: "requestImage",
    value: function requestImage(x, y, level) {
      if (!this.ready) {
        throw new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DeveloperError"]("requestImage must not be called before the imagery provider is ready.");
      }

      var url = this._url;

      if (url instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"]) {
        url = url.url;
      }

      url = url.replace("{x}", String(x)).replace("{y}", String(-y)).replace("{z}", level).replace("{s}", "1");
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ImageryProvider"].loadImage(this, url);
    }
  }]);

  return BaiduImageryProvider;
}();
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/TencentImageryProvider.js





function TencentImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = TencentImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TencentImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

//腾讯地图


var TencentImageryProvider_TencentImageryProvider = /*#__PURE__*/function (_XyzImageryProvider) {
  inherits_default()(TencentImageryProvider, _XyzImageryProvider);

  var _super = TencentImageryProvider_createSuper(TencentImageryProvider);

  function TencentImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TencentImageryProvider);

    switch (options.layer) {
      default:
        break;

      case "vec":
        options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=1&scene=0";
        break;

      case "img_d":
        options.url = "https://p{s}.map.gtimg.com/sateTiles/{z}/{sx}/{sy}/{x}_{reverseY}.jpg?version=400";
        options["customTags"] = {
          sx: function sx(imageryProvider, x, y, level) {
            return x >> 4;
          },
          sy: function sy(imageryProvider, x, y, level) {
            return (1 << level) - y >> 4;
          }
        };
        break;

      case "img_z":
        options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=2&scene=0";
        break;

      case "custom":
        //Custom 各种自定义样式
        //可选值：灰白地图:3,暗色地图:4
        options.style = options.style || "4";
        options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=" + options.style + "&scene=0";
        break;
    }

    options.subdomains = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.subdomains, ["0", "1", "2"]);
    return _super.call(this, options);
  }

  return TencentImageryProvider;
}(XyzImageryProvider_XyzImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/GoogleImageryProvider.js






function GoogleImageryProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GoogleImageryProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GoogleImageryProvider_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GoogleImageryProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GoogleImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = GoogleImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GoogleImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var GoogleImageryProvider_GoogleImageryProvider = /*#__PURE__*/function (_XyzImageryProvider) {
  inherits_default()(GoogleImageryProvider, _XyzImageryProvider);

  var _super = GoogleImageryProvider_createSuper(GoogleImageryProvider);

  function GoogleImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GoogleImageryProvider);

    var _url;

    if (options.chinaCRS == ChinaCRS["a" /* ChinaCRS */].WGS84) {
      //无偏移
      switch (options.layer) {
        default:
        case "img_d":
          // _url = 'http://www.google.cn/maps/vt?lyrs=s&x={x}&y={y}&z={z}';
          // _url = 'http://mt{s}.google.cn/vt/lyrs=s&x={x}&y={y}&z={z}';
          _url = "http://mt3.google.cn/vt?lyrs=s@187&hl=us&gl=us&x={x}&y={y}&z={z}";
          break;
      }
    } else {
      //有偏移
      switch (options.layer) {
        default:
          _url = options.url;
          break;

        case "vec":
          _url = "http://mt{s}.google.cn/vt/lyrs=m@207000000&hl=zh-CN&gl=CN&src=app&x={x}&y={y}&z={z}&s=Galile";
          break;

        case "img_d":
          _url = "http://mt{s}.google.cn/vt/lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}&s=Gali";
          break;

        case "img_z":
          _url = "http://mt{s}.google.cn/vt/imgtp=png32&lyrs=h@207000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galil";
          break;

        case "ter":
          _url = "http://mt{s}.google.cn/vt/lyrs=t@131,r@227000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galile";
          break;
      }
    }

    if (options.proxy || options.headers || options.queryParameters) {
      //存在代理等参数时
      _url = Object(Util["getUrlResource"])({
        url: _url.replace("{s}", "1"),
        proxy: options.proxy,
        headers: options.headers,
        queryParameters: options.queryParameters
      });
    }

    return _super.call(this, GoogleImageryProvider_objectSpread(GoogleImageryProvider_objectSpread({
      subdomains: ["1", "2", "3"],
      maximumLevel: 20
    }, options), {}, {
      url: _url
    }));
  }

  return GoogleImageryProvider;
}(XyzImageryProvider_XyzImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/OsmImageryProvider.js






function OsmImageryProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function OsmImageryProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { OsmImageryProvider_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { OsmImageryProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function OsmImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = OsmImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function OsmImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //OSM

var OsmImageryProvider_OsmImageryProvider = /*#__PURE__*/function (_XyzImageryProvider) {
  inherits_default()(OsmImageryProvider, _XyzImageryProvider);

  var _super = OsmImageryProvider_createSuper(OsmImageryProvider);

  function OsmImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, OsmImageryProvider);

    var _url = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

    if (options.proxy || options.headers || options.queryParameters) {
      //存在代理等参数时
      _url = Object(Util["getUrlResource"])({
        url: _url.replace("{s}", "a"),
        proxy: options.proxy,
        headers: options.headers,
        queryParameters: options.queryParameters
      });
    }

    return _super.call(this, OsmImageryProvider_objectSpread(OsmImageryProvider_objectSpread({
      subdomains: "abc",
      maximumLevel: 18
    }, options), {}, {
      url: _url
    }));
  }

  return OsmImageryProvider;
}(XyzImageryProvider_XyzImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/EmptyImageryProvider.js






function EmptyImageryProvider_createSuper(Derived) { var hasNativeReflectConstruct = EmptyImageryProvider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EmptyImageryProvider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

 //空白图层，目前主要在Lod矢量数据加载作为事件触发使用。

var EmptyImageryProvider_EmptyImageryProvider = /*#__PURE__*/function (_Cesium$TileCoordinat) {
  inherits_default()(EmptyImageryProvider, _Cesium$TileCoordinat);

  var _super = EmptyImageryProvider_createSuper(EmptyImageryProvider);

  function EmptyImageryProvider() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EmptyImageryProvider);

    _this = _super.call(this, options);
    _this.options = options;
    _this._minimumLevel = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minimumLevel, 0);
    _this._maximumLevel = options.maximumLevel;
    _this._tilingScheme = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.tilingScheme, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeographicTilingScheme"]({
      ellipsoid: options.ellipsoid
    }));

    if (options.rectangle) {
      _this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].intersection(options.rectangle, _this._tilingScheme.rectangle);
    } else {
      _this._rectangle = _this._tilingScheme.rectangle;
    }

    return _this;
  }

  createClass_default()(EmptyImageryProvider, [{
    key: "requestImage",
    value: function requestImage(x, y, level) {
      var canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 256;

      if (level < this._minimumLevel || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._maximumLevel) && level > this._maximumLevel) {
        return canvas;
      }

      if (this.options.debuggerTileInfo) {
        var context = canvas.getContext("2d");
        context.strokeStyle = "#ffff00";
        context.lineWidth = 2;
        context.strokeRect(1, 1, 255, 255);
        var label = "L" + level + "X" + x + "Y" + y;
        context.font = "bold 25px Arial";
        context.textAlign = "center";
        context.fillStyle = "black";
        context.fillText(label, 127, 127);
        context.fillStyle = "#ffff00";
        context.fillText(label, 124, 124);
      }

      return canvas;
    }
  }]);

  return EmptyImageryProvider;
}(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TileCoordinatesImageryProvider"]);
// CONCATENATED MODULE: ./src/layer/tileLayer/provider/index.js








// CONCATENATED MODULE: ./src/layer/BaseLayer.js









function BaseLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseLayer_createSuper(Derived) { var hasNativeReflectConstruct = BaseLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 图层对象 的基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 图层id标识
 * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
 * @param {String} [options.name = '未命名'] 图层名称
 * @param {Boolean} [options.show = true] 图层是否显示
 * @param {Number} [options.opacity = 1] 透明度，取值范围：0.0-1.0
 * @param {Object} [options.center] 图层自定义定位视角
 * @param {Object} [options.popup] 当图层支持popup弹窗时，绑定的值
 * @param {Object} [options.tooltip]  当图层支持tooltip弹窗时，绑定的值
 * @param {Object} [options.contextmenuItems] 当图层支持右键菜单时，绑定的值
 * @param {Boolean} [options.stopPropagation=false] 当前类中事件是否停止冒泡, false时：事件冒泡到map中。
 *
 * @export
 * @class BaseLayer
 * @extends {BaseClass}
 */

var BaseLayer_BaseLayer = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(BaseLayer, _BaseClass);

  var _super = BaseLayer_createSuper(BaseLayer);

  function BaseLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseLayer);

    _this = _super.call(this, options);
    _this.options = options;
    _this._uuid = Object(Util["uuid"])();
    options.id = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.id, _this._uuid);
    options.pid = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.pid, -1);
    options.name = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.name, "未命名");
    _this._show = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.show, true);
    _this._opacity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.opacity, 1);

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.alpha)) {
      _this._opacity = options.alpha;
    }

    _this._bindControl();

    _this._state = State.INITIALIZED;
    return _this;
  } //========== 对外属性 ==========

  /**
   *  内置唯一标识ID
   *
   * @type {String}
   * @readonly
   */


  createClass_default()(BaseLayer, [{
    key: "uuid",
    get: function get() {
      return this._uuid;
    }
    /**
     * 对象的pid标识
     *
     * @type {String|Number}
     */

  }, {
    key: "pid",
    get: function get() {
      return this.options.pid;
    },
    set: function set(pid) {
      this.options.pid = pid;
    }
    /**
     * 对象的id标识
     *
     * @type {String|Number}
     */

  }, {
    key: "id",
    get: function get() {
      return this.options.id;
    },
    set: function set(id) {
      this.options.id = id;
    }
    /**
     * 名称 标识
     *
     * @type {String}
     */

  }, {
    key: "name",
    get: function get() {
      return this.options.name;
    },
    set: function set(name) {
      this.options.name = name;
    }
    /**
     * 图层类型
     *
     * @type {String}
     * @readonly
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     *
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * 是否已添加到地图
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isAdded",
    get: function get() {
      return this._state == State.ADDED;
    }
    /**
     * 是否已经销毁了
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isDestroy",
    get: function get() {
      return this._state == State.DESTROY;
    }
  }, {
    key: "layer",
    get: function get() {
      return null;
    }
    /**
     * 显示隐藏状态
     *
     * @type {Boolean}
     */

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(show) {
      if (this._show == show || this.isDestroy) {
        return;
      }

      this.options.show = show;
      this._show = show;

      if (this.layer) {
        if (Array.isArray(this.layer)) {
          this.layer.forEach(function (item) {
            item.show = show;
          });
        } else {
          this.layer.show = show;
        }
      }

      if (this.isAdded) {
        this._showHook && this._showHook(show);

        if (show) {
          this.fire(EventType.show, {
            layer: this
          });
        } else {
          this.fire(EventType.hide, {
            layer: this
          });
        }
      }
    }
    /**
     * 是否可以调整透明度
     *
     * @type {Boolean}
     * @readonly
     *
     */

  }, {
    key: "hasOpacity",
    get: function get() {
      return this.setOpacity ? true : false;
    }
    /**
     * 透明度，取值范围：0.0-1.0
     * @type {Number}
     *
     */

  }, {
    key: "opacity",
    get: function get() {
      return this._opacity;
    },
    set: function set(value) {
      this._opacity = value;
      this.setOpacity && this.setOpacity(value);
    }
    /**
     * 添加到地图上，同 map.addThing
     *
     * @param {Map} map 地图对象
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "addTo",
    value: function addTo(map) {
      if (map && map.addLayer) {
        map.addLayer(this);
      }

      return this;
    }
    /**
     * 从地图上移除，同map.removeThing
     *
     * @param {Boolean} destroy 是否调用destroy释放
     * @return {void}  无
     */

  }, {
    key: "remove",
    value: function remove(destroy) {
      if (this._map) {
        this._map.removeLayer(this, destroy);
      }
    }
    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onAdd",
    value: function _onAdd(map) {
      if (this._state == State.ADDED) {
        return;
      }

      this._map = map;

      if (!this.options.stopPropagation) {
        this.addEventParent(map);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._mountedHook();

          this._createOK = true;
        }
      }

      this._addedHook && this._addedHook();

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this._state = State.ADDED;
      this.fire(EventType.add);
      this.fire(EventType.addLayer, {
        layer: this
      }, true);
    }
    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onRemove",
    value: function _onRemove() {
      if (this._state == State.REMOVED) {
        return;
      }

      if (!this._map) {
        return;
      }

      this._removedHook && this._removedHook();
      this._state = State.REMOVED;
      this.fire(EventType.remove);
      this.fire(EventType.removeLayer, {
        layer: this
      }, true);

      if (this.options && !this.options.stopPropagation) {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {}
    /**
     * 显示错误弹窗，
     * 调用cesium的cesiumWidget.showErrorPanel
     *
     * @param {String} title 标题
     * @param {Object} error 错误内容对象
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "showError",
    value: function showError(title, error) {
      if (!error) {
        error = "未知错误";
      }

      if (this._map) {
        this._map.cesiumWidget.showErrorPanel(title, undefined, error);
      }

      Object(Log["logError"])("layer错误:" + title, error);
      return this;
    }
    /**
     * 入场动画后再执行flyTo，直接调用flyTo可能造成入场动画失败。
     *
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "flyToByAnimationEnd",
    value: function flyToByAnimationEnd() {
      var _this2 = this;

      if (!this._map || !this.show) {
        return this;
      }

      if (this._map.isFlyAnimation()) {
        this._map.openFlyAnimationEndFun = function () {
          _this2.flyTo(_this2.options.flyToOptions);
        };
      } else {
        this.flyTo(BaseLayer_objectSpread(BaseLayer_objectSpread({}, this.options.flyToOptions || {}), {}, {
          duration: 0
        }));
      }

      return this;
    }
    /**
     * 飞行定位至图层数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} options.radius 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.8] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
      * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (!this._map) {
        return this;
      }

      if (this.options.center) {
        this._map.setCameraView(this.options.center, options);
      } else if (this.options.extent) {
        this._map.flyToExtent(this.options.extent, options);
      } else if (this.options.onCenterAt) {
        this.options.onCenterAt(options);
      }

      return this;
    }
    /**
     * 更新图层参数
     *
     * @param {Object} options 与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (!options || Object.keys(options).length == 0) {
        return this;
      }

      this.options = Object(Util["merge"])(this.options, options);

      this._bindControl();

      this._setOptionsHook && this._setOptionsHook(this.options);
      return this;
    }
    /**
     * 将图层转为Json简单对象，用于存储后再传参加载
     * @return {Object} Json简单对象
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var options = Object(Util["clone"])(this.options);
      options.id = this.id;
      options.type = this.type;
      options.show = this.show || this.isAdded;

      this._toJsonEx(options);

      return options;
    } //转为json的额外需要处理的对象

  }, {
    key: "_toJsonEx",
    value: function _toJsonEx(newData) {} //============== popup/tooltip/contextmenuItems ======================
    //绑定内置的控件

  }, {
    key: "_bindControl",
    value: function _bindControl() {
      var _this3 = this;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.contextmenuItems)) {
        this.contextmenuItems = this.options.contextmenuItems;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.popup)) {
        this.popup = bindLayerPopup(this.options.popup, function (inhtml, event) {
          var attr = BaseLayer_objectSpread({
            layer_name: _this3.options.name
          }, _this3._getAttrForPopup(event));

          var title = _this3.options.popupTitleField ? attr[_this3.options.popupTitleField] : _this3.name;

          if (_this3.options.popupNoTitle) {
            title = null;
          }

          return Object(Util["getTemplateHtml"])(BaseLayer_objectSpread(BaseLayer_objectSpread({}, _this3.options.popup), {}, {
            title: title,
            template: inhtml,
            attr: attr
          }));
        });
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.tooltip)) {
        this.tooltip = bindLayerPopup(this.options.tooltip, function (inhtml, event) {
          var attr = BaseLayer_objectSpread({
            layer_name: _this3.options.name
          }, _this3._getAttrForPopup(event));

          var title = _this3.options.tooltipTitleField ? attr[_this3.options.tooltipTitleField] : _this3.name;

          if (_this3.options.tooltipNoTitle) {
            title = null;
          }

          return Object(Util["getTemplateHtml"])(BaseLayer_objectSpread(BaseLayer_objectSpread({}, _this3.options.tooltip), {}, {
            title: title,
            template: inhtml,
            attr: attr
          }));
        });
      }
    }
  }, {
    key: "_getAttrForPopup",
    value: function _getAttrForPopup(event) {
      var _event$graphic, _attr;

      if ((_event$graphic = event.graphic) !== null && _event$graphic !== void 0 && _event$graphic.attr) {
        return event.graphic.attr;
      }

      if (!event.czmObject) {
        return {};
      }

      var attr = event.czmObject._attr || event.czmObject.properties || event.czmObject.attribute;

      if (attr && attr.type && attr.attr) {
        //兼容历史数据,V2内部标绘生产的geojson
        attr = attr.attr;
      }

      return (_attr = attr) !== null && _attr !== void 0 ? _attr : {};
    } //销毁释放对象

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      if (this._state != State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }

      get_default()(getPrototypeOf_default()(BaseLayer.prototype), "destroy", this).call(this, noDel);

      this._state = State.DESTROY;
    }
  }]);

  return BaseLayer;
}(BaseClass_BaseClass); //对图层的popup tooltip处理（图层一般因为有属性读取及格式化处理）

function bindLayerPopup(popup, getHtmlFun) {
  //显示内容
  var inhtml;

  if (typeof_default()(popup) == "object" && popup.html) {
    inhtml = popup.html;
  } else {
    inhtml = popup;
    popup = {
      html: inhtml
    };
  }

  if (typeof inhtml == "function") {
    //自定义的回调方法
    popup.html = function (target, cartesian, callback) {
      return inhtml(target, cartesian, callback);
    };
  } else {
    //内置的格式化方法，一般使用getPopup
    popup.html = function (target) {
      return getHtmlFun(inhtml, target);
    };
  }

  popup.anchor = popup.anchor || [0, -15];
  return popup;
}
// CONCATENATED MODULE: ./src/layer/BaseGraphicLayer.js







function BaseGraphicLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseGraphicLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseGraphicLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseGraphicLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseGraphicLayer_createSuper(Derived) { var hasNativeReflectConstruct = BaseGraphicLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseGraphicLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} BaseGraphicLayer.EventType
 * 图层类支持的{@link EventType}事件类型
 *
 * @property {String} add 添加对象
 * @property {String} remove 移除对象
 * @property {String} show 显示了对象
 * @property {String} hide 隐藏了对象
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了矢量数据对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 矢量数据图层 Base基类
 *
 * @param {BaseGraphicLayer.ConstructorOptions} options 描述初始化构造参数选项的对象
 * @export
 * @class BaseGraphicLayer
 * @extends {BaseLayer}
 * @see [支持的事件类型]{@link BaseGraphicLayer.EventType}
 */

var BaseGraphicLayer_BaseGraphicLayer = /*#__PURE__*/function (_BaseLayer) {
  inherits_default()(BaseGraphicLayer, _BaseLayer);

  var _super = BaseGraphicLayer_createSuper(BaseGraphicLayer);

  //========== 构造方法 ==========
  function BaseGraphicLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseGraphicLayer);

    if (options.url && options.templateValues) {
      options.url = Object(Util["template"])(options.url, options.templateValues);
    }

    _this = _super.call(this, options);

    _this._setOptionsHook(options);

    return _this;
  }

  createClass_default()(BaseGraphicLayer, [{
    key: "_showHook",
    value: function _showHook(show) {
      if (!show) {
        this._closeAllControl();
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._bindDth();
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._unbindDth();

      this._closeAllControl();
    }
  }, {
    key: "_setOptionsHook",
    value: function _setOptionsHook(options) {
      //单体化时，不可调整透明度
      if (options.dth) {
        if (this.setOpacity) {
          delete this.setOpacity;
        }

        options.symbol = options.symbol || {};
        options.symbol.styleOptions = options.symbol.styleOptions || {};
        options.symbol.styleOptions.clampToGround = true;
      }
    } //是建筑物单体化时

  }, {
    key: "_bindDth",
    value: function _bindDth() {
      if (this.options.dth) {
        var _this$options$symbol;

        if (!((_this$options$symbol = this.options.symbol) !== null && _this$options$symbol !== void 0 && _this$options$symbol.type)) {
          this.options.symbol = this.options.symbol || {};
          this.options.symbol.type = "polygonP";
        }

        this._dth_highlighColor = Object(Util["getColorByStyle"])(this.options.dth, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString("rgba(255,255,0,0.3)")); //高亮时颜色

        this._dth_nullColor = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.01);

        if (this.options.dth.type == "click") {
          this.on(EventType.click, this._dthGraphic_mouseOverHandler, this);

          this._map.on(EventType.clickMap, this._dthGraphic_mouseOutHandler, this);
        } else {
          this.on(EventType.mouseOver, this._dthGraphic_mouseOverHandler, this);
          this.on(EventType.mouseOut, this._dthGraphic_mouseOutHandler, this);
        }
      }
    }
  }, {
    key: "_unbindDth",
    value: function _unbindDth() {
      if (this.options.dth) {
        if (this.options.dth.type == "click") {
          this.off(EventType.click, this._dthGraphic_mouseOverHandler, this);

          this._map.off(EventType.clickMap, this._dthGraphic_mouseOutHandler, this);
        } else {
          this.off(EventType.mouseOver, this._dthGraphic_mouseOverHandler, this);
          this.off(EventType.mouseOut, this._dthGraphic_mouseOutHandler, this);
        }

        this.clearLastDth();
      }
    }
    /**
     * 清除已选中的单体化高亮
     * @return {void}  无
     */

  }, {
    key: "clearLastDth",
    value: function clearLastDth() {
      var graphic = this._dth_highlighGraphic;

      if (!graphic) {
        return;
      }

      var attributes = graphic.geometryInstanceAttributes;

      if (attributes) {
        attributes.color = graphic._dth_material_bak || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].toValue(this._dth_nullColor);
      } else if (graphic.entityGraphic) {
        graphic.entityGraphic.material = graphic._dth_material_bak || this._dth_nullColor;
      }

      this._dth_highlighGraphic = null;
    }
    /**
     * 外部指定显示的单体化对象。
     * @param {BaseGraphic} graphic 本图层内的指定矢量对象
     * @return {void}  无
     */

  }, {
    key: "showDth",
    value: function showDth(graphic) {
      this.clearLastDth();

      if (graphic.type == "polygonP") {
        var attributes = graphic.geometryInstanceAttributes;

        if (!graphic._dth_material_bak) {
          graphic._dth_material_bak = attributes.color;
        }

        attributes.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ColorGeometryInstanceAttribute"].toValue(this._dth_highlighColor);
      } else if (graphic.entityGraphic) {
        if (!graphic._dth_material_bak) {
          graphic._dth_material_bak = graphic.entityGraphic.material;
        }

        graphic.entityGraphic.material = this._dth_highlighColor;
      }

      this._dth_highlighGraphic = graphic;
    } //移入

  }, {
    key: "_dthGraphic_mouseOverHandler",
    value: function _dthGraphic_mouseOverHandler(event) {
      var graphic = event.graphic;

      if (graphic) {
        this.showDth(graphic);
      } else {
        this.clearLastDth();
      }
    } //移出

  }, {
    key: "_dthGraphic_mouseOutHandler",
    value: function _dthGraphic_mouseOutHandler(event) {
      this.clearLastDth();
    } //关闭所有内部控件

  }, {
    key: "_closeAllControl",
    value: function _closeAllControl() {
      this.closePopup();
      this.closeTooltip();
      this.closeSmallTooltip();
      this.closeContextMenu();
    } //============== popup ======================

    /**
     * 是否存在Popup绑定
     *
     * @return {Boolean} 是否存在Popup绑定
     */

  }, {
    key: "hasPopup",
    value: function hasPopup() {
      return this.popup != null && this.popup != false;
    }
    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.template=true] 是否使用内置的Html模版，false时全部使用外部指定的html。
     * @param {Boolean} [options.timeRender=false] 是否实时更新面板，此时需要绑定content回调方法处理。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "bindPopup",
    value: function bindPopup(content, options) {
      this.popup = BaseGraphicLayer_objectSpread({
        html: content
      }, options);
      return this;
    }
    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "unbindPopup",
    value: function unbindPopup(stopPropagation) {
      if (stopPropagation) {
        this.popup = false;
      } else {
        this.popup = null;
      }

      this.closePopup();
      return this;
    }
    /**
     * 打开绑定的弹窗
     *
     * @param {BaseGraphic|Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindPopup绑定的参数，具体参考bindPopup方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "openPopup",
    value: function openPopup(position, options) {
      if (this.popup && position && this._map) {
        if (position.center && position.openPopup) {
          //是BaseGraphic时
          var graphic = position;

          this._map.openPopup(graphic.center, this, BaseGraphicLayer_objectSpread({
            heightReference: graphic.style.heightReference,
            clampToGround: graphic.style.clampToGround,
            event: {
              graphic: graphic
            }
          }, options));
        } else {
          this._map.openPopup(position, this, options);
        }
      }

      return this;
    }
    /**
     * 关闭弹窗
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closePopup",
    value: function closePopup() {
      // if (this.popup && this._map) {
      if (this._map) {
        this._map.closePopup(this);
      }

      return this;
    } //============== tooltip ======================

    /**
     * 是否绑定了tooltip
     *
     * @return {Boolean} 是否绑定
     */

  }, {
    key: "hasTooltip",
    value: function hasTooltip() {
      return this.tooltip != null && this.tooltip != false;
    }
    /**
     * 绑定鼠标移入的弹窗
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.template=true] 是否使用内置的Html模版，false时全部使用外部指定的html。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "bindTooltip",
    value: function bindTooltip(content, options) {
      this.tooltip = BaseGraphicLayer_objectSpread({
        html: content
      }, options);
      return this;
    }
    /**
     * 解除绑定的鼠标移入对象后的弹窗。
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "unbindTooltip",
    value: function unbindTooltip(stopPropagation) {
      if (stopPropagation) {
        this.tooltip = false;
      } else {
        this.tooltip = null;
      }

      this.closeTooltip();
      return this;
    }
    /**
     * 打开绑定的tooltip弹窗
     *
     * @param {BaseGraphic|Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindTooltip绑定的参数，具体参考bindTooltip方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openTooltip",
    value: function openTooltip(position, options) {
      if (this.tooltip && position && this._map) {
        if (position.center && position.openTooltip) {
          //是BaseGraphic时
          var graphic = position;

          this._map.openTooltip(graphic.center, this, BaseGraphicLayer_objectSpread({
            event: {
              graphic: graphic
            }
          }, options));
        } else {
          this._map.openTooltip(position, this, options);
        }
      }

      return this;
    }
    /**
     *  关闭弹窗
     *
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "closeTooltip",
    value: function closeTooltip() {
      // if (this.tooltip && this._map) {
      if (this._map) {
        this._map.closeTooltip(this);
      }

      return this;
    } //============== Small tooltip ======================

    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openSmallTooltip",
    value: function openSmallTooltip(position, message) {
      if (this._map) {
        this._map.openSmallTooltip(position, message);
      }

      return this;
    }
    /**
     * 关闭小提示窗
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeSmallTooltip",
    value: function closeSmallTooltip() {
      if (this._map) {
        this._map.closeSmallTooltip();
      }

      return this;
    } //============== contextMenu ======================

    /**
     * 是否有绑定的右键菜单
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "hasContextMenu",
    value: function hasContextMenu() {
      return this.contextmenuItems != null;
    }
    /**
     * 获取绑定的右键菜单数组
     *
     * @return {Object[]} 右键菜单数组
     */

  }, {
    key: "getContextMenu",
    value: function getContextMenu() {
      return this.contextmenuItems;
    }
    /**
     * 绑定右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
     * @param {String} [content.iconCls] 小图标css
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 参数对象(预留，目前未用)
     * @return {this} 当前对象本身，可以链式调用
     *
     * @example
     * //在layer上绑定右键菜单
        graphicLayer.bindContextMenu([
          {
            text: '删除对象',
            iconCls: 'fa fa-trash-o',
            callback: function (e) {
              let graphic = e.graphic
              if (graphic) {
                graphicLayer.removeGraphic(graphic)
              }
            },
          },
          {
            text: '计算长度',
            iconCls: 'fa fa-medium',
            show: function (e) {
              let graphic = e.graphic
              return graphic.type === 'polyline'
            },
            callback: function (e) {
              let graphic = e.graphic
              let strDis = tudou3d.MeasureUtil.formatDistance(graphic.distance)
              haoutil.alert('该对象的长度为:' + strDis)
            },
          },
        ])
      */

  }, {
    key: "bindContextMenu",
    value: function bindContextMenu(content, options) {
      this.contextmenuItems = content;
      return this;
    }
    /**
     * 解除绑定的右键菜单
     *
     * @param {Boolean} [stopPropagation=false] 单击事件中是否继续冒泡查找
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "unbindContextMenu",
    value: function unbindContextMenu(stopPropagation) {
      if (stopPropagation) {
        this.contextmenuItems = false;
      } else {
        this.contextmenuItems = null;
      }

      this.closeContextMenu();
      return this;
    }
    /**
     * 打开右键菜单
     *
     * @param {BaseGraphic|Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @param {Object} [options={}] 可以覆盖bindContextMenu绑定的参数，具体参考bindContextMenu方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openContextMenu",
    value: function openContextMenu(position, options) {
      if (this.contextmenuItems && position && this._map) {
        if (position.center && position.openContextMenu) {
          //是BaseGraphic时
          var graphic = position;

          this._map.openContextMenu(graphic.center, this, BaseGraphicLayer_objectSpread({
            event: {
              graphic: graphic
            }
          }, options));
        } else {
          this._map.openContextMenu(position, this, options);
        }
      }

      return this;
    }
    /**
     *  关闭右键菜单
     *
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "closeContextMenu",
    value: function closeContextMenu() {
      // if (this.contextmenuItems && this._map) {
      if (this._map) {
        this._map.closeContextMenu(this);
      }

      return this;
    }
  }]);

  return BaseGraphicLayer;
}(BaseLayer_BaseLayer);
/**
 * 矢量数据图层 通用构造参数
 *
 * @typedef {Object} BaseGraphicLayer.ConstructorOptions
 *
 * @property {String|Number} [id = uuid()] 图层id标识
 * @property {String|Number} [pid = -1] 图层父级的id，一般图层管理中使用
 * @property {String} [name = '未命名'] 图层名称
 * @property {Boolean} [show = true] 图层是否显示
 * @property {Object} [center] 图层自定义定位视角{@link Map#setCameraView}
 * @property {Number} center.lng 经度值, 180 - 180
 * @property {Number} center.lat 纬度值, -90 - 90
 * @property {Number} center.alt 高度值
 * @property {Number} center.heading 方向角度值，绕垂直于地心的轴旋转角度, 0-360
 * @property {Number} center.pitch 俯仰角度值，绕纬度线旋转角度, 0-360
 * @property {Number} center.roll 翻滚角度值，绕经度线旋转角度, 0-360
 * @property {Object} [extent=null] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
 * @property {Number} extent.xmin 最小经度值, -180 至 180
 * @property {Number} extent.xmax 最大纬度值, -180 至 180
 * @property {Number} extent.ymin 最小纬度值, -90 至 90
 * @property {Number} extent.ymax 最大纬度值, -90 至 90
 * @property {Number} [extent.height=0] 矩形高度值
 * @property {Boolean} [flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
 *
 * @property {String|Array} [popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板，当为数组时支持：
 * @property {String} popup.field 字段名称
 * @property {String} popup.name 显示的对应自定义名称
 * @property {String} [popup.type] 默认为label文本，也可以支持：'button'按钮，'html' html内容。
 * @property {String} [popup.callback] 当type为'button'按钮时，单击后触发的事件。
 * @property {String} [popup.html] 当type为'html'时，对于拼接的html内容。
 * @property {String|Function} [popup.format] 使用window上有效的格式化js方法名称或function回调方法，来格式化字符串值。
 * @property {String} [popup.unit] 追加的计量单位 或 其他字符串后缀。
 * @property {String|Array} [tooltip]  绑定的tooltip弹窗值，支持值同popup，也可以bindTooltip方法绑定
 * @property {Object} [contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
 *
 *
 * @property {Number} [opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
 * @property {Number} [zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
 *
 */
// CONCATENATED MODULE: ./src/layer/GroupLayer.js







function GroupLayer_createSuper(Derived) { var hasNativeReflectConstruct = GroupLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GroupLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 图层组，可以用于将多个图层组合起来方便控制（比如将 卫星底图 和 文字注记层 放在一起控制管理），或用于 图层管理 的图层分组节点（虚拟节点）。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 图层id标识
 * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
 * @param {String} [options.name = '未命名'] 图层名称
 * @param {Boolean} [options.show = true] 图层是否显示
 * @param {Number} [options.opacity = 1] 透明度，取值范围：0.0-1.0
 * @param {Object} [options.center] 图层自定义定位视角
 * @param {Object[]} [options.layers] 子图层数组，每个子图层的配置见按各类型图层配置即可。
 *
 * @export
 * @class GroupLayer
 * @extends {BaseGraphicLayer}
 */

var GroupLayer_GroupLayer = /*#__PURE__*/function (_BaseGraphicLayer) {
  inherits_default()(GroupLayer, _BaseGraphicLayer);

  var _super = GroupLayer_createSuper(GroupLayer);

  function GroupLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GroupLayer);

    _this = _super.call(this, options);
    _this._arrLayer = [];
    return _this;
  } // 父类使用的


  createClass_default()(GroupLayer, [{
    key: "layer",
    get: function get() {
      return this._arrLayer;
    }
    /**
     * 子图层对象数组
     *
     * @type {BaseLayer[]}
     * @readonly
     */

  }, {
    key: "arrLayer",
    get: function get() {
      return this._arrLayer;
    }
    /**
     * 是否空组 ，空组目前就图层管理用于图层分组节点（虚拟节点）。
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasEmptyGroup",
    get: function get() {
      return this.length == 0;
    }
    /**
     * 是否有子图层
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasChildLayer",
    get: function get() {
      return this.length > 0;
    }
    /**
     * 子图层的个数
     *
     * @type {Int}
     * @readonly
     */

  }, {
    key: "length",
    get: function get() {
      var _this$options$layers;

      if (((_this$options$layers = this.options.layers) === null || _this$options$layers === void 0 ? void 0 : _this$options$layers.length) > 0) {
        return this.options.layers.length;
      } else {
        return this._arrLayer.length;
      }
    }
    /**
     * 是否可以调整透明度
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasOpacity",
    get: function get() {
      if (this._arrLayer.length == 0) {
        return false;
      }

      return this._arrLayer[0].hasOpacity;
    }
    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasZIndex",
    get: function get() {
      if (this._arrLayer.length == 0) {
        return false;
      }

      return this._arrLayer[0].hasZIndex;
    }
    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */

  }, {
    key: "zIndex",
    get: function get() {
      return this.options.zIndex;
    },
    set: function set(zIndex) {
      this.options.zIndex = zIndex;
      this.eachLayer(function (layer) {
        if (layer.hasZIndex) {
          layer.zIndex = zIndex;
        }
      }, this);
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      get_default()(getPrototypeOf_default()(GroupLayer.prototype), "_mountedHook", this).call(this);

      var layers = this.options.layers;

      if (layers && layers.length > 0) {
        for (var index = 0; index < layers.length; index++) {
          var item = layers[index];
          item.noLayerManage = this.options.noLayerManage;
          var childlayer = Object(LayerUtil["create"])(item, this.options.templateValues);

          if (childlayer) {
            childlayer.parent = this;
            childlayer.addEventParent(this);
            this.addLayer(childlayer);
          }
        }
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this2 = this;

      this.eachLayer(function (layer) {
        layer.addEventParent(_this2);

        layer._onAdd(_this2._map);
      }, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      var _this3 = this;

      this.eachLayer(function (layer) {
        layer.removeEventParent(_this3);

        layer._onRemove(_this3._map);
      }, this);
    } //显示隐藏

  }, {
    key: "_showHook",
    value: function _showHook(value) {
      this.eachLayer(function (layer) {
        layer.show = value;
      }, this);
    } //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this.eachLayer(function (layer) {
        layer.opacity = value;
      }, this);
    }
    /**
     * 添加子图层，并绑定关联关系。
     *
     * @param {BaseLayer} childlayer 子图层对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addLayer",
    value: function addLayer(childlayer) {
      childlayer.pid = this.id;
      childlayer.parent = this;
      childlayer.addEventParent(this);

      this._arrLayer.push(childlayer);

      if (this.isAdded && !childlayer.isAdded) {
        this._map.addLayer(childlayer);
      }

      return this;
    }
    /**
     * 移除子图层，并解除关联关系。
     *
     * @param {BaseLayer} childlayer 子图层对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeLayer",
    value: function removeLayer(childlayer) {
      childlayer.parent = null;
      childlayer.removeEventParent(this);
      Object(Util["removeArrayItem"])(this._arrLayer, childlayer);

      if (this._map && childlayer.isAdded) {
        this._map.removeLayer(childlayer);
      }

      return this;
    }
    /**
     * 遍历每一个子图层并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachLayer",
    value: function eachLayer(method, context) {
      if (!this._arrLayer) {
        return;
      }

      this._arrLayer.forEach(function (layer) {
        method.call(context, layer);
      });

      return this;
    }
    /**
     * 获取所有子图层对象
     * @return {BaseLayer[]}} 所有子图层对象
     */

  }, {
    key: "getLayers",
    value: function getLayers() {
      return this._arrLayer;
    }
    /**
     * 根据ID或取图层
     *
     * @param {String|Number} id 图层id或uuid
     * @return {BaseLayer} 图层对象
     */

  }, {
    key: "getLayerById",
    value: function getLayerById(id) {
      var layers = this._arrLayer;

      if (!this._arrLayer || this._arrLayer.length == 0) {
        return;
      }

      for (var i = 0, len = layers.length; i < len; i++) {
        var layer = layers[i];

        if (layer.uuid == id || layer.id == id) {
          return layer;
        }
      }

      return undefined;
    }
    /**
     * 根据id或name属性获取图层
     *
     * @param {String|Number} name 图层id或uuid或name值
     * @return {BaseLayer} 图层对象
     */

  }, {
    key: "getLayer",
    value: function getLayer(name) {
      if (!this._arrLayer || this._arrLayer.length == 0) {
        return undefined;
      }

      for (var i = 0; i < this._arrLayer.length; i++) {
        var layer = this._arrLayer[i];

        if (layer.name == name || layer.uuid == name || layer.id == name) {
          return layer;
        }
      }

      return undefined;
    }
    /**
     * 是否有同名的子图层，一般用于新增时判断
     *
     * @param {String} name 图层名称
     * @param {BaseLayer} [excludedLayer=null] 可以指定不进行判断的图层，比如当前图层本身
     * @return {Boolean} 是否同名
     */

  }, {
    key: "hasLayer",
    value: function hasLayer(name, excludedLayer) {
      for (var i = 0; i < this._arrLayer.length; i++) {
        var layer = this._arrLayer[i];

        if (excludedLayer && layer == excludedLayer) {
          continue;
        }

        if (layer.name == name || layer.id == name) {
          return true;
        }
      }

      return false;
    } //销毁释放对象

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      this.eachLayer(function (layer) {
        layer.destroy(noDel);
      }, this);

      get_default()(getPrototypeOf_default()(GroupLayer.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return GroupLayer;
}(BaseGraphicLayer_BaseGraphicLayer); //注册下

Object(LayerUtil["register"])("group", GroupLayer_GroupLayer);
// CONCATENATED MODULE: ./src/layer/tileLayer/BaseTileLayer.js







function BaseTileLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaseTileLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseTileLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseTileLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseTileLayer_createSuper(Derived) { var hasNativeReflectConstruct = BaseTileLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseTileLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} BaseTileLayer.EventType
 * 当前栅格瓦片图层支持的{@link EventType}事件类型
 *
 * @property {String} add 添加对象
 * @property {String} remove 移除对象
 * @property {String} show 显示了对象
 * @property {String} hide 隐藏了对象
 *
 * @property {String} load 瓦片图层初始化完成
 * @property {String} addTile 栅格瓦片图层，开始加载瓦片
 * @property {String} addTileSuccess 栅格瓦片图层，加载瓦片完成
 * @property {String} addTileError 栅格瓦片图层，加载瓦片出错了
 *
 * @property {String} click  鼠标单击事件【WMS等动态服务enablePickFeatures:true时,支持单击获取对应的矢量对象】
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.addTile, function (event) {
 *   console.log('addTile', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 栅格Tile瓦片图层 基类
 *
 * @param {BaseTileLayer.ConstructorOptions} options 描述初始化构造参数选项的对象
 * @export
 * @class BaseTileLayer
 * @extends {BaseLayer}
 *
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.ImageryLayer
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 */

var BaseTileLayer_BaseTileLayer = /*#__PURE__*/function (_BaseLayer) {
  inherits_default()(BaseTileLayer, _BaseLayer);

  var _super = BaseTileLayer_createSuper(BaseTileLayer);

  function BaseTileLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaseTileLayer);

    _this = _super.call(this, options);

    _this._setRectangleByOptions(options);

    _this.isTile = true;
    return _this;
  }
  /**
   * 瓦片图层对应的内部ImageryLayer对象
   *
   * @type {Cesium.ImageryLayer}
   * @readonly
   */


  createClass_default()(BaseTileLayer, [{
    key: "layer",
    get: function get() {
      return this._imageryLayer;
    }
    /**
     * 瓦片图层对应的内部ImageryProvider对象
     *
     * @type {Cesium.XXXImageryProvider}
     * @readonly
     */

  }, {
    key: "imageryProvider",
    get: function get() {
      var _this$_imageryLayer;

      return (_this$_imageryLayer = this._imageryLayer) === null || _this$_imageryLayer === void 0 ? void 0 : _this$_imageryLayer.imageryProvider;
    }
    /**
     * 透明度，同opacity。从0.0到1.0。
     *
     * @type {Number}
     * @default 1.0
     */

  }, {
    key: "alpha",
    get: function get() {
      return this.opacity;
    },
    set: function set(value) {
      this.opacity = value;
    }
    /**
     * 亮度，取值范围：0.0-1.0。
     *
     * @type {Number}
     * @default 1.0
     */

  }, {
    key: "brightness",
    get: function get() {
      var _this$_imageryLayer2;

      return this.options.brightness || ((_this$_imageryLayer2 = this._imageryLayer) === null || _this$_imageryLayer2 === void 0 ? void 0 : _this$_imageryLayer2.brightness);
    },
    set: function set(value) {
      this.options.brightness = value;

      if (this._imageryLayer == null) {
        return;
      }

      this._imageryLayer.brightness = value;
    }
    /**
     * 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
     *
     * @type {Number}
     * @default 1.0
     */

  }, {
    key: "contrast",
    get: function get() {
      var _this$_imageryLayer3;

      return this.options.contrast || ((_this$_imageryLayer3 = this._imageryLayer) === null || _this$_imageryLayer3 === void 0 ? void 0 : _this$_imageryLayer3.contrast);
    },
    set: function set(value) {
      this.options.contrast = value;

      if (this._imageryLayer == null) {
        return;
      }

      this._imageryLayer.contrast = value;
    }
    /**
     * 色调。 0.0 时未修改的图像颜色。
     *
     * @type {Number}
     * @default 0.0
     */

  }, {
    key: "hue",
    get: function get() {
      var _this$_imageryLayer4;

      return this.options.hue || ((_this$_imageryLayer4 = this._imageryLayer) === null || _this$_imageryLayer4 === void 0 ? void 0 : _this$_imageryLayer4.hue);
    },
    set: function set(value) {
      this.options.hue = value;

      if (this._imageryLayer == null) {
        return;
      }

      this._imageryLayer.hue = value;
    }
    /**
     * 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
     *
     * @type {Number}
     * @default 1.0
     */

  }, {
    key: "saturation",
    get: function get() {
      var _this$_imageryLayer5;

      return this.options.saturation || ((_this$_imageryLayer5 = this._imageryLayer) === null || _this$_imageryLayer5 === void 0 ? void 0 : _this$_imageryLayer5.saturation);
    },
    set: function set(value) {
      this.options.saturation = value;

      if (this._imageryLayer == null) {
        return;
      }

      this._imageryLayer.saturation = value;
    }
    /**
     * 伽马校正值。 1.0使用未修改的图像颜色。
     *
     * @type {Number}
     * @default 1.0
     */

  }, {
    key: "gamma",
    get: function get() {
      var _this$_imageryLayer6;

      return this.options.gamma || ((_this$_imageryLayer6 = this._imageryLayer) === null || _this$_imageryLayer6 === void 0 ? void 0 : _this$_imageryLayer6.gamma);
    },
    set: function set(value) {
      this.options.gamma = value;

      if (this._imageryLayer == null) {
        return;
      }

      this._imageryLayer.gamma = value;
    }
    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasZIndex",
    get: function get() {
      return true;
    }
    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */

  }, {
    key: "zIndex",
    get: function get() {
      return this.options.zIndex;
    },
    set: function set(zIndex) {
      this.options.zIndex = zIndex;

      if (this._imageryLayer == null || zIndex == null) {
        return;
      } //先移动到最顶层


      this._map.imageryLayers.raiseToTop(this._imageryLayer);

      var layers = this._map.imageryLayers._layers;

      for (var i = layers.length - 1; i >= 0; i--) {
        var imageLayer = layers[i];

        if (imageLayer == this._imageryLayer) {
          continue;
        }

        var options = imageLayer._tudou3d_config; // this._map.getLayerById(layers[i]._tudou3d_layerId)

        if (options && options.zIndex) {
          if (zIndex < options.zIndex) {
            this._map.imageryLayers.lower(this._imageryLayer); //下移一个位置

          }
        }
      }
    }
    /**
     * 瓦片数据范围
     * @type {Cesium.Rectangle}
     */

  }, {
    key: "rectangle",
    get: function get() {
      var _this$_imageryLayer7, _this$_imageryLayer7$;

      if (this._rectangle) {
        return this._rectangle;
      } else if ((_this$_imageryLayer7 = this._imageryLayer) !== null && _this$_imageryLayer7 !== void 0 && (_this$_imageryLayer7$ = _this$_imageryLayer7.imageryProvider) !== null && _this$_imageryLayer7$ !== void 0 && _this$_imageryLayer7$.ready && this._imageryLayer.imageryProvider.rectangle) {
        return this._imageryLayer.imageryProvider.rectangle;
      } else {
        return null;
      }
    },
    set: function set(value) {
      var _this$_imageryLayer8, _this$_imageryLayer8$;

      this._rectangle = value || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].MAX_VALUE;
      this.options.rectangle = formatRectangle(this._rectangle);

      if ((_this$_imageryLayer8 = this._imageryLayer) !== null && _this$_imageryLayer8 !== void 0 && (_this$_imageryLayer8$ = _this$_imageryLayer8.imageryProvider) !== null && _this$_imageryLayer8$ !== void 0 && _this$_imageryLayer8$.ready && this._imageryLayer.imageryProvider.rectangle) {
        this._imageryLayer.imageryProvider._rectangle = this._rectangle;
      }
    }
  }, {
    key: "_setRectangleByOptions",
    value: function _setRectangleByOptions(options) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.rectangle)) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.rectangle.xmin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.rectangle.xmax) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.rectangle.ymin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.rectangle.ymax)) {
          this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(options.rectangle.xmin, options.rectangle.ymin, options.rectangle.xmax, options.rectangle.ymax);
        } else {
          this._rectangle = options.rectangle;
        }
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.bbox) && options.bbox.length && options.bbox.length == 4) {
        this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]);
      }
    } //更新参数

  }, {
    key: "_setOptionsHook",
    value: function _setOptionsHook(options) {
      this._setRectangleByOptions(options);

      this.reload();
    }
    /**
     * 创建瓦片图层对应的ImageryProvider对象
     * @param {Object} [options={}] 参数对象，具体每类瓦片图层都不一样。
     * @return {Cesium.UrlTemplateImageryProvider|*}  创建完成的 ImageryProvider 对象
     * @abstract
     */

  }, {
    key: "_createImageryProvider",
    value: function _createImageryProvider(options) {
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["UrlTemplateImageryProvider"](options);
    } //对象添加到地图上的创建钩子方法

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this2 = this;

      var imageryProvider = this._createImageryProvider(BaseTileLayer_objectSpread(BaseTileLayer_objectSpread({}, this.options), {}, {
        mapChinaCRS: this._map.chinaCRS //map地图的坐标系

      }));

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](imageryProvider)) {
        return;
      }

      var options = this.options;

      var layerOpts = BaseTileLayer_objectSpread(BaseTileLayer_objectSpread({
        show: this.show,
        //避免异步加载中设置show=false，需要赋值下
        alpha: this.opacity
      }, options), {}, {
        rectangle: this.rectangle
      });

      this._imageryLayer = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ImageryLayer"](imageryProvider, layerOpts);
      this._imageryLayer._tudou3d_layerId = this.uuid;
      this._imageryLayer._tudou3d_config = this.options; //以下4个接口为修改Cesium实现，在cesium内部会调用该4个回调方法。

      this._imageryLayer.onAddTile = function (imagery) {
        var params = _this2._getTileEventParams(imagery);

        _this2.fire(EventType.addTile, params); //添加瓦片，请求前

      };

      this._imageryLayer.onAddTileSuccess = function (imagery) {
        var params = _this2._getTileEventParams(imagery);

        _this2.fire(EventType.addTileSuccess, params);
      };

      this._imageryLayer.onAddTileError = function (imagery) {
        var params = _this2._getTileEventParams(imagery);

        _this2.fire(EventType.addTileError, params);
      };

      this._imageryLayer.onRemoveTile = function (imagery) {
        var params = _this2._getTileEventParams(imagery);

        _this2.fire(EventType.removeTile, params);
      };

      this._map.imageryLayers.add(this._imageryLayer); //调整顺序


      if (this.options.zIndex) {
        this.zIndex = this.options.zIndex;
      }

      imageryProvider.readyPromise.then(function (e) {
        _this2.fire(EventType.load, {}, true);

        setTimeout(function () {
          var _this2$options;

          if ((_this2$options = _this2.options) !== null && _this2$options !== void 0 && _this2$options.flyTo) {
            _this2.flyToByAnimationEnd();
          }
        }, 50);
      });
    }
  }, {
    key: "_getTileEventParams",
    value: function _getTileEventParams(imagery) {
      return {
        x: imagery.x,
        y: imagery.y,
        level: imagery.level,
        extent: formatRectangle(imagery.rectangle)
      };
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.imageryLayers.remove(this._imageryLayer, true);

      this._imageryLayer = null;
    }
    /**
     * 重新加载图层
     * @return {void}  无
     */

  }, {
    key: "reload",
    value: function reload() {
      if (this._imageryLayer) {
        this._removedHook();

        this._addedHook();
      }
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      if (this._imageryLayer) {
        this._imageryLayer.alpha = value;
      }
    } //定位至数据区域

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map || this._imageryLayer == null) {
        return;
      }

      if (this.options.center) {
        this._map.setCameraView(this.options.center, options);
      } else if (this.options.extent) {
        this._map.flyToExtent(this.options.extent, options);
      } else {
        var rectangle = this.rectangle; //arcgis图层等，读取配置信息

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](rectangle) && !rectangle.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].MAX_VALUE) && rectangle.west > 0 && rectangle.south > 0 && rectangle.east > 0 && rectangle.north > 0) {
          this._map.camera.flyTo(BaseTileLayer_objectSpread(BaseTileLayer_objectSpread({}, options), {}, {
            destination: rectangle
          }));
        }
      }
    }
  }]);

  return BaseTileLayer;
}(BaseLayer_BaseLayer);
/**
 * 栅格Tile瓦片图层 通用构造参数
 *
 * @typedef {Object} BaseTileLayer.ConstructorOptions
 *
 * @property {String|Number} [id = uuid()] 图层id标识
 * @property {String|Number} [pid = -1] 图层父级的id，一般图层管理中使用
 * @property {String} [name = '未命名'] 图层名称
 * @property {Boolean} [show = true] 图层是否显示
 * @property {Object} [center] 图层自定义定位视角 {@link Map#setCameraView}
 * @property {Number} center.lng 经度值, 180 - 180
 * @property {Number} center.lat 纬度值, -90 - 90
 * @property {Number} center.alt 高度值
 * @property {Number} center.heading 方向角度值，绕垂直于地心的轴旋转角度, 0-360
 * @property {Number} center.pitch 俯仰角度值，绕纬度线旋转角度, 0-360
 * @property {Number} center.roll 翻滚角度值，绕经度线旋转角度, 0-360
 * @property {Boolean} [flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
 *
 *
 * @property {Number} [minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
 * @property {Number} [maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
 * @property {Number} [minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
 * @property {Number} [maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
 *
 * @property {Object} rectangle 瓦片数据的矩形区域范围
 * @property {Number} rectangle.xmin 最小经度值, -180 至 180
 * @property {Number} rectangle.xmax 最大纬度值, -180 至 180
 * @property {Number} rectangle.ymin 最小纬度值, -90 至 90
 * @property {Number} rectangle.ymax 最大纬度值, -90 至 90
 * @property {Number[]} bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 *
 * @property {CRS} [crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
 * @property {ChinaCRS} [chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
 *
 * @property {String|String[]} [subdomains='abc'] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
 * @property {Object} [customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
 * @property {Number} [tileWidth=256] 图像图块的像素宽度。
 * @property {Number} [tileHeight=256] 图像图块的像素高度。
 * @property {Boolean} [hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
 *
 * @property {Boolean} [enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
 *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
 * @property {GetFeatureInfoFormat[]} [getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
 * @property {String|Array} [popup] 当pickFeatures有效返回时，图层支持popup弹窗，绑定的弹窗值（如wms动态服务），支持：'all'、数组、字符串模板，当为数组时支持：
 * @property {String} popup.field 字段名称
 * @property {String} popup.name 显示的对应自定义名称 *
 * @property {String} [popup.type] 默认为label文本，也可以支持：'button'按钮，'html' html内容。
 * @property {String} [popup.callback] 当type为'button'按钮时，单击后触发的事件。
 * @property {String} [popup.html] 当type为'html'时，对于拼接的html内容。 *
 * @property {String} [popup.format] 使用window的外部格式化js方法，格式化字符串值。
 * @property {String} [popup.unit] 追加的计量单位值。
 *
 * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0。
 * @property {Number|Function} [alpha=1.0] 同opacity。
 * @property {Number|Function} [nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
 * @property {Number|Function} [dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
 * @property {Number|Function} [brightness=1.0] 亮度，取值范围：0.0-1.0。
 * @property {Number|Function} [contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
 * @property {Number|Function} [hue=0.0] 色调。 0.0 时未修改的图像颜色。
 * @property {Number|Function} [saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
 * @property {Number|Function} [gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
 *
 * @property {Number} [maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
 * @property {Cesium.Rectangle} [cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
 * @property {Cesium.Color} [colorToAlpha]  用作Alpha的颜色。
 * @property {Number} [colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
 *
 * @property {String} [proxy] 加载资源时要使用的代理服务url。
 * @property {Object} [templateValues] 一个对象，用于替换Url中的模板值的键/值对
 * @property {Object} [queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
 * @property {Object} [headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
 *
 * @property {Number} [zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
 */
// CONCATENATED MODULE: ./src/layer/terrain/TerrainLayer.js






function TerrainLayer_createSuper(Derived) { var hasNativeReflectConstruct = TerrainLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TerrainLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 地形服务图层，一个地图中只会生效一个地形服务图层（单选）
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 图层id标识
 * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
 * @param {String} [options.name = '未命名'] 图层名称
 * @param {Boolean} [options.show = true] 图层是否显示（多个地形服务时，请只设置一个TerrainLayer图层的show为tue）
 * @param {Object} options.terrain 地形服务配置
 * @param {TerrainType} [options.terrain.type='xyz'] 地形类型
 * @param {String|Cesium.Resource} options.terrain.url 地形服务地址
 * @param {Boolean} [options.terrain.requestVertexNormals=true] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
 * @param {Boolean} [options.terrain.requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
 * @param {Boolean} [options.terrain.requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
 *
 * @export
 * @class TerrainLayer
 * @extends {BaseLayer}
 */

var TerrainLayer_TerrainLayer = /*#__PURE__*/function (_BaseLayer) {
  inherits_default()(TerrainLayer, _BaseLayer);

  var _super = TerrainLayer_createSuper(TerrainLayer);

  function TerrainLayer() {
    classCallCheck_default()(this, TerrainLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(TerrainLayer, [{
    key: "_showHook",
    value: function _showHook(show) {
      if (show) {
        this._addedHook();
      } else {
        this._removedHook();
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._czmLayer = Object(LayerUtil["createTerrainProvider"])(this.options.terrain, this.options.templateValues);
      this.fire(EventType.load, {
        terrain: this._czmLayer
      });
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.terrainProvider = this._czmLayer;
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.terrainProvider = Object(LayerUtil["getNoTerrainProvider"])();
    }
  }]);

  return TerrainLayer;
}(BaseLayer_BaseLayer); //注册下

Object(LayerUtil["register"])("terrain", TerrainLayer_TerrainLayer);
// CONCATENATED MODULE: ./src/layer/tileLayer/ArcGisCacheLayer.js






function ArcGisCacheLayer_createSuper(Derived) { var hasNativeReflectConstruct = ArcGisCacheLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ArcGisCacheLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * AraGIS生成的金字塔瓦片数据
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Boolean} [options.upperCase] url请求的瓦片图片名称是否大写。
 *
 * @export
 * @class ArcGisCacheLayer
 * @extends {BaseTileLayer}
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @example
let tileLayer = new tudou3d.layer.ArcGisCacheLayer({
  url: 'http://data.tudou3d.cn/tile/hf/guihua/_alllayers/{z}/{y}/{x}.png',
  minimumLevel: 1,
  maximumLevel: 17,
  minimumTerrainLevel: 1,
  // "maximumTerrainLevel": 17, //如果需要大于maximumTerrainLevel层时不显示瓦片，则取消注释
  rectangle: { xmin: 116.846, xmax: 117.642, ymin: 31.533, ymax: 32.185 }, // 控制切片如果在矩形坐标内才显示，如果不在矩形坐标内不显示
})
map.addLayer(tileLayer)
 */

var ArcGisCacheLayer_ArcGisCacheLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(ArcGisCacheLayer, _BaseTileLayer);

  var _super = ArcGisCacheLayer_createSuper(ArcGisCacheLayer);

  function ArcGisCacheLayer() {
    classCallCheck_default()(this, ArcGisCacheLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ArcGisCacheLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return createImageryProvider(options);
    }
  }]);

  return ArcGisCacheLayer;
}(BaseTileLayer_BaseTileLayer);

function createImageryProvider(options) {
  options.url = options.url.replace("{x}", "C{arc_x}").replace("{y}", "R{arc_y}").replace("{z}", "L{arc_z}");
  var upperCase = options.upperCase; //是否大写
  //对arcgis切片的支持 ，示例 /_alllayers/L{arc_z}/R{arc_y}/C{arc_x}.jpg

  options.customTags = options.customTags || {};

  options.customTags["arc_x"] = function (imageryProvider, x, y, level) {
    if (upperCase) {
      return Object(Util["padLeft0"])(x.toString(16), 8).toUpperCase();
    } else {
      return Object(Util["padLeft0"])(x.toString(16), 8);
    }
  };

  options.customTags["arc_y"] = function (imageryProvider, x, y, level) {
    if (upperCase) {
      return Object(Util["padLeft0"])(y.toString(16), 8).toUpperCase();
    } else {
      return Object(Util["padLeft0"])(y.toString(16), 8);
    }
  };

  options.customTags["arc_z"] = function (imageryProvider, x, y, level) {
    if (upperCase) {
      return Object(Util["padLeft0"])(level.toString(), 2).toUpperCase();
    } else {
      return Object(Util["padLeft0"])(level.toString(), 2);
    }
  };

  options.customTags["arc_z4490"] = function (imageryProvider, x, y, level) {
    if (upperCase) {
      return Object(Util["padLeft0"])((level + 1).toString(), 2).toUpperCase();
    } else {
      return Object(Util["padLeft0"])((level + 1).toString(), 2);
    }
  };

  options = Object(LayerUtil["converOptions"])(options);
  return new XyzImageryProvider_XyzImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


ArcGisCacheLayer_ArcGisCacheLayer.createImageryProvider = createImageryProvider; //注册下

var layerType = "arcgis_cache"; //图层类型

Object(LayerUtil["register"])(layerType, ArcGisCacheLayer_ArcGisCacheLayer);
Object(LayerUtil["registerImageryProvider"])(layerType, createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/ArcGisLayer.js







function ArcGisLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ArcGisLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ArcGisLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ArcGisLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ArcGisLayer_createSuper(Derived) { var hasNativeReflectConstruct = ArcGisLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ArcGisLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * @typedef {Object} ArcGisLayer.EventType
 * ArcGIS服务图层支持的{@link EventType}事件类型
 *
 * @property {String} loadConfig 加载metadata配置信息完成事件
 * @property {String} click  鼠标单击事件【enablePickFeatures:true时,支持单击获取对应的矢量对象】
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.loadConfig, function (event) {
 *   console.log('loadConfig', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * ArcGIS标准服务图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} options.url ArcGIS MapServer服务的网址。
 * @param {String} [options.layers] 要显示的图层的逗号分隔列表，如果应显示所有图层，则未定义。
 * @param {String} [options.layerDefs] 可以对动态服务加条件筛选数据，示例："{\"0\":\"用地编号 = 'R'\"}"
 * @param {Number} [options.maxTileLevel] 指定在小于此层级时用瓦片加载，大于该层级用动态服务.可以在瓦片服务类型时，同时使用瓦片和动态服务。
 * @param {Number} [options.wkid] 当非标准EPSG标号时，可以指定wkid值。
 *
 * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] 于确定图块是否为 无效，应将其丢弃。如果未指定此值，则为默认 {@link DiscardMissingTileImagePolicy} 用于平铺的地图服务器，并且{@link NeverTileDiscardPolicy} 用于非平铺地图服务器。在前一种情况下， 我们要求最大图块级别的图块0,0并检查像素（0,0），（200,20），（20,200）， （80,110）和（160，130）。如果所有这些像素都是透明的，则丢弃检查为 禁用，并且不会丢弃任何图块。如果它们中的任何一种具有不透明的颜色， 在这些像素位置具有相同值的图块将被丢弃。的最终结果 对于标准ArcGIS Server，这些默认值应该是正确的图块丢弃。确保 不会丢弃任何图块，为此构造并传递 {@link NeverTileDiscardPolicy} 参数。
 * @param {Boolean} [options.usePreCachedTilesIfAvailable=true] 	如果为true，则表示服务器已预先缓存 如果可用，则使用图块。如果为false，则将忽略所有预缓存的图块，并且 使用了'导出'服务。
 *
 * @param {Boolean} [options.showClickFeature=false] 是否鼠标单击高亮显示对应的矢量数据
 * @param {Object} [options.pickFeatureStyle]  鼠标单击高亮矢量数据的样式，支持对应数据类型（点/线/面）对应的style
 * @param {String} [options.pickFeatureStyle.color='#FFFF00'] 颜色
 * @param {Number} [options.pickFeatureStyle.opacity=1.0] 透明度
 *
 *
 * @export
 * @class ArcGisLayer
 * @extends {BaseTileLayer}
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see [支持的事件类型]{@link ArcGisLayer.EventType}
 * @see {@link https://developers.arcgis.com/rest/|ArcGIS Server REST API}
 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
 */

var ArcGisLayer_ArcGisLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(ArcGisLayer, _BaseTileLayer);

  var _super = ArcGisLayer_createSuper(ArcGisLayer);

  function ArcGisLayer() {
    classCallCheck_default()(this, ArcGisLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ArcGisLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      var that = this;

      function metadataSuccess(data) {
        if (that.isDestroy) {
          return;
        }

        that._initByMetaData(data);

        that.capabilities = data;
        that.fire(EventType.loadConfig, {
          capabilities: data
        });
      }

      return ArcGisLayer_createImageryProvider(options, metadataSuccess);
    } //根据服务配置信息，加一些处理

  }, {
    key: "_initByMetaData",
    value: function _initByMetaData(data) {
      var _extent = data.fullExtent || data.extent;

      if (!this.options.rectangle && _extent) {
        var _extent2, _extent2$spatialRefer;

        var wkid = ((_extent2 = _extent) === null || _extent2 === void 0 ? void 0 : (_extent2$spatialRefer = _extent2.spatialReference) === null || _extent2$spatialRefer === void 0 ? void 0 : _extent2$spatialRefer.wkid) || this.options.wkid;
        var crs;

        if (wkid) {
          if (wkid === 102100 || wkid === 900913) {
            wkid = 3857;
          }

          crs = "EPSG:" + wkid;
        } else if (this.options.crs) {
          crs = this.options.crs;
        }

        if (crs && !this._rectangle) {
          if (crs !== CRS["a" /* CRS */].EPSG4326 && crs !== CRS["a" /* CRS */].EPSG4490) {
            var ptMin = Object(PointTrans["proj4Trans"])([_extent.xmin, _extent.ymin], crs);
            var ptMax = Object(PointTrans["proj4Trans"])([_extent.xmax, _extent.ymax], crs);
            _extent = {
              xmin: ptMin[0],
              ymin: ptMin[1],
              xmax: ptMax[0],
              ymax: ptMax[1]
            };
          }

          this.options.extent = _extent;
          this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);
        }
      }
    }
    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.timeRender=false] 是否实时更新面板，此时需要绑定content回调方法处理。
     * @param {Boolean} [options.template=true] 是否使用内置的Html模版，false时全部使用外部指定的html。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "bindPopup",
    value: function bindPopup(content, options) {
      this.options.popup = ArcGisLayer_objectSpread({
        html: content
      }, options);

      this._bindControl();

      return this;
    }
  }]);

  return ArcGisLayer;
}(BaseTileLayer_BaseTileLayer);

function ArcGisLayer_createImageryProvider(options, metadataSuccess) {
  if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.layer) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.url)) {
    switch (options.layer) {
      default:
        break;

      case "vec":
        options.url = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer";
        break;

      case "img_d":
        options.url = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer";
        break;
    }
  }

  options = Object(LayerUtil["converOptions"])(options);
  options.metadataSuccess = metadataSuccess;
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ArcGisMapServerImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


ArcGisLayer_ArcGisLayer.createImageryProvider = ArcGisLayer_createImageryProvider; //注册下

var ArcGisLayer_layerType = "arcgis"; //图层类型

Object(LayerUtil["register"])(ArcGisLayer_layerType, ArcGisLayer_ArcGisLayer);
Object(LayerUtil["registerImageryProvider"])(ArcGisLayer_layerType, ArcGisLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/BaiduLayer.js






function BaiduLayer_createSuper(Derived) { var hasNativeReflectConstruct = BaiduLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaiduLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 百度地图
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.layer] 图层类型，以及以下内容:<br />
 * <ul>
 *     <li><code>vec</code>: 电子图层</li>
 *     <li><code>img_d</code>: 卫星影像</li>
 *     <li><code>img_z</code>: 影像注记</li>
 *     <li><code>custom</code>: 自定义样式图层</li>
 *     <li><code>time</code>: 实时路况信息</li>
 *     <li><code>streetview</code>: 街景覆盖图层</li>
 * </ul>
 * @param {Boolean} [options.bigfont] 当layer为vec或img_z时，来标识使用是否大写字体。
 * @param {String} [options.style] 当layer为custom时，标识的样式，可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
 * @param {String} [options.url=null] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var BaiduLayer_BaiduLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(BaiduLayer, _BaseTileLayer);

  var _super = BaiduLayer_createSuper(BaiduLayer);

  function BaiduLayer() {
    classCallCheck_default()(this, BaiduLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaiduLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return BaiduLayer_createImageryProvider(options);
    }
  }]);

  return BaiduLayer;
}(BaseTileLayer_BaseTileLayer);

function BaiduLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new BaiduImageryProvider_BaiduImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


BaiduLayer_BaiduLayer.createImageryProvider = BaiduLayer_createImageryProvider; //注册下

var BaiduLayer_layerType = "baidu"; //图层类型

Object(LayerUtil["register"])(BaiduLayer_layerType, BaiduLayer_BaiduLayer);
Object(LayerUtil["registerImageryProvider"])(BaiduLayer_layerType, BaiduLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/BingLayer.js







function BingLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BingLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BingLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BingLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BingLayer_createSuper(Derived) { var hasNativeReflectConstruct = BingLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BingLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 微软bing地图
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} [options.url='https://dev.virtualearth.net'] 托管影像图像的Bing Maps服务器的网址。
 * @property {String} [options.key=tudou3d.Token.bing] 您的应用程序的Bing Maps密钥，可以在{@link https://www.bingmapsportal.com/}中创建
 * @property {Cesium.BingMapsStyle} [mapStyle=Cesium.BingMapsStyle.AERIAL] 要加载的必应地图图像的类型。
 * @property {String} [tileProtocol] 加载图块时要使用的协议，例如' http'或' https'。 默认情况下，将使用与页面相同的协议来加载图块。
 * @property {String} [culture='zh-Hans'] 请求Bing Maps图像时要使用的区域性标记。不支持所有文化。请参阅   {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}了解有关支持的文化的信息。
 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] 于确定图块是否为无效，应将其丢弃。如果未指定此值，则为默认 {@link DiscardMissingTileImagePolicy} 用于平铺的地图服务器，并且{@link NeverTileDiscardPolicy} 用于非平铺地图服务器。在前一种情况下， 我们要求最大图块级别的图块0,0并检查像素（0,0），（200,20），（20,200）， （80,110）和（160，130）。如果所有这些像素都是透明的，则丢弃检查为 禁用，并且不会丢弃任何图块。如果它们中的任何一种具有不透明的颜色， 在这些像素位置具有相同值的图块将被丢弃。的最终结果 对于标准ArcGIS Server，这些默认值应该是正确的图块丢弃。确保 不会丢弃任何图块，为此构造并传递 {@link NeverTileDiscardPolicy} 参数。
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var BingLayer_BingLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(BingLayer, _BaseTileLayer);

  var _super = BingLayer_createSuper(BingLayer);

  function BingLayer() {
    classCallCheck_default()(this, BingLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(BingLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return BingLayer_createImageryProvider(options);
    }
  }]);

  return BingLayer;
}(BaseTileLayer_BaseTileLayer);

function BingLayer_createImageryProvider(options) {
  options.url = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.url, "https://dev.virtualearth.net");
  options.culture = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.culture, "zh-Hans");
  options.key = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.key, bing);
  options.layer = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.layer, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BingMapsStyle"].Aerial);
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BingMapsImageryProvider"](BingLayer_objectSpread({
    mapStyle: options.layer
  }, options));
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


BingLayer_BingLayer.createImageryProvider = BingLayer_createImageryProvider; //注册下

var BingLayer_layerType = "bing"; //图层类型

Object(LayerUtil["register"])(BingLayer_layerType, BingLayer_BingLayer);
Object(LayerUtil["registerImageryProvider"])(BingLayer_layerType, BingLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/GaodeLayer.js






function GaodeLayer_createSuper(Derived) { var hasNativeReflectConstruct = GaodeLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GaodeLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 高德
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.layer] 图层类型，以及以下内容:<br />
 * <ul>
 *     <li><code>vec</code>: 电子图层</li>
 *     <li><code>img_d</code>: 卫星影像</li>
 *     <li><code>img_z</code>: 影像注记</li>
 *     <li><code>time</code>: 实时路况信息</li>
 * </ul>
 * @param {String} [options.url=null] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
 * @param {Boolean} [options.bigfont] 当layer为vec时，来标识使用是否大写字体。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var GaodeLayer_GaodeLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(GaodeLayer, _BaseTileLayer);

  var _super = GaodeLayer_createSuper(GaodeLayer);

  function GaodeLayer() {
    classCallCheck_default()(this, GaodeLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GaodeLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return GaodeLayer_createImageryProvider(options);
    }
  }]);

  return GaodeLayer;
}(BaseTileLayer_BaseTileLayer);

function GaodeLayer_createImageryProvider(options) {
  options.chinaCRS = options.chinaCRS || ChinaCRS["a" /* ChinaCRS */].GCJ02;
  options = Object(LayerUtil["converOptions"])(options);
  return new GaodeImageryProvider_GaodeImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


GaodeLayer_GaodeLayer.createImageryProvider = GaodeLayer_createImageryProvider; //注册下

var GaodeLayer_layerType = "gaode"; //图层类型

Object(LayerUtil["register"])(GaodeLayer_layerType, GaodeLayer_GaodeLayer);
Object(LayerUtil["registerImageryProvider"])(GaodeLayer_layerType, GaodeLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/GeeLayer.js







function GeeLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GeeLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GeeLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GeeLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GeeLayer_createSuper(Derived) { var hasNativeReflectConstruct = GeeLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GeeLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * GoogleEarth Enterprise企业版本 影像服务
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} options.url  承载瓦片服务的谷歌地球企业服务器的url
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.GoogleEarthEnterpriseImageryProvider
 */

var GeeLayer_GeeLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(GeeLayer, _BaseTileLayer);

  var _super = GeeLayer_createSuper(GeeLayer);

  function GeeLayer() {
    classCallCheck_default()(this, GeeLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GeeLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return GeeLayer_createImageryProvider(options);
    }
  }]);

  return GeeLayer;
}(BaseTileLayer_BaseTileLayer);

function GeeLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GoogleEarthEnterpriseImageryProvider"](GeeLayer_objectSpread(GeeLayer_objectSpread({}, options), {}, {
    metadata: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GoogleEarthEnterpriseMetadata"](options.url)
  }));
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


GeeLayer_GeeLayer.createImageryProvider = GeeLayer_createImageryProvider; //注册下

var GeeLayer_layerType = "gee"; //图层类型

Object(LayerUtil["register"])(GeeLayer_layerType, GeeLayer_GeeLayer);
Object(LayerUtil["registerImageryProvider"])(GeeLayer_layerType, GeeLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/GoogleLayer.js






function GoogleLayer_createSuper(Derived) { var hasNativeReflectConstruct = GoogleLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GoogleLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 谷歌
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.layer] 图层类型，以及以下内容:<br />
 * <ul>
 *     <li><code>vec</code>: 电子图层</li>
 *     <li><code>img_d</code>: 卫星影像</li>
 *     <li><code>img_z</code>: 影像注记</li>
 *     <li><code>ter</code>: 地形渲染图</li>
 * </ul>
 * @param {ChinaCRS} [options.chinaCRS='GCJ02'] 可以加ChinaCRS.WGS84标识切换到无偏底图（仅layer：img_d 时有效）
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var GoogleLayer_GoogleLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(GoogleLayer, _BaseTileLayer);

  var _super = GoogleLayer_createSuper(GoogleLayer);

  function GoogleLayer() {
    classCallCheck_default()(this, GoogleLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GoogleLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return GoogleLayer_createImageryProvider(options);
    }
  }]);

  return GoogleLayer;
}(BaseTileLayer_BaseTileLayer);

function GoogleLayer_createImageryProvider(options) {
  options.chinaCRS = options.chinaCRS || ChinaCRS["a" /* ChinaCRS */].GCJ02;
  options = Object(LayerUtil["converOptions"])(options);
  return new GoogleImageryProvider_GoogleImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


GoogleLayer_GoogleLayer.createImageryProvider = GoogleLayer_createImageryProvider; //注册下

var GoogleLayer_layerType = "google"; //图层类型

Object(LayerUtil["register"])(GoogleLayer_layerType, GoogleLayer_GoogleLayer);
Object(LayerUtil["registerImageryProvider"])(GoogleLayer_layerType, GoogleLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/ImageLayer.js






function ImageLayer_createSuper(Derived) { var hasNativeReflectConstruct = ImageLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ImageLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 单张图片图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} options.url 图片url地址
 * @param {Object} options.rectangle 瓦片数据的矩形区域范围
 * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
 * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
 * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
 * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90 *
 * @param {Number[]} options.bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.SingleTileImageryProvider
 */

var ImageLayer_ImageLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(ImageLayer, _BaseTileLayer);

  var _super = ImageLayer_createSuper(ImageLayer);

  function ImageLayer() {
    classCallCheck_default()(this, ImageLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ImageLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return ImageLayer_createImageryProvider(options);
    }
  }]);

  return ImageLayer;
}(BaseTileLayer_BaseTileLayer);

function ImageLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SingleTileImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


ImageLayer_ImageLayer.createImageryProvider = ImageLayer_createImageryProvider; //注册下

var ImageLayer_layerType = "image"; //图层类型

Object(LayerUtil["register"])(ImageLayer_layerType, ImageLayer_ImageLayer);
Object(LayerUtil["registerImageryProvider"])(ImageLayer_layerType, ImageLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/IonLayer.js






function IonLayer_createSuper(Derived) { var hasNativeReflectConstruct = IonLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function IonLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * cesium ion资源地图，官网： {@link https://cesium.com/ion/signin/}
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Number} options.assetId ION服务 assetId
 * @param {String} [options.accessToken=tudou3d.Token.ion] ION服务 token令牌
 * @param {String|Resource} [options.server=Ion.defaultServer] Cesium ion API服务器的资源。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.IonImageryProvider
 */

var IonLayer_IonLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(IonLayer, _BaseTileLayer);

  var _super = IonLayer_createSuper(IonLayer);

  function IonLayer() {
    classCallCheck_default()(this, IonLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(IonLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return IonLayer_createImageryProvider(options);
    }
  }]);

  return IonLayer;
}(BaseTileLayer_BaseTileLayer);

function IonLayer_createImageryProvider(options) {
  options.accessToken = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.accessToken, ion);
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["IonImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


IonLayer_IonLayer.createImageryProvider = IonLayer_createImageryProvider; //注册下

var IonLayer_layerType = "ion"; //图层类型

Object(LayerUtil["register"])(IonLayer_layerType, IonLayer_IonLayer);
Object(LayerUtil["registerImageryProvider"])(IonLayer_layerType, IonLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/MapboxLayer.js






function MapboxLayer_createSuper(Derived) { var hasNativeReflectConstruct = MapboxLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MapboxLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * Mapbox地图服务
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} [options.url='https://api.mapbox.com/styles/v1/'] Mapbox服务器网址。
 * @param {String} [options.username='tudougis'] 地图帐户的用户名。
 * @param {String} options.styleId Mapbox样式ID。
 * @param {String} [options.accessToken=tudou3d.Token.mapbox] 图像的Token公共访问令牌。
 * @param {Number} [options.tilesize=512] 图像块的大小。
 * @param {Boolean} [options.scaleFactor=true] 确定贴图是否以 @2x 比例因子渲染。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.MapboxStyleImageryProvider
 */

var MapboxLayer_MapboxLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(MapboxLayer, _BaseTileLayer);

  var _super = MapboxLayer_createSuper(MapboxLayer);

  function MapboxLayer() {
    classCallCheck_default()(this, MapboxLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(MapboxLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return MapboxLayer_createImageryProvider(options);
    }
  }]);

  return MapboxLayer;
}(BaseTileLayer_BaseTileLayer);

function MapboxLayer_createImageryProvider(options) {
  //参考：https://docs.mapbox.com/api/maps/#request-embeddable-html
  options.url = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.url, "https://api.mapbox.com/styles/v1");
  options.username = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.username, "tudougis");
  options.accessToken = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.accessToken, mapbox);
  options.scaleFactor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.scaleFactor, true);
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["MapboxStyleImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


MapboxLayer_MapboxLayer.createImageryProvider = MapboxLayer_createImageryProvider; //注册下

var MapboxLayer_layerType = "mapbox"; //图层类型

Object(LayerUtil["register"])(MapboxLayer_layerType, MapboxLayer_MapboxLayer);
Object(LayerUtil["registerImageryProvider"])(MapboxLayer_layerType, MapboxLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/OsmLayer.js






function OsmLayer_createSuper(Derived) { var hasNativeReflectConstruct = OsmLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function OsmLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * OSM开源地图
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var OsmLayer_OsmLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(OsmLayer, _BaseTileLayer);

  var _super = OsmLayer_createSuper(OsmLayer);

  function OsmLayer() {
    classCallCheck_default()(this, OsmLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(OsmLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return OsmLayer_createImageryProvider(options);
    }
  }]);

  return OsmLayer;
}(BaseTileLayer_BaseTileLayer);

function OsmLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new OsmImageryProvider_OsmImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


OsmLayer_OsmLayer.createImageryProvider = OsmLayer_createImageryProvider; //注册下

var OsmLayer_layerType = "osm"; //图层类型

Object(LayerUtil["register"])(OsmLayer_layerType, OsmLayer_OsmLayer);
Object(LayerUtil["registerImageryProvider"])(OsmLayer_layerType, OsmLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/TdtLayer.js






function TdtLayer_createSuper(Derived) { var hasNativeReflectConstruct = TdtLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TdtLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 天地图
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.layer] 图层类型，以及以下内容:<br />
 * <ul>
 *     <li><code>vec_d</code>: 电子图层</li>
 *     <li><code>vec_z</code>: 电子注记</li>
 *     <li><code>img_d</code>: 卫星影像</li>
 *     <li><code>img_z</code>: 影像注记</li>
 *     <li><code>ter_d</code>: 地形渲染图</li>
 *     <li><code>ter_z</code>: 地形渲染图注记</li>
 * </ul>
 * @param {String[]} [options.key=tudou3d.Token.tiandituArr] 天地图服务Token，可以自行注册官网： {@link https://console.tianditu.gov.cn/api/key}
 * @param {CRS} [options.crs='EPSG3857'] 标识不同坐标系。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var TdtLayer_TdtLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(TdtLayer, _BaseTileLayer);

  var _super = TdtLayer_createSuper(TdtLayer);

  function TdtLayer() {
    classCallCheck_default()(this, TdtLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(TdtLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return TdtLayer_createImageryProvider(options);
    }
  }]);

  return TdtLayer;
}(BaseTileLayer_BaseTileLayer);

function TdtLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new TdtImageryProvider_TdtImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


TdtLayer_TdtLayer.createImageryProvider = TdtLayer_createImageryProvider; //注册下

var TdtLayer_layerType = "tdt"; //图层类型

Object(LayerUtil["register"])(TdtLayer_layerType, TdtLayer_TdtLayer);
Object(LayerUtil["registerImageryProvider"])(TdtLayer_layerType, TdtLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/TencentLayer.js






function TencentLayer_createSuper(Derived) { var hasNativeReflectConstruct = TencentLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TencentLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 腾讯
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.layer] 图层类型，以及以下内容:<br />
 * <ul>
 *     <li><code>vec</code>: 电子图层</li>
 *     <li><code>img_d</code>: 卫星影像</li>
 *     <li><code>img_z</code>: 影像注记</li>
 *     <li><code>custom</code>: 地形渲染图</li>
 * </ul>
 * @param {String} [options.style] 当layer为custom时，标识的样式，可选值：灰白地图:3,暗色地图:4
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var TencentLayer_TencentLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(TencentLayer, _BaseTileLayer);

  var _super = TencentLayer_createSuper(TencentLayer);

  function TencentLayer() {
    classCallCheck_default()(this, TencentLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(TencentLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return TencentLayer_createImageryProvider(options);
    }
  }]);

  return TencentLayer;
}(BaseTileLayer_BaseTileLayer);

function TencentLayer_createImageryProvider(options) {
  options.chinaCRS = options.chinaCRS || ChinaCRS["a" /* ChinaCRS */].GCJ02;
  options = Object(LayerUtil["converOptions"])(options);
  return new TencentImageryProvider_TencentImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


TencentLayer_TencentLayer.createImageryProvider = TencentLayer_createImageryProvider; //注册下

var TencentLayer_layerType = "tencent"; //图层类型

Object(LayerUtil["register"])(TencentLayer_layerType, TencentLayer_TencentLayer);
Object(LayerUtil["registerImageryProvider"])(TencentLayer_layerType, TencentLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/TmsLayer.js






function TmsLayer_createSuper(Derived) { var hasNativeReflectConstruct = TmsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TmsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * TileMapService 提供由MapTiler，GDAL2Tiles等生成的切片图像
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Resource|String|Promise<Resource>|Promise<String>} [options.url='.'] 服务地址
 * @param {String} [options.fileExtension='png'] 服务器上图像的文件扩展名。
 * @param {Boolean} [options.flipXY] gdal2tiles.py的旧版本将tilemapresource.xml中的X和Y值翻转了。指定此选项将执行相同的操作，从而允许加载这些不正确的图块集。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.TileMapServiceImageryProvider
 */

var TmsLayer_TmsLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(TmsLayer, _BaseTileLayer);

  var _super = TmsLayer_createSuper(TmsLayer);

  function TmsLayer() {
    classCallCheck_default()(this, TmsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(TmsLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return TmsLayer_createImageryProvider(options);
    }
  }]);

  return TmsLayer;
}(BaseTileLayer_BaseTileLayer);

function TmsLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);

  if (!options.url) {
    options.url = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["buildModuleUrl"]("Assets/Textures/NaturalEarthII");
  }

  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TileMapServiceImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


TmsLayer_TmsLayer.createImageryProvider = TmsLayer_createImageryProvider; //注册下

var TmsLayer_layerType = "tms"; //图层类型

Object(LayerUtil["register"])(TmsLayer_layerType, TmsLayer_TmsLayer);
Object(LayerUtil["registerImageryProvider"])(TmsLayer_layerType, TmsLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/WmsLayer.js







function WmsLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WmsLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WmsLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WmsLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WmsLayer_createSuper(Derived) { var hasNativeReflectConstruct = WmsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WmsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * WMS服务
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} options.url WMS服务的URL。URL支持相同的关键字 {@link XyzLayer}.
 * @param {String} options.layers 要包含的图层，用逗号分隔。
 * @param {Object} [options.parameters=WebMapServiceImageryProvider.DefaultParameters] 要在URL中 传递给WMS服务GetMap请求的其他参数。
 * @param {Object} [options.getFeatureInfoParameters=WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters] 要在GetFeatureInfo URL中传递给WMS服务器的其他参数。
 * @param {String} [options.crs] CRS规范，用于WMS规范>= 1.3.0。
 * @param {String} [options.srs] SRS规范，与WMS规范1.1.0或1.1.1一起使用
 * @param {Cesium.Clock} [options.clock] 一个时钟实例，用于确定时间维度的值。指定' times '时需要。
 * @param {Cesium.TimeIntervalCollection} [options.times] TimeIntervalCollection 的数据属性是一个包含时间动态维度及其值的对象。
 *
 * @param {Boolean} [options.showClickFeature=false] 是否鼠标单击高亮显示对应的矢量数据
 * @param {Object} [options.pickFeatureStyle]  鼠标单击高亮矢量数据的样式，支持对应数据类型（点/线/面）对应的style
 * @param {String} [options.pickFeatureStyle.color='#FFFF00'] 颜色
 * @param {Number} [options.pickFeatureStyle.opacity=1.0] 透明度
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.WebMapServiceImageryProvider
 */

var WmsLayer_WmsLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(WmsLayer, _BaseTileLayer);

  var _super = WmsLayer_createSuper(WmsLayer);

  function WmsLayer() {
    classCallCheck_default()(this, WmsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(WmsLayer, [{
    key: "_createImageryProvider",
    value:
    /**
     * 这里读取配置导致加载速度过慢
     * 赵西洋
     * 2021-10-06
     */
    // _addedHook() {
    //   this.getMetadata().then((data) => {
    //     if (this.isAdded) {
    //       super._addedHook();
    //     }
    //   });
    // }
    //构建ImageryProvider
    function _createImageryProvider(options) {
      return WmsLayer_createImageryProvider(options);
    }
    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.timeRender=false] 是否实时更新面板，此时需要绑定content回调方法处理。
     * @param {Boolean} [options.template=true] 是否使用内置的Html模版，false时全部使用外部指定的html。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "bindPopup",
    value: function bindPopup(content, options) {
      this.options.popup = WmsLayer_objectSpread({
        html: content
      }, options);

      this._bindControl();

      return this;
    } //读取配置信息

  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this.capabilities) {
          resolve(_this.capabilities);
          return;
        } //请求的wms参数


        var parameters = {
          service: "WMS",
          request: "GetCapabilities",
          version: "1.3.0"
        };
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchXML(WmsLayer_objectSpread(WmsLayer_objectSpread({}, _this.options), {}, {
          queryParameters: parameters
        })).then(function (data) {
          if (_this.isDestroy) {
            return;
          }

          if (data) {
            _this.capabilities = data;

            try {
              _this._initByMetaData(data);
            } catch (e) {
              Object(Log["logInfo"])("WMS 解析GetCapabilities有误", e);
            }
          }

          resolve(data);

          _this.fire(EventType.loadConfig, {
            capabilities: data
          });
        })["catch"](function (error) {
          Object(Log["logInfo"])("WMS getMetadata请求出错", error);
          resolve();
        });
      });
    } //根据服务配置信息，加一些处理

  }, {
    key: "_initByMetaData",
    value: function _initByMetaData(data) {
      var layerName = this.options.layers;

      if (layerName.indexOf(":") != -1) {
        layerName = layerName.split(":")[1];
      }

      var contents = this._readChildNode(data, "Layer");

      var layers = contents.getElementsByTagName("Layer");

      for (var i = 0, len = layers.length; i < len; i++) {
        var item = layers[i];

        var currName = this._readChildNodeVal(item, "Name");

        if (currName == layerName) {
          var crs = this._readChildNodeVal(item, "CRS");

          if (!this.options.crs && crs) {
            this.options.crs = crs;
          }

          var bbox = this._readChildNode(item, "BoundingBox");

          if (!this.options.rectangle && bbox) {
            var xmin = Number(bbox.getAttribute("minx"));
            var ymin = Number(bbox.getAttribute("miny"));
            var xmax = Number(bbox.getAttribute("maxx"));
            var ymax = Number(bbox.getAttribute("maxy"));
            var _extent = {
              xmin: xmin,
              ymin: ymin,
              xmax: xmax,
              ymax: ymax
            };
            this.options.extent = _extent;
            this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);
          }

          break;
        }
      }
    }
  }, {
    key: "_readChildNode",
    value: function _readChildNode(node, tagName) {
      var tagChildNodes = node.getElementsByTagName(tagName);

      if (tagChildNodes.length > 0) {
        return tagChildNodes[0];
      } else {
        return null;
      }
    }
  }, {
    key: "_readChildNodeVal",
    value: function _readChildNodeVal(node, tagName) {
      var childNode = this._readChildNode(node, tagName);

      if (childNode !== null && childNode !== void 0 && childNode.innerHTML) {
        return childNode.innerHTML;
      } else if (childNode !== null && childNode !== void 0 && childNode.getInnerHTML) {
        return childNode.getInnerHTML();
      } else {
        return null;
      }
    }
  }]);

  return WmsLayer;
}(BaseTileLayer_BaseTileLayer);

function WmsLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMapServiceImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


WmsLayer_WmsLayer.createImageryProvider = WmsLayer_createImageryProvider; //注册下

var WmsLayer_layerType = "wms"; //图层类型

Object(LayerUtil["register"])(WmsLayer_layerType, WmsLayer_WmsLayer);
Object(LayerUtil["registerImageryProvider"])(WmsLayer_layerType, WmsLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/WmtsLayer.js









function WmtsLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WmtsLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WmtsLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WmtsLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WmtsLayer_createSuper(Derived) { var hasNativeReflectConstruct = WmtsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WmtsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * WMTS服务
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Cesium.Resource|String} options.url WMTS GetTile操作(用于kvp编码的请求)或tile-URL模板(用于RESTful请求)的基本URL。tile-URL模板应该包含以下变量:&#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125; 前两个是可选的，如果实际值是硬编码的或者服务器不需要。 &#123;s&#125;关键字可用于指定子域。
 * @param {String} [options.format='image/jpeg'] 要从服务器检索的瓦片图像的MIME类型。
 * @param {String} options.layer WMTS请求的层名。
 * @param {String} options.style WMTS请求的样式名称。
 * @param {String} options.tileMatrixSetID 用于WMTS请求的TileMatrixSet的标识符。
 * @param {String[]} [options.tileMatrixLabels] 瓦片矩阵中用于WMTS请求的标识符列表，每个瓦片矩阵级别一个。
 * @param {Cesium.Clock} [options.clock] 一个时钟实例，用于确定时间维度的值。指定' times '时需要。
 * @param {Cesium.TimeIntervalCollection} [options.times] TimeIntervalCollection 的数据属性是一个包含时间动态维度及其值的对象。
 *
 * @param {Boolean} [options.enablePickFeatures=false] 如果为true，则请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
 * @param {Cesium.Resource|String} [options.pickFeaturesUrl] enablePickFeatures为true时，用于单击查看矢量对象功能的对应wms服务url。
 *
 * @param {Boolean} [options.showClickFeature=false] enablePickFeatures为true时，是否鼠标单击高亮显示对应的矢量数据
 * @param {Object} [options.pickFeatureStyle]  enablePickFeatures为true时，鼠标单击高亮矢量数据的样式，支持对应数据类型（点/线/面）对应的style
 * @param {String} [options.pickFeatureStyle.color='#FFFF00'] 颜色
 * @param {Number} [options.pickFeatureStyle.opacity=1.0] 透明度
 * @param {Function} [options.pickFeatures]  外部自定义单击请求对应矢量数据的处理。与pickFeaturesUrl二选一
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.WebMapTileServiceImageryProvider
 */

var WmtsLayer_WmtsLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(WmtsLayer, _BaseTileLayer);

  var _super = WmtsLayer_createSuper(WmtsLayer);

  function WmtsLayer() {
    classCallCheck_default()(this, WmtsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(WmtsLayer, [{
    key: "_addedHook",
    value: function _addedHook() {
      var _this = this;

      this.getMetadata().then(function (data) {
        if (_this.isAdded) {
          get_default()(getPrototypeOf_default()(WmtsLayer.prototype), "_addedHook", _this).call(_this);
        }
      });
    } //构建ImageryProvider

  }, {
    key: "_createImageryProvider",
    value: function _createImageryProvider(options) {
      var _this2 = this;

      var imageryProvider = WmtsLayer_createImageryProvider(options);

      if (options.pickFeatures) {
        imageryProvider.pickFeatures = options.pickFeatures;
      } else if (options.pickFeaturesUrl) {
        imageryProvider.pickFeatures = function (x, y, level, longitude, latitude) {
          return _this2.pickFeatures(x, y, level, longitude, latitude);
        };
      }

      return imageryProvider;
    } //单击图上点去查询对应矢量数据

  }, {
    key: "pickFeatures",
    value: function pickFeatures(x, y, level, longitude, latitude) {
      if (!this.options.enablePickFeatures) {
        return undefined;
      }

      var imageryProvider = this.imageryProvider;
      var longitudeLatitudeProjectedScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();

      if (imageryProvider.tilingScheme.projection instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeographicProjection"]) {
        longitudeLatitudeProjectedScratch.x = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(longitude);
        longitudeLatitudeProjectedScratch.y = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(latitude);
      } else {
        var cartographic = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();
        cartographic.longitude = longitude;
        cartographic.latitude = latitude;
        imageryProvider.tilingScheme.projection.project(cartographic, longitudeLatitudeProjectedScratch);
      }

      var ijScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]();
      var rectangle = imageryProvider.tilingScheme.tileXYToNativeRectangle(x, y, level, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]());
      ijScratch.x = imageryProvider.tileWidth * (longitudeLatitudeProjectedScratch.x - rectangle.west) / rectangle.width | 0;
      ijScratch.y = imageryProvider.tileHeight * (rectangle.north - longitudeLatitudeProjectedScratch.y) / rectangle.height | 0; //请求的wms参数

      var parameters = {
        service: "WMS",
        version: "1.1.1",
        request: "GetFeatureInfo",
        layers: this.options.layer,
        query_layers: this.options.layer,
        info_format: "application/json",
        srs: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.crs, this.options.tilingScheme && this.options.tilingScheme.projection instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMercatorProjection"] ? "EPSG:3857" : "EPSG:4326"),
        bbox: "".concat(rectangle.west, ",").concat(rectangle.south, ",").concat(rectangle.east, ",").concat(rectangle.north),
        width: imageryProvider.tileWidth,
        height: imageryProvider.tileHeight,
        x: ijScratch.x,
        y: ijScratch.y
      };
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(WmtsLayer_objectSpread(WmtsLayer_objectSpread({}, this.options), {}, {
        url: this.options.pickFeaturesUrl,
        queryParameters: parameters
      })).then(function (json) {
        var result = [];
        var features = json.features;

        for (var i = 0; i < features.length; ++i) {
          var feature = features[i];
          var featureInfo = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ImageryLayerFeatureInfo"]();
          featureInfo.data = feature;
          featureInfo.properties = feature.properties;
          featureInfo.configureNameFromProperties(feature.properties);
          featureInfo.configureDescriptionFromProperties(feature.properties); // If this is a point feature, use the coordinates of the point.

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](feature.geometry) && feature.geometry.type === "Point") {
            var _longitude = feature.geometry.coordinates[0];
            var _latitude = feature.geometry.coordinates[1];
            featureInfo.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromDegrees(_longitude, _latitude);
          }

          result.push(featureInfo);
        }

        return result;
      });
    } //读取配置信息

  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.capabilities) {
          resolve(_this3.capabilities);
          return;
        } //请求的wfs参数


        var parameters = {
          service: "WMTS",
          request: "GetCapabilities",
          version: "1.0.0"
        };
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchXML(WmtsLayer_objectSpread(WmtsLayer_objectSpread({}, _this3.options), {}, {
          queryParameters: parameters
        })).then(function (data) {
          if (_this3.isDestroy) {
            return;
          }

          if (data) {
            _this3.capabilities = data;

            try {
              _this3._initByMetaData(data);
            } catch (e) {
              Object(Log["logInfo"])("解析GetCapabilities出错", e);
            }
          }

          resolve(data);

          _this3.fire(EventType.loadConfig, {
            capabilities: data
          });
        })["catch"](function (error) {
          Object(Log["logInfo"])("WMTS GetCapabilities请求出错", error);
          resolve();
        });
      });
    } //根据服务配置信息，加一些处理

  }, {
    key: "_initByMetaData",
    value: function _initByMetaData(data) {
      var contents = this._readChildNode(data, "Contents");

      var layers = contents.getElementsByTagName("Layer");

      for (var i = 0, len = layers.length; i < len; i++) {
        var item = layers[i];

        var layerName = this._readChildNodeVal(item, "ows:Identifier");

        if (layerName == this.options.layer) {
          var bbox = this._readChildNode(item, "ows:WGS84BoundingBox");

          if (!this.options.rectangle && bbox) {
            var lower = this._readChildNodeVal(bbox, "ows:LowerCorner");

            var upper = this._readChildNodeVal(bbox, "ows:UpperCorner");

            if (lower && upper) {
              lower = lower.split(" ");
              upper = upper.split(" ");
              var xmin = Number(lower[0]);
              var ymin = Number(lower[1]);
              var xmax = Number(upper[0]);
              var ymax = Number(upper[1]);
              var _extent = {
                xmin: xmin,
                ymin: ymin,
                xmax: xmax,
                ymax: ymax
              };
              this.options.extent = _extent;
              this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);
            }
          }

          if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.style)) {
            this.options.style = this._readChildNodeVal(this._readChildNode(item, "Style"), "ows:Identifier");
          }

          var TileMatrixSetLink = item.getElementsByTagName("TileMatrixSetLink");

          for (var j = 0, _len = TileMatrixSetLink.length; j < _len; j++) {
            var tileMatrixSet = TileMatrixSetLink[j];

            var tileMatrixSetID = this._readChildNodeVal(tileMatrixSet, "TileMatrixSet");

            if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.tileMatrixSetID)) {
              this.options.tileMatrixSetID = tileMatrixSetID; //默认就使用第0个
            }

            if (tileMatrixSetID == this.options.tileMatrixSetID) {
              if (!this.options.tileMatrixLabels) {
                var tileMatrixSetLimits = this._readChildNode(tileMatrixSet, "TileMatrixSetLimits");

                var tileMatrixList = tileMatrixSetLimits.getElementsByTagName("TileMatrixLimits");
                var tileMatrixLabels = [];

                for (var k = 0, _len2 = tileMatrixList.length; k < _len2; k++) {
                  var tileMatrix = this._readChildNodeVal(tileMatrixList[k], "TileMatrix");

                  tileMatrixLabels.push(tileMatrix);
                }

                this.options.tileMatrixLabels = tileMatrixLabels;
              }

              break;
            }
          }

          break;
        }
      }
    }
  }, {
    key: "_readChildNode",
    value: function _readChildNode(node, tagName) {
      if (!node) {
        return null;
      }

      var tagChildNodes = node.getElementsByTagName(tagName);

      if (tagChildNodes.length > 0) {
        return tagChildNodes[0];
      } else {
        return null;
      }
    }
  }, {
    key: "_readChildNodeVal",
    value: function _readChildNodeVal(node, tagName) {
      if (!node) {
        return null;
      }

      var childNode = this._readChildNode(node, tagName);

      if (childNode !== null && childNode !== void 0 && childNode.innerHTML) {
        return childNode.innerHTML;
      } else if (childNode !== null && childNode !== void 0 && childNode.getInnerHTML) {
        return childNode.getInnerHTML();
      } else {
        return null;
      }
    }
  }]);

  return WmtsLayer;
}(BaseTileLayer_BaseTileLayer);

function WmtsLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);

  if (options.crs == CRS["a" /* CRS */].EPSG4490) {
    options.tileMatrixLabels = toConsumableArray_default()(Array(20).keys()).map(function (level) {
      return (level + 1).toString();
    });
  }

  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["WebMapTileServiceImageryProvider"](options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


WmtsLayer_WmtsLayer.createImageryProvider = WmtsLayer_createImageryProvider; //注册下

var WmtsLayer_layerType = "wmts"; //图层类型

Object(LayerUtil["register"])(WmtsLayer_layerType, WmtsLayer_WmtsLayer);
Object(LayerUtil["registerImageryProvider"])(WmtsLayer_layerType, WmtsLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/XyzLayer.js






function XyzLayer_createSuper(Derived) { var hasNativeReflectConstruct = XyzLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function XyzLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 标准xyz金字塔
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {Cesium.Resource|String} options.url  用于请求瓦片图块的URL模板。它具有以下关键字:
 * <ul>
 *     <li><code>{z}</code>: 切片方案中切片的级别。零级是四叉树金字塔的根。</li>
 *     <li><code>{x}</code>:切片方案中的图块X坐标，其中0是最西端的图块。</li>
 *     <li><code>{y}</code>: 切片方案中的图块Y坐标，其中0是最北的图块。</li>
 *     <li><code>{s}</code>:可用的子域之一，用于克服浏览器对每个主机的并发请求数的限制。</li>
 *     <li><code>{reverseX}</code>: 切片方案中的图块X坐标，其中0是最东的图块。</li>
 *     <li><code>{reverseY}</code>:切片方案中的图块Y坐标，其中0是最南端的图块。</li>
 *     <li><code>{reverseZ}</code>:在切片方案中切片的级别，其中级别0是四叉树金字塔的最大级别。为了使用reverseZ，必须定义maximumLevel。</li>
 *     <li><code>{westDegrees}</code>: 瓦片图块在测地角度上的西边缘。</li>
 *     <li><code>{southDegrees}</code>:瓦片图块在测地角度上的南边缘。</li>
 *     <li><code>{eastDegrees}</code>:以大地测量度表示的图块的东边缘。</li>
 *     <li><code>{northDegrees}</code>: 瓦片图块在测地角度上的北边缘。</li>
 *     <li><code>{westProjected}</code>:图块方案的墨卡托投影坐标中图块的西边缘。</li>
 *     <li><code>{southProjected}</code>: 图块方案的墨卡托投影坐标中图块的南边缘。</li>
 *     <li><code>{eastProjected}</code>: :图块方案的墨卡托投影坐标中图块的东边缘。</li>
 *     <li><code>{northProjected}</code>:图块方案的墨卡托投影坐标中图块的北边缘。</li>
 *     <li><code>{width}</code>:每个图块的宽度（以像素为单位）。</li>
 *     <li><code>{height}</code>: 每个图块的高度（以像素为单位）。</li>
 * </ul>
 * @param {Object} [options.urlSchemeZeroPadding] 为每个图块坐标获取URL方案零填充。格式为' 000'，其中每个坐标将在左侧用零填充，以匹配传递的零字符串的宽度。例如设置:
 * urlSchemeZeroPadding:{'{x}':'0000'}将导致'x'值为12，以在生成的URL中返回{x}的字符串'0012'。传递的对象具有以下关键字:
 * <ul>
 *  <li> <code>{z}</code>: 切片方案中图块级别的零填充。</li>
 *  <li> <code>{x}</code>: 切片方案中图块X坐标的零填充。</li>
 *  <li> <code>{y}</code>: 切片方案中图块Y坐标的零填充。</li>
 *  <li> <code>{reverseX}</code>: 在平铺方案中图块reverseX坐标的零填充。</li>
 *  <li> <code>{reverseY}</code>: 在切片方案中，图块反向Y坐标的零填充。</li>
 *  <li> <code>{reverseZ}</code>: 在切片方案中，图块的reverseZ坐标的零填充。</li>
 * </ul>
 * @param {Cesium.Resource|String} [options.pickFeaturesUrl] 用于选择功能的URL模板。如果未指定此属性，
 *                 {@link Cesium.UrlTemplateImageryProvider#pickFeatures} 会立即返回undefined，表示没有 功能选择。
 *      网址模板支持 <code>url</code>参数支持的所有关键字参数，以及以下内容:
 * <ul>
 *     <li><code>{i}</code>: 所选位置的像素列（水平坐标），其中最西端的像素为0。</li>
 *     <li><code>{j}</code>: 所选位置的像素行（垂直坐标），其中最北端的像素为0。</li>
 *     <li><code>{reverseI}</code>: 所选位置的像素列（水平坐标），其中最东端的像素为0。</li>
 *     <li><code>{reverseJ}</code>: 所选位置的像素行（垂直坐标），其中最南端的像素为0。</li>
 *     <li><code>{longitudeDegrees}</code>: 所选位置的经度（以度为单位）。</li>
 *     <li><code>{latitudeDegrees}</code>: 所选位置的纬度（以度为单位）。</li>
 *     <li><code>{longitudeProjected}</code>:在平铺方案的投影坐标中所拾取位置的经度。</li>
 *     <li><code>{latitudeProjected}</code>: 在平铺方案的投影坐标中所拾取位置的纬度。</li>
 *     <li><code>{format}</code>: 获取功能信息的格式，如 {@link GetFeatureInfoFormat}中所指定。</li>
 * </ul>
 * @export
 * @class XyzLayer
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 */

var XyzLayer_XyzLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(XyzLayer, _BaseTileLayer);

  var _super = XyzLayer_createSuper(XyzLayer);

  function XyzLayer() {
    classCallCheck_default()(this, XyzLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(XyzLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return XyzLayer_createImageryProvider(options);
    }
  }]);

  return XyzLayer;
}(BaseTileLayer_BaseTileLayer);

function XyzLayer_createImageryProvider(options) {
  options = Object(LayerUtil["converOptions"])(options);
  return new XyzImageryProvider_XyzImageryProvider(options);
}
/**
 * 创建用于图层的 ImageryProvider对象
 *
 * @param {Object} options Provider参数，同图层构造参数。
 * @return {*} ImageryProvider类
 * @function
 */


XyzLayer_XyzLayer.createImageryProvider = XyzLayer_createImageryProvider; //注册下

var XyzLayer_layerType = "xyz"; //图层类型

Object(LayerUtil["register"])(XyzLayer_layerType, XyzLayer_XyzLayer);
Object(LayerUtil["registerImageryProvider"])(XyzLayer_layerType, XyzLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/GridLayer.js






function GridLayer_createSuper(Derived) { var hasNativeReflectConstruct = GridLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GridLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 网格线
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Number} [options.cells=2] 网格单元格的数量。
 * @param {String} [options.color=rgba(255,255,255,1)] 绘制网格线的颜色。
 * @param {String} [options.glowColor=color.withAlpha(0.3)] 为网格线绘制渲染线发光效果的颜色。
 * @param {Number} [options.glowWidth=3] 用于渲染线发光效果的线的宽度。
 * @param {String} [options.backgroundColor='rgba(0,0,0,0)'] 背景填充颜色。
 * @param {Number} [options.canvasSize=256] 用于渲染的画布的大小。
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.GridImageryProvider
 */

var GridLayer_GridLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(GridLayer, _BaseTileLayer);

  var _super = GridLayer_createSuper(GridLayer);

  function GridLayer() {
    classCallCheck_default()(this, GridLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GridLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return GridLayer_createImageryProvider(options);
    }
  }]);

  return GridLayer;
}(BaseTileLayer_BaseTileLayer);

function GridLayer_createImageryProvider(options) {
  options.cells = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.cells, 2);
  options.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(options.color || "rgba(255,255,255,1)");
  options.glowWidth = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.glowWidth, 3);

  if (options.glowColor) {
    options.glowColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(options.glowColor);
  } else {
    options.glowColor = options.color.withAlpha(0.3);
  }

  options.backgroundColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(options.backgroundColor || "rgba(0,0,0,0)");
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GridImageryProvider"](options);
}

GridLayer_GridLayer.createImageryProvider = GridLayer_createImageryProvider; //注册下

var GridLayer_layerType = "grid"; //图层类型

Object(LayerUtil["register"])(GridLayer_layerType, GridLayer_GridLayer);
Object(LayerUtil["registerImageryProvider"])(GridLayer_layerType, GridLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/TileInfoLayer.js






function TileInfoLayer_createSuper(Derived) { var hasNativeReflectConstruct = TileInfoLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TileInfoLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 瓦片信息，一般用于测试
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.color=rgba(255,0,0,1)]  画瓦片边框线和标签的颜色
 *
 * @export
 * @extends {BaseTileLayer}
 *
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 * @see Cesium.UrlTemplateImageryProvider
 * @see Cesium.TileCoordinatesImageryProvider
 */

var TileInfoLayer_TileInfoLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(TileInfoLayer, _BaseTileLayer);

  var _super = TileInfoLayer_createSuper(TileInfoLayer);

  function TileInfoLayer() {
    classCallCheck_default()(this, TileInfoLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(TileInfoLayer, [{
    key: "_createImageryProvider",
    value: //构建ImageryProvider
    function _createImageryProvider(options) {
      return TileInfoLayer_createImageryProvider(options);
    }
  }]);

  return TileInfoLayer;
}(BaseTileLayer_BaseTileLayer);

function TileInfoLayer_createImageryProvider(options) {
  options.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(options.color || "rgba(255,0,0,1)");
  options = Object(LayerUtil["converOptions"])(options);
  return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TileCoordinatesImageryProvider"](options);
}

TileInfoLayer_TileInfoLayer.createImageryProvider = TileInfoLayer_createImageryProvider; //注册下

var TileInfoLayer_layerType = "tileinfo"; //图层类型

Object(LayerUtil["register"])(TileInfoLayer_layerType, TileInfoLayer_TileInfoLayer);
Object(LayerUtil["registerImageryProvider"])(TileInfoLayer_layerType, TileInfoLayer_createImageryProvider);
// CONCATENATED MODULE: ./src/layer/tileLayer/EmptyTileLayer.js






function EmptyTileLayer_createSuper(Derived) { var hasNativeReflectConstruct = EmptyTileLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function EmptyTileLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 空白图层，目前主要在Lod矢量数据加载作为事件触发使用。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseTileLayer.ConstructorOptions} [options.通用参数] 包含父类支持的相关参数
 *
 * @export
 * @class EmptyTileLayer
 * @extends {BaseTileLayer}
 * @see [支持的事件类型]{@link BaseTileLayer.EventType}
 */

var EmptyTileLayer_EmptyTileLayer = /*#__PURE__*/function (_BaseTileLayer) {
  inherits_default()(EmptyTileLayer, _BaseTileLayer);

  var _super = EmptyTileLayer_createSuper(EmptyTileLayer);

  function EmptyTileLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, EmptyTileLayer);

    _this = _super.call(this, options);
    _this._minimumLevel = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minimumLevel, 0);
    _this._maximumLevel = options.maximumLevel;
    return _this;
  } //构建ImageryProvider


  createClass_default()(EmptyTileLayer, [{
    key: "_createImageryProvider",
    value: function _createImageryProvider(options) {
      options = Object(LayerUtil["converOptions"])(options);
      options.minimumTerrainLevel = this._minimumLevel;
      options.maximumTerrainLevel = this._maximumLevel;
      return new EmptyImageryProvider_EmptyImageryProvider(options);
    }
  }, {
    key: "getMaxLevel",
    value: function getMaxLevel() {
      var maxLevel = 0;

      for (var i in this._imageryLayer._imageryCache) {
        var imagery = this._imageryLayer._imageryCache[i];

        if (imagery.level > maxLevel) {
          maxLevel = imagery.level;
        }
      }

      return maxLevel;
    }
    /**
     * 判断级别是否在当前图层的最大最小层级范围内
     * @param {Number} level 判断的级别
     * @return {Boolean} 是否在限定的范围内
     */

  }, {
    key: "isInRange",
    value: function isInRange(level) {
      var maxLevel = this.getMaxLevel();

      if (level < this._minimumLevel || level < maxLevel - 1 || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._maximumLevel) && level >= this._maximumLevel) {
        return false;
      } else {
        return true;
      }
    }
    /**
     * 判断所有瓦片 是否都在最大最小层级范围外，用于判断清除数据
     * @param {Number} level 判断的级别
     * @return {Boolean} 是否都在范围外
     */

  }, {
    key: "isAllOutRange",
    value: function isAllOutRange(level) {
      var maxLevel = this.getMaxLevel();
      return maxLevel < this._minimumLevel || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._maximumLevel) && level >= this._maximumLevel;
    }
  }]);

  return EmptyTileLayer;
}(BaseTileLayer_BaseTileLayer);
// CONCATENATED MODULE: ./src/layer/czmFileLayer/core/config2Entity.js


function config2Entity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function config2Entity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { config2Entity_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { config2Entity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













var config2Entity_nullColor = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.01); //根据config配置，更新entitys
//目前仅czml、kml、geojson 的 ceisum 原始加载方式用到

function config2Entity(entities, config, lblAddFun) {
  for (var i = entities.length - 1; i >= 0; i--) {
    var entity = entities[i]; //样式

    var symbol = config.symbol;

    if (symbol) {
      if (typeof symbol == "function") {
        //完全自定义的回调方法，自行处理entity
        symbol(entity, entity._attr);
      } else {
        setConfigSymbol(entity, config, lblAddFun);
      }
    }
  }

  return entities;
}

function getStyleBySymbolConfig(symbol, attr, entity) {
  var styleOpt = symbol.styleOptions;

  if (symbol.styleField && attr) {
    //存在多个symbol，按styleField进行分类
    var styleFieldVal = attr[symbol.styleField];
    var styleOptField = symbol.styleFieldOptions[styleFieldVal];

    if (styleOptField != null) {
      styleOpt = Object(Util["clone"])(styleOpt);
      styleOpt = config2Entity_objectSpread(config2Entity_objectSpread({}, styleOpt), styleOptField);
    }
  } //外部使用代码示例
  // var layerWork = map.getLayer(301087, "id")
  // layerWork.config.symbol.callback = function (attr, entity, styleOpt) {
  //     var val = attr.floor;
  //     if (val < 10)
  //         return { color: "#ff0000" };
  //     else
  //         return { color: "#0000ff" };
  // }


  if (typeof symbol.callback == "function") {
    //只是动态返回symbol的自定义的回调方法，返回style
    styleOpt = Object(Util["clone"])(styleOpt);

    var _styleOptField = symbol.callback(attr, entity, styleOpt);

    if (_styleOptField) {
      styleOpt = config2Entity_objectSpread(config2Entity_objectSpread({}, styleOpt), _styleOptField);
    }
  }

  styleOpt = styleOpt || {};
  return styleOpt;
} //外部配置的symbol


function setConfigSymbol(entity, config, lblAddFun) {
  var attr = entity._attr;

  if (attr && attr.type && attr.attr) {
    //兼容历史数据,V2内部标绘生产的geojson
    attr = attr.attr;
  }

  var entityCollection = entity.entityCollection; //entity原有的集合

  var styleOpt = getStyleBySymbolConfig(config.symbol, attr, entity); //添加文本的统一回调方法 ，默认为entity方式，可以外部处理。

  function defaultLblAdd(position, labelattr, attr) {
    if (labelattr.text == "") {
      return null;
    }

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](labelattr.height)) {
      position = Object(PointUtil["setPositionsHeight"])(position, labelattr.height);
    }

    var lblEx = entityCollection.add({
      position: position,
      label: labelattr,
      _attr: attr
    });
    return lblEx;
  }

  lblAddFun = lblAddFun || defaultLblAdd;

  if (entity.polyline) {
    PolylineStyleConver_PolylineStyleConver.toCesiumVal(styleOpt, entity.polyline, true); //存在附加的条带时

    if (styleOpt.corridor) {
      var corridorStyle = config2Entity_objectSpread({
        color: styleOpt.color,
        opacity: styleOpt.opacity
      }, styleOpt.corridor); // 可采用格式化字符串


      if (Object(Util["isString"])(styleOpt.corridor.width)) {
        corridorStyle.width = Object(Util["template"])(styleOpt.corridor.width, attr);
      }

      if (entity._corridorEx) {
        CorridorStyleConver_CorridorStyleConver.toCesiumVal(corridorStyle, entity._corridorEx.corridor, true);
      } else {
        var corridor = CorridorStyleConver_CorridorStyleConver.toCesiumVal(corridorStyle, {}, true);
        corridor.positions = Object(Util["getCesiumValue"])(entity.polyline.positions);
        var lineEx = entityCollection.add({
          corridor: corridor,
          _attr: attr
        });
        lineEx._tudou3d_layerId = config.uuid;
        entity._corridorEx = lineEx;
      }
    } //线时，加上文字标签


    if (styleOpt.label && styleOpt.label.text) {
      if (entity._labelEx) {
        LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var pots = Object(Util["getCesiumValue"])(entity.polyline.positions);
        var position = pots[Math.floor(pots.length / 2)];

        if (styleOpt.label.position) {
          if (styleOpt.label.position == "center") {
            position = centerOfMass(pots, styleOpt.label.height);
          } else if (Object(Util["isNumber"])(styleOpt.label.position)) {
            position = pots[styleOpt.label.position];
          }
        } //文本属性


        var labelattr = LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);
        labelattr.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](labelattr.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
        var lblEx = lblAddFun(position, labelattr, attr);

        if (lblEx) {
          lblEx._tudou3d_layerId = config.uuid;
        }

        entity._labelEx = lblEx;
      }
    }
  }

  if (entity.polygon) {
    var _styleOpt$outlineStyl;

    PolygonStyleConver_PolygonStyleConver.toCesiumVal(styleOpt, entity.polygon, true); //加上线宽

    if (styleOpt.outline && (styleOpt.outlineWidth > 1 || ((_styleOpt$outlineStyl = styleOpt.outlineStyle) === null || _styleOpt$outlineStyl === void 0 ? void 0 : _styleOpt$outlineStyl.width) > 1)) {
      entity.polygon.outline = false;

      var outlineStyle = config2Entity_objectSpread(config2Entity_objectSpread({}, styleOpt), {}, {
        outline: false,
        color: styleOpt.outlineColor,
        width: styleOpt.outlineWidth,
        opacity: styleOpt.outlineOpacity
      }, styleOpt.outlineStyle || {}); //_outlineEx是数组，支持挖洞多边形的多个边线。


      if (entity._outlineEx) {
        for (var i = 0, len = entity._outlineEx.length; i < len; i++) {
          PolylineStyleConver_PolylineStyleConver.toCesiumVal(outlineStyle, entity._outlineEx[i].polyline, true);
        }
      } else {
        var arrline = getAllPositions(entity);
        entity._outlineEx = [];

        for (var _i = 0, _len = arrline.length; _i < _len; _i++) {
          var polyline = PolylineStyleConver_PolylineStyleConver.toCesiumVal(outlineStyle, {}, true);
          polyline.positions = arrline[_i];

          var _lineEx = entityCollection.add({
            polyline: polyline,
            _attr: attr
          });

          _lineEx._tudou3d_layerId = config.uuid;

          entity._outlineEx.push(_lineEx);
        }
      }
    } //面时，加上文字标签


    if (styleOpt.label && styleOpt.label.text) {
      if (entity._labelEx) {
        LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var _position = centerOfMass(getPositions(entity), styleOpt.label.height); //文本属性


        var _labelattr = LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);

        _labelattr.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_labelattr.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);

        var _lblEx = lblAddFun(_position, _labelattr, attr);

        if (_lblEx) {
          _lblEx._tudou3d_layerId = config.uuid;
        }

        entity._labelEx = _lblEx;
      }
    }
  } //entity本身存在文字标签


  if (entity.label) {
    styleOpt.label = styleOpt.label || styleOpt || {};

    if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](styleOpt.label.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](styleOpt.label.heightReference)) {
      styleOpt.label.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](styleOpt.label.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
    }

    LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, entity.label, attr);
  } else {
    //外部完全自定义的方式
    if (styleOpt.label && typeof styleOpt.label == "function") {
      styleOpt.label(entity, attr, function (position, styleLbl) {
        //文本属性
        var labelattr = LabelStyleConver_LabelStyleConver.toCesiumVal(styleLbl, {}, attr);
        labelattr.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](labelattr.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
        var lblEx = lblAddFun(position, labelattr, attr);

        if (lblEx) {
          lblEx._tudou3d_layerId = config.uuid;
        }
      });
    }
  } //图标时


  if (entity.billboard) {
    if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](styleOpt.clampToGround) && !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](styleOpt.heightReference)) {
      styleOpt.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](styleOpt.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
    } // 可采用格式化字符串


    styleOpt.image = Object(Util["template"])(styleOpt.image, attr);
    BillboardStyleConver_BillboardStyleConver.toCesiumVal(styleOpt, entity.billboard, true); //支持小模型

    if (styleOpt.model) {
      if (entity._modelEx) {
        ModelStyleConver_ModelStyleConver.toCesiumVal(styleOpt.model, entity._modelEx.model, true);
      } else {
        var modelattr = ModelStyleConver_ModelStyleConver.toCesiumVal(styleOpt.model, true);
        modelattr.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](modelattr.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
        var modelEx = entityCollection.add({
          position: entity.position,
          model: modelattr,
          _attr: attr
        });
        modelEx._tudou3d_layerId = config.uuid;
        entity._modelEx = modelEx;
      }
    } //支持point


    if (styleOpt.point) {
      if (entity._pointEx) {
        PointStyleConver_PointStyleConver.toCesiumVal(styleOpt.point, entity._pointEx.point, true);
      } else {
        var _modelattr = PointStyleConver_PointStyleConver.toCesiumVal(styleOpt.point, {}, true);

        _modelattr.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_modelattr.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);
        var pointEx = entityCollection.add({
          position: entity.position,
          point: _modelattr,
          _attr: attr
        });
        pointEx._tudou3d_layerId = config.uuid;
        entity._pointEx = pointEx;
      }
    } //加上文字标签 (entity本身不存在label时)


    if (styleOpt.label && styleOpt.label.text && !entity.label) {
      if (entity._labelEx) {
        LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var _position2 = entity.position; //文本属性

        var _labelattr2 = LabelStyleConver_LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);

        _labelattr2.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_labelattr2.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);

        var _lblEx2 = lblAddFun(_position2, _labelattr2, attr);

        if (_lblEx2) {
          _lblEx2._tudou3d_layerId = config.uuid;
        }

        entity._labelEx = _lblEx2;
      }
    }
  } //记录下样式配置


  entity.styleOpt = styleOpt;
}
// CONCATENATED MODULE: ./src/layer/czmFileLayer/CzmGeoJsonLayer.js








function CzmGeoJsonLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CzmGeoJsonLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CzmGeoJsonLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CzmGeoJsonLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CzmGeoJsonLayer_createSuper(Derived) { var hasNativeReflectConstruct = CzmGeoJsonLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CzmGeoJsonLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * @typedef {Object} CzmGeoJsonLayer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphicLayer.EventType} 通用 支持的父类的事件类型
 * @property {String} load 完成加载，执行所有内部处理后
 * @property {String} addGraphic 添加矢量数据时
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.load, function (event) {
 *   console.log('矢量数据对象加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * GeoJSON数据图层(ceisum原生)，该类中矢量数据是使用ceisum原生方法加载的entity对象。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.url] geojson文件或服务url地址
 * @param {Object} [options.data] geojson格式规范数据对象，与url二选一即可。
 * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
 *
 * @param {Object} [options.symbol] 矢量数据的style样式
 * @param {BillboardEntity.StyleOptions} options.symbol.styleOptions 点数据时的Style样式，可以附加 model {@link ModelEntity.StyleOptions} 或 point {@link PointEntity.StyleOptions}
 * @param {PolylineEntity.StyleOptions} options.symbol.styleOptions 线数据时的Style样式，可以附加 corridor {@link CorridorEntity.StyleOptions}
 * @param {PolygonEntity.StyleOptions} options.symbol.styleOptions 面数据时的Style样式
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
 *
 * @class CzmGeoJsonLayer
 * @extends {BaseGraphicLayer}
 *
 * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
 * @see Cesium.GeoJsonDataSource
 */

var CzmGeoJsonLayer_CzmGeoJsonLayer = /*#__PURE__*/function (_BaseGraphicLayer) {
  inherits_default()(CzmGeoJsonLayer, _BaseGraphicLayer);

  var _super = CzmGeoJsonLayer_createSuper(CzmGeoJsonLayer);

  //========== 构造方法 ==========
  function CzmGeoJsonLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CzmGeoJsonLayer);

    _this = _super.call(this, options);

    _this._setOptionsHook(options);

    return _this;
  }
  /**
   * GeoJsonDataSource 对象
   * @type {Cesium.GeoJsonDataSource}
   * @readonly
   */


  createClass_default()(CzmGeoJsonLayer, [{
    key: "layer",
    get: function get() {
      return this._dataSource;
    }
    /**
     * Entity矢量数据 集合
     * @type {Cesium.EntityCollection}
     * @readonly
     */

  }, {
    key: "entities",
    get: function get() {
      if (this._dataSource) {
        return this._dataSource.entities;
      } else {
        return null;
      }
    }
    /**
     * 当存在 文字primitive 数据的内部Cesium容器
     * @type {Cesium.LabelCollection}
     * @readonly
     */

  }, {
    key: "labelCollection",
    get: function get() {
      if (!this._labelCollection) {
        this._labelCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelCollection"]({
          scene: this._map.scene
        });

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._labelCollection);
        }
      }

      return this._labelCollection;
    }
    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasZIndex",
    get: function get() {
      return true;
    }
    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */

  }, {
    key: "zIndex",
    get: function get() {
      return this.options.zIndex;
    },
    set: function set(zIndex) {
      this.options.zIndex = zIndex;

      if (this._dataSource == null || zIndex == null) {
        return;
      }

      if (!this._map.dataSources.contains(this._dataSource)) {
        return;
      }

      this._dataSource.zIndex = zIndex; //先移动到最顶层

      this._map.dataSources.raiseToTop(this._dataSource);

      var layers = this._map.dataSources;

      for (var i = layers.length - 1; i >= 0; i--) {
        var layer = layers.get(i);

        if (layer == this._dataSource) {
          continue;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](layer.zIndex) && zIndex < layer.zIndex) {
          this._map.dataSources.lower(this._dataSource); //下移一个位置

        }
      }
    }
    /**
     * 是否贴地
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "clampToGround",
    get: function get() {
      if (this.options.clampToGround) {
        return true;
      }

      if (this.options.symbol && this.options.symbol.styleOptions && this.options.symbol.styleOptions.clampToGround) {
        return true;
      }

      return false;
    }
  }, {
    key: "_setOptionsHook",
    value: function _setOptionsHook(options) {
      var _this$options$symbol;

      //GeoJsonDataSource.load中使用
      if ((_this$options$symbol = this.options.symbol) !== null && _this$options$symbol !== void 0 && _this$options$symbol.styleOptions) {
        var style = this.options.symbol.styleOptions;

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.clampToGround)) {
          this.options.clampToGround = style.clampToGround;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.color)) {
          var color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.color, "#FFFF00")).withAlpha(Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.opacity, 0.5)));
          this.options.fill = color;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.outlineColor)) {
          var outlineColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.outlineOpacity, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.opacity, 1.0)));
          this.options.stroke = outlineColor;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style.outlineWidth)) {
          this.options.strokeWidth = style.outlineWidth;
        }
      }
    }
  }, {
    key: "_showHook",
    value: function _showHook(val) {
      get_default()(getPrototypeOf_default()(CzmGeoJsonLayer.prototype), "_showHook", this).call(this, val);

      if (this._labelCollection) {
        this._labelCollection.show = val;
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      get_default()(getPrototypeOf_default()(CzmGeoJsonLayer.prototype), "_mountedHook", this).call(this);

      this.load();
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(CzmGeoJsonLayer.prototype), "_addedHook", this).call(this);

      if (this._dataSource) {
        this._map.dataSources.add(this._dataSource);
      }

      if (this._labelCollection) {
        this._map.scene.primitives.add(this._labelCollection);
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(CzmGeoJsonLayer.prototype), "_removedHook", this).call(this);

      if (this._labelCollection) {
        this._map.scene.primitives.remove(this._labelCollection);

        this._labelCollection = null;
      }

      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);
      }
    } //定位至数据区域

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (!this._map) {
        return;
      }

      if (this.options.center) {
        this._map.setCameraView(this.options.center, options);
      } else if (this.options.extent) {
        this._map.flyToExtent(this.options.extent, options);
      } else if (this._dataSource) {
        this._map.viewer.flyTo(this._dataSource, options);
      }
    }
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {String} [newOptions.url] geojson文件或服务url地址
     * @param {Object} [newOptions.data] geojson格式规范数据对象，与url二选一即可。
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @param {BaseGraphicLayer.ConstructorOptions} [newOptions.通用参数] 包含父类支持的所有参数
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "load",
    value: function load(newOptions) {
      var _this2 = this;

      if (newOptions) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](newOptions.clear, true)) {
          delete this.options.url;
          delete this.options.data;
        }

        this.clear();
        this.options = CzmGeoJsonLayer_objectSpread(CzmGeoJsonLayer_objectSpread({}, this.options), newOptions);
      }

      if (this.options.url) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(this.options).then(function (data) {
          if (_this2._state !== State.ADDED) {
            return;
          }

          _this2._load_data(data);
        })["catch"](function (error) {
          this.showError("服务出错", error);
        });
      } else if (this.options.data) {
        this._load_data(this.options.data);
      } else {
        if (newOptions) {
          Object(Log["logWarn"])("CzmGeoJsonLayer：没有传入 url 或 data 参数,请确认是否有误。");
        }
      }

      return this;
    }
  }, {
    key: "_load_data",
    value: function _load_data(geojson) {
      var _this3 = this;

      if (this.options.format) {
        geojson = this.options.format(geojson);
      }

      var loadPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeoJsonDataSource"].load(geojson, this.options);
      loadPromise.then(function (dataSource) {
        _this3.showResult(dataSource);
      })["catch"](function (error) {
        this.showError("服务出错", error);
      });
    }
  }, {
    key: "showResult",
    value: function showResult(dataSource) {
      var _this4 = this;

      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);

        delete this._dataSource;
      }

      if (!dataSource || this._state == State.REMOVED) {
        return;
      }

      dataSource.show = this.show; //避免异步加载中设置show=false，需要赋值下

      this._map.dataSources.add(dataSource);

      this._dataSource = dataSource;

      if (this.options.zIndex) {
        this.zIndex = this.options.zIndex;
      }

      var entities = dataSource.entities.values;
      var list = [];

      for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        entity._tudou3d_layerId = this.uuid; //属性

        var attr = this.getEntityAttr(entity);
        entity._attr = attr || {}; //重新绑定，后续使用

        this.fire(EventType.addGraphic, {
          czmObject: entity,
          attr: attr
        });
        list.push(CzmGeoJsonLayer_objectSpread(CzmGeoJsonLayer_objectSpread({}, attr), {}, {
          _entity: entity
        }));
      }

      this.options.uuid = this.uuid;
      config2Entity(entities, this.options, function (position, labelattr, attr) {
        return _this4.lblAddFun(position, labelattr, attr);
      });

      if (this._opacity != 1) {
        this.setOpacity(this._opacity);
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this.fire(EventType.load, {
        dataSource: dataSource,
        entities: entities,
        list: list
      });
    }
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} symbol 设置新的symbol 矢量数据样式.  {@link GraphicType}
     * @param {Object} symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
     * @param {String} [symbol.styleField] 按 styleField 属性设置不同样式。
     * @param {Object} [symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "updateStyle",
    value: function updateStyle(symbol) {
      var _this5 = this;

      if (!this._dataSource) {
        return;
      }

      if (symbol) {
        this.options.symbol = CzmGeoJsonLayer_objectSpread(CzmGeoJsonLayer_objectSpread({}, this.options.symbol), symbol);
      }

      var entities = this._dataSource.entities.values;
      this.options.uuid = this.uuid;
      config2Entity(entities, this.options, function (position, labelattr, attr) {
        return _this5.lblAddFun(position, labelattr, attr);
      });
      return this;
    }
    /**
     * 添加label文本注记
     *
     * @param {Cesium.Cartesian3|Cesium.XXXPositionProperty} position 坐标位置
     * @param {Object} labelattr label文本的属性
     * @param {Object} attr 属性信息
     * @return {Cesium.Label} label文本对象
     */

  }, {
    key: "lblAddFun",
    value: function lblAddFun(position, labelattr, attr) {
      if (labelattr.text == "") {
        return null;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](labelattr.height)) {
        position = Object(PointUtil["setPositionsHeight"])(position, labelattr.height);
      } //entity方式
      // let lblEx = this._dataSource.entities.add({
      //   position: position,
      //   label: labelattr,
      //   properties: attr,
      // })
      //LabelCollection方式


      if (!this.labelCollection) {
        this.labelCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelCollection"]({
          scene: this.viewer.scene
        });
        this.viewer.scene.primitives.add(this.labelCollection);
      }

      labelattr.position = Object(PointUtil["getPositionValue"])(position);
      var lblEx = this.labelCollection.add(labelattr);
      lblEx.properties = attr;
      lblEx._tudou3d_layerId = this.uuid;
      return lblEx;
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;

      if (this._dataSource == null) {
        return;
      }

      var entities = this._dataSource.entities.values;

      for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];

        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
          this._updatEntityAlpha(entity.polygon.material.color, this._opacity);

          if (entity.polygon.outlineColor) {
            this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
          }
        }

        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
          this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
        }

        if (entity.billboard) {
          entity.billboard.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(this._opacity);
        }

        if (entity.model) {
          entity.model.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE.withAlpha(this._opacity);
        }

        if (entity.label) {
          var _opacity = this._opacity;

          if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) {
            _opacity = entity.styleOpt.label.opacity;
          }

          if (entity.label.fillColor) {
            this._updatEntityAlpha(entity.label.fillColor, _opacity);
          }

          if (entity.label.outlineColor) {
            this._updatEntityAlpha(entity.label.outlineColor, _opacity);
          }

          if (entity.label.backgroundColor) {
            this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
          }
        }
      }
    }
  }, {
    key: "_updatEntityAlpha",
    value: function _updatEntityAlpha(color, opacity) {
      if (!color) {
        return;
      }

      var newclr = Object(Util["getCesiumValue"])(color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"], this._map.clock.currentTime);

      if (!newclr || !newclr.withAlpha) {
        return color;
      }

      newclr = newclr.withAlpha(opacity);
      color.setValue(newclr);
    }
    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     */

  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      return Object(Util["getAttrVal"])(entity.properties);
    }
    /**
     * 清除所有数据
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this._labelCollection) {
        this._labelCollection.removeAll();
      }

      if (this._dataSource) {
        this._dataSource.entities.removeAll();
      }

      this._closeAllControl();

      return this;
    }
  }]);

  return CzmGeoJsonLayer;
}(BaseGraphicLayer_BaseGraphicLayer); //注册下

Object(LayerUtil["register"])("czmGeojson", CzmGeoJsonLayer_CzmGeoJsonLayer);
// CONCATENATED MODULE: ./src/layer/czmFileLayer/KmlLayer.js







function KmlLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function KmlLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { KmlLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { KmlLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function KmlLayer_createSuper(Derived) { var hasNativeReflectConstruct = KmlLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function KmlLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * KML数据图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.url] KML文件或服务url地址
 * @param {Document | Blob} [options.data] 已解析的KML文档或包含二进制KMZ数据或已解析的KML文档的Blob，与url二选一即可。
 * @param {Function} [options.format] 可以对加载的KML数据进行格式化或转换操作
 *
 * @param {Object} [options.symbol] 矢量数据的style样式
 * @param {BillboardEntity.StyleOptions} options.symbol.styleOptions 点数据时的Style样式，可以附加 model {@link ModelEntity.StyleOptions} 或 point {@link PointEntity.StyleOptions}
 * @param {PolylineEntity.StyleOptions} options.symbol.styleOptions 线数据时的Style样式，可以附加 corridor {@link CorridorEntity.StyleOptions}
 * @param {PolygonEntity.StyleOptions} options.symbol.styleOptions 面数据时的Style样式
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
 *
 * @export
 * @class KmlLayer
 * @extends {CzmGeoJsonLayer}
 *
 * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
 * @see Cesium.KmlDataSource
 */

var KmlLayer_KmlLayer = /*#__PURE__*/function (_CzmGeoJsonLayer) {
  inherits_default()(KmlLayer, _CzmGeoJsonLayer);

  var _super = KmlLayer_createSuper(KmlLayer);

  function KmlLayer() {
    classCallCheck_default()(this, KmlLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(KmlLayer, [{
    key: "load",
    value:
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {Document | Blob} [newOptions.data] 已解析的KML文档或包含二进制KMZ数据或已解析的KML文档的Blob，与url二选一即可。
     *
     * @param {String} [newOptions.url] KML文件或服务url地址
     * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
     * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
     * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
     * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
     *
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @param {BaseGraphicLayer.ConstructorOptions} [newOptions.通用参数] 包含父类支持的所有参数
     * @return {this} 当前对象本身，可以链式调用
     * @override
     */
    function load() {
      var _this = this;

      var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = KmlLayer_objectSpread(KmlLayer_objectSpread({}, this.options), newOptions);
      var loadPromise;

      if (this.options.url) {
        var url = Object(Util["getUrlResource"])(this.options);
        loadPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KmlDataSource"].load(url, {
          camera: this._map.scene.camera,
          canvas: this._map.scene.canvas,
          clampToGround: this.options.clampToGround
        });
      } else if (this.options.data) {
        loadPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KmlDataSource"].load(this.options.data, {
          camera: this._map.scene.camera,
          canvas: this._map.scene.canvas,
          clampToGround: this.options.clampToGround
        });
        Object(Log["logError"])("KmlLayer：请必须传入 url 或 data 参数");
      }

      loadPromise.then(function (dataSource) {
        _this.showResult(dataSource);
      })["catch"](function (error) {
        this.showError("服务出错", error);
      });
    }
    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     * @override
     */

  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      var attr = {
        name: entity.name,
        description: entity.description
      };
      var extendedData = entity._kml.extendedData;

      for (var key in extendedData) {
        attr[key] = extendedData[key].value;
      }

      attr = Object(Util["getAttrVal"])(attr);

      if (attr.description) {
        attr.description = attr.description.replace(/<div[^>]+>/g, ""); //剔除div html标签
      }

      return attr;
    }
  }]);

  return KmlLayer;
}(CzmGeoJsonLayer_CzmGeoJsonLayer); //注册下

Object(LayerUtil["register"])("kml", KmlLayer_KmlLayer);
// CONCATENATED MODULE: ./src/layer/czmFileLayer/CzmlLayer.js








function CzmlLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function CzmlLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CzmlLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CzmlLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function CzmlLayer_createSuper(Derived) { var hasNativeReflectConstruct = CzmlLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CzmlLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * CZML数据图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.url] CZML文件或服务url地址
 * @param {Object} [options.data] CZML格式规范数据对象，与url二选一即可。
 * @param {Function} [options.format] 可以对加载的CZML数据进行格式化或转换操作
 *
 * @export
 * @class CzmlLayer
 * @extends {CzmGeoJsonLayer}
 *
 * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
 * @see Cesium.CzmlDataSource
 */

var CzmlLayer_CzmlLayer = /*#__PURE__*/function (_CzmGeoJsonLayer) {
  inherits_default()(CzmlLayer, _CzmGeoJsonLayer);

  var _super = CzmlLayer_createSuper(CzmlLayer);

  function CzmlLayer() {
    classCallCheck_default()(this, CzmlLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(CzmlLayer, [{
    key: "_showHook",
    value: function _showHook(val) {
      get_default()(getPrototypeOf_default()(CzmlLayer.prototype), "_showHook", this).call(this, val);

      if (val) {
        this.setCzmlTime();
      } else {
        this.setNowTime();
      }
    }
  }, {
    key: "setCzmlTime",
    value: function setCzmlTime() {
      var _this$_dataSource;

      if ((_this$_dataSource = this._dataSource) !== null && _this$_dataSource !== void 0 && _this$_dataSource.clock) {
        this._map.clock.clockRange = this._dataSource.clock.clockRange;
        this._map.clock.multiplier = this._dataSource.clock.multiplier;
        this._map.clock.startTime = this._dataSource.clock.startTime;
        this._map.clock.stopTime = this._dataSource.clock.stopTime;
        this._map.clock.currentTime = this._dataSource.clock.startTime;
      }
    }
  }, {
    key: "setNowTime",
    value: function setNowTime() {
      this._map.clock.clockRange = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClockRange"].UNBOUNDED;
      this._map.clock.multiplier = 1;
      var now = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date());
      this._map.clock.startTime = now.clone();
      this._map.clock.stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].addDays(now, 1.0, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"]());
      this._map.clock.currentTime = now.clone();
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(CzmlLayer.prototype), "_removedHook", this).call(this);

      this.setNowTime();
    }
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {Object} [newOptions.data] CZML格式规范数据对象，与url二选一即可。
     *
     * @param {String} [newOptions.url] CZML文件或服务url地址
     * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
     * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
     * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
     * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
     *
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @param {BaseGraphicLayer.ConstructorOptions} [newOptions.通用参数] 包含父类支持的所有参数
     * @return {this} 当前对象本身，可以链式调用
     * @override
     */

  }, {
    key: "load",
    value: function load() {
      var _this = this;

      var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = CzmlLayer_objectSpread(CzmlLayer_objectSpread({}, this.options), newOptions);
      var loadPromise;

      if (this.options.url) {
        var url = Object(Util["getUrlResource"])(this.options);
        loadPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CzmlDataSource"].load(url, this.options);
      } else if (this.options.data) {
        loadPromise = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CzmlDataSource"].load(this.options.data, this.options);
      } else {
        Object(Log["logError"])("CzmlLayer：请必须传入 url 或 data 参数");
      }

      loadPromise.then(function (dataSource) {
        _this.showResult(dataSource);
      })["catch"](function (error) {
        this.showError("服务出错", error);
      });
    }
    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     * @override
     */

  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      if (entity.properties) {
        return Object(Util["getAttrVal"])(entity.properties);
      }

      if (entity.description) {
        return {
          description: Object(Util["getCesiumValue"])(entity.description)
        };
      }
    }
  }]);

  return CzmlLayer;
}(CzmGeoJsonLayer_CzmGeoJsonLayer); //注册下

Object(LayerUtil["register"])("czml", CzmlLayer_CzmlLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/GraphicLayer.js








function GraphicLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GraphicLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GraphicLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GraphicLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GraphicLayer_createSuper(Derived) { var hasNativeReflectConstruct = GraphicLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GraphicLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }











/**
 * @typedef {Object} GraphicLayer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphicLayer.EventType} 通用 支持的父类的事件类型
 *
 * @property {String} addGraphic 添加矢量数据时
 * @property {String} removeGraphic 移除矢量数据时
 *
 * @property {String} drawStart 开始绘制 标绘事件
 * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
 * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
 * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
 * @property {String} drawCreated 创建完成 标绘事件
 * @property {String} editStart 开始编辑 标绘事件
 * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
 * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
 * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
 * @property {String} editRemovePoint 编辑删除了点 标绘事件
 * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
 * @property {String} editStop 停止编辑 标绘事件
 *
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.load, function (event) {
 *   console.log('矢量数据对象加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 矢量数据图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {Boolean} [options.hasEdit=false] 是否自动激活编辑（true时，单击后自动激活编辑）
 * @param {Boolean} [options.isAutoEditing=true] 完成标绘时是否自动启动编辑(需要hasEdit:true时)
 * @param {Boolean} [options.isContinued=false] 是否连续标绘
 * @param {Boolean} [options.isRestorePositions=false] 在标绘和编辑结束时，是否将坐标还原为普通值，true: 停止编辑时会有闪烁，但效率要好些。
 *
 * @param {Object|Object[]} [options.data=null] 需要自动加载的数据，内部自动生成Graphic对象。{@link GraphicUtil#.create}
 *
 * @param {Object} options.clustering 点数据时，设置聚合相关参数：
 * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
 * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
 * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
 * @param {Number} [options.clustering.radius=26] 内置样式时，圆形图标的半径大小（单位：像素）
 * @param {String} [options.clustering.fontColor='#ffffff'] 内置样式时，数字的颜色
 * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 内置样式时，圆形图标的背景颜色
 * @param {Number} [options.clustering.opacity=0.5] 内置样式时，圆形图标的透明度
 * @param {Number} [options.clustering.borderWidth=5] 圆形图标的边框宽度（单位：像素），0不显示
 * @param {String} [options.clustering.borderColor='rgba(110, 204, 57, 0.5)'] 内置样式时，圆形图标的边框颜色
 * @param {Number} [options.clustering.borderOpacity=0.6] 内置样式时，圆形图标边框的透明度
 * @param {Function} [options.clustering.getImage] 自定义聚合的图标样式，例如：getImage:function(count) { return image}
 *
 * @param {Boolean} [options.stopPropagation=false] 当前类中事件是否停止冒泡, false时：事件冒泡到map中。
 * @export
 * @class GraphicLayer
 * @extends {BaseGraphicLayer}
 * @see [支持的事件类型]{@link GraphicLayer.EventType}

 */

var GraphicLayer_GraphicLayer = /*#__PURE__*/function (_BaseGraphicLayer) {
  inherits_default()(GraphicLayer, _BaseGraphicLayer);

  var _super = GraphicLayer_createSuper(GraphicLayer);

  function GraphicLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GraphicLayer);

    _this = _super.call(this, options);
    _this._cacheUuid = {};
    _this._cacheId = {};
    _this.hasEdit = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.hasEdit, false);
    _this.isAutoEditing = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.isAutoEditing, true);
    _this.isContinued = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.isContinued, false);
    return _this;
  } //默认


  createClass_default()(GraphicLayer, [{
    key: "layer",
    get: function get() {
      var arr = [];

      if (this._dataSource) {
        arr.push(this._dataSource);
      }

      if (this._primitiveCollection) {
        arr.push(this._primitiveCollection);
      }

      if (this._labelCollection) {
        arr.push(this._labelCollection);
      }

      if (this._billboardCollection) {
        arr.push(this._billboardCollection);
      }

      if (this._pointCollection) {
        arr.push(this._pointCollection);
      }

      if (this._polylineCollection) {
        arr.push(this._polylineCollection);
      }

      return arr;
    }
    /**
     * 是否聚合(点数据时)
     * @type {Boolean}
     */

  }, {
    key: "clustering",
    get: function get() {
      return this.dataSource.clustering.enabled;
    },
    set: function set(val) {
      this.dataSource.clustering.enabled = val;
    }
    /**
     * 当加载Entity类型数据的内部Cesium容器 {@link BaseEntity}
     * @type {Cesium.CustomDataSource}
     * @readonly
     */

  }, {
    key: "dataSource",
    get: function get() {
      if (!this._dataSource) {
        this._dataSource = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CustomDataSource"](this.uuid);
        this._dataSource.show = this.show;

        if (this._state == State.ADDED) {
          this._map.dataSources.add(this._dataSource);

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.zIndex)) {
            this.zIndex = this.options.zIndex;
          }
        }
      }

      return this._dataSource;
    }
    /**
     * 当加载普通 primitive类型数据的内部Cesium容器 {@link BasePrimitive}
     * @type {Cesium.PrimitiveCollection}
     */

  }, {
    key: "primitiveCollection",
    get: function get() {
      if (!this._primitiveCollection) {
        this._primitiveCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveCollection"]();
        this._primitiveCollection.show = this.show;

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._primitiveCollection);

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.zIndex)) {
            this.zIndex = this.options.zIndex;
          }
        }
      }

      return this._primitiveCollection;
    }
    /**
     * 当加载 文字primitive 数据的内部Cesium容器 {@link LabelPrimitive}
     * @type {Cesium.LabelCollection}
     * @readonly
     * @ignore
     */

  }, {
    key: "labelCollection",
    get: function get() {
      if (!this._labelCollection) {
        this._labelCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelCollection"]({
          scene: this._map.scene
        });
        this._labelCollection.show = this.show;

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._labelCollection);
        }
      }

      return this._labelCollection;
    }
    /**
     * 当加载 点primitive 数据的内部Cesium容器 {@link PointPrimitive}
     * @type {Cesium.PointPrimitiveCollection}
     * @readonly
     * @ignore
     */

  }, {
    key: "pointCollection",
    get: function get() {
      if (!this._pointCollection) {
        this._pointCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PointPrimitiveCollection"]();
        this._pointCollection.show = this.show;

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._pointCollection);
        }
      }

      return this._pointCollection;
    }
    /**
     * 当加载 图标点primitive 数据的内部Cesium容器 {@link BillboardPrimitive}
     * @type {Cesium.BillboardCollection}
     * @readonly
     * @ignore
     */

  }, {
    key: "billboardCollection",
    get: function get() {
      if (!this._billboardCollection) {
        this._billboardCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BillboardCollection"]({
          scene: this._map.scene
        });
        this._billboardCollection.show = this.show;

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._billboardCollection);
        }
      }

      return this._billboardCollection;
    }
    /**
     * 当加载 简单线primitive 数据的内部Cesium容器 {@link PolylinePrimitive}
     * @type {Cesium.PolylineCollection}
     * @readonly
     * @ignore
     */

  }, {
    key: "polylineCollection",
    get: function get() {
      if (!this._polylineCollection) {
        this._polylineCollection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineCollection"]();
        this._polylineCollection.show = this.show;

        if (this._state == State.ADDED) {
          this._map.scene.primitives.add(this._polylineCollection);
        }
      }

      return this._polylineCollection;
    }
    /**
     * 当加载 DivGraphic 数据的内部DOM容器 {@link DivGraphic}
     *
     * @type {Element}
     * @readonly
     */

  }, {
    key: "container",
    get: function get() {
      if (!this._container) {
        this._container = create("div", "tudou3d-divlayer");

        if (this.show) {
          this._container.style.display = "block";
        } else {
          this._container.style.display = "none";
        }

        if (this._state == State.ADDED) {
          this._map.container.appendChild(this._container);
        }
      }

      return this._container;
    }
    /**
     * 当加载 DivGraphic 数据的DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
     * @type {Boolean}
     */

  }, {
    key: "pointerEvents",
    get: function get() {
      return this._pointerEvents;
    },
    set: function set(value) {
      this._pointerEvents = value;

      if (value) {
        this.container.style["pointer-events"] = "all";
      } else {
        /*加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件*/
        this.container.style["pointer-events"] = "none";
      }
    }
    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasZIndex",
    get: function get() {
      return true;
    }
    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */

  }, {
    key: "zIndex",
    get: function get() {
      return this.options.zIndex;
    },
    set: function set(zIndex) {
      this.options.zIndex = zIndex;

      if (zIndex == null) {
        return;
      } //调整primitives顺序


      if (this._primitiveCollection && this._map.scene.primitives.contains(this._primitiveCollection)) {
        this._primitiveCollection.zIndex = zIndex; //先移动到最顶层

        this._map.scene.primitives.raiseToTop(this._primitiveCollection);

        var layers = this._map.scene.primitives;

        for (var i = layers.length - 1; i >= 0; i--) {
          var layer = layers.get(i);

          if (layer == this._primitiveCollection) {
            continue;
          }

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](layer.zIndex) && zIndex < layer.zIndex) {
            this._map.scene.primitives.lower(this._primitiveCollection); //下移一个位置

          }
        }
      } //调整dataSources顺序


      if (this._dataSource && this._map.dataSources.contains(this._dataSource)) {
        this._dataSource.zIndex = zIndex; //先移动到最顶层

        this._map.dataSources.raiseToTop(this._dataSource);

        var _layers = this._map.dataSources;

        for (var _i = _layers.length - 1; _i >= 0; _i--) {
          var _layer = _layers.get(_i);

          if (_layer == this._dataSource) {
            continue;
          }

          if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_layer.zIndex) && zIndex < _layer.zIndex) {
            this._map.dataSources.lower(this._dataSource); //下移一个位置

          }
        }
      }
    }
    /**
     * 图层内的Graphic矢量数据个数
     *
     * @type {Number}
     * @readonly
     */

  }, {
    key: "length",
    get: function get() {
      return Object.keys(this._cacheUuid).length;
    }
    /**
     * 图层内的Graphic集合对象
     *
     * @type {BaseGraphic[]}
     * @readonly
     */

  }, {
    key: "graphics",
    get: function get() {
      return this.getGraphics();
    }
    /**
     * 是否自动激活编辑（true时，单击后自动激活编辑）
     *
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "hasEdit",
    get: function get() {
      return this._hasEdit;
    },
    set: function set(val) {
      if (val) {
        this.activateEdit();
      } else {
        this.disableEdit();
      }
    }
    /**
     * 是否正在编辑状态
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isEditing",
    get: function get() {
      return this.lastEditGraphic != null;
    }
    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onAdd",
    value: function _onAdd(map) {
      if (this._state == State.ADDED) {
        return;
      }

      this._state = State.ADDED;
      this._map = map;

      if (!this.options.stopPropagation) {
        this.addEventParent(map);
      }

      if (this._dataSource) {
        this._map.dataSources.add(this._dataSource);
      }

      if (this._primitiveCollection) {
        this._map.scene.primitives.add(this._primitiveCollection);
      }

      if (this._labelCollection) {
        this._map.scene.primitives.add(this._labelCollection);
      }

      if (this._billboardCollection) {
        this._map.scene.primitives.add(this._billboardCollection);
      }

      if (this._pointCollection) {
        this._map.scene.primitives.add(this._pointCollection);
      }

      if (this._polylineCollection) {
        this._map.scene.primitives.add(this._polylineCollection);
      }

      if (this._container) {
        this._map.container.appendChild(this._container);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._mountedHook();

          this._createOK = true;
        }
      }

      this._addedHook && this._addedHook();
      this.eachGraphic(function (graphic) {
        graphic._map = map;
      }, this);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.zIndex)) {
        this.zIndex = this.options.zIndex;
      }

      this.fire(EventType.addLayer, {
        layer: this
      }, true);
    }
    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onRemove",
    value: function _onRemove() {
      if (this._state == State.REMOVED) {
        return;
      }

      if (!this._map) {
        return;
      }

      this.eachGraphic(function (graphic) {
        graphic._map = null;
      }, this);
      this._cacheUuid = {};
      this._cacheId = {};

      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);
      }

      if (this._primitiveCollection) {
        this._map.scene.primitives.remove(this._primitiveCollection);
      }

      if (this._labelCollection) {
        this._map.scene.primitives.remove(this._labelCollection);
      }

      if (this._billboardCollection) {
        this._map.scene.primitives.remove(this._billboardCollection);
      }

      if (this._pointCollection) {
        this._map.scene.primitives.remove(this._pointCollection);
      }

      if (this._polylineCollection) {
        this._map.scene.primitives.remove(this._polylineCollection);
      }

      if (this._container && this._container.parentNode) {
        this._map.container.removeChild(this._container);
      } //自动释放时


      if (this._map.scene.primitives.destroyPrimitives) {
        this.clear();
        this._primitiveCollection = null;
        this._labelCollection = null;
        this._billboardCollection = null;
        this._pointCollection = null;
        this._polylineCollection = null;
      }

      this._removedHook && this._removedHook();
      this._state = State.REMOVED;
      this.fire(EventType.removeLayer, {
        layer: this
      }, true);

      if (this.options && !this.options.stopPropagation) {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }
  }, {
    key: "_showHook",
    value: function _showHook(show) {
      get_default()(getPrototypeOf_default()(GraphicLayer.prototype), "_showHook", this).call(this, show);

      if (show) {
        if (this._container) {
          this._container.style.display = "block";
          this.eachGraphic(function (graphic) {
            graphic.updateDivPosition && graphic.updateDivPosition();
          }, this);
        }
      } else {
        if (this._container) {
          this._container.style.display = "none";
        }

        this.stopDraw();
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      get_default()(getPrototypeOf_default()(GraphicLayer.prototype), "_mountedHook", this).call(this);

      this.on(EventType.drawCreated, function (e) {
        setTimeout(function () {
          if (_this2.isContinued) {
            //连续标绘时
            _this2.stopDraw();

            _this2.startDraw(Object(Util["clone"])(e.graphic.options));
          } else if (_this2.hasEdit && _this2.isAutoEditing) {
            //创建完成后激活编辑
            _this2.startEditing(e.graphic);
          }
        }, 50);
      }, this);
      this.on(EventType.load, function (e) {
        if (_this2.hasEdit && _this2.isAutoEditing && _this2.lastEditGraphic == e.graphic) {
          _this2.startEditing(e.graphic); //模型加载完成后更新编辑

        }
      }, this);

      if (this.options.clustering) {
        this._bindClustering(this.options.clustering);
      }

      if (this.options.data && this.type == "graphic") {
        this.addGraphic(this.options.data);
      }

      if (this.options.geojson) {
        this.loadGeoJSON(this.options.geojson);
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(GraphicLayer.prototype), "_addedHook", this).call(this);

      if (this._hasEdit) {
        this._bindEditEvent();
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(GraphicLayer.prototype), "_removedHook", this).call(this);

      if (this._hasEdit) {
        this.stopDraw();

        this._unbindEditEvent();
      }
    } //飞行定位至图层数据所在的视角

  }, {
    key: "flyTo",
    value: function flyTo(options) {
      if (!this._map) {
        return;
      }

      if (this.options.center) {
        this._map.setCameraView(this.options.center, options);
      } else if (this.options.extent) {
        this._map.flyToExtent(this.options.extent, options);
      } else if (this.options.onCenterAt) {
        this.options.onCenterAt(options);
      } else {
        var arr = this.getGraphics();

        this._map.flyToGraphic(arr, options);
      }

      return this;
    } //是否为编辑的拖拽点

  }, {
    key: "isEditDraggerPoint",
    value: function isEditDraggerPoint(graphic) {
      return graphic._isDragger && graphic instanceof PointPrimitive_PointPrimitive;
    }
    /**
     * 将图层数据导出为GeoJSON格式规范对象。
     * @return {Object} GeoJSON格式规范对象
     */

  }, {
    key: "toGeoJSON",
    value: function toGeoJSON() {
      var _this3 = this;

      this.stopEditing();
      var features = [];
      this.eachGraphic(function (graphic) {
        if (_this3.isEditDraggerPoint(graphic)) {
          return;
        }

        var geojson = graphic.toGeoJSON();

        if (!geojson) {
          return;
        }

        features.push(geojson);
      }, this);
      return {
        type: "FeatureCollection",
        layer: {
          id: this.id,
          name: this.name
        },
        features: features
      };
    } //转为json的额外需要处理的对象

  }, {
    key: "_toJsonEx",
    value: function _toJsonEx(newData) {
      var _this4 = this;

      this.stopEditing();
      var arr = [];
      this.eachGraphic(function (graphic) {
        if (_this4.isEditDraggerPoint(graphic) || !graphic.state) {
          return;
        }

        var geojson = graphic.toJSON();

        if (!geojson) {
          return;
        }

        arr.push(geojson);
      }, this);
      newData.data = arr;
    }
    /**
     * 加载转换GeoJSON格式规范数据为Graphic后加载到图层中。
     *
     * @param {String|Object} geojson GeoJSON格式规范数据
     * @param {Object} [options] 加载控制参数,包含：
     * @param {Boolean} [options.clear=false] 是否清除图层已有数据
     * @param {Boolean} [options.flyTo=false] 是否加载完成后进行飞行到数据区域
     * @param {Object} [options.style] 可以设置指定style样式
     * @return {BaseGraphic[]} 转换后的Graphic对象数组
     *
     */

  }, {
    key: "loadGeoJSON",
    value: function loadGeoJSON(geojson) {
      var _this$options$symbol;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      try {
        if (Object(Util["isString"])(geojson)) {
          geojson = JSON.parse(geojson);
        }
      } catch (e) {
        Object(Log["logError"])("loadGeoJSON:请确认json文件格式正确!", e);
        return;
      }

      if (options.clear) {
        this.clear();
      }

      var arr = Object(Util["geoJsonToGraphics"])(geojson, GraphicLayer_objectSpread({
        symbol: this.options.symbol,
        crs: this.options.crs,
        hasEdit: this.hasEdit
      }, options));
      var arrthis = [];
      var type = (_this$options$symbol = this.options.symbol) === null || _this$options$symbol === void 0 ? void 0 : _this$options$symbol.type;
      var defaultOptions = this.options.graphicOptions || {};

      if (type && type.indexOf("Combine") !== -1) {
        var graphic = this._addGraphic(GraphicLayer_objectSpread(GraphicLayer_objectSpread({}, defaultOptions), {}, {
          type: type,
          instances: arr
        }));

        arrthis.push(graphic);
      } else {
        for (var i = 0, len = arr.length; i < len; i++) {
          var graphicOptions = GraphicLayer_objectSpread(GraphicLayer_objectSpread({}, defaultOptions), arr[i]);

          if (this.options.onCreateGraphic) {
            var _graphic = this.options.onCreateGraphic(graphicOptions);

            if (_graphic) {
              this.addGraphic(_graphic);

              if (Array.isArray(_graphic)) {
                arrthis = arrthis.concat(_graphic);
              } else {
                arrthis.push(_graphic);
              }
            }
          } else {
            var _graphic2 = this._addGraphic(graphicOptions);

            arrthis.push(_graphic2);
          }
        }
      }

      if (options.flyTo && this.show) {
        this._map.flyToGraphic(arrthis);
      }

      return arrthis;
    } //聚合处理

  }, {
    key: "_bindClustering",
    value: function _bindClustering() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var clustering = this.dataSource.clustering;
      clustering.enabled = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.enabled, false);
      clustering.pixelRange = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.pixelRange, 20); //多少像素矩形范围内聚合
      //一些属性

      var heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND);

      if (options.clampToGround) {
        heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND;
      }

      var timeTik = setInterval(function () {
        if (clustering._cluster) {
          clustering._cluster();
        }
      }, 800);
      clustering.clusterEvent.addEventListener(function (clusteredEntities, cluster) {
        if (timeTik) {
          clearInterval(timeTik);
          timeTik = null;
        }

        cluster.label._tudou3d_layerId = _this5.uuid;
        cluster.billboard._tudou3d_layerId = _this5.uuid;
        cluster.point._tudou3d_layerId = _this5.uuid;
        cluster.label.show = false;
        cluster.billboard.show = true;
        cluster.billboard.id = cluster.label.id;
        cluster.billboard.verticalOrigin = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM;
        cluster.billboard.heightReference = heightReference; //贴地

        cluster.billboard.scale = 0.5; //必须，解决数字文本锯齿

        if (options.getImage) {
          cluster.billboard.image = options.getImage(clusteredEntities.length, options);
        } else {
          cluster.billboard.image = Object(Util["getCircleImage"])(clusteredEntities.length, options);
        }
      });
    } // /**
    //  * 设置透明度
    //  *
    //  * @param {Number} value 透明度
    //  * @return {void}  无
    //  */
    // setOpacity(value) {
    //   this._opacity = value
    //   this.eachGraphic((graphic) => {
    //     if (graphic.setOpacity) {
    //       graphic.setOpacity(value)
    //     }
    //   }, this)
    // }
    //==================以下是对graphic矢量数据的管理=========================

    /**
     * 添加Graphic矢量数据
     *
     * @param {BaseGraphic|BaseGraphic[]} graphic 矢量数据
     * @return {BaseGraphic|BaseGraphic[]} 添加后的Graphic对象
     */

  }, {
    key: "addGraphic",
    value: function addGraphic(graphic) {
      var _this6 = this;

      if (!this._createOK && this._mountedHook) {
        this._createOK = true;

        this._mountedHook();
      }

      if (Array.isArray(graphic)) {
        var arr = [];
        graphic.forEach(function (item) {
          var result = _this6._addGraphic(item);

          if (result) {
            arr.push(result);
          }
        });
        return arr;
      } else {
        return this._addGraphic(graphic);
      }
    } //内部添加Grphic

  }, {
    key: "_addGraphic",
    value: function _addGraphic(graphic) {
      if (!graphic._onAdd && graphic.type) {
        graphic = Object(GraphicUtil["create"])(graphic.type, graphic);
      }

      if (graphic && !this._cacheUuid.hasOwnProperty(graphic.uuid)) {
        graphic._onAdd(this);

        this._cacheUuid[graphic.uuid] = graphic;
        this._cacheId[graphic.id] = graphic;
      }

      return graphic;
    }
    /**
     * 移除Graphic矢量数据
     *
     * @param {BaseGraphic} graphic 矢量数据
     * @param {Boolean} [hasDestory=false] 是否释放矢量对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeGraphic",
    value: function removeGraphic(graphic, hasDestory) {
      this._removeGraphic(graphic, hasDestory);

      return this;
    } //内部移除Grphic

  }, {
    key: "_removeGraphic",
    value: function _removeGraphic(graphic, hasDestory) {
      if (!graphic || !graphic._onRemove) {
        return this;
      }

      delete this._cacheUuid[graphic.uuid];
      delete this._cacheId[graphic.id];

      graphic._onRemove();

      if (hasDestory) {
        graphic.destroy();
      }
    }
    /**
     * 根据id或uuid取矢量数据对象
     *
     * @param {String|Number} id  矢量数据id或uuid
     * @return {BaseGraphic} 矢量数据对象
     */

  }, {
    key: "getGraphicById",
    value: function getGraphicById(id) {
      if (this._cacheUuid[id]) {
        //为uuid时
        return this._cacheUuid[id];
      }

      if (this._cacheId[id]) {
        //为id时
        return this._cacheId[id];
      }

      var keys = Object.keys(this._cacheUuid);

      for (var i = 0, len = keys.length; i < len; i++) {
        var graphic = this._cacheUuid[keys[i]];

        if (id == graphic.id) {
          return graphic;
        }
      }

      return undefined;
    }
    /**
     * 根据 指定属性 获取 单个矢量数据对象（多个匹配时取首个）
     *
     * @param {Object|String|Number} attrName 属性名称值（如id、name等）
     * @param {String} attrVal 属性值
     * @return {BaseGraphic} 矢量数据对象
     */

  }, {
    key: "getGraphicByAttr",
    value: function getGraphicByAttr(attrName, attrVal) {
      var result = this.getGraphicsByAttr(attrName, attrVal);

      if ((result === null || result === void 0 ? void 0 : result.length) > 0) {
        return result[0];
      } else {
        return null;
      }
    }
    /**
     * 根据 指定属性 获取  矢量数据对象 数组
     *
     * @param {Object|String|Number} attrName 属性名称值（如id、name等）
     * @param {String} attrVal 属性值
     * @return {BaseGraphic[]} 矢量数据对象
     */

  }, {
    key: "getGraphicsByAttr",
    value: function getGraphicsByAttr(attrName, attrVal) {
      var result = [];
      this.eachGraphic(function (graphic) {
        if (graphic[attrName] == attrVal || graphic.attr[attrName] == attrVal) {
          result.push(graphic);
        }
      }, this);
      return result;
    }
    /**
     * 遍历所有矢量数据并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachGraphic",
    value: function eachGraphic(method, context) {
      var _this7 = this;

      if (!this._cacheUuid) {
        return;
      }

      Object.keys(this._cacheUuid).forEach(function (key, index) {
        method && method.call(context || _this7, _this7._cacheUuid[key], index);
      });
      return this;
    }
    /**
     * 获取图层内 所有矢量数据
     *
     * @return {BaseGraphic[]} 矢量数据数组
     */

  }, {
    key: "getGraphics",
    value: function getGraphics() {
      var _this8 = this;

      var result = [];

      if (this._cacheUuid) {
        Object.keys(this._cacheUuid).forEach(function (key) {
          var graphic = _this8._cacheUuid[key];

          if (_this8.isEditDraggerPoint(graphic)) {
            return;
          }

          result.push(graphic);
        });
      }

      return result;
    }
    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestory=false] 是否释放矢量对象
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear(hasDestory) {
      var _this9 = this;

      this.stopDraw();
      this.eachGraphic(function (graphic) {
        _this9._removeGraphic(graphic, hasDestory);
      }, this);
      this._cacheUuid = {};
      this._cacheId = {};

      if (this._dataSource) {
        this._dataSource.entities.removeAll();
      }

      if (this._primitiveCollection) {
        this._primitiveCollection.removeAll();
      }

      if (this._labelCollection) {
        this._labelCollection.removeAll();
      }

      if (this._billboardCollection) {
        this._billboardCollection.removeAll();
      }

      if (this._pointCollection) {
        this._pointCollection.removeAll();
      }

      if (this._polylineCollection) {
        this._polylineCollection.removeAll();
      }

      this._closeAllControl();
    }
    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude=null]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Function} options.callback  异步计算高度完成后 的回调方法
     * @param {Function} options.endItem  异步计算高度完成后 的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var graphics = this.getGraphics();
      var index = -1;
      var len = graphics.length;

      function getLineFD() {
        index++;

        if (index >= len) {
          if (options.callback) {
            options.callback(index, len);
          }

          return;
        }

        if (options.endItem) {
          options.endItem(index, len);
        }

        var graphic = graphics[index];

        if (graphic.clampToGround) {
          graphic.clampToGround(GraphicLayer_objectSpread(GraphicLayer_objectSpread({}, options), {}, {
            callback: function callback() {
              getLineFD();
            }
          }));
        } else {
          getLineFD();
        }
      }

      getLineFD();
      return this;
    } //==================绘制及编辑=======================

    /**
     * 开始绘制矢量数据，绘制的数据会加载在当前图层。
     *
     * @param {Object} options Graphic构造参数,包含：
     * @param {GraphicType} options.type 类型
     * @param {Object} [options.其他] 按type支持 {@link GraphicType} 类的构造方法参数
     * @param {Function} [options.success] 绘制创建完成的回调方法，同drawCreated事件，例如： success: function (graphic){  }
     * @return {BaseGraphic} 创建完成的矢量数据对象
     */

  }, {
    key: "startDraw",
    value: function startDraw(options) {
      this.stopDraw();

      if (!this._map) {
        throw new Error("startDraw:需要 map.addLayer(当前图层) 后，才行使用本方法");
      }

      var graphic = Object(GraphicUtil["fromDraw"])(this, options);

      if (graphic == null) {
        return;
      }

      this._graphic_drawing = graphic;
      return graphic;
    }
    /**
     * 停止绘制，如有未完成的绘制会自动删除
     *
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      this.stopEditing();

      if (this._graphic_drawing && this._graphic_drawing._enabledDraw) {
        //说明有未完成编辑的对象
        this._graphic_drawing.stopDraw();

        this._graphic_drawing = null;
      }

      return this;
    }
    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     *
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      this.stopEditing();

      if (this._graphic_drawing && this._graphic_drawing._enabledDraw) {
        //说明有未完成编辑的对象
        this._graphic_drawing.endDraw();

        this._graphic_drawing = null;
      }

      return this;
    }
    /**
     * 激活编辑，绑定相关处理，同 hasEdit=true
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "activateEdit",
    value: function activateEdit() {
      if (this._hasEdit) {
        return;
      }

      this._hasEdit = true;

      if (this._map) {
        this._bindEditEvent();
      }

      return this;
    }
    /**
     * 释放编辑，解除绑定相关事件，同 hasEdit=false
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "disableEdit",
    value: function disableEdit() {
      if (!this._hasEdit) {
        return;
      }

      this._hasEdit = false;

      this._unbindEditEvent();

      this.stopEditing();
      return this;
    }
  }, {
    key: "_bindEditEvent",
    value: function _bindEditEvent() {
      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.mouseMoveTarget, this._onMouseMoveHandler, this);
    }
  }, {
    key: "_unbindEditEvent",
    value: function _unbindEditEvent() {
      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.mouseMoveTarget, this._onMouseMoveHandler, this);
    }
  }, {
    key: "_onMouseMoveHandler",
    value: function _onMouseMoveHandler(event) {
      //无法编辑时，跳出
      if (!this._hasEdit) {
        return;
      } //正在拖拽其他的entity时，跳出


      if (!this._map.scene.screenSpaceCameraController.enableInputs) {
        return;
      }

      var result = this._map.mouseEvent.getPickTarget(event.endPosition);

      var graphic = result === null || result === void 0 ? void 0 : result.graphic;

      if (graphic == null || result.layer != this || !graphic.EditClass) {
        this._map.closeSmallTooltip();

        return;
      } //正在绘制本身时 或 是拖拽点时，跳出


      if (graphic._enabledDraw || graphic._isDragger) {
        return;
      } //右键菜单打开了，跳出


      if (this._map.contextmenu.show && this._map.contextmenu.target == graphic) {
        return;
      } //不允许编辑时


      if (!graphic.hasEdit) {
        // this._map.openSmallTooltip(event.windowPosition, this._map.getLangText('_该对象不允许编辑'))
        return;
      }

      this._map.openSmallTooltip(event.windowPosition, this._map.getLangText("_激活编辑提示"));
    }
  }, {
    key: "_onClickHandler",
    value: function _onClickHandler(event) {
      var graphic = event.graphic;

      if (this.hasEdit && graphic && event.layer == this && graphic.EditClass) {
        this.startEditing(graphic, event);
      } else {
        this.stopEditing();
      }
    }
    /**
     * 激活编辑指定的矢量数据
     *
     * @param {BaseGraphic} graphic 需要激活编辑的矢量数据
     * @param {Object} [event] 内部使用，传递事件
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "startEditing",
    value: function startEditing(graphic, event) {
      if (!graphic || !graphic.startEditing || !graphic.isAdded || !graphic.hasEdit) {
        return;
      }

      if (this.lastEditGraphic == graphic || graphic._enabledDraw) {
        return;
      }

      this.stopEditing();
      graphic.startEditing();
      this.closeTooltip();
      this.closePopup();

      if (event && graphic._draw_tooltip) {
        this._map.openSmallTooltip(event.position, graphic._draw_tooltip);
      }

      this.lastEditGraphic = graphic;
      return this;
    }
    /**
     * 停止编辑，释放正在编辑的对象。
     * @param {BaseGraphic} [graphic] 需要停止编辑的矢量数据，默认为上一次正在编辑的对象
     *
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "stopEditing",
    value: function stopEditing(graphic) {
      if (graphic) {
        graphic.stopEditing();
      }

      if (!this.lastEditGraphic) {
        return;
      }

      this.lastEditGraphic.stopEditing();
      this.lastEditGraphic = null;
      return this;
    }
  }]);

  return GraphicLayer;
}(BaseGraphicLayer_BaseGraphicLayer); //注册下

Object(LayerUtil["register"])("graphic", GraphicLayer_GraphicLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/GraphicGroupLayer.js








function GraphicGroupLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GraphicGroupLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GraphicGroupLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GraphicGroupLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GraphicGroupLayer_createSuper(Derived) { var hasNativeReflectConstruct = GraphicGroupLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GraphicGroupLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 矢量数据图层组，主要用于 多图层的标绘
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 图层id标识
 * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
 * @param {String} [options.name = '未命名'] 图层名称
 * @param {Boolean} [options.show = true] 图层是否显示
 * @param {Object} [options.center] 图层自定义定位视角
 * @param {GraphicLayer[]} [options.layers] 子图层数组，每个子图层的配置见按各类型图层配置即可。
 *
 *
 * @export
 * @class GraphicGroupLayer
 * @extends {GroupLayer}
 */

var GraphicGroupLayer_GraphicGroupLayer = /*#__PURE__*/function (_GroupLayer) {
  inherits_default()(GraphicGroupLayer, _GroupLayer);

  var _super = GraphicGroupLayer_createSuper(GraphicGroupLayer);

  function GraphicGroupLayer() {
    classCallCheck_default()(this, GraphicGroupLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GraphicGroupLayer, [{
    key: "hasEdit",
    get:
    /**
     * 是否可以编辑
     *
     * @type {Boolean}
     * @readonly
     */
    function get() {
      return this._hasEdit;
    },
    set: function set(val) {
      this._hasEdit = val;

      if (this._selectedLayer) {
        if (val) {
          this._selectedLayer.activateEdit();
        } else {
          this._selectedLayer.disableEdit();
        }
      }
    }
    /**
     * 当前激活的图层
     * @type {GraphicLayer}
     */

  }, {
    key: "selectedLayer",
    get: function get() {
      return this._selectedLayer;
    },
    set: function set(layer) {
      if (this._selectedLayer) {
        //上一次的取消激活状态
        delete this._selectedLayer.isActivate;

        this._selectedLayer.disableEdit();
      }

      if (!(layer instanceof GraphicLayer_GraphicLayer)) {
        layer = this.getLayer(layer);
      }

      this._selectedLayer = layer;

      if (this._selectedLayer) {
        //本次的标记为激活状态
        this._selectedLayer.isActivate = true;

        if (this._hasEdit) {
          this._selectedLayer.activateEdit();
        }
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      get_default()(getPrototypeOf_default()(GraphicGroupLayer.prototype), "_mountedHook", this).call(this);

      if (this.options.geojson) {
        this.loadGeoJSON(this.options.geojson);
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(GraphicGroupLayer.prototype), "_addedHook", this).call(this);

      this._processForRemoveLayer();
    } //新增或获取已有分组

  }, {
    key: "_getOrCreateLayer",
    value: function _getOrCreateLayer(name) {
      if (!name) {
        return this.selectedLayer;
      }

      var layer = this.getLayer(name);

      if (layer) {
        return layer;
      } else {
        return this.createLayer(name);
      }
    }
    /**
     * 创建并添加指定名称的图层
     *
     * @param {String} name 图层名称
     * @return {GraphicLayer} 创建完成的图层
     */

  }, {
    key: "createLayer",
    value: function createLayer(name) {
      var layerOptions = Object(Util["clone"])(this.options, ["id", "uuid", "pid", "geojson", "data"]);
      layerOptions.name = name;
      layerOptions.pid = this.id; //创建图层

      var graphicLayer = new GraphicLayer_GraphicLayer(layerOptions);

      if (this._events) {
        graphicLayer._events = GraphicGroupLayer_objectSpread({}, this._events);
      }

      this._map.addLayer(graphicLayer);

      this.addLayer(graphicLayer);
      return graphicLayer;
    }
    /**
     * 删除指定名称的图层
     *
     * @param {String} name 图层名称
     * @return {Boolean} 是否删除成功
     */

  }, {
    key: "deleteLayer",
    value: function deleteLayer(name) {
      var layer;

      if (name instanceof GraphicLayer_GraphicLayer) {
        layer = name;
      } else {
        layer = this.getLayer(name);
      }

      if (layer) {
        if (this.selectedLayer == layer) {
          this.selectedLayer = null;
        }

        Object(Util["removeArrayItem"])(this._arrLayer, layer);

        this._map.removeLayer(layer, true);

        this._processForRemoveLayer();

        return true;
      } else {
        return false;
      }
    }
    /**
     * 删除所有没有数据的矢量图层
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "deleteEmptyLayer",
    value: function deleteEmptyLayer() {
      for (var i = this._arrLayer.length - 1; i >= 0; i--) {
        var layer = this._arrLayer[i];

        if (layer.length == 0) {
          if (this.selectedLayer == layer) {
            this.selectedLayer = null;
          }

          this._arrLayer.splice(i, 1);

          this._map.removeLayer(layer, true);
        }
      }

      this._processForRemoveLayer();

      return this;
    } //删除分组后的对默认图层和激活图层的特殊处理

  }, {
    key: "_processForRemoveLayer",
    value: function _processForRemoveLayer() {
      if (this._arrLayer.length == 0 && this.options.defaultLayer) {
        //如果有指定默认图层，自动加个图层
        this.selectedLayer = this.createLayer(this.options.defaultLayer);
      }

      if (this.selectedLayer == null && this._arrLayer.length > 0) {
        //再次激活第1个图层
        this.selectedLayer = this._arrLayer[0];
      }
    } //==========================Graphic===========================

    /**
     *  移动矢量对象到新分组
     *
     * @param {BaseGraphic} graphic  矢量对象
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */

  }, {
    key: "moveToLayer",
    value: function moveToLayer(graphic, layer) {
      if (!(layer instanceof GraphicLayer_GraphicLayer)) {
        layer = this.getLayer(layer);
      }

      graphic.remove(); //从原有的集合中删除

      layer.addGraphic(graphic); //加入到draw集合图层中
    }
    /**
     * 获取图层内 所有矢量数据
     * @return {BaseGraphic[]} 矢量数据数组
     */

  }, {
    key: "getGraphics",
    value: function getGraphics() {
      var result = [];
      this.eachGraphic(function (graphic, layer) {
        result.push(graphic);
      }, this);
      return result;
    }
    /**
     * 根据id或uuid取矢量数据对象
     *
     * @param {String|Number} id  矢量数据id或uuid
     * @return {BaseGraphic} 矢量数据对象
     */

  }, {
    key: "getGraphicById",
    value: function getGraphicById(id) {
      if (!id) {
        return undefined;
      }

      for (var i = this._arrLayer.length - 1; i >= 0; i--) {
        var layer = this._arrLayer[i];
        var graphic = layer.getGraphicById(id);

        if (graphic) {
          return graphic;
        }
      }

      return undefined;
    }
    /**
     * 遍历所有矢量数据并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachGraphic",
    value: function eachGraphic(method, context) {
      this.eachLayer(function (layer) {
        layer.eachGraphic(method, context);
      }, this);
      return this;
    }
    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestory=false] 是否释放矢量对象
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear(hasDestory) {
      this.eachLayer(function (layer) {
        layer.clear(hasDestory);
      }, this);
    }
    /**
     * 将图层数据导出为GeoJSON格式规范对象。
     * @return {Object} GeoJSON格式规范对象
     */

  }, {
    key: "toGeoJSON",
    value: function toGeoJSON() {
      var _this = this;

      this.stopDraw();
      var features = [];
      var layerNames = [];
      this.eachLayer(function (layer) {
        layerNames.push(layer.name);
        layer.eachGraphic(function (graphic) {
          var feature = graphic.toGeoJSON();
          feature.properties._layer = layer.name; //记录分组信息

          features.push(feature);
        }, _this);
      }, this);
      return {
        type: "FeatureCollection",
        layer: {
          id: this.id,
          name: this.name,
          layers: layerNames,
          selected: this.selectedLayer.name
        },
        features: features
      };
    }
    /**
     * 加载转换GeoJSON格式规范数据为Graphic后加载到图层中。
     *
     * @param {String|Object} geojson GeoJSON格式规范数据
     * @param {Object} [options] 加载控制参数,包含：
     * @param {Boolean} [options.clear=false] 是否清除图层已有数据
     * @param {Boolean} [options.flyTo=false] 是否加载完成后进行飞行到数据区域
     * @param {Object} [options.style] 可以设置指定style样式
     * @param {String} [options.layer] 指定导入所有数据到指定的图层
     * @return {BaseGraphic[]} 转换后的Graphic对象数组
     */

  }, {
    key: "loadGeoJSON",
    value: function loadGeoJSON(geojson) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      try {
        if (Object(Util["isString"])(geojson)) {
          geojson = JSON.parse(geojson);
        }
      } catch (e) {
        Object(Util["alert"])(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
        return;
      }

      if (options.clear) {
        this.clear(true);
      } //存在分组信息


      var fixedLayer;

      if (options.layer) {
        fixedLayer = this.getLayer(options.layer);
      } else {
        var _geojson, _geojson$layer;

        var objLayer = {};
        var layerNames = (_geojson = geojson) === null || _geojson === void 0 ? void 0 : (_geojson$layer = _geojson.layer) === null || _geojson$layer === void 0 ? void 0 : _geojson$layer.layers;

        if (layerNames) {
          var _geojson2, _geojson2$layer;

          for (var k = 0; k < layerNames.length; k++) {
            var layer = this._getOrCreateLayer(layerNames[k]);

            objLayer[layerNames[k]] = layer;
          }

          if ((_geojson2 = geojson) !== null && _geojson2 !== void 0 && (_geojson2$layer = _geojson2.layer) !== null && _geojson2$layer !== void 0 && _geojson2$layer.selected) {
            var _geojson3, _geojson3$layer;

            var slayer = objLayer[(_geojson3 = geojson) === null || _geojson3 === void 0 ? void 0 : (_geojson3$layer = _geojson3.layer) === null || _geojson3$layer === void 0 ? void 0 : _geojson3$layer.selected];

            if (slayer) {
              this.selectedLayer = slayer;
            }
          }
        }
      }

      var features = Object(Util["getGeoJsonFeatures"])(geojson);
      var arrthis = [];

      for (var i = 0, len = features.length; i < len; i++) {
        var feature = features[i];

        var _layer = void 0;

        if (fixedLayer) {
          _layer = fixedLayer;
        } else {
          var layerName = feature.properties._layer;
          _layer = layerName ? this.getLayer(layerName) : null;

          if (!_layer) {
            _layer = this.selectedLayer;
          }
        }

        var arr = _layer.loadGeoJSON(feature, GraphicGroupLayer_objectSpread(GraphicGroupLayer_objectSpread({}, options), {}, {
          clear: false,
          flyTo: false
        }));

        arrthis = arrthis.concat(arr);
      }

      if (options.flyTo) {
        this._map.flyToGraphic(arrthis);
      }

      return arrthis;
    } //转为json的额外需要处理的对象

  }, {
    key: "_toJsonEx",
    value: function _toJsonEx(newData) {
      newData.geojson = this.toGeoJSON();
    } //==================绘制及编辑=======================

    /**
     * 开始绘制矢量数据，绘制的数据会加载在当前图层。
     *
     * @param {Object} options Graphic构造参数,包含：
     * @param {GraphicType} options.type 类型
     * @param {Object} [options.其他] 按type支持{@link GraphicType}类的构造方法参数
     * @return {BaseGraphic} 创建完成的矢量数据对象
     */

  }, {
    key: "startDraw",
    value: function startDraw(options) {
      return this._selectedLayer.startDraw(options);
    }
    /**
     * 停止绘制，如有未完成的绘制会自动删除
     *
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      return this._selectedLayer.stopDraw();
    }
    /**
     * 激活编辑，绑定相关处理，同 hasEdit=true
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "activateEdit",
    value: function activateEdit() {
      return this._selectedLayer.activateEdit();
    }
    /**
     * 释放编辑，解除绑定相关事件，同 hasEdit=false
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "disableEdit",
    value: function disableEdit() {
      return this._selectedLayer.disableEdit();
    }
  }]);

  return GraphicGroupLayer;
}(GroupLayer_GroupLayer); //注册下

Object(LayerUtil["register"])("graphicGroup", GraphicGroupLayer_GraphicGroupLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/DivLayer.js







function DivLayer_createSuper(Derived) { var hasNativeReflectConstruct = DivLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DivLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * DIV图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Boolean} [options.hasEdit=false] 是否可编辑
 * @param {Boolean} [options.isAutoEditing=true] 完成标绘时是否自动启动编辑(需要hasEdit:true时)
 * @param {Boolean} [options.isContinued=false] 是否连续标绘
 * @param {Object|Object[]} [options.data=null] 需要自动加载的数据，内部自动生成Graphic对象。{@link GraphicUtil#.create}
 * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
 *
 * @export
 * @class DivLayer
 * @extends {GraphicLayer}
 *
 * @see [支持的事件类型]{@link GraphicLayer.EventType}
 */

var DivLayer_DivLayer = /*#__PURE__*/function (_GraphicLayer) {
  inherits_default()(DivLayer, _GraphicLayer);

  var _super = DivLayer_createSuper(DivLayer);

  function DivLayer() {
    classCallCheck_default()(this, DivLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(DivLayer, [{
    key: "container",
    get:
    /**
     * 容纳 {@link DivGraphic} 数据的DOM容器
     * @type {Element}
     * @readonly
     */
    function get() {
      return this._container;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      if (!this._container) {
        this._container = create("div", "tudou3d-divlayer");
      }

      this.pointerEvents = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.pointerEvents, true);
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      if (this._container) {
        this._map.container.appendChild(this._container);
      }

      get_default()(getPrototypeOf_default()(DivLayer.prototype), "_addedHook", this).call(this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(DivLayer.prototype), "_removedHook", this).call(this);

      if (this._container && this._container.parentNode) {
        this._map.container.removeChild(this._container);
      }
    } //==================绘制及编辑=======================

  }, {
    key: "_bindEditEvent",
    value: function _bindEditEvent() {
      this._map.on(EventType.click, this._onClickHandler, this);

      this.on(EventType.mouseOver, this._onMouseOverHandler, this);
      this.on(EventType.mouseOut, this._onMouseOutHandler, this);
    }
  }, {
    key: "_unbindEditEvent",
    value: function _unbindEditEvent() {
      this._map.off(EventType.click, this._onClickHandler, this);

      this.off(EventType.mouseOver, this._onMouseOverHandler, this);
      this.off(EventType.mouseOut, this._onMouseOutHandler, this);
    }
  }, {
    key: "_onClickHandler",
    value: function _onClickHandler(event) {
      var graphic = event.graphic;

      if (graphic && event.layer == this) {
        this.startEditing(graphic, event);
      } else {
        this.stopEditing();
      }
    }
  }, {
    key: "_onMouseOverHandler",
    value: function _onMouseOverHandler(event) {
      this._map.openSmallTooltip({
        x: event.clientX,
        y: event.clientY
      }, "单击后 激活编辑");
    }
  }, {
    key: "_onMouseOutHandler",
    value: function _onMouseOutHandler(event) {
      this._map.closeSmallTooltip();
    }
  }]);

  return DivLayer;
}(GraphicLayer_GraphicLayer); //注册下

Object(LayerUtil["register"])("div", DivLayer_DivLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/GeoJsonLayer.js








function GeoJsonLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GeoJsonLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GeoJsonLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GeoJsonLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GeoJsonLayer_createSuper(Derived) { var hasNativeReflectConstruct = GeoJsonLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GeoJsonLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * @typedef {Object} GeoJsonLayer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphicLayer.EventType} 通用 支持的base父类的事件类型
 * @property {GraphicLayer.EventType} 通用 支持的父类的事件类型
 * @property {String} load 完成加载，执行所有内部处理后
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.load, function (event) {
 *   console.log('矢量数据对象加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 加载展示 GeoJSON数据 的图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {String} [options.url] SDK标绘生产的geojson文件或服务url地址
 * @param {Object} [options.data] SDK标绘生产的geojson格式规范数据对象，与url二选一即可。
 * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857'
 * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
 * @param {Function} [options.onCreateGraphic] 解析geojson后，外部自定义方法来创建Graphic对象
 *
 * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
 * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
 * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
 * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
 *
 * @param {Object} [options.graphicOptions] 默认的graphic的构造参数，每种不同类型数据都有不同的属性，具体见各{@link GraphicType}矢量数据的构造参数。
 *
 * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
 * @param {GraphicType} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
 * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各{@link GraphicType}矢量数据的style参数。
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 *
 * @param {Object} [options.dth] 标识当前图层为单体化类型数据
 * @param {String} [options.dth.type='mouseMove'] 标识是鼠标移入还是单击进行展示单体化面 , 可选值： 'click'、'mouseMove'
 * @param {String} [options.dth.color='#ffff00'] 单体化面的颜色
 * @param {Number} [options.dth.opacity=0.3] 单体化面的透明度
 * @param {Number} [options.dth.buffer] 缓冲扩大面的范围（单位：米）
 * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
 * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
 * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
 * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
 *
 * @param {Boolean|Object} [options.mask] 标识是否绘制区域边界的反选遮罩层
 *
 * @export
 * @class GeoJsonLayer
 * @extends {GraphicLayer}
 * @see [支持的事件类型]{@link GeoJsonLayer.EventType}
 */

var GeoJsonLayer_GeoJsonLayer = /*#__PURE__*/function (_GraphicLayer) {
  inherits_default()(GeoJsonLayer, _GraphicLayer);

  var _super = GeoJsonLayer_createSuper(GeoJsonLayer);

  function GeoJsonLayer() {
    classCallCheck_default()(this, GeoJsonLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GeoJsonLayer, [{
    key: "_showHook",
    value: function _showHook(val) {
      get_default()(getPrototypeOf_default()(GeoJsonLayer.prototype), "_showHook", this).call(this, val);

      if (val && this._hasLoad) {
        this._hasLoad = false;
        this.load();
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(GeoJsonLayer.prototype), "_addedHook", this).call(this);

      if (this.show) {
        this.load();
      } else {
        this._hasLoad = true;
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(GeoJsonLayer.prototype), "_removedHook", this).call(this);

      this.clear();
    }
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions] 新设定的参数，会与类的构造参数合并。
     * @param {String} [newOptions.url] geojson文件或服务url地址
     * @param {Object} [newOptions.data] geojson格式规范数据对象，与url二选一即可。
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @param {BaseGraphicLayer.ConstructorOptions} [newOptions.通用参数] 包含父类支持的所有参数
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "load",
    value: function load(newOptions) {
      var _this = this;

      if (newOptions) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](newOptions.clear, true)) {
          delete this.options.url;
          delete this.options.data;
        }

        this.clear();
        this.options = GeoJsonLayer_objectSpread(GeoJsonLayer_objectSpread({}, this.options), newOptions);
      }

      if (this.options.url) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(this.options).then(function (data) {
          if (_this._state !== State.ADDED) {
            return;
          }

          _this._load_data(data);
        })["catch"](function (error) {
          this.showError("服务出错", error);
        });
      } else if (this.options.data) {
        this._load_data(this.options.data);
      } else {
        if (newOptions) {
          Object(Log["logWarn"])("GeoJsonLayer：没有传入 url 或 data 参数,请确认是否有误。");
        }
      }
    } //geojson转换为图层的矢量数据对象

  }, {
    key: "_load_data",
    value: function _load_data(geojson) {
      var _this$options$dth;

      if (this.options.format) {
        geojson = this.options.format(geojson);
      }

      var arr = this.loadGeoJSON(geojson, {
        clear: true,
        buffer: ((_this$options$dth = this.options.dth) === null || _this$options$dth === void 0 ? void 0 : _this$options$dth.buffer) || 0
      });
      var listAttr = [];
      arr.forEach(function (graphic) {
        listAttr.push(GeoJsonLayer_objectSpread(GeoJsonLayer_objectSpread({}, graphic.attr), {}, {
          graphic: graphic
        }));
      });
      this.fire(EventType.load, {
        geojson: geojson,
        list: listAttr,
        graphics: arr
      });

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }
    }
  }]);

  return GeoJsonLayer;
}(GraphicLayer_GraphicLayer); //注册下

Object(LayerUtil["register"])("geojson", GeoJsonLayer_GeoJsonLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/ModelLayer.js







function ModelLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ModelLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ModelLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ModelLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ModelLayer_createSuper(Derived) { var hasNativeReflectConstruct = ModelLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * gltf小模型图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {String} options.url 【方式1】模型的url地址
 * @param {LatLngPoint|Cesium.Cartesian3} options.position 模型所在位置坐标
 * @param {Object} options.style 模型的样式配置
 *
 * @param {Object[]} options.data 【方式2】多个模型时，可以传入data数组构造：
 * @param {String} options.data.url 模型的url地址
 * @param {LatLngPoint|Cesium.Cartesian3} options.data.position 模型所在位置坐标
 * @param {Object} options.data.style 模型的样式配置
 *
 * @param {LatLngPointp[]|Cesium.Cartesian3[]} options.positions 【方式3】多个同属性(url和style完全相同)模型时，可以直接简化，传入positions属性。
 *
 * @param {Boolean} [options.hasEdit=false] 是否可编辑
 * @param {Boolean} [options.isAutoEditing=true] 完成标绘时是否自动启动编辑(需要hasEdit:true时)
 * @param {Boolean} [options.isContinued=false] 是否连续标绘
 * @example
 *
//方式1：单个模型时，直接按下面传入position即可
let gltfLayer = new tudou3d.layer.ModelLayer({
  name: '上海浦东',
  url: 'http://data.mars3d.cn/gltf/mars/shanghai/scene.gltf',
  style: { scale: 520, heading: 215 }, //style同标绘的model类型
  position: [121.507762, 31.233975, 200],
})
map.addLayer(gltfLayer)

//方式2：多个模型时，可以传入data属性构造
let gltfLayer = new tudou3d.layer.ModelLayer({
  name: '骨骼动画',
  data: [
    {
      url: 'http://data.mars3d.cn/gltf/mars/fengche.gltf',
      position: [117.170624, 31.840666, 278.66],
      style: { scale: 200, heading: 270 },
    },
    {
      url: 'http://data.mars3d.cn/gltf/mars/firedrill/xiaofangyuan-run.gltf',
      position: [117.184442, 31.842172, 33.92],
      style: { scale: 300 },
    },
  ],
})
map.addLayer(gltfLayer)


//方式3： 多个同属性(url和style完全相同)模型时，可以直接简化，传入positions属性。
let gltfLayer = new tudou3d.layer.ModelLayer({
  name: '风力发电机',
  url: 'http://data.mars3d.cn/gltf/mars/fengche.gltf',
  style: { scale: 40, heading: 135, minimumPixelSize: 30, clampToGround: true },
  positions: [
    { lng: 112.227630577, lat: 39.0613382363999, alt: 1815 },
    { lng: 112.229302206, lat: 39.0579481036999, alt: 1827 },
    { lng: 112.226596341, lat: 39.0584773033999, alt: 1849 },
  ],
})
map.addLayer(gltfLayer)

 * @export
 * @class ModelLayer
 * @extends {GraphicLayer}
 * @see [支持的事件类型]{@link GraphicLayer.EventType}
 */

var ModelLayer_ModelLayer = /*#__PURE__*/function (_GraphicLayer) {
  inherits_default()(ModelLayer, _GraphicLayer);

  var _super = ModelLayer_createSuper(ModelLayer);

  function ModelLayer() {
    classCallCheck_default()(this, ModelLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ModelLayer, [{
    key: "layer",
    get:
    /**
     * 加载gltf模型数据的内部Cesium容器
     * @type {Cesium.CustomDataSource}
     * @readonly
     */
    function get() {
      return this.dataSource;
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      var type = "model"; //通用方式，可以传入data数组

      if (this.options.data) {
        this.options.data.forEach(function (item) {
          item.type = type;
        });
        this.addGraphic(this.options.data);
      } //单个模型时，直接传入position即可
      else if (this.options.position) {
        this.addGraphic(ModelLayer_objectSpread(ModelLayer_objectSpread({}, this.options), {}, {
          type: type
        }));
      } else if (this.options.positions) {
        //多个同属性(url和style完全相同)模型时，可以直接传入positions属性。
        var arr = [];
        this.options.positions.forEach(function (item) {
          arr.push(ModelLayer_objectSpread(ModelLayer_objectSpread({}, _this.options), {}, {
            type: type,
            position: item
          }));
        });
        this.addGraphic(arr);
      }
    }
  }]);

  return ModelLayer;
}(GraphicLayer_GraphicLayer); //注册下

Object(LayerUtil["register"])("model", ModelLayer_ModelLayer); //主要

Object(LayerUtil["register"])("gltf", ModelLayer_ModelLayer); //备用
// CONCATENATED MODULE: ./src/layer/graphicLayer/TilesetLayer.js








function TilesetLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function TilesetLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TilesetLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TilesetLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TilesetLayer_createSuper(Derived) { var hasNativeReflectConstruct = TilesetLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









/**
 * @typedef {Object} TilesetLayer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphicLayer.EventType} 通用 支持的父类的事件类型
 * @property {String} initialTilesLoaded 3dtiles模型，模型瓦片初始化完成 该回调只执行一次
 * @property {String} allTilesLoaded 3dtiles模型
 * @property {String} loadBefore 完成加载，但未做任何其他处理前
 * @property {String} load 完成加载，执行所有内部处理后
 *
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.load, function (event) {
 *   console.log('矢量数据对象加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 3dtiles 三维模型图层。
 *
 * @param {Object} options 参数对象， 构造参数建议从{@link http://tudou3d.cn/example/g20_3dtiles_edit.html|模型编辑页面}设置后保存参数后拷贝json参数即可。参数包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {Resource|String} options.url tileset的主JSON文件的 url
 * @param {Number} [options.maximumScreenSpaceError=16] 用于驱动细化细节级别的最大屏幕空间错误。数值加大，能让最终成像变模糊
 * @param {Number} [options.maximumMemoryUsage=512] 数据集可以使用的最大内存量(以MB计)。这个参数默认是512，也即是当几何体和纹理资源大于512MB的时候，Cesium就会淘汰掉当前帧中没有visited的所有块，这个值其实很小，也是cesium为了避免资源占用过高的一个保障，不过上述我们也估算过最差情况下，没有做纹理crn压缩的情况下，这个值很容易被超过，导致很多人误以为cesium的淘汰没有效果。这个值如果设置的过小，导致cesium几乎每帧都在尝试淘汰数据，增加了遍历的时间，也同时增加了崩溃的风险。这个值如果设置的过大，cesium的淘汰机制失效，那么容易导致显存超过显卡内存，也会导致崩溃。 这个值应该处于最差视角下资源占用 和 显存最大量之间。结论：这个参数要根据当前显卡显存来配置，如果我们场景只显示这一个模型数据，这个可以设置到显存的50 % 左右，比如我的显存是6G，这个可以设置到3000左右。那么既保证不超过显存限制，又可以最大利用显存缓存，配合crn压缩之后，这个几乎可以保证你第二次查看模型同一位置的时候，看不到加载过程，非常棒。
 * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] 确定tileset是否投射或接收来自光源的阴影。
 *
 * @param {Boolean} [options.cullWithChildrenBounds=true] 优化选择。是否使用子绑定卷的并集来筛选贴图。
 * @param {Boolean} [options.cullRequestsWhileMoving=true] 优化选择。不要要求贴图，当他们回来的时候可能不会使用，因为相机的运动。这个优化只适用于固定瓷砖组。
 * @param {Number} [options.cullRequestsWhileMovingMultiplier=60.0] 优化选择。在移动时选择请求时使用的倍增器。越大的选择性越强，越小的选择性越弱。值越小能够更快的剔除。
 * @param {Boolean} [options.preloadWhenHidden=false] 当true时，tileset.show是false，也去预加载数据。
 * @param {Boolean} [options.preloadFlightDestinations=true] 优化选择。当摄像机在飞行时，在摄像机的飞行目的地预加载贴图。
 * @param {Boolean} [options.preferLeaves=false] 优化选择。最好先加载上叶子节点数据。这个参数默认是false，同等条件下，叶子节点会优先加载。但是Cesium的tile加载优先级有很多考虑条件，这个只是其中之一，如果skipLevelOfDetail=false，这个参数几乎无意义。所以要配合skipLevelOfDetail=true来使用，此时设置preferLeaves=true。这样我们就能最快的看见符合当前视觉精度的块，对于提升大数据以及网络环境不好的前提下有一点点改善意义。
 * @param {Boolean} [options.dynamicScreenSpaceError=false] 优化选择。减少远离摄像头的贴图的屏幕空间误差。true时会在真正的全屏加载完之后才清晰化模型.
 * @param {Number} [options.dynamicScreenSpaceErrorDensity=0.00278] 密度用来调整动态画面空间误差，类似于雾密度。
 * @param {Number} [options.dynamicScreenSpaceErrorFactor=4.0] 用于增加计算的动态屏幕空间误差的因素。
 * @param {Number} [options.dynamicScreenSpaceErrorHeightFalloff=0.25] 瓷砖密度开始下降时的高度之比。
 * @param {Number} [options.progressiveResolutionHeightFraction=0.3] 优化选择。如果在(0.0,0.5)之间，在屏幕空间或以上的瓷砖错误降低屏幕分辨率 <code>progressiveResolutionHeightFraction*screenHeight</code> 将优先。这可以帮助得到一个快速层的瓷砖下来，而全分辨率的瓷砖继续加载。
 * @param {Boolean} [options.foveatedScreenSpaceError=true] 优化选择。通过暂时提高屏幕边缘的贴图的屏幕空间误差，优先加载屏幕中央的贴图。一旦所有由{@link cesium3dtilesset#foveatedConeSize}确定的屏幕中央的贴图被加载，屏幕空间错误就会恢复正常。
 * @param {Number} [options.foveatedConeSize=0.1] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制决定哪些贴图被延迟的锥大小。装在这个圆锥体里的瓷砖会立即被装入。锥外的贴图有可能被延迟，这取决于它们在锥外的距离和它们的屏幕空间误差。这是由{@link Cesium3DTileset#foveatedInterpolationCallback}和{@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation}控制的。设置为0.0意味着圆锥将是由相机位置和它的视图方向形成的线。将此设置为1.0意味着圆锥将包含相机的整个视场，禁用此效果。
 * @param {Number} [options.foveatedMinimumScreenSpaceErrorRelaxation=0.0] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。屏幕空间错误将基于所提供的{@link Cesium3DTileset#foveatedInterpolationCallback}从tileset值开始直到{@link Cesium3DTileset#maximumScreenSpaceError}。
 * @param {Cesium3DTileset.foveatedInterpolationCallback} [options.foveatedInterpolationCallback=Math.lerp] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。优化选择。当{@link Cesium3DTileset#foveatedScreenSpaceError}为true时使用，以控制凸出圆锥外的贴图的屏幕空间误差提高多少，插值在{@link Cesium3DTileset#foveatedminimumscreenspaceerror}和{@link Cesium3DTileset#maximumScreenSpaceError}之间。
 * @param {Number} [options.foveatedTimeDelay=0.2] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。优化选择。优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制在延迟tile开始加载前摄像机停止移动后等待多长时间(秒)。这个时间延迟阻止了在相机移动时请求屏幕边缘的贴图。将此设置为0.0将立即请求任何给定视图中的所有贴图。
 * @param {Boolean} [options.skipLevelOfDetail=false] 优化选择。确定在遍历过程中是否应应用跳过详细信息的级别。是Cesium在1.5x 引入的一个优化参数，这个参数在金字塔数据加载中，可以跳过一些级别，这样整体的效率会高一些，数据占用也会小一些。但是带来的异常是：1） 加载过程中闪烁，看起来像是透过去了，数据载入完成后正常。2，有些异常的面片，这个还是因为两级LOD之间数据差异较大，导致的。当这个参数设置false，两级之间的变化更平滑，不会跳跃穿透，但是清晰的数据需要更长，而且还有个致命问题，一旦某一个tile数据无法请求到或者失败，导致一直不清晰。所以我们建议：对于网络条件好，并且数据总量较小的情况下，可以设置false，提升数据显示质量。
 * @param {Number} [options.baseScreenSpaceError=1024] 当skipLevelOfDetail为true时，跳过详细级别之前必须达到的屏幕空间错误。
 * @param {Number} [options.skipScreenSpaceErrorFactor=16] 当skipLevelOfDetail = true时，一个定义要跳过的最小屏幕空间错误的乘法器。与skipLevels一起使用，以决定加载哪些贴图。
 * @param {Number} [options.skipLevels=1] 当skipLevelOfDetail是true，一个常量定义了加载tiles时要跳过的最小级别数。当它为0时，不会跳过任何级别。与skipScreenSpaceErrorFactor一起使用，以决定加载哪些贴图。
 * @param {Boolean} [options.immediatelyLoadDesiredLevelOfDetail=false] 当skipLevelOfDetail为true时，只有满足最大屏幕空间错误的tiles才会被下载。跳过因素将被忽略，并且只加载所需的块。
 * @param {Boolean} [options.loadSiblings=false] 当skipLevelOfDetail = true时，判断遍历过程中是否总是下载可见块的兄弟块。如果为true则不会在已加载完模型后，自动从中心开始超清化模型。
 * @param {ClippingPlaneCollection} [options.clippingPlanes] {@link ClippingPlaneCollection}用于选择性地禁用tile集的渲染。
 * @param {ClassificationType} [options.classificationType] 确定地形、3D贴图或两者都将被这个贴图集分类。有关限制和限制的详细信息，请参阅{@link cesium3dtilesset #classificationType}。
 * @param {Object} [options.pointCloudShading] 基于几何误差和光照构造一个{@link PointCloudShading}对象来控制点衰减的选项。
 * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] 缩放来自地球、天空、大气和星星天空盒的漫反射和高光图像照明。
 * @param {Cartesian3} [options.lightColor] 光的颜色当遮光模型。当undefined场景的浅色被使用代替。
 * @param {Number} [options.luminanceAtZenith=0.2] 太阳在天顶的亮度，单位是千坎德拉每平方米，用于这个模型的程序环境地图。
 * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] 三阶球面调和系数用于基于图像的漫射色彩照明。
 * @param {String} [options.specularEnvironmentMaps] 一个KTX文件的URL，该文件包含高光照明的立方体映射和复杂的高光mipmaps。
 * @param {Boolean} [options.backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;当为false时，禁用背面剔除。
 * @param {String} [options.debugHeatmapTilePropertyName] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;作为热图着色的tile变量。所有渲染的贴图都将相对于其他指定的变量值着色。
 * @param {Object} [options.pickPrimitive]  要在拾取过程中呈现的原语，而不是tile集合。
 *
 * @param {Object} [options.position] 模型新的中心点位置（移动模型）
 * @param {Number} options.position.lng 经度值, 180 - 180
 * @param {Number} options.position.lat 纬度值, -90 - 90
 * @param {Number} options.position.alt 高度值（单位：米）
 * @param {Object} [options.rotation] 模型的旋转方向
 * @param {Number} options.rotation.x X方向，角度值0-360
 * @param {Number} options.rotation.y Y方向，角度值0-360
 * @param {Number} options.rotation.z 四周方向，角度值0-360
 * @param {Number} [options.scale=1] 缩放比例
 * @param {String|Cesium.Axis} [options.axis=''] 轴方向
 *
 * @param {Cesium.Matrix4} [options.modelMatrix] 模型的矩阵位置，内部无坐标位置的模型使用，此时position和rotation等参数均无效。
 * @param {function} [options.updateMatrix] 外部自定义修复模型矩阵位置
 *
 * @param {ChinaCRS} [options.chinaCRS] 标识模型的国内坐标系（用于自动纠偏或加偏）
 * @param {Object|Cesium.Cesium3DTileStyle} [options.style]  模型样式， 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
 * @param {Boolean|String} [options.tudouJzwStyle=false] 开启或设置建筑物特效样式。
 *
 * @param {Boolean} [options.showClickFeature=false] 是否鼠标单击高亮显示模型构件
 * @param {Boolean} [options.showMoveFeature=false] 是否鼠标移入高亮显示模型构件
 * @param {Object} [options.pickFeatureStyle]  鼠标单击或移入高亮构件的style样式
 * @param {String} [options.pickFeatureStyle.color='#FFFF00'] 颜色
 * @param {Number} [options.pickFeatureStyle.opacity=1.0] 透明度
 *
 * @export
 * @class TilesetLayer
 * @extends {BaseGraphicLayer}
 *
 * @see Cesium.Cesium3DTileset
 * @see [支持的事件类型]{@link TilesetLayer.EventType}
 */

var TilesetLayer_TilesetLayer = /*#__PURE__*/function (_BaseGraphicLayer) {
  inherits_default()(TilesetLayer, _BaseGraphicLayer);

  var _super = TilesetLayer_createSuper(TilesetLayer);

  //========== 构造方法 ==========
  function TilesetLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TilesetLayer);

    _this = _super.call(this, options);
    /**
     * 原始的旋转角度，示例：{ x: 0, y: 0, z: 0 }
     * @type {Object}
     * @readonly
     */

    _this.orginRotation = {
      x: 0,
      y: 0,
      z: 0
    }; //原始的旋转角度

    _this._orginCenterPoint = new LatLngPoint["a" /* LatLngPoint */](); //原始的中心点位置

    return _this;
  }

  createClass_default()(TilesetLayer, [{
    key: "layer",
    get: function get() {
      return this._tileset;
    }
    /**
     * 模型对应的 Cesium3DTileset对象
     * @type {Cesium.Cesium3DTileset}
     * @readonly
     */

  }, {
    key: "tileset",
    get: function get() {
      return this._tileset;
    }
    /**
     * 是否鼠标单击高亮显示模型构件
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "showClickFeature",
    get: function get() {
      return this.options.showClickFeature;
    },
    set: function set(value) {
      this.options.showClickFeature = value;
    }
    /**
     * 开启或设置建筑物特效样式。
     * @type {Boolean|Object}
     */

  }, {
    key: "tudouJzwStyle",
    get: function get() {
      return this.options.tudouJzwStyle;
    },
    set: function set(value) {
      this.options.tudouJzwStyle = value;

      if (this._tileset) {
        this._tileset.tudouJzwStyle = value;
      }
    }
    /**
     * 模型样式， 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
     * @type {Object|Cesium.Cesium3DTileStyle}
     */

  }, {
    key: "style",
    get: function get() {
      return this.options.style;
    },
    set: function set(value) {
      this.options.style = value;

      if (this._tileset) {
        if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cesium3DTileStyle"]) {
          this._tileset.style = value;
        } else {
          this._tileset.style = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cesium3DTileStyle"](value);
        }
      }
    }
    /**
     * 模型原始的中心点坐标
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "orginCenterPoint",
    get: function get() {
      return this._orginCenterPoint;
    }
    /**
     * 模型原始的中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "orginCenterPosition",
    get: function get() {
      return this._orginCenterPosition;
    }
    /**
     * 模型当前中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "position",
    get: function get() {
      return this._center.toCartesian();
    }
    /**
     * 模型当前中心点坐标
     * @type {LatLngPoint}
     */

  }, {
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(value) {
      this._center = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this.updateMatrix();
    }
    /**
     * 调整修改模型高度
     * @type {LatLngPoint}
     */

  }, {
    key: "height",
    get: function get() {
      if (this.center) {
        return this.center.alt;
      }

      return 0;
    },
    set: function set(value) {
      if (!this._tileset) {
        return;
      }

      this.center.alt = value;
      this.updateMatrix();
    }
    /**
     * 旋转方向，示例：{ x: 0, y: 0, z: 0 }
     * @type {Object}
     */

  }, {
    key: "rotation",
    get: function get() {
      if (this.options.rotation) {
        return this.options.rotation;
      }

      return this.orginRotation;
    },
    set: function set(value) {
      this.options.rotation = value;
      this.updateMatrix();
    }
    /**
     * X轴上的旋转方向
     * @type {Number}
     */

  }, {
    key: "rotation_x",
    get: function get() {
      if (this.options.rotation && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.rotation.x)) {
        return this.options.rotation.x;
      }

      return this.orginRotation.x;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.x = value;
      this.updateMatrix();
    }
    /**
     * Y轴上的旋转方向
     * @type {Number}
     */

  }, {
    key: "rotation_y",
    get: function get() {
      if (this.options.rotation && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.rotation.y)) {
        return this.options.rotation.y;
      }

      return this.orginRotation.y;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.y = value;
      this.updateMatrix();
    }
    /**
     * Z轴上的旋转方向
     * @type {Number}
     */

  }, {
    key: "rotation_z",
    get: function get() {
      if (this.options.rotation && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.rotation.z)) {
        return this.options.rotation.z;
      }

      return this.orginRotation.z;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.z = value;
      this.updateMatrix();
    }
    /**
     * 轴方向
     * @type {String|Cesium.Axis}
     */

  }, {
    key: "axis",
    get: function get() {
      return this.options.axis || "";
    },
    set: function set(value) {
      this.options.axis = value;
      this.updateMatrix();
    }
    /**
     * 缩放比例
     * @type {Number}
     */

  }, {
    key: "scale",
    get: function get() {
      return this.options.scale || 1;
    },
    set: function set(value) {
      this.options.scale = value;
      this.updateMatrix();
    }
  }, {
    key: "boundingSphere",
    get: function get() {
      var _this$_tileset;

      return (_this$_tileset = this._tileset) === null || _this$_tileset === void 0 ? void 0 : _this$_tileset.boundingSphere;
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this2 = this;

      get_default()(getPrototypeOf_default()(TilesetLayer.prototype), "_addedHook", this).call(this);

      this._tileset = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cesium3DTileset"](TilesetLayer_objectSpread(TilesetLayer_objectSpread({}, this.options), {}, {
        url: Object(Util["getUrlResource"])(this.options)
      }));
      this._tileset.name = this.name;
      this._tileset._tudou3d_layerId = this.uuid;
      this.loadOk = false;

      this._tileset.readyPromise.then(function (tileset) {
        _this2.loadOk = true;
        _this2._tileset.show = _this2.show;

        _this2._initModel();
      });

      this._map.scene.primitives.add(this._tileset); //绑定一些事件


      this._tileset.initialTilesLoaded.addEventListener(function (event) {
        //该回调只执行一次
        _this2.fire(EventType.initialTilesLoaded, event);
      });

      this._tileset.allTilesLoaded.addEventListener(function (event) {
        //该回调会执行多次，视角变化后重新加载一次完成后都会回调
        _this2.fire(EventType.allTilesLoaded, event);
      });
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(TilesetLayer.prototype), "_removedHook", this).call(this);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.visibleDistanceMax)) {
        this._map.off(EventType.cameraChanged, this.updateVisibleDistance, this);
      }

      if (this._tileset) {
        this._map.scene.primitives.remove(this._tileset);

        delete this._tileset;
      }
    }
  }, {
    key: "_mergePostion",
    value: function _mergePostion(configCenter) {
      if (configCenter) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](configCenter.lat)) {
          this.center.lat = configCenter.lat;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](configCenter.lng)) {
          this.center.lng = configCenter.lng;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](configCenter.alt)) {
          this.center.alt = configCenter.alt;
        }
      }
    }
  }, {
    key: "_setOptionsHook",
    value: function _setOptionsHook(options) {
      if (!this._tileset) {
        return;
      } //设置新的中心点


      this._mergePostion(this.options.position);

      this.updateMatrix();
    }
  }, {
    key: "_initModel",
    value: function _initModel() {
      this.fire(EventType.loadBefore, {
        tileset: this._tileset
      }); //================模型中心点相关处理===============
      //记录模型原始的中心点

      this._orginCenterPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._tileset.boundingSphere.center); //是否存在世界矩阵 _root.transform

      this.transform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.transform, this._tileset._root && this._tileset._root.transform);

      if (this.transform) {
        //原始矩阵
        this.orginMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromArray(this._tileset._root.transform), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]()); //获取transform中的中心点

        var matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromArray(this._tileset._root.transform);
        var position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].getTranslation(matrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](position) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position)) {
          this._orginCenterPosition = position; //计算 orginRotation
          //取旋转矩阵

          var rotmat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].getMatrix3(matrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]()); //默认的旋转矩阵

          var defrotmat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].getMatrix3(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(position), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]()); //计算rotmat 的x轴，在defrotmat 上 旋转

          var xaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(defrotmat, 0, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          var yaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(defrotmat, 1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          var zaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(defrotmat, 2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          var dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].getColumn(rotmat, 0, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(dir, zaxis, dir);
          dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(zaxis, dir, dir);
          dir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(dir, dir);
          var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(xaxis, dir);
          var ay = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(yaxis, dir);

          if (ay > Math.PI * 0.5) {
            heading = 2 * Math.PI - heading;
          } //原始的旋转角度


          this.orginRotation = {
            x: 0,
            y: 0,
            z: Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(heading).toFixed(1))
          };
        } else {
          this.transform = false;
        }
      }

      this._orginCenterPoint = LatLngPoint["a" /* LatLngPoint */].fromCartesian(this._orginCenterPosition); //打印下

      Object(Log["logInfo"])(this.name + " 模型中心位置:" + this._orginCenterPoint.toString()); //================设置相关配置参数===============
      //设置style

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.style)) {
        this.style = this.options.style;
      } //透明度


      if (this._opacity != 1) {
        this.setOpacity(this._opacity);
      } //当前中心点信息


      this._center = this._orginCenterPoint.clone(); //设置新的中心点

      this._mergePostion(this.options.position); //有坐标系配置


      if (this.options.chinaCRS) {
        var crsCenter = this.transformCenter(this.center);

        this._mergePostion(crsCenter);
      } //更新矩阵


      if (this._hasUpdateMater()) {
        this.updateMatrix();
      } //设置最大视距后自动隐藏（不建议，效率一般）


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.visibleDistanceMax)) {
        this.bindVisibleDistance();
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this.fire(EventType.load, {
        tileset: this._tileset
      });
    }
    /**
     * 模型自动贴地计算及处理,
     * 因为模型在设计或生产时，模型的视角中心位置不一定在0,0,0点，此方法不是唯一准确的。
     *
     * @param {number} [addHeight=1] 计算完成的贴地高度基础上增加的高度值。
     * @return {void}  无
     */

  }, {
    key: "clampToGround",
    value: function clampToGround() {
      var _this3 = this;

      var addHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this._map && this._map.hasTerrain) {
        //有地形时
        Object(PointUtil["getSurfaceTerrainHeight"])(this._map.scene, this._orginCenterPosition, {
          asyn: true,
          //是否异步求准确高度
          callback: function callback(newHeight, cartOld) {
            if (newHeight == null) {
              return;
            }

            _this3.height = newHeight - _this3._orginCenterPoint.alt + addHeight;
          }
        });
      } else {
        //无地形时
        this.height = -this._orginCenterPoint.alt + addHeight;
      }
    } //是否需要更新矩阵

  }, {
    key: "_hasUpdateMater",
    value: function _hasUpdateMater() {
      if (!this.center.equals(this._orginCenterPoint)) {
        return true;
      }

      if (this.options.rotation) {
        return true;
      }

      if (this.options.scale > 0 && this.options.scale != 1) {
        return true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.axis)) {
        return true;
      }

      return false;
    }
    /**
     * 重新计算当前矩阵（需要是否存在世界矩阵时）
     * @return {Cesium.Matrix4|undefined} 计算完成的矩阵
     */

  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      if (!this._tileset) {
        return undefined;
      }

      if (this.options.updateMatrix) {
        var _matrix = this.options.updateMatrix(this.position, this);

        this._tileset.modelMatrix = _matrix;
        return _matrix;
      }

      if (!this.transform) {
        return this.updateMatrix2();
      }

      var matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this.position); //旋转

      if (this.options.rotation) {
        var mx = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationX(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.rotation_x));
        var my = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationY(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.rotation_y));
        var mz = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].fromRotationZ(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(360 - this.rotation_z));
        var rotationX = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(mx);
        var rotationY = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(my);
        var rotationZ = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromRotationTranslation(mz); //矩阵相乘

        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(matrix, rotationX, matrix);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(matrix, rotationY, matrix);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(matrix, rotationZ, matrix);
      } //缩放比例


      if (this.options.scale > 0 && this.options.scale != 1) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByUniformScale(matrix, this.options.scale, matrix);
      } //垂直轴变换 ，兼容旧版本数据z轴方向不对的情况
      //如果可以修改模型json源文件，可以在json文件里面加了一行来修正："gltfUpAxis" : "Z",


      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.axis)) {
        var rightaxis;

        if (Object(Util["isString"])(this.options.axis)) {
          switch (this.options.axis.toUpperCase()) {
            default:
              break;

            case "Y_UP_TO_Z_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].Y_UP_TO_Z_UP;
              break;

            case "Z_UP_TO_Y_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].Z_UP_TO_Y_UP;
              break;

            case "X_UP_TO_Z_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].X_UP_TO_Z_UP;
              break;

            case "Z_UP_TO_X_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].Z_UP_TO_X_UP;
              break;

            case "X_UP_TO_Y_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].X_UP_TO_Y_UP;
              break;

            case "Y_UP_TO_X_UP":
              rightaxis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"].Y_UP_TO_X_UP;
              break;
          }
        } else if (this.options.axis instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Axis"]) {
          rightaxis = this.options.axis;
        }

        if (rightaxis) {
          matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyTransformation(matrix, rightaxis, matrix);
        }
      }

      this._tileset._root.transform = matrix;
      return matrix;
    }
    /**
     * 重新计算当前矩阵，普通方式, 此种方式[x，y不能多次更改]
     * @return {Cesium.Matrix4} 计算完成的矩阵
     */

  }, {
    key: "updateMatrix2",
    value: function updateMatrix2() {
      if (!this._tileset) {
        return;
      }

      var catographic = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this._tileset.boundingSphere.center);
      var surface = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(catographic.longitude, catographic.latitude, 0.0);
      var center = this.position;
      var translation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(center, surface, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var matrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromTranslation(translation);
      this._tileset.modelMatrix = matrix;
      return matrix;
    }
    /**
     * 获取构件节点位置，现对于原始矩阵变化后的新位置
     *
     * @param {Cesium.Cartesian3} position 原始位置
     * @return {Cesium.Cartesian3} 新位置
     */

  }, {
    key: "getPositionByOrginMatrix",
    value: function getPositionByOrginMatrix(position) {
      if (this.orginMatrix) {
        var mat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiply(this._tileset._root.transform, this.orginMatrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
        return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(mat, position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      }

      return position;
    }
    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      if (this.options.onSetOpacity) {
        this.options.onSetOpacity(value); //外部自定义处理
      } else {
        if (this._tileset) {
          this._tileset.style = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cesium3DTileStyle"]({
            color: "color() *vec4(1,1,1," + value + ")"
          });
        }
      }
    } //定位至数据区域

  }, {
    key: "flyTo",
    value: function flyTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._map) {
        return;
      }

      if (this.options.center) {
        this._map.setCameraView(this.options.center, options);
      } else if (this.options.extent) {
        this._map.flyToExtent(this.options.extent, options);
      } else if (this.loadOk) {
        this._map.flyToPoint(this._tileset.boundingSphere.center, TilesetLayer_objectSpread({
          radius: this._tileset.boundingSphere.radius * 2,
          maxPitch: -45
        }, options));
      }
    } //根据map及图层坐标系 转换中心点

  }, {
    key: "transformCenter",
    value: function transformCenter(center) {
      if (!center) {
        return false;
      }

      var dstCoordType = this._map.chinaCRS; //map地图的坐标系

      var srcCoordType = this.options.chinaCRS; //layer图层的坐标系（默认与地图一致）

      var TransFun = Object(PointUtil["getTransFun"])(srcCoordType, dstCoordType);

      if (!TransFun) {
        return false;
      }

      var pt = TransFun([center.lng, center.lat]);
      return {
        lng: pt[0],
        lat: pt[1],
        alt: center.alt
      };
    } //绑定  设置最大视距后自动隐藏（不建议，效率一般）

  }, {
    key: "bindVisibleDistance",
    value: function bindVisibleDistance() {
      this._map.on(EventType.cameraChanged, this.updateVisibleDistance, this);
    }
  }, {
    key: "updateVisibleDistance",
    value: function updateVisibleDistance() {
      if (!this._show) {
        return;
      }

      if (this._map.scene.mode != external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        return;
      }

      if (!this._tileset || !this.loadOk) {
        return;
      }

      var camera_distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this.position, this._map.camera.positionWC);

      if (camera_distance > this.options.visibleDistanceMax + 100000) {
        //在模型的外包围外
        this._tileset.show = false;
      } else {
        var target = this._map.getCenter(); //取屏幕中心点坐标


        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](target)) {
          var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(target, this._map.camera.positionWC);
          this._tileset.show = distance < this.options.visibleDistanceMax;
        } else {
          this._tileset.show = true;
        }
      }
    }
  }]);

  return TilesetLayer;
}(BaseGraphicLayer_BaseGraphicLayer); //注册下

Object(LayerUtil["register"])("3dtiles", TilesetLayer_TilesetLayer); //主要

Object(LayerUtil["register"])("tileset", TilesetLayer_TilesetLayer); //备用
// CONCATENATED MODULE: ./src/layer/graphicLayer/OsmBuildingsLayer.js






function OsmBuildingsLayer_createSuper(Derived) { var hasNativeReflectConstruct = OsmBuildingsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function OsmBuildingsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * OSM在线 建筑物模型
 *
 * @param {Object} options 参数对象， 构造参数建议从{@link http://tudou3d.cn/example/g20_3dtiles_edit.html|模型编辑页面}设置后保存参数后拷贝json参数即可。参数包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {Object|Cesium.Cesium3DTileStyle} [options.style]  模型样式， 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
 *
 * @param {Boolean} [options.showClickFeature=false] 是否鼠标单击高亮显示模型构件
 * @param {Boolean} [options.showMoveFeature=false] 是否鼠标移入高亮显示模型构件
 * @param {Object} [options.pickFeatureStyle]  鼠标单击或移入高亮构件的style样式
 * @param {String} [options.pickFeatureStyle.color='#FFFF00'] 颜色
 * @param {Number} [options.pickFeatureStyle.opacity=1.0] 透明度
 * @export
 * @class OsmBuildingsLayer
 * @extends {TilesetLayer}
 * @see [支持的事件类型]{@link TilesetLayer.EventType}
 */

var OsmBuildingsLayer_OsmBuildingsLayer = /*#__PURE__*/function (_TilesetLayer) {
  inherits_default()(OsmBuildingsLayer, _TilesetLayer);

  var _super = OsmBuildingsLayer_createSuper(OsmBuildingsLayer);

  function OsmBuildingsLayer() {
    classCallCheck_default()(this, OsmBuildingsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(OsmBuildingsLayer, [{
    key: "_addedHook",
    value: //创建图层对象的方法
    function _addedHook() {
      var _this = this;

      this._tileset = this._map.scene.primitives.add(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["createOsmBuildings"]());
      this._tileset.name = this.name;
      this._tileset._tudou3d_layerId = this.uuid;
      this.loadOk = false;

      this._tileset.readyPromise.then(function (tileset) {
        _this.loadOk = true;

        _this.fire(EventType.load, {
          tileset: _this._tileset
        });
      }); //绑定一些事件


      this._tileset.initialTilesLoaded.addEventListener(function (event) {
        //该回调只执行一次
        _this.fire(EventType.initialTilesLoaded, event);
      });

      this._tileset.allTilesLoaded.addEventListener(function (event) {
        //该回调会执行多次，视角变化后重新加载一次完成后都会回调
        _this.fire(EventType.allTilesLoaded, event);
      });
    }
  }]);

  return OsmBuildingsLayer;
}(TilesetLayer_TilesetLayer); //注册下

Object(LayerUtil["register"])("osmBuildings", OsmBuildingsLayer_OsmBuildingsLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/core/GraticuleProvider.js


 //经纬网

var mins = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(0.05), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(0.1), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(0.2), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(0.5), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(1.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(2.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(5.0), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(10.0)];

function gridPrecision(dDeg) {
  if (dDeg < 0.01) {
    return 2;
  }

  if (dDeg < 0.1) {
    return 1;
  }

  if (dDeg < 1) {
    return 0;
  }

  return 0;
}

function GraticuleProvider(options) {
  this.options = options;
  this._tilingScheme = options.tilingScheme || new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeographicTilingScheme"]();
  this._tileWidth = options.tileWidth || 256;
  this._tileHeight = options.tileHeight || 256;
  this._ready = true; // default to decimal intervals

  this._sexagesimal = options.sexagesimal || false;
  this._numLines = options.numLines || 50;
  this._scene = options.scene;
  this._ellipsoid = this._scene.globe.ellipsoid;
  this._labels = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelCollection"]();

  this._scene.primitives.add(this._labels);

  this._polylines = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolylineCollection"]();

  this._scene.primitives.add(this._polylines);

  var canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 256;
  this._canvas = canvas;
  var that = this;

  this._scene.camera.moveEnd.addEventListener(function () {
    if (!that._show) {
      return;
    }

    that._polylines.removeAll();

    that._labels.removeAll();

    that._currentExtent = null;

    that._drawGrid(that._getExtentView());
  });

  this._scene.imageryLayers.addImageryProvider(this);
} // let definePropertyWorks = (function () {
//   try {
//     return 'x' in Object.defineProperty({}, 'x', {})
//   } catch (e) {
//     return false
//   }
// })()

/**
 * Defines properties on an object, using Object.defineProperties if available,
 * catch returns the object unchanged.  This function should be used in
 * setup code to prevent errors from completely halting JavaScript execution
 * in legacy browsers.
 * @private
 */


Object.defineProperties(GraticuleProvider.prototype, {
  url: {
    get: function get() {
      return undefined;
    }
  },
  proxy: {
    get: function get() {
      return undefined;
    }
  },
  tileWidth: {
    get: function get() {
      return this._tileWidth;
    }
  },
  tileHeight: {
    get: function get() {
      return this._tileHeight;
    }
  },
  maximumLevel: {
    get: function get() {
      return 18;
    }
  },
  minimumLevel: {
    get: function get() {
      return 0;
    }
  },
  tilingScheme: {
    get: function get() {
      return this._tilingScheme;
    }
  },
  rectangle: {
    get: function get() {
      return this._tilingScheme.rectangle;
    }
  },
  tileDiscardPolicy: {
    get: function get() {
      return undefined;
    }
  },
  errorEvent: {
    get: function get() {
      return this._errorEvent;
    }
  },
  ready: {
    get: function get() {
      return this._ready;
    }
  },
  credit: {
    get: function get() {
      return this._credit;
    }
  },
  hasAlphaChannel: {
    get: function get() {
      return true;
    }
  }
});

GraticuleProvider.prototype.makeLabel = function (lng, lat, text, top, color) {
  var addAtrr = LabelStyleConver_LabelStyleConver.toCesiumVal(this.options.labelStyle || {}, {
    style: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["LabelStyle"].FILL_AND_OUTLINE,
    fillColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].AZURE,
    outlineColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].BLACK,
    outlineWidth: 2,
    pixelOffset: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](5, top ? 5 : -5),
    eyeOffset: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].ZERO,
    horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
    verticalOrigin: top ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].TOP,
    scale: 1.0
  });
  addAtrr.position = this._ellipsoid.cartographicToCartesian(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](lng, lat, 10.0));
  addAtrr.text = text;

  this._labels.add(addAtrr);
};

GraticuleProvider.prototype._drawGrid = function (extent) {
  if (this._currentExtent && this._currentExtent.equals(extent)) {
    return;
  }

  this._currentExtent = extent;

  this._polylines.removeAll();

  this._labels.removeAll(); // let minPixel = 0
  // let maxPixel = this._canvasSize


  var dLat = 0,
      dLng = 0,
      index; // get the nearest to the calculated value

  for (index = 0; index < mins.length && dLat < (extent.north - extent.south) / 10; index++) {
    dLat = mins[index];
  }

  for (index = 0; index < mins.length && dLng < (extent.east - extent.west) / 10; index++) {
    dLng = mins[index];
  } // round iteration limits to the computed grid interval


  var minLng = (extent.west < 0 ? Math.ceil(extent.west / dLng) : Math.floor(extent.west / dLng)) * dLng;
  var minLat = (extent.south < 0 ? Math.ceil(extent.south / dLat) : Math.floor(extent.south / dLat)) * dLat;
  var maxLng = (extent.east < 0 ? Math.ceil(extent.east / dLat) : Math.floor(extent.east / dLat)) * dLat;
  var maxLat = (extent.north < 0 ? Math.ceil(extent.north / dLng) : Math.floor(extent.north / dLng)) * dLng; // extend to make sure we cover for non refresh of tiles

  minLng = Math.max(minLng - 2 * dLng, -Math.PI);
  maxLng = Math.min(maxLng + 2 * dLng, Math.PI);
  minLat = Math.max(minLat - 2 * dLat, -Math.PI / 2);
  maxLat = Math.min(maxLat + 2 * dLng, Math.PI / 2);
  var ellipsoid = this._ellipsoid;
  var lat,
      lng,
      granularity = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(1); // labels positions

  var latitudeText = minLat + Math.floor((maxLat - minLat) / dLat / 2) * dLat;

  for (lng = minLng; lng < maxLng; lng += dLng) {
    // draw meridian
    var path = [];

    for (lat = minLat; lat < maxLat; lat += granularity) {
      path.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](lng, lat));
    }

    path.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](lng, maxLat));

    this._polylines.add(PolylineStyleConver_PolylineStyleConver.toCesiumVal(this.options.lineStyle || {}, {
      positions: ellipsoid.cartographicArrayToCartesianArray(path),
      width: 1
    }));

    var degLng = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(lng);
    this.makeLabel(lng, latitudeText, this._sexagesimal ? this._decToSex(degLng) : degLng.toFixed(gridPrecision(dLng)), false);
  } // lats


  var longitudeText = minLng + Math.floor((maxLng - minLng) / dLng / 2) * dLng;

  for (lat = minLat; lat < maxLat; lat += dLat) {
    // draw parallels
    var _path = [];

    for (lng = minLng; lng < maxLng; lng += granularity) {
      _path.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](lng, lat));
    }

    _path.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](maxLng, lat));

    this._polylines.add(PolylineStyleConver_PolylineStyleConver.toCesiumVal(this.options.lineStyle || {}, {
      positions: ellipsoid.cartographicArrayToCartesianArray(_path),
      width: 1
    }));

    var degLat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(lat);
    this.makeLabel(longitudeText, lat, this._sexagesimal ? this._decToSex(degLat) : degLat.toFixed(gridPrecision(dLat)), true);
  }
};

GraticuleProvider.prototype.requestImage = function (x, y, level) {
  if (this._show) {
    this._drawGrid(this._getExtentView());
  }

  return this._canvas;
};

GraticuleProvider.prototype.setVisible = function (show) {
  this._show = show;

  if (!show) {
    this._polylines.removeAll();

    this._labels.removeAll();
  } else {
    this._currentExtent = null;

    this._drawGrid(this._getExtentView());
  }
};

GraticuleProvider.prototype.isVisible = function () {
  return this._show;
};

GraticuleProvider.prototype._decToSex = function (d) {
  var degs = Math.floor(d);
  var mins = ((Math.abs(d) - degs) * 60.0).toFixed(2);

  if (mins == "60.00") {
    degs += 1.0;
    mins = "0.00";
  }

  return [degs, ":", mins].join("");
};

GraticuleProvider.prototype._getExtentView = function () {
  var camera = this._scene.camera;
  var canvas = this._scene.canvas;
  var corners = [camera.pickEllipsoid(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, 0), this._ellipsoid), camera.pickEllipsoid(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](canvas.width, 0), this._ellipsoid), camera.pickEllipsoid(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, canvas.height), this._ellipsoid), camera.pickEllipsoid(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](canvas.width, canvas.height), this._ellipsoid)];

  for (var index = 0; index < 4; index++) {
    if (corners[index] == undefined) {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].MAX_VALUE;
    }
  }

  return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromCartographicArray(this._ellipsoid.cartesianArrayToCartographicArray(corners));
};


// CONCATENATED MODULE: ./src/layer/graphicLayer/GraticuleLayer.js







function GraticuleLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GraticuleLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GraticuleLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GraticuleLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GraticuleLayer_createSuper(Derived) { var hasNativeReflectConstruct = GraticuleLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GraticuleLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 经纬网
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {PolylinePrimitive.StyleOptions} [options.lineStyle] 线的样式
 * @param {LabelEntity.StyleOptions} [options.labelStyle] 文本的样式
 * @param {Number} [options.numLines=10] 网格数
 *
 * @export
 * @class GraticuleLayer
 * @extends {BaseLayer}
 */

var GraticuleLayer_GraticuleLayer = /*#__PURE__*/function (_BaseLayer) {
  inherits_default()(GraticuleLayer, _BaseLayer);

  var _super = GraticuleLayer_createSuper(GraticuleLayer);

  function GraticuleLayer() {
    classCallCheck_default()(this, GraticuleLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(GraticuleLayer, [{
    key: "layer",
    get: function get() {
      return this._graticuleProvider;
    }
  }, {
    key: "_showHook",
    value: function _showHook(val) {
      if (this._graticuleProvider) {
        this._graticuleProvider.setVisible(val);
      }
    } // 创建图层对象的方法

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._graticuleProvider = new GraticuleProvider(GraticuleLayer_objectSpread({
        scene: this._map.scene,
        numLines: 10
      }, this.options));
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._graticuleProvider.setVisible(true);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._graticuleProvider.setVisible(false);
    }
  }]);

  return GraticuleLayer;
}(BaseLayer_BaseLayer); //注册下

Object(LayerUtil["register"])("graticule", GraticuleLayer_GraticuleLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/LodGraphicLayer.js








function LodGraphicLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function LodGraphicLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LodGraphicLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LodGraphicLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function LodGraphicLayer_createSuper(Derived) { var hasNativeReflectConstruct = LodGraphicLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LodGraphicLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * @typedef {Object} LodGraphicLayer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {BaseGraphicLayer.EventType} 通用 支持的父类的事件类型
 * @property {String} addGraphic 添加矢量数据时
 * @property {String} removeGraphic 移除矢量数据时
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.addGraphic, function (event) {
 *   console.log('添加了矢量数据', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 矢量数据LOD分层分块加载类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称
 * @param {Function} options.queryGridData  获取网格内对应数据的的外部处理回调方法
 * @param {Function} options.createGraphic  根据数据创建矢量对象的外部处理回调方法
 * @param {Function} options.updateGraphic  根据数据更新矢量对象的外部处理回调方法，一般动态数据时可以用
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
 * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
 * @param {Object} options.rectangle 瓦片数据的矩形区域范围
 * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
 * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
 * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
 * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
 * @param {Number[]} options.bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 *
 * @param {Object} options.clustering 设置聚合相关参数：
 * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
 * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
 * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
 * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
 * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
 * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
 * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
 * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
 *
 * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
 * @param {BillboardEntity.StyleOptions} options.symbol.styleOptions 点数据时的Style样式，可以附加 model {@link ModelEntity.StyleOptions} 或 point {@link PointEntity.StyleOptions}
 * @param {PolylineEntity.StyleOptions} options.symbol.styleOptions 线数据时的Style样式，可以附加 corridor {@link CorridorEntity.StyleOptions}
 * @param {PolygonEntity.StyleOptions} options.symbol.styleOptions 面数据时的Style样式
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 *
 * @export
 * @class LodGraphicLayer
 * @extends {GraphicLayer}
 *
 * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
 */

var LodGraphicLayer_LodGraphicLayer = /*#__PURE__*/function (_GraphicLayer) {
  inherits_default()(LodGraphicLayer, _GraphicLayer);

  var _super = LodGraphicLayer_createSuper(LodGraphicLayer);

  //========== 构造方法 ==========
  function LodGraphicLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LodGraphicLayer);

    _this = _super.call(this, options);

    if (_this.options.debuggerTileInfo) {
      _this.bindPopup(function (event) {
        var _event$graphic;

        var gridList = (event === null || event === void 0 ? void 0 : (_event$graphic = event.graphic) === null || _event$graphic === void 0 ? void 0 : _event$graphic.gridList) || [];
        return gridList.join("<br/>");
      });
    }

    _this._cacheGrid = {}; //网格缓存,存放矢量对象id集合

    _this._cacheGraphic = {}; //矢量对象缓存,存放矢量对象的id唯一标识和其所对应的网格集合

    return _this;
  } //========== 方法==========


  createClass_default()(LodGraphicLayer, [{
    key: "_showHook",
    value: function _showHook(val) {
      get_default()(getPrototypeOf_default()(LodGraphicLayer.prototype), "_showHook", this).call(this, val);

      if (this._tileLayer) {
        this._tileLayer.show = val;
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      get_default()(getPrototypeOf_default()(LodGraphicLayer.prototype), "_mountedHook", this).call(this);

      var tileOptions = LodGraphicLayer_objectSpread(LodGraphicLayer_objectSpread({}, this.options), {}, {
        noLayerManage: true
      });

      delete tileOptions.id;
      delete tileOptions.name;
      delete tileOptions.url;
      delete tileOptions.type;
      this._tileLayer = new EmptyTileLayer_EmptyTileLayer(tileOptions);
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      get_default()(getPrototypeOf_default()(LodGraphicLayer.prototype), "_addedHook", this).call(this);

      this._tileLayer.on(EventType.addTile, this._tileLayer_addTileHandler, this);

      this._tileLayer.on(EventType.removeTile, this._tileLayer_removeTileHandler, this);

      this._map.addLayer(this._tileLayer);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      get_default()(getPrototypeOf_default()(LodGraphicLayer.prototype), "_removedHook", this).call(this);

      this._tileLayer.off(EventType.addTile, this._tileLayer_addTileHandler, this);

      this._tileLayer.off(EventType.removeTile, this._tileLayer_removeTileHandler, this);

      this._map.removeLayer(this._tileLayer);

      this.clear();
    }
  }, {
    key: "getGridKey",
    value: function getGridKey(grid) {
      return grid.level + "_x" + grid.x + "_y" + grid.y;
    }
  }, {
    key: "checkHasBreak",
    value: function checkHasBreak(cacheKey) {
      if (!this.show || !this._cacheGrid[cacheKey]) {
        return true;
      }

      return false;
    } //加载了一个瓦片

  }, {
    key: "_tileLayer_addTileHandler",
    value: function _tileLayer_addTileHandler(event) {
      if (!this._tileLayer.isInRange(event.level)) {
        return;
      }

      var cacheKey = this.getGridKey(event);
      event.key = cacheKey;
      this._cacheGrid[cacheKey] = {
        grid: event,
        isLoading: true
      };
      var that = this;
      this.queryGridData(event, function (grid, arrdata) {
        if (that.show) {
          that._showData(grid, arrdata);
        }
      });
    } //获取数据的唯一标识

  }, {
    key: "_getItemDataId",
    value: function _getItemDataId(item) {
      if (item.id) {
        return item.id;
      }

      if (item.type == "Feature") {
        item = item.properties;
      }

      if (item[this.options.IdField]) {
        return item[this.options.IdField];
      }

      return null;
    }
  }, {
    key: "_showData",
    value: function _showData(grid, arrdata) {
      var cacheKey = grid.key;

      if (this.checkHasBreak[cacheKey]) {
        //异步请求结束时,如果已经卸载了网格就直接跳出。
        return;
      }

      var arrIds = [];

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var attr = arrdata[i];

        var id = this._getItemDataId(attr);

        if (!id) {
          Object(Log["logWarn"])("LodGraphicLayer: 数据的ID识别失败", attr);
        }

        var graphic = this._cacheGraphic[id];

        if (graphic) {
          //已存在时，更新
          graphic.gridList.push(cacheKey);
          this.updateGraphic(graphic, attr);
        } else {
          //不存在时，创建
          var _graphic = this.createGraphic(grid, attr);

          if (!_graphic) {
            continue;
          }

          _graphic.gridList = [cacheKey];
          this._cacheGraphic[id] = _graphic;
        }

        arrIds.push(id);
      }

      this._cacheGrid[cacheKey] = this._cacheGrid[cacheKey] || {};
      this._cacheGrid[cacheKey].ids = arrIds;
      this._cacheGrid[cacheKey].isLoading = false;
    } //卸载了一个瓦片

  }, {
    key: "_tileLayer_removeTileHandler",
    value: function _tileLayer_removeTileHandler(event) {
      if (this._tileLayer.isAllOutRange(event.level)) {
        this.clear();
        return;
      }

      var cacheKey = this.getGridKey(event);
      var layers = this._cacheGrid[cacheKey];

      if (layers) {
        if (layers.ids) {
          for (var i = 0; i < layers.ids.length; i++) {
            var id = layers.ids[i];
            var graphic = this._cacheGraphic[id];

            if (!graphic) {
              continue;
            } //移除数组中的一项


            Object(Util["removeArrayItem"])(graphic.gridList, cacheKey);

            if (graphic.gridList.length == 0) {
              this.removeGraphic(graphic);
              delete this._cacheGraphic[id];
            }
          }
        }

        delete this._cacheGrid[cacheKey];
      }
    }
    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @param {Function} callback 数据获取完成后调用该回调方法。如:callback(grid, arrdata)
     * @return {void}  无
     * @abstract
     */

  }, {
    key: "queryGridData",
    value: function queryGridData(grid, callback) {
      if (this.options.queryGridData) {
        //传参方式
        this.options.queryGridData(grid, callback);
      }
    }
    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} attr 数据的属性信息
     * @return {Graphic}  矢量对象
     * @abstract
     */

  }, {
    key: "createGraphic",
    value: function createGraphic(grid, attr) {
      if (this.options.createGraphic) {
        //传参方式
        return this.options.createGraphic(grid, attr);
      }

      return null;
    }
    /**
     * 根据 attr属性 更新 矢量对象，主要是属性是动态变化的场景下使用。
     * @param {Graphic} graphic 矢量对象
     * @param {Object} attr 数据的属性信息
     * @return {void}  无
     * @abstract
     */

  }, {
    key: "updateGraphic",
    value: function updateGraphic(graphic, attr) {
      if (this.options.updateGraphic) {
        //传参方式
        this.options.updateGraphic(graphic, attr);
      }
    }
    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestory=false] 是否释放矢量对象
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      get_default()(getPrototypeOf_default()(LodGraphicLayer.prototype), "clear", this).call(this);

      this._cacheGraphic = {};
      this._cacheGrid = {};
    }
    /**
     * 重新加载数据
     * @return {void}  无
     */

  }, {
    key: "reload",
    value: function reload() {
      var that = this;

      for (var i in this._cacheGrid) {
        var item = this._cacheGrid[i];

        if (item == null || item.grid == null || item.isLoading) {
          continue;
        }

        this.queryGridData(item.grid, function (grid, arrdata) {
          that._showData(grid, arrdata);
        });
      }
    }
  }]);

  return LodGraphicLayer;
}(GraphicLayer_GraphicLayer); //注册下

Object(LayerUtil["register"])("lodGraphic", LodGraphicLayer_LodGraphicLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/GeodePoiLayer.js







function GeodePoiLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GeodePoiLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GeodePoiLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GeodePoiLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GeodePoiLayer_createSuper(Derived) { var hasNativeReflectConstruct = GeodePoiLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function GeodePoiLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }












/**
 * 高德在线POI图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {String[]} [options.key = tudou3d.Token.gaodeArr] 高德KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
 * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
 * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
 * @param {Object} options.rectangle 瓦片数据的矩形区域范围
 * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
 * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
 * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
 * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
 * @param {Number[]} options.bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 * @param {Object} options.clustering 设置聚合相关参数：
 * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
 * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
 * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
 * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
 * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
 * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
 * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
 * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
 *
 * @param {Object} [options.symbol] 矢量数据的style样式
 * @param {BillboardEntity.StyleOptions|PointEntity.StyleOptions} options.symbol.styleOptions 点的Style样式。
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 *
 *
 * @export
 * @class GeodePoiLayer
 * @extends {LodGraphicLayer}
 * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
 */

var GeodePoiLayer_GeodePoiLayer = /*#__PURE__*/function (_LodGraphicLayer) {
  inherits_default()(GeodePoiLayer, _LodGraphicLayer);

  var _super = GeodePoiLayer_createSuper(GeodePoiLayer);

  //========== 构造方法 ==========
  function GeodePoiLayer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GeodePoiLayer);

    _this = _super.call(this, options);
    _this._key_index = 0;
    _this._keys = _this.options.key || gaodeArr;

    _this.bindPopup(function (event) {
      var _event$graphic;

      var item = (_event$graphic = event.graphic) === null || _event$graphic === void 0 ? void 0 : _event$graphic.attr;

      if (!item) {
        return;
      }

      var inHtml = "<div>名称：" + item.name + "</div>" + "<div>地址：" + item.address + "</div>" + "<div>区域：" + item.pname + item.cityname + item.adname + "</div>" + "<div>类别：" + item.type + "</div>";
      return inHtml;
    }, {
      anchor: [0, -10]
    });

    return _this;
  } //========== 对外属性 ==========

  /**
   * 获取配置的高德Key（多个时轮询）
   *
   * @type {String}
   * @readonly
   */


  createClass_default()(GeodePoiLayer, [{
    key: "key",
    get: function get() {
      var thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx];
    }
    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @param {Function} callback 数据获取完成后调用该回调方法。如:callback(grid, arrdata)
     * @return {void}  无
     * @private
     */

  }, {
    key: "queryGridData",
    value: function queryGridData(grid, callback) {
      var jwd1 = PointTrans["wgs2gcj"]([grid.extent.xmin, grid.extent.ymax]); //加偏

      var jwd2 = PointTrans["wgs2gcj"]([grid.extent.xmax, grid.extent.ymin]); //加偏

      var polygon = jwd1[0] + "," + jwd1[1] + "|" + jwd2[0] + "," + jwd2[1];
      var filter = this.options.filter || {};
      filter.output = "json";
      filter.key = this.key;
      filter.polygon = polygon;

      if (!filter.offset) {
        filter.offset = 25;
      }

      if (!filter.types) {
        filter.types = "120000|130000|190000";
      } //查询POI服务


      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GeodePoiLayer_objectSpread({
        url: "https://restapi.amap.com/v3/place/polygon",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          Object(Log["logError"])("POI 请求失败", data);
          callback(grid, []);
          return;
        }

        var arrdata = data.pois;
        callback(grid, arrdata);
      })["catch"](function (error) {
        Object(Log["logError"])("POI 请求出错", error);
      });
    }
    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} attr 数据的属性信息
     * @return {Graphic}  矢量对象
     * @private
     */

  }, {
    key: "createGraphic",
    value: function createGraphic(grid, attr) {
      var _this$options$cluster;

      var arrjwd = attr.location.split(",");
      arrjwd = PointTrans["gcj2wgs"](arrjwd); //纠偏

      var style = Object(Util["getSymbolStyle"])(this.options.symbol, attr);
      style.clampToGround = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.clampToGround, true);
      var graphic;

      if ((_this$options$cluster = this.options.clustering) !== null && _this$options$cluster !== void 0 && _this$options$cluster.enabled) {
        //当存在聚合时
        if (style.image) {
          graphic = new BillboardEntity_BillboardEntity({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        } else {
          graphic = new PointEntity_PointEntity({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        }
      } else {
        if (style.image) {
          graphic = new BillboardPrimitive_BillboardPrimitive({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        } else {
          graphic = new PointPrimitive_PointPrimitive({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        }
      }

      this.addGraphic(graphic);
      return graphic;
    }
  }]);

  return GeodePoiLayer;
}(LodGraphicLayer_LodGraphicLayer); //注册下

Object(LayerUtil["register"])("gaodePOI", GeodePoiLayer_GeodePoiLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/WfsLayer.js








function WfsLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function WfsLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { WfsLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { WfsLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function WfsLayer_createSuper(Derived) { var hasNativeReflectConstruct = WfsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function WfsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * WFS图层
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {String} options.url WFS服务地址
 * @param {String} options.layer 图层名称（命名空间:图层名称），多个图层名称用逗号隔开
 * @param {Object} [options.parameters] 要在URL中 传递给WFS服务GetFeature请求的其他参数。
 * @param {Object} [options.headers] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 *
 * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
 * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
 * @param {Object} options.rectangle 瓦片数据的矩形区域范围
 * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
 * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
 * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
 * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
 * @param {Number[]} options.bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 * @param {Object} [options.dth] 标识当前图层为单体化类型数据
 * @param {String} [options.dth.type='mouseMove'] 标识是鼠标移入还是单击进行展示单体化面 , 可选值： 'click'、'mouseMove'
 * @param {String} [options.dth.color='rgba(0,255,0,0.3)'] 单体化面的颜色
 * @param {Number} [options.dth.buffer] 缓冲扩大面的范围（单位：米）
 *
 * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
 * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
 * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
 * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
 *
 *
 * @param {Object} options.clustering 设置聚合相关参数[entity点类型时]：
 * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
 * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
 * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
 * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
 * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
 * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
 * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
 * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
 *
 * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
 * @param {GraphicType} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
 * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 *
 * @export
 * @class WfsLayer
 * @extends {LodGraphicLayer}
 * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
 */

var WfsLayer_WfsLayer = /*#__PURE__*/function (_LodGraphicLayer) {
  inherits_default()(WfsLayer, _LodGraphicLayer);

  var _super = WfsLayer_createSuper(WfsLayer);

  function WfsLayer() {
    classCallCheck_default()(this, WfsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(WfsLayer, [{
    key: "_mountedHook",
    value:
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      get_default()(getPrototypeOf_default()(WfsLayer.prototype), "_mountedHook", this).call(this);

      this.getMetadata();
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this = this;

      //请求的wfs参数
      var parameters = {
        service: "WFS",
        request: "GetCapabilities",
        version: "1.0.0"
      };
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchXML(WfsLayer_objectSpread(WfsLayer_objectSpread({}, this.options), {}, {
        queryParameters: parameters
      })).then(function (data) {
        if (!data || _this.isDestroy) {
          return;
        }

        _this.capabilities = data;

        try {
          _this._initByMetaData(data);
        } catch (e) {
          Object(Log["logInfo"])("解析GetCapabilities出错", e);
        }

        _this.fire(EventType.loadConfig, data);
      })["catch"](function (error) {
        Object(Log["logInfo"])("wfs请求GetCapabilities出错", error);
      });
    } //根据服务配置信息，加一些处理

  }, {
    key: "_initByMetaData",
    value: function _initByMetaData(data) {
      var featureTypeList = this._readChildNode(data, "FeatureTypeList");

      var featureType = featureTypeList.getElementsByTagName("FeatureType");

      for (var i = 0, len = featureType.length; i < len; i++) {
        var item = featureType[i];

        var layerName = this._readChildNodeVal(item, "Name");

        if (layerName == this.options.layer) {
          var crs = this._readChildNodeVal(item, "SRS");

          if (!this.options.crs && crs) {
            this.options.crs = crs;
          }

          var bbox = this._readChildNode(item, "LatLongBoundingBox");

          if (!this.options.rectangle && bbox) {
            var xmin = Number(bbox.getAttribute("minx"));
            var ymin = Number(bbox.getAttribute("miny"));
            var xmax = Number(bbox.getAttribute("maxx"));
            var ymax = Number(bbox.getAttribute("maxy"));
            var _extent = {
              xmin: xmin,
              ymin: ymin,
              xmax: xmax,
              ymax: ymax
            };

            if (this.options.crs !== CRS["a" /* CRS */].EPSG4326 && this.options.crs !== CRS["a" /* CRS */].EPSG4490) {
              var ptMin = Object(PointTrans["proj4Trans"])([_extent.xmin, _extent.ymin], this.options.crs);
              var ptMax = Object(PointTrans["proj4Trans"])([_extent.xmax, _extent.ymax], this.options.crs);
              _extent = {
                xmin: ptMin[0],
                ymin: ptMin[1],
                xmax: ptMax[0],
                ymax: ptMax[1]
              };
            }

            this.options.extent = _extent;
            this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);

            if (this._tileLayer) {
              this._tileLayer.rectangle = this._rectangle;
            }

            if (this.options.flyTo) {
              this.flyToByAnimationEnd();
            }
          }

          break;
        }
      }
    }
  }, {
    key: "_readChildNode",
    value: function _readChildNode(node, tagName) {
      var tagChildNodes = node.getElementsByTagName(tagName);

      if (tagChildNodes.length > 0) {
        return tagChildNodes[0];
      } else {
        return null;
      }
    }
  }, {
    key: "_readChildNodeVal",
    value: function _readChildNodeVal(node, tagName) {
      var childNode = this._readChildNode(node, tagName);

      if (childNode !== null && childNode !== void 0 && childNode.innerHTML) {
        return childNode.innerHTML;
      } else if (childNode !== null && childNode !== void 0 && childNode.getInnerHTML) {
        return childNode.getInnerHTML();
      } else {
        return null;
      }
    }
    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @param {Function} callback 数据获取完成后调用该回调方法。如:callback(grid, arrdata)
     * @return {void}  无
     * @private
     */

  }, {
    key: "queryGridData",
    value: function queryGridData(grid, callback) {
      var that = this;
      var bbox;

      if (this.options.crs !== CRS["a" /* CRS */].EPSG4326 && this.options.crs !== CRS["a" /* CRS */].EPSG4490) {
        var ptMin = Object(PointTrans["proj4Trans"])([grid.extent.xmin, grid.extent.ymin], "EPSG:4326", this.options.crs);
        var ptMax = Object(PointTrans["proj4Trans"])([grid.extent.xmax, grid.extent.ymax], "EPSG:4326", this.options.crs);
        bbox = ptMin[0] + "," + ptMin[1] + "," + ptMax[0] + "," + ptMax[1];
      } else {
        bbox = grid.extent.xmin + "," + grid.extent.ymin + "," + grid.extent.xmax + "," + grid.extent.ymax;
      } //请求的wfs参数


      var parameters = {
        service: "WFS",
        request: "GetFeature",
        typeName: this.options.layer || this.options.typeName,
        version: "1.0.0",
        outputFormat: "application/json",
        srsName: this.options.crs || "EPSG:4326",
        bbox: bbox
      }; //其他可选参数

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.parameters)) {
        for (var key in this.options.parameters) {
          if (key == "cql_filter") {
            delete parameters.bbox;
            parameters[key] = this.options.parameters[key] + " and BBOX(geometry, " + bbox + ")";
          } else {
            parameters[key] = this.options.parameters[key];
          }
        }
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(WfsLayer_objectSpread(WfsLayer_objectSpread({}, this.options), {}, {
        queryParameters: parameters
      })).then(function (featureCollection) {
        if (!that._show || !that._cacheGrid[grid.key]) {
          callback(grid, []);
          return; //异步请求结束时,如果已经卸载了网格就直接跳出。
        }

        if (featureCollection == undefined || featureCollection == null) {
          callback(grid, []);
          return; //数据为空
        }

        if (featureCollection.type == "Feature") {
          featureCollection = {
            type: "FeatureCollection",
            features: [featureCollection]
          };
        }

        callback(grid, featureCollection.features);
      })["catch"](function (error) {
        Object(Log["logError"])("wfs请求GetFeature出错", error);
      });
    }
    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} item 数据的属性信息，当前是geojson
     * @return {Graphic}  矢量对象
     * @private
     */

  }, {
    key: "createGraphic",
    value: function createGraphic(grid, item) {
      var _this$options$dth;

      var arr = this.loadGeoJSON(item, {
        clear: false,
        flyTo: false,
        buffer: ((_this$options$dth = this.options.dth) === null || _this$options$dth === void 0 ? void 0 : _this$options$dth.buffer) || 0
      });

      if ((arr === null || arr === void 0 ? void 0 : arr.length) > 0) {
        return arr[0];
      } else {
        return null;
      }
    }
  }]);

  return WfsLayer;
}(LodGraphicLayer_LodGraphicLayer); //注册下

Object(LayerUtil["register"])("wfs", WfsLayer_WfsLayer);
// EXTERNAL MODULE: ./node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js
var t_arcgis_esm = __webpack_require__(21);

// CONCATENATED MODULE: ./src/layer/graphicLayer/ArcGisWfsLayer.js








function ArcGisWfsLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ArcGisWfsLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ArcGisWfsLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ArcGisWfsLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ArcGisWfsLayer_createSuper(Derived) { var hasNativeReflectConstruct = ArcGisWfsLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ArcGisWfsLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * ArcGIS WFS服务图层，
 * 按瓦片网格分块分层加载。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 *
 * @param {String} options.url ArcGIS服务地址, 示例：'http://server.mars3d.cn/arcgis/rest/services/mars/hefei/MapServer/37',
 * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
 * @param {String} [options.where] 用于筛选数据的where查询条件
 * @param {Number} [options.wkid] 当非标准EPSG标号时，可以指定wkid值。
 *
 * @param {Object} [options.parameters] 要在URL中 传递给WFS服务GetFeature请求的其他参数。
 * @param {Object} [options.headers] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 *
 * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称,默认读取 id或objectid或OBJECTID
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
 * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
 * @param {Object} options.rectangle 瓦片数据的矩形区域范围
 * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
 * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
 * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
 * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
 * @param {Number[]} options.bbox bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
 * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
 *
 *
 * @param {Object} [options.dth] 标识当前图层为单体化类型数据
 * @param {String} [options.dth.type='mouseMove'] 标识是鼠标移入还是单击进行展示单体化面 , 可选值： 'click'、'mouseMove'
 * @param {String} [options.dth.color='#ffff00'] 单体化面的颜色
 * @param {Number} [options.dth.opacity=0.3] 单体化面的透明度
 * @param {Number} [options.dth.buffer] 缓冲扩大面的范围（单位：米）
 *
 * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
 * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
 * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
 * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
 *
 * @param {Object} options.clustering 设置聚合相关参数[entity点类型时]：
 * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
 * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
 * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
 * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
 * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
 * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
 * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
 * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
 *
 * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
 * @param {GraphicType} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
 * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
 *
 * @export
 * @class ArcGisWfsLayer
 * @extends {LodGraphicLayer}
 * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
 * @see [支持的事件类型]{@link ArcGisLayer.EventType}
 */

var ArcGisWfsLayer_ArcGisWfsLayer = /*#__PURE__*/function (_LodGraphicLayer) {
  inherits_default()(ArcGisWfsLayer, _LodGraphicLayer);

  var _super = ArcGisWfsLayer_createSuper(ArcGisWfsLayer);

  function ArcGisWfsLayer() {
    classCallCheck_default()(this, ArcGisWfsLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ArcGisWfsLayer, [{
    key: "_mountedHook",
    value:
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      get_default()(getPrototypeOf_default()(ArcGisWfsLayer.prototype), "_mountedHook", this).call(this);

      this.getMetadata();
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this = this;

      var url = this.options.url;

      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      } //请求的wfs参数


      var parameters = {
        f: "json"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(ArcGisWfsLayer_objectSpread(ArcGisWfsLayer_objectSpread({}, this.options), {}, {
        url: url,
        queryParameters: parameters
      })).then(function (data) {
        if (!data || _this.isDestroy) {
          return;
        }

        _this._initByMetaData(data);

        _this.fire(EventType.loadConfig, data);
      })["catch"](function (error) {
        Object(Log["logInfo"])("wfs请求getMetadata出错", error);
      });
    } //根据服务配置信息，加一些处理

  }, {
    key: "_initByMetaData",
    value: function _initByMetaData(data) {
      this.metaData = data;

      var _extent = data.fullExtent || data.extent;

      if (!this.options.rectangle && _extent) {
        var _extent2, _extent2$spatialRefer;

        var wkid = ((_extent2 = _extent) === null || _extent2 === void 0 ? void 0 : (_extent2$spatialRefer = _extent2.spatialReference) === null || _extent2$spatialRefer === void 0 ? void 0 : _extent2$spatialRefer.wkid) || this.options.wkid;

        if (wkid) {
          if (!this.options.wkid) {
            this.options.wkid = wkid;
          }
        }

        if (this.options.wkid) {
          var crs = "EPSG:" + this.options.wkid;

          if (crs !== CRS["a" /* CRS */].EPSG4326 && crs !== CRS["a" /* CRS */].EPSG4490) {
            var ptMin = Object(PointTrans["proj4Trans"])([_extent.xmin, _extent.ymin], crs);
            var ptMax = Object(PointTrans["proj4Trans"])([_extent.xmax, _extent.ymax], crs);
            _extent = {
              xmin: ptMin[0],
              ymin: ptMin[1],
              xmax: ptMax[0],
              ymax: ptMax[1]
            };
          }

          this.options.extent = _extent;
          this._rectangle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);

          if (this._tileLayer) {
            this._tileLayer.rectangle = this._rectangle;
          }

          if (this.options.flyTo) {
            this.flyToByAnimationEnd();
          }
        }
      }
    }
    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @param {Function} callback 数据获取完成后调用该回调方法。如:callback(grid, arrdata)
     * @return {void}  无
     * @private
     */

  }, {
    key: "queryGridData",
    value: function queryGridData(grid, callback) {
      var _this2 = this;

      var url = this.options.url;

      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      } //请求的wfs参数


      var parameters = {
        f: "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: this.options.where || "1=1",
        geometry: JSON.stringify({
          xmin: grid.extent.xmin,
          ymin: grid.extent.ymin,
          xmax: grid.extent.xmax,
          ymax: grid.extent.ymax,
          spatialReference: {
            wkid: 4326
          }
        }),
        geometryType: "esriGeometryEnvelope",
        //矩形边界
        spatialRel: "esriSpatialRelIntersects" //包含或交叉关系

      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(ArcGisWfsLayer_objectSpread(ArcGisWfsLayer_objectSpread({}, this.options), {}, {
        url: url + "/query",
        queryParameters: parameters
      })).then(function (result) {
        if (!_this2.show || !_this2._cacheGrid[grid.key]) {
          callback(grid, []);
          return; //异步请求结束时,如果已经卸载了网格就直接跳出。
        }

        if (result == undefined || result == null) {
          callback(grid, []);
          return; //数据为空
        }

        var featureCollection = Object(t_arcgis_esm["a" /* arcgisToGeoJSON */])(result);

        if (featureCollection.type == "Feature") {
          featureCollection = {
            type: "FeatureCollection",
            features: [featureCollection]
          };
        }

        callback(grid, featureCollection.features);
      })["catch"](function (error) {
        Object(Log["logError"])("wfs请求出错", error);
      });
    } //获取数据的唯一标识

  }, {
    key: "_getItemDataId",
    value: function _getItemDataId(item) {
      var _this$metaData, _this$metaData$fields;

      if (item.id) {
        return item.id;
      }

      if (item.type == "Feature") {
        item = item.properties;
      }

      if (item[this.options.IdField]) {
        return item[this.options.IdField];
      }

      if (item.OBJECTID) {
        return item.OBJECTID;
      }

      if (item.objectid) {
        return item.objectid;
      }

      if (((_this$metaData = this.metaData) === null || _this$metaData === void 0 ? void 0 : (_this$metaData$fields = _this$metaData.fields) === null || _this$metaData$fields === void 0 ? void 0 : _this$metaData$fields.length) > 0) {
        var IdField = this.metaData.fields[0].name;

        if (item[IdField]) {
          return item[IdField];
        }
      }

      return null;
    }
    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} item 数据的属性信息，当前是geojson
     * @return {Graphic}  矢量对象
     * @private
     */

  }, {
    key: "createGraphic",
    value: function createGraphic(grid, item) {
      var _this$options$dth;

      if (this.options.createGraphic) {
        return this.options.createGraphic(grid, item); //传参方式
      }

      var arr = this.loadGeoJSON(item, {
        clear: false,
        flyTo: false,
        buffer: ((_this$options$dth = this.options.dth) === null || _this$options$dth === void 0 ? void 0 : _this$options$dth.buffer) || 0
      });

      if ((arr === null || arr === void 0 ? void 0 : arr.length) > 0) {
        return arr[0];
      } else {
        return null;
      }
    }
    /**
     * 更新where条件后 刷新数据
     *
     * @param {String} where 筛选条件
     * @return {void}  无
     */

  }, {
    key: "setWhere",
    value: function setWhere(where) {
      this.options.where = where;
      this.reload();
    }
  }]);

  return ArcGisWfsLayer;
}(LodGraphicLayer_LodGraphicLayer); //注册下

Object(LayerUtil["register"])("arcgis_wfs", ArcGisWfsLayer_ArcGisWfsLayer);
// CONCATENATED MODULE: ./src/layer/graphicLayer/ArcGisWfsSingleLayer.js







function ArcGisWfsSingleLayer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ArcGisWfsSingleLayer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ArcGisWfsSingleLayer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ArcGisWfsSingleLayer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ArcGisWfsSingleLayer_createSuper(Derived) { var hasNativeReflectConstruct = ArcGisWfsSingleLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ArcGisWfsSingleLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * ArcGIS WFS服务图层，
 * 一次性请求加载，适合少量数据时使用。
 *
 * @param {Object} options 参数对象，包括以下：
 *
 * @param {String} options.url ArcGIS服务地址, 示例：'http://server.mars3d.cn/arcgis/rest/services/mars/hefei/MapServer/37',
 * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
 * @param {String} [options.where] 用于筛选数据的where查询条件
 *
 * @param {BaseGraphicLayer.ConstructorOptions} [options.通用参数] 包含父类支持的所有参数
 * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
 * @param {Object} [options.dth] 标识当前图层为单体化类型数据
 * @param {String} [options.dth.type='mouseMove'] 标识是鼠标移入还是单击进行展示单体化面 , 可选值： 'click'、'mouseMove'
 * @param {String} [options.dth.color='#ffff00'] 单体化面的颜色
 * @param {Number} [options.dth.opacity=0.3] 单体化面的透明度
 * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
 * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
 * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
 * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
 *
 * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
 * @param {BillboardEntity.StyleOptions} options.symbol.styleOptions 点数据时的Style样式，可以附加 model {@link ModelEntity.StyleOptions} 或 point {@link PointEntity.StyleOptions}
 * @param {PolylineEntity.StyleOptions} options.symbol.styleOptions 线数据时的Style样式，可以附加 corridor {@link CorridorEntity.StyleOptions}
 * @param {PolygonEntity.StyleOptions} options.symbol.styleOptions 面数据时的Style样式
 * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
 * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
 * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
 * @export
 * @class ArcGisWfsSingleLayer
 * @extends {GeoJsonLayer}
 */

var ArcGisWfsSingleLayer_ArcGisWfsSingleLayer = /*#__PURE__*/function (_GeoJsonLayer) {
  inherits_default()(ArcGisWfsSingleLayer, _GeoJsonLayer);

  var _super = ArcGisWfsSingleLayer_createSuper(ArcGisWfsSingleLayer);

  function ArcGisWfsSingleLayer() {
    classCallCheck_default()(this, ArcGisWfsSingleLayer);

    return _super.apply(this, arguments);
  }

  createClass_default()(ArcGisWfsSingleLayer, [{
    key: "load",
    value: function load() {
      var _this = this;

      var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = ArcGisWfsSingleLayer_objectSpread(ArcGisWfsSingleLayer_objectSpread({}, this.options), newOptions);
      var url = this.options.url;

      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      } //请求的wfs参数


      var parameters = {
        f: "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: this.options.where || "1=1"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(ArcGisWfsSingleLayer_objectSpread(ArcGisWfsSingleLayer_objectSpread({}, this.options), {}, {
        url: url + "/query",
        queryParameters: parameters
      })).then(function (result) {
        if (!result) {
          _this.fire(EventType.load);

          return; //数据为空
        }

        var featureCollection = Object(t_arcgis_esm["a" /* arcgisToGeoJSON */])(result);

        _this._load_data(featureCollection);
      })["catch"](function (error) {
        Object(Log["logError"])("wfs请求出错", error);
      });
    }
    /**
     * 更新where条件后 刷新数据
     *
     * @param {String} where 筛选条件
     * @return {void}  无
     */

  }, {
    key: "setWhere",
    value: function setWhere(where) {
      this.load({
        where: where
      });
    }
  }]);

  return ArcGisWfsSingleLayer;
}(GeoJsonLayer_GeoJsonLayer); //注册下

Object(LayerUtil["register"])("arcgis_wfs_single", ArcGisWfsSingleLayer_ArcGisWfsSingleLayer);
// CONCATENATED MODULE: ./src/layer/index.js








































 //常用方法的第2入口


// CONCATENATED MODULE: ./src/thing/analysis/Underground.js






function Underground_createSuper(Derived) { var hasNativeReflectConstruct = Underground_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Underground_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 地下模式类
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.alpha = 0.5] 透明度  0.0-1.0
 * @param {Color} [options.color = Cesium.Color.BLAC] 当相机在地下或球体是半透明时，渲染球体背面的颜色
 *
 * @export
 * @class Underground
 * @extends {BaseThing}
 */

var Underground_Underground = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Underground, _BaseThing);

  var _super = Underground_createSuper(Underground);

  function Underground() {
    classCallCheck_default()(this, Underground);

    return _super.apply(this, arguments);
  }

  createClass_default()(Underground, [{
    key: "translucency",
    get:
    /**
     * 控制球体透明度的Cesium内部对象
     * @type {Cesium.GlobeTranslucency}
     * @readonly
     */
    function get() {
      return this._map.scene.globe.translucency;
    }
    /**
     * 透明度
     * @type {Number}
     */

  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = val;

      if (!this._map) {
        return;
      }

      this.translucency.frontFaceAlphaByDistance.nearValue = this._alpha;
      this.translucency.frontFaceAlphaByDistance.farValue = this._alpha;
    }
    /**
     * 当相机在地下或球体是半透明时，渲染球体背面的颜色，将根据相机的距离与地球颜色混合。
     * 禁用地下着色时，可以设置为undefined。
     *
     * @type {Cesium.Color}
     */

  }, {
    key: "color",
    get: function get() {
      return this._map.scene.globe.undergroundColor;
    },
    set: function set(val) {
      this._map.scene.globe.undergroundColor = val;
    }
    /**
     * 获取或设置将color与Globe颜色混合的远近距离。
     * alpha将插值在{@link Cesium.NearFarScalar#nearValue}和{@linkCesium.NearFarScalar#farValue}之间，
     * 同时摄像机距离在指定的{@link Cesium.NearFarScalar#near}和{@link Cesium.NearFarScalar#far}的上下边界内。
     * 在这些范围之外，alpha仍然被限制在最近的范围内。如果未定义，地下颜色将不会与地球颜色混合。
     * 当相机在椭球上方时，距离计算从椭球上最近的点而不是相机的位置。
     *
     * @type {Cesium.NearFarScalar}
     */

  }, {
    key: "colorAlphaByDistance",
    get: function get() {
      return this._map.scene.globe.undergroundColorAlphaByDistance;
    },
    set: function set(val) {
      this._map.scene.globe.undergroundColorAlphaByDistance = val;
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(value) {
      if (!this._map) {
        return;
      }

      this._map.scene.globe.depthTestAgainstTerrain = value ? true : this.depthTestOld;
      this._map.scene.screenSpaceCameraController.enableCollisionDetection = !value; //相机对地形的碰撞检测状态

      this.translucency.enabled = value;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this.translucency.frontFaceAlphaByDistance = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["NearFarScalar"](100.0, 0.0, 900.0, 1.0);
      this.translucency.backFaceAlpha = 0;
      this.alpha = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.alpha, 0.5);
      this.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].BLACK);
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this.depthTestOld = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](this._map.scene.globe.depthTestAgainstTerrain);

      this._enabledHook(this.enabled);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.globe.depthTestAgainstTerrain = this.depthTestOld;

      this._enabledHook(false);
    }
  }]);

  return Underground;
}(BaseThing_BaseThing);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/ViewShed3D.glsl
var PostProcessStage_ViewShed3D = __webpack_require__(78);
var ViewShed3D_default = /*#__PURE__*/__webpack_require__.n(PostProcessStage_ViewShed3D);

// CONCATENATED MODULE: ./src/thing/analysis/ViewShed3D.js






function ViewShed3D_createSuper(Derived) { var hasNativeReflectConstruct = ViewShed3D_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ViewShed3D_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









/**
 * @typedef {Object} ViewShed3D.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 *
 * @property {String} drawStart  开始绘制
 * @property {String} drawAddPoint  绘制过程中增加了点
 * @property {String} drawMouseMove  正在移动鼠标中，绘制过程中鼠标移动了点
 * @property {String} drawCreated  完成绘制
 * @property {String} end  完成分析
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.end, function (event) {
 *   console.log('分析完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 可视域分析
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {LatLngPoint|Cesium.Cartesian3} [options.position] 视点位置，未传入值时自动激活鼠标绘制
 * @param {LatLngPoint|Cesium.Cartesian3} [options.cameraPosition] 相机位置
 *
 * @param {Number} [options.horizontalAngle = 120] 水平张角(度数)，取值范围 0-120
 * @param {Number} [options.verticalAngle = 90] 垂直张角(度数)，取值范围 0-90
 * @param {Cesium.Color} [options.visibleAreaColor =  new Cesium.Color(0, 1, 0, 1)] 可视区域颜色
 * @param {Cesium.Color} [options.hiddenAreaColor =  new Cesium.Color(1, 0, 0, 1)] 不可视区域颜色
 * @param {Number} [options.alpha = 0.5] 混合系数 0.0-1.0
 * @param {Number} [options.offsetHeight=1.5] 在起点增加的高度值，比如加上人的身高
 * @param {Boolean} [options.showFrustum=true] 是否显示视椎体框线
 *
 * @export
 * @class ViewShed3D
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link ViewShed3D.EventType}
 */

var ViewShed3D_ViewShed3D = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(ViewShed3D, _BaseThing);

  var _super = ViewShed3D_createSuper(ViewShed3D);

  //========== 构造方法 ==========
  function ViewShed3D() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ViewShed3D);

    _this = _super.call(this, options);
    _this._horizontalAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.horizontalAngle, 120); //水平张角

    _this._verticalAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.verticalAngle, 90); //垂直张角

    _this._visibleAreaColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.visibleAreaColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 1, 0)); //可视颜色

    _this._hiddenAreaColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.hiddenAreaColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 0, 0)); //不可视颜色

    _this._alpha = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.alpha, 0.5); //混合系数

    _this._offsetHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.offsetHeight, 1.5);
    _this._showFrustum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.showFrustum, true); //视椎体显示

    _this._maximumDistance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maximumDistance, 5000.0);
    return _this;
  } //========== 对外属性 ==========

  /**
   *  水平张角(度数)，取值范围 0-120
   * @type {Number}
   */


  createClass_default()(ViewShed3D, [{
    key: "horizontalAngle",
    get: function get() {
      return this._horizontalAngle;
    },
    set: function set(val) {
      this._horizontalAngle = val;

      if (this._rectangularSensor) {
        //传感器水平半角
        this._rectangularSensor.style = {
          xHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val / 2)
        };
      }
    }
    /**
     *  垂直张角(度数)，取值范围 0-90
     * @type {Number}
     */

  }, {
    key: "verticalAngle",
    get: function get() {
      return this._verticalAngle;
    },
    set: function set(val) {
      this._verticalAngle = val;

      if (this._rectangularSensor) {
        //传感器垂直半角
        this._rectangularSensor.style = {
          yHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(val / 2)
        };
      }
    }
    /**
     * 可视距离（单位：米）
     * @type {Number}
     */

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    },
    set: function set(val) {
      this._distance = val;

      if (this._rectangularSensor) {
        this._rectangularSensor.style = {
          radius: val
        };
      }
    }
    /**
     *  可视区域颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "visibleAreaColor",
    get: function get() {
      return this._visibleAreaColor;
    },
    set: function set(val) {
      this._visibleAreaColor = val;
    }
    /**
     *  不可视区域颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "hiddenAreaColor",
    get: function get() {
      return this._hiddenAreaColor;
    },
    set: function set(val) {
      this._hiddenAreaColor = val;
    }
    /**
     * 混合系数 0-1
     * @type {Number}
     */

  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = val;
    }
    /**
     * 是否显示视椎体框线
     * @type {Boolean}
     */

  }, {
    key: "showFrustum",
    get: function get() {
      return this._showFrustum;
    },
    set: function set(val) {
      this._showFrustum = val;

      if (this._rectangularSensor) {
        this._rectangularSensor.show = val;
      }
    }
    /**
     * 相机位置(笛卡尔坐标)
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "cameraPosition",
    get: function get() {
      return this._cameraPosition;
    },
    set: function set(value) {
      var _this$_cameraPoint;

      this._cameraPoint = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._cameraPosition = (_this$_cameraPoint = this._cameraPoint) === null || _this$_cameraPoint === void 0 ? void 0 : _this$_cameraPoint.toCartesian();

      this._updateDraw();
    }
    /**
     * 相机位置
     * @type {LatLngPoint}
     */

  }, {
    key: "cameraPoint",
    get: function get() {
      return this._cameraPoint;
    }
    /**
     * 视点位置 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */

  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      var _this$_point;

      this._point = LatLngPoint["a" /* LatLngPoint */].parse(value);
      this._position = (_this$_point = this._point) === null || _this$_point === void 0 ? void 0 : _this$_point.toCartesian();

      this._updateDraw();
    }
    /**
     * 视点位置
     * @type {LatLngPoint}
     * @readonly
     */

  }, {
    key: "point",
    get: function get() {
      return this._point;
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (val) {
        if (!this.postProcess) {
          this._addPostProcess();
        }
      } else {
        if (this.postProcess) {
          this._map.scene.postProcessStages.remove(this.postProcess);

          delete this.postProcess;
        }
      }

      if (this._rectangularSensor) {
        this._rectangularSensor.show = this._showFrustum && val;
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //默认材质
      this._defaultColorTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: this._map.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([0, 0, 0, 0])
        },
        flipY: false
      });
      this.graphicLayer = new GraphicLayer_GraphicLayer({
        name: "可视域边线",
        noLayerManage: true
      });
      this.graphicLayer._tudou3d_private = true;
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.addLayer(this.graphicLayer);

      this._map.viewer.terrainShadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].ENABLED;

      if (this.options.cameraPosition) {
        //相机位置
        this.cameraPosition = this.options.cameraPosition;
      }

      if (this.options.position) {
        //视点位置
        this.position = this.options.position;
      }

      if (this.cameraPosition && this.position) {
        this._addToScene();
      } else {
        this._bindMourseEvent();
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.terrainShadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].DISABLED;

      this._unbindMourseEvent();

      if (this.postProcess) {
        this._map.scene.postProcessStages.remove(this.postProcess);

        delete this.postProcess;
      }

      if (this._rectangularSensor) {
        this._rectangularSensor.remove();

        delete this._rectangularSensor;
      }

      this._map.removeLayer(this.graphicLayer);

      this._map.scene.primitives.remove(this);
    } //激活绑定事件

  }, {
    key: "_bindMourseEvent",
    value: function _bindMourseEvent() {
      this.fire(EventType.drawStart);

      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.setCursor(true);
    } //解绑事件

  }, {
    key: "_unbindMourseEvent",
    value: function _unbindMourseEvent() {
      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.setCursor(false);
    }
  }, {
    key: "_onClickHandler",
    value: function _onClickHandler(event) {
      var cartesian = event.cartesian;

      if (!cartesian) {
        return;
      }

      this.fire(EventType.drawAddPoint, event);

      if (!this._cameraPosition) {
        //相机位置
        cartesian = Object(PointUtil["addPositionsHeight"])(cartesian, this._offsetHeight); //加人的身高等因素，略微抬高一些

        this.cameraPosition = cartesian;
      } else if (this._cameraPosition && !this._position) {
        var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._cameraPosition, cartesian);

        if (len > 5000) {
          cartesian = Object(PointUtil["getOnLinePointByLen"])(this._cameraPosition, cartesian, 5000);
        }

        this.position = cartesian;

        this._addToScene();

        this._unbindMourseEvent();

        this.fire(EventType.drawCreated, event);
      }
    }
  }, {
    key: "_onMouseMoveHandler",
    value: function _onMouseMoveHandler(event) {
      var cartesian = event.cartesian;

      if (!cartesian) {
        return;
      }

      var cp = this._cameraPosition;

      if (cp) {
        var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(cp, cartesian);

        if (len > 5000) {
          len = 5000;
          cartesian = Object(PointUtil["getOnLinePointByLen"])(cp, cartesian, 5000);
        }

        this.frustumQuaternion = this.getFrustumQuaternion(cp, cartesian);
        this.distance = Number(len.toFixed(1));

        this._addRectangularSensor();

        this.fire(EventType.drawMouseMove, event);
      }
    }
  }, {
    key: "_updateDraw",
    value: function _updateDraw() {
      if (!this._map) {
        return;
      } // if (this.postProcess) {
      //   this._map.scene.postProcessStages.remove(this.postProcess)
      //   delete this.postProcess
      // }

    } //添加到场景里

  }, {
    key: "_addToScene",
    value: function _addToScene() {
      var scene = this._map.scene;
      var camera_pos = this._cameraPosition;
      var lookat_pos = this._position;
      this.frustumQuaternion = this.getFrustumQuaternion(camera_pos, lookat_pos);
      this.distance = Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(camera_pos, lookat_pos).toFixed(1));
      var lightCamera = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Camera"](scene);
      lightCamera.position = camera_pos;
      lightCamera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(lookat_pos, camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
      lightCamera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(camera_pos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
      lightCamera.frustum = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PerspectiveFrustum"]({
        fov: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(120),
        aspectRatio: scene.canvas.clientWidth / scene.canvas.clientHeight,
        near: 0.1,
        far: 5000
      }); //创建ShadowMap

      this.viewShadowMap = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMap"]({
        lightCamera: lightCamera,
        enabled: false,
        isPointLight: false,
        isSpotLight: true,
        cascadesEnabled: false,
        context: scene.context,
        pointLightRadius: this.distance,
        maximumDistance: this._maximumDistance
      });

      this._addPostProcess();

      this._addRectangularSensor();

      this._map.scene.primitives.add(this);

      this.fire(EventType.end, {
        distance: this.distance,
        cameraPosition: this._cameraPosition,
        position: this._position
      });
    } //添加雷达

  }, {
    key: "_addRectangularSensor",
    value: function _addRectangularSensor() {
      if (this._rectangularSensor) {
        this._rectangularSensor.orientation = this.frustumQuaternion;
        this._rectangularSensor.position = this._cameraPosition;
        return;
      }

      this._rectangularSensor = new RectangularSensor_RectangularSensor({
        position: this._cameraPosition,
        orientation: this.frustumQuaternion,
        style: {
          radius: this.distance,
          //传感器的半径
          xHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.horizontalAngle / 2),
          //传感器水平半角
          yHalfAngle: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this.verticalAngle / 2),
          //传感器垂直半角
          material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0.4),
          //目前用的统一材质
          lineColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 1.0, 1.0, 1.0),
          //线的颜色
          slice: 8,
          showScanPlane: false,
          //是否显示扫描面
          showThroughEllipsoid: false,
          //此参数控制深度检测，为false启用深度检测，可以解决雷达一半在地球背面时显示的问题
          showLateralSurfaces: false,
          showDomeSurfaces: false
        },
        show: this._showFrustum && this.enabled
      });
      this.graphicLayer.addGraphic(this._rectangularSensor);
    } //添加后处理

  }, {
    key: "_addPostProcess",
    value: function _addPostProcess() {
      var that = this;
      var bias = this.viewShadowMap._isPointLight ? this.viewShadowMap._pointBias : this.viewShadowMap._primitiveBias;
      this.postProcess = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: ViewShed3D_default.a,
        uniforms: {
          czzj: function czzj() {
            return that.verticalAngle;
          },
          dis: function dis() {
            return that.distance;
          },
          spzj: function spzj() {
            return that.horizontalAngle;
          },
          visibleColor: function visibleColor() {
            return that.visibleAreaColor;
          },
          disVisibleColor: function disVisibleColor() {
            return that.hiddenAreaColor;
          },
          mixNum: function mixNum() {
            return that.alpha;
          },
          tudouShadow: function tudouShadow() {
            return that.viewShadowMap._shadowMapTexture || that._defaultColorTexture;
          },
          _shadowMap_matrix: function _shadowMap_matrix() {
            return that.viewShadowMap._shadowMapMatrix;
          },
          shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
            return that.viewShadowMap._lightPositionEC;
          },
          shadowMap_lightPositionWC: function shadowMap_lightPositionWC() {
            return that.viewShadowMap._lightCamera.position;
          },
          shadowMap_lightDirectionEC: function shadowMap_lightDirectionEC() {
            return that.viewShadowMap._lightDirectionEC;
          },
          shadowMap_lightUp: function shadowMap_lightUp() {
            return that.viewShadowMap._lightCamera.up;
          },
          shadowMap_lightDir: function shadowMap_lightDir() {
            return that.viewShadowMap._lightCamera.direction;
          },
          shadowMap_lightRight: function shadowMap_lightRight() {
            return that.viewShadowMap._lightCamera.right;
          },
          shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
            var texelStepSize = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]();
            texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
            texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"].fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
          },
          shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
            return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"].fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
          },
          depthTexture1: function depthTexture1() {
            return that.getSceneDepthTexture(that._map.scene);
          }
        }
      });

      this._map.scene.postProcessStages.add(this.postProcess);
    }
  }, {
    key: "getSceneDepthTexture",
    value: function getSceneDepthTexture(scene) {
      var environmentState = scene._environmentState;
      var view = scene._view;
      var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;
      var globeFramebuffer = useGlobeDepthFramebuffer ? view.globeDepth.framebuffer : undefined;
      var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();
      var depthTexture = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](globeFramebuffer, sceneFramebuffer).depthStencilTexture; //对的
      // var depthTexture = scene._view.pickDepths[0]._depthTexture;
      // var depthTexture = scene._view.pickDepths[0]._textureToCopy;
      // var depthTexture = scene._view.pickDepths[0]._copyDepthCommand._framebuffer._colorTextures[0];
      // var depthTexture = this.wyypost&&this.wyypost._depthTexture?this.wyypost._depthTexture:scene.context.uniformState.globeDepthTexture;
      // var depthTexture = scene.context.uniformState.globeDepthTexture;//对的

      return depthTexture;
    } //获取四元数

  }, {
    key: "getFrustumQuaternion",
    value: function getFrustumQuaternion(cpos, position) {
      //获取相机四元数，用来调整视椎体摆放
      var direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(position, cpos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(cpos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var camera = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Camera"](this._map.scene);
      camera.position = cpos;
      camera.direction = direction;
      camera.up = up;
      direction = camera.directionWC;
      up = camera.upWC;
      var right = camera.rightWC;
      var scratchRight = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var scratchRotation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"]();
      var scratchOrientation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"](); // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());

      right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(right, scratchRight);
      var rotation = scratchRotation;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 0, right, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 1, up, rotation);
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix3"].setColumn(rotation, 2, direction, rotation); //计算视锥姿态

      var orientation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Quaternion"].fromRotationMatrix(rotation, scratchOrientation);
      return orientation;
    } //更新

  }, {
    key: "update",
    value: function update(frameState) {
      if (this.viewShadowMap) {
        frameState.shadowMaps.push(this.viewShadowMap);
      }
    }
  }]);

  return ViewShed3D;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/analysis/Sightline.js






function Sightline_createSuper(Derived) { var hasNativeReflectConstruct = Sightline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Sightline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * @typedef {Object} Sightline.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始分析
 * @property {String} end  完成分析
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.end, function (event) {
 *   console.log('分析完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 通视分析
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Cesium.Color} [options.visibleColor =  new Cesium.Color(0, 1, 0, 1)] 可视区域颜色
 * @param {Cesium.Color} [options.hiddenColor =  new Cesium.Color(1, 0, 0, 1)] 不可视区域颜色
 * @param {Cesium.Color} [options.depthFailColor] 当线位于地形或被遮挡时的区域颜色
 *
 * @export
 * @class Sightline
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link Sightline.EventType}
 */

var Sightline_Sightline = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Sightline, _BaseThing);

  var _super = Sightline_createSuper(Sightline);

  function Sightline() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Sightline);

    _this = _super.call(this, options);
    _this._visibleColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.visibleColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0, 1, 0, 1)); //可视区域

    _this._hiddenColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.hiddenColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1, 0, 0, 1)); //不可视区域

    _this._depthFailColor = options.depthFailColor;
    _this.lines = [];
    return _this;
  } //========== 对外属性 ==========

  /**
   *  可视区域颜色
   * @type {Cesium.Color}
   */


  createClass_default()(Sightline, [{
    key: "visibleColor",
    get: function get() {
      return this._visibleColor;
    },
    set: function set(val) {
      this._visibleColor = val;
    }
    /**
     *  不可视区域颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "hiddenColor",
    get: function get() {
      return this._hiddenColor;
    },
    set: function set(val) {
      this._hiddenColor = val;
    }
    /**
     *  当线位于地形或被遮挡时的区域颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "depthFailColor",
    get: function get() {
      return this._depthFailColor;
    },
    set: function set(val) {
      this._depthFailColor = val;
    } //========== 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {}
    /**
     * 添加通视分析
     *
     * @param { Cesium.Cartesian3} origin 起点（视点位置）
     * @param { Cesium.Cartesian3} target 终点（目标点位置）
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.offsetHeight=0] 在起点增加的高度值，比如加上人的身高
     * @return {Object} 分析结果
     */

  }, {
    key: "add",
    value: function add(origin, target) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (options.offsetHeight) {
        origin = Object(PointUtil["addPositionsHeight"])(origin, options.offsetHeight); //加人的身高
      }

      this.fire(EventType.start);
      var old_depthTestAgainstTerrain = this._map.scene.globe.depthTestAgainstTerrain;
      this._map.scene.globe.depthTestAgainstTerrain = true;
      var currDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(target, origin, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var currRay = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](origin, currDir);

      var pickRes = this._map.scene.drillPickFromRay(currRay, 2, this.lines);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickRes) && pickRes.length > 0 && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickRes[0]) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickRes[0].position)) {
        var position = pickRes[0].position;
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(origin, target);
        var distanceFx = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(origin, position);

        if (distanceFx < distance) {
          //存在正常分析结果
          var _arrEentity = this._showPolyline(origin, target, position);

          var _result = {
            block: true,
            //存在遮挡
            position: position,
            entity: _arrEentity
          };
          this.fire(EventType.end, _result);
          return _result;
        }
      }

      this._map.scene.globe.depthTestAgainstTerrain = old_depthTestAgainstTerrain;

      var arrEentity = this._showPolyline(origin, target);

      var result = {
        block: false,
        entity: arrEentity
      };
      this.fire(EventType.end, result);
      return result;
    }
    /**
     * 添加通视分析，插值异步分析
     *
     * @param { Cesium.Cartesian3} origin 起点
     * @param { Cesium.Cartesian3} target 终点（目标点）
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.offsetHeight=0] 在起点增加的高度值，比如加上人的身高
     * @param {Number} [options.splitNum=50] 插值数，等比分割的个数
     * @param {Number} [options.minDistance] 插值时的最小间隔(单位：米)，优先级高于splitNum
     * @return {void}  无,  分析结果在end事件中返回
     */

  }, {
    key: "addAsync",
    value: function addAsync(origin, target) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (options.offsetHeight) {
        origin = Object(PointUtil["addPositionsHeight"])(origin, options.offsetHeight); //加人的身高
      } //插值求新路线


      var positionsNew = interLine([origin, target], {
        splitNum: options.splitNum || 50,
        minDistance: options.minDistance
      });
      this.fire(EventType.start); //求对比的贴地地面高度

      computeSurfacePoints({
        map: this._map,
        positions: positionsNew,
        //需要计算的源路线坐标数组
        callback: function callback(raisedPositions, noHeight) {
          if (!noHeight) {
            for (var i = 0; i < positionsNew.length; i++) {
              var position = positionsNew[i];
              var xHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(position).height; //线高度

              var dHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(raisedPositions[i]).height; //地面高度

              if (xHeight <= dHeight) {
                var arrEentity = _this2._showPolyline(origin, target, position);

                _this2.fire(EventType.end, {
                  block: true,
                  //存在遮挡
                  position: position,
                  entity: arrEentity
                });

                return;
              }
            }
          }

          var arrEentity2 = _this2._showPolyline(origin, target);

          _this2.fire(EventType.end, {
            block: false,
            entity: arrEentity2
          });
        }
      });
    }
  }, {
    key: "_showPolyline",
    value: function _showPolyline(origin, target, position) {
      if (position) {
        //存在正常分析结果
        var entity1 = this._map.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
          polyline: {
            positions: [origin, position],
            width: 2,
            material: this._visibleColor,
            depthFailMaterial: this._depthFailColor
          }
        }));

        this.lines.push(entity1);

        var entity2 = this._map.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
          polyline: {
            positions: [position, target],
            width: 2,
            material: this._hiddenColor,
            depthFailMaterial: this._depthFailColor
          }
        }));

        this.lines.push(entity2);
        return [entity1, entity2];
      } else {
        //无正确分析结果时，直接返回
        var entity = this._map.entities.add(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]({
          polyline: {
            positions: [origin, target],
            width: 2,
            material: this._visibleColor,
            depthFailMaterial: this._depthFailColor
          }
        }));

        this.lines.push(entity);
        return [entity];
      }
    }
    /**
     *  清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      for (var i = 0, len = this.lines.length; i < len; i++) {
        this._map.entities.remove(this.lines[i]);
      }

      this.lines = [];
    }
  }]);

  return Sightline;
}(BaseThing_BaseThing);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Skyline.glsl
var PostProcessStage_Skyline = __webpack_require__(79);
var Skyline_default = /*#__PURE__*/__webpack_require__.n(PostProcessStage_Skyline);

// CONCATENATED MODULE: ./src/thing/analysis/Skyline.js







function Skyline_createSuper(Derived) { var hasNativeReflectConstruct = Skyline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Skyline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 天际线 描边
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Cesium.Color} [options.color =new Cesium.Color(1.0, 0.0, 0.0)] 边际线颜色
 * @param {Number} [options.width = 2] 天际线宽度
 *
 * @export
 * @class Skyline
 * @extends {BaseThing}
 */

var Skyline_Skyline = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Skyline, _BaseThing);

  var _super = Skyline_createSuper(Skyline);

  function Skyline() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Skyline);

    _this = _super.call(this, options);
    /**
     * 边际线颜色
     * @type {Cesium.Color}
     */

    _this.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](1.0, 0.0, 0.0));
    /**
     * 天际线宽度
     * @type {Number}
     */

    _this.width = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.width, 2); //以下参数不常用，未公开

    _this.strokeType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.strokeType, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](true, false, false)); //天际线，物体描边，全描边

    _this.bjColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.bjColor, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 1.0)); //物体描边颜色

    _this.distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.distance, 500); //物体描边距离

    return _this;
  }

  createClass_default()(Skyline, [{
    key: "_enabledHook",
    value: function _enabledHook(val) {
      this.postProcessStage.enabled = val;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var that = this;
      var camera = this._map.camera;
      this.postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Skyline_default.a,
        uniforms: {
          height: function height() {
            return camera.positionCartographic.height;
          },
          lineWidth: function lineWidth() {
            return that.width;
          },
          strokeType: function strokeType() {
            return that.strokeType;
          },
          tjxColor: function tjxColor() {
            return that.color;
          },
          bjColor: function bjColor() {
            return that.bjColor;
          },
          cameraPos: function cameraPos() {
            return camera.position;
          },
          mbDis: function mbDis() {
            return that.distance;
          }
        },
        enabled: this.enabled
      });
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.scene.postProcessStages.add(this.postProcessStage);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.postProcessStages.remove(this.postProcessStage);
    }
  }, {
    key: "destroy",
    value: function destroy(noDel) {
      if (this.postProcessStage) {
        this.postProcessStage.destroy();
        delete this.postProcessStage;
      }

      get_default()(getPrototypeOf_default()(Skyline.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return Skyline;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/analysis/Shadows.js






function Shadows_createSuper(Derived) { var hasNativeReflectConstruct = Shadows_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Shadows_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * @typedef {Object} Shadows.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} change 变化了
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('时间发送了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 日照分析
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @export
 * @class Shadows
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link Shadows.EventType}
 */

var Shadows_Shadows = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Shadows, _BaseThing);

  var _super = Shadows_createSuper(Shadows);

  function Shadows() {
    classCallCheck_default()(this, Shadows);

    return _super.apply(this, arguments);
  }

  createClass_default()(Shadows, [{
    key: "time",
    get:
    /**
     * 设置时间
     * @type {Date}
     */
    function get() {
      var currentTime = this._map.clock.currentTime;
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].toDate(currentTime);
    },
    set: function set(date) {
      this._map.clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(date);
      this.stop();
    }
    /**
     * 是否在播放
     * @type {Boolean}
     * @readonly
     */

  }, {
    key: "isStart",
    get: function get() {
      return this._map.clock.shouldAnimate;
    }
    /**
     * 倍速,控制速率
     * @type {Number}
     */

  }, {
    key: "multiplier",
    get: function get() {
      var _this$_map;

      return (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.multiplier;
    },
    set: function set(val) {
      this.options.multiplier = val;

      if (this._map) {
        this._map.clock.multiplier = val;
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (!this._map) {
        return;
      }

      this._map.viewer.shadows = val;
      this._map.viewer.terrainShadows = val ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].ENABLED : external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].DISABLED; //山体阴影

      this._map.scene.globe.enableLighting = val;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      //记录原始值
      this._last_startTime = this._map.clock.startTime;
      this._last_stopTime = this._map.clock.stopTime;
      this._last_shouldAnimate = this._map.clock.shouldAnimate;
      this._last_clockRange = this._map.clock.clockRange;
      this._last_multiplier = this._map.clock.multiplier;
      this._last_shadows = this._map.viewer.shadows; //记录原始值 end

      this._enabledHook(this.enabled);

      this._map.clock.shouldAnimate = false;
      this._map.clock.clockRange = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClockRange"].LOOP_STOP;
      this._map.clock.multiplier = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.multiplier, 1600);

      if (this.options.time) {
        this.time = this.options.time;
      }

      this._map.on(EventType.clockTick, this._onClockTickHanlder, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.clockTick, this._onClockTickHanlder, this);

      this._enabledHook(false);

      this._map.viewer.shadows = this._last_shadows;
      this._map.clock.clockRange = this._last_clockRange;
      this._map.clock.multiplier = this._last_multiplier;
      this._map.clock.shouldAnimate = this._last_shouldAnimate;
    }
  }, {
    key: "_onClockTickHanlder",
    value: function _onClockTickHanlder() {
      if (!this._map.clock.shouldAnimate) {
        return;
      }

      this.fire(EventType.change);
    }
    /**
     * 开始播放日照分析效果
     *
     * @param {Date} startDate 开始时间
     * @param {Date} endDate 结束时间
     * @param {Date} [currentTime=startDate] 当前所在时间
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start(startDate, endDate, currentTime) {
      if (!this._map) {
        return;
      }

      if (!startDate || !endDate || startDate >= endDate) {
        return;
      }

      this._map.clock.startTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(startDate);
      this._map.clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(currentTime || startDate);
      this._map.clock.stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(endDate);
      this._map.clock.shouldAnimate = true;
    }
    /**
     *  暂停
     * @return {void}  无
     */

  }, {
    key: "pause",
    value: function pause() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;
      }
    }
    /**
     *  继续
     * @return {void}  无
     */

  }, {
    key: "proceed",
    value: function proceed() {
      if (this._map) {
        this._map.clock.shouldAnimate = true;
      }
    }
    /**
     *  停止
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;
      }
    }
    /**
     *  清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.stop();
      this.currentTime = new Date();
      this._map.clock.startTime = this._last_startTime;
      this._map.clock.stopTime = this._last_stopTime;
    }
  }]);

  return Shadows;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/measure/MeasureBase.js








function MeasureBase_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureBase_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureBase_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureBase_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureBase_createSuper(Derived) { var hasNativeReflectConstruct = MeasureBase_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureBase_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //显示测量结果文本的字体

var defaultLabelStyle = {
  color: '#ffffff',
  font_size: 20,
  outline: true,
  outlineColor: '#000000',
  outlineWidth: 3,
  background: true,
  backgroundColor: '#000000',
  backgroundOpacity: 0.5,
  scaleByDistance: true,
  scaleByDistance_far: 800000,
  scaleByDistance_farValue: 0.5,
  scaleByDistance_near: 1000,
  scaleByDistance_nearValue: 1,
  pixelOffsetY: -15,
  visibleDepth: false //一直显示，不被地形等遮挡

};
/**
 * 单个测量对象的控制基类，
 * 非直接调用，由 Measure 类统一创建及管理
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
 *
 * @export
 * @class MeasureBase
 * @extends {BaseClass}
 */

var MeasureBase_MeasureBase = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(MeasureBase, _BaseClass);

  var _super = MeasureBase_createSuper(MeasureBase);

  //========== 构造方法 ==========
  function MeasureBase() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, MeasureBase);

    _this = _super.call(this, options); //文本样式

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.label)) {
      _this.labelStyle = MeasureBase_objectSpread(MeasureBase_objectSpread({}, defaultLabelStyle), options.label);
    } else {
      _this.labelStyle = MeasureBase_objectSpread({}, defaultLabelStyle);
    }

    return _this;
  }
  /**
   * 对应的矢量图层
   * @type {GraphicLayer}
   * @readonly
   */


  createClass_default()(MeasureBase, [{
    key: "graphicLayer",
    get: function get() {
      return this._graphicLayer;
    }
    /**
     * 加载Entity数据的内部Cesium容器
     * @type {Cesium.CustomDataSource}
     * @readonly
     */

  }, {
    key: "dataSource",
    get: function get() {
      return this._graphicLayer.dataSource;
    }
    /**
     * 图层内的Graphic集合对象
     *
     * @type {BaseGraphic[]}
     * @readonly
     */

  }, {
    key: "graphics",
    get: function get() {
      return this._graphicLayer.graphics;
    }
  }, {
    key: "_onAdd",
    value: function _onAdd(target) {
      this._target = target;
      this._map = target._map;
      this._graphicLayer = target.graphicLayer;

      this._bindEvent();
    }
  }, {
    key: "_onRemove",
    value: function _onRemove() {
      this._graphicLayer = null;
      this._map = null;
      this._target = null;
    } //抛出事件

  }, {
    key: "fire",
    value: function fire(type, data, propagate) {
      this._target.fire(type, data, propagate);

      return this;
    }
  }, {
    key: "_bindEvent",
    value: function _bindEvent() {
      var _this2 = this;

      //事件监听
      this._graphicLayer.on(EventType.drawAddPoint, function (event) {
        var graphic = event.graphic;

        if (graphic._measureType != _this2.type) {
          return;
        }

        _this2.graphic = graphic;

        _this2.showAddPointLength(graphic);
      });

      this._graphicLayer.on(EventType.drawRemovePoint, function (event) {
        if (event.graphic._measureType != _this2.type) {
          return;
        }

        _this2.showRemoveLastPointLength(event);
      });

      this._graphicLayer.on(EventType.drawMouseMove, function (event) {
        var graphic = event.graphic;

        if (graphic._measureType != _this2.type) {
          return;
        }

        _this2.graphic = graphic;

        _this2.showMoveDrawing(graphic);
      });

      this._graphicLayer.on(EventType.drawCreated, function (event) {
        var graphic = event.graphic;

        if (graphic._measureType != _this2.type) {
          return;
        }

        _this2.graphic = graphic;

        _this2.showDrawEnd(graphic);

        _this2.graphic = null;
      }); //编辑了线


      this._graphicLayer.on([EventType.editMovePoint, EventType.editRemovePoint], function (event) {
        var graphic = event.graphic;

        if (graphic._measureType != _this2.type) {
          return;
        }

        _this2.updateForEdit(graphic);
      }); //编辑中，拖动了点


      this._graphicLayer.on(EventType.editMouseMove, function (event) {
        var graphic = event.graphic;

        if (graphic._measureType != _this2.type) {
          return;
        }

        if (_this2.updateForEditMouseMove) {
          _this2.updateForEditMouseMove(graphic);
        }
      }); //连续标绘


      this._graphicLayer.on(EventType.drawCreated, function (event) {
        var _this2$_target, _this2$_target$option;

        var graphic = event.graphic;

        if (!((_this2$_target = _this2._target) !== null && _this2$_target !== void 0 && (_this2$_target$option = _this2$_target.options) !== null && _this2$_target$option !== void 0 && _this2$_target$option.isContinued) || graphic._measureType != _this2.type) {
          return;
        }

        _this2.startDraw(_this2.options);
      });
    }
  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(graphic) {}
  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(event) {}
  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {}
  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {}
  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {}
    /**
     * 开始绘制创建测量的矢量数据
     * @param {Object} options 控制参数，具体见子类实现
     * @return {void}  无
     */

  }, {
    key: "startDraw",
    value: function startDraw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = options || {};
      this.options.style = this.options.style || {};

      var graphic = this._startDraw(this.options);

      graphic._measureType = this.type;
    }
  }, {
    key: "_startDraw",
    value: function _startDraw() {}
    /**
     * 取消并停止绘制，如有未完成的绘制会自动删除
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      if (!this._graphicLayer) {
        return;
      }

      this.clearLastNoEnd();

      this._graphicLayer.stopDraw();

      return this;
    }
    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {void}  无
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (this.graphic) {
        var graphic = this.graphic;
        this.showMoveDrawing(graphic);

        this._graphicLayer.endDraw(); //会触发drawCreated


        this.graphic = null;
      }
    }
    /**
     * 清除测量
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.stopDraw();

      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }

      this.fire(EventType.remove, {
        measureType: this.type
      });
    }
  }, {
    key: "destroy",
    value: function destroy(noDel) {
      this.clear();

      get_default()(getPrototypeOf_default()(MeasureBase.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return MeasureBase;
}(BaseClass_BaseClass);
// CONCATENATED MODULE: ./src/thing/measure/MeasureAngle.js







function MeasureAngle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureAngle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureAngle_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureAngle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureAngle_createSuper(Derived) { var hasNativeReflectConstruct = MeasureAngle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureAngle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 // import { getPositionByDirectionAndLen } from '../../util/PointUtil'

 // import { PolylineEntity } from '../../graphic/entity/PolylineEntity'


var MeasureAngle_MeasureAngle = /*#__PURE__*/function (_MeasureBase) {
  inherits_default()(MeasureAngle, _MeasureBase);

  var _super = MeasureAngle_createSuper(MeasureAngle);

  function MeasureAngle() {
    classCallCheck_default()(this, MeasureAngle);

    return _super.apply(this, arguments);
  }

  createClass_default()(MeasureAngle, [{
    key: "type",
    get: //========== 构造方法 ==========
    function get() {
      return 'angle';
    } //清除未完成的数据

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      if (this.totalLable) {
        this.graphicLayer.removeGraphic(this.totalLable);
        this.totalLable = null;
      } // if (this.exLine) {
      //   this.graphicLayer.removeGraphic(this.exLine)
      //   this.exLine = null
      // }
      // if (this.exLine2) {
      //   this.graphicLayer.removeGraphic(this.exLine2)
      //   this.exLine2 = null
      // }

    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var map = this._map;
      var graphicLbl = new LabelEntity_LabelEntity({
        style: MeasureAngle_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
        }, this.labelStyle),
        attr: {
          unit: options.unit
        },
        show: false
      });
      graphicLbl._noMousePick = true;
      graphicLbl.hasEdit = false;

      graphicLbl.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var lenstr = formatDistance(this.attr.valueLen, this.attr.unit);
        this.text = map.getLangText('_角度') + ':' + this.attr.value + '°\n' + map.getLangText('_距离') + ':' + lenstr;
        return lenstr;
      };

      this.graphicLayer.addGraphic(graphicLbl);
      this.totalLable = graphicLbl;
      return this._graphicLayer.startDraw({
        type: 'polyline',
        maxPointNum: 2,
        hasMoveEdit: false,
        style: MeasureAngle_objectSpread({
          materialType: 'PolylineArrow',
          color: '#ebe967',
          width: 9,
          clampToGround: true
        }, options.style)
      });
    } //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(graphic) {
      this.showMoveDrawing(graphic); //兼容手机端
    } //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      // if (this.exLine) {
      //   this.graphicLayer.removeGraphic(this.exLine)
      //   this.exLine = null
      // }
      // if (this.exLine2) {
      //   this.graphicLayer.removeGraphic(this.exLine2)
      //   this.exLine2 = null
      // }
      if (this.totalLable) {
        this.totalLable.show = false;
      }
    } //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      var positions = graphic.positionsShow;

      if (positions.length < 2) {
        this.totalLable.show = false;
        return;
      } //求长度


      var len = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], positions[1]); //求方位角（正北为0）

      var bearing = getAngle(positions[0], positions[1], true); // this.updateExLine(graphic, positions[1], len) //参考线
      //显示文本

      this.totalLable.attr.value = bearing;
      this.totalLable.attr.valueLen = len;
      var lenstr = this.totalLable.showText();
      this.totalLable.position = positions[1];
      this.totalLable.show = true;
      this.fire(EventType.change, {
        mtype: this.type,
        value: bearing,
        label: lenstr,
        length: len
      });
    } // updateExLine(graphic, position, len) {
    //   //求参考点
    //   let radius = len * 0.3
    //   let dashPoint1 = getPositionByDirectionAndLen(position, 0, radius) //方向(正东方向为0,顺时针到360度)
    //   let dashPoint2 = getPositionByDirectionAndLen(position, 90, radius)
    //   let dashPoint3 = getPositionByDirectionAndLen(position, 180, radius)
    //   let dashPoint4 = getPositionByDirectionAndLen(position, 270, radius)
    //   if (this.exLine) {
    //     this.exLine._positions_draw = [dashPoint1, dashPoint3]
    //   } else {
    //     let exLine = new PolylineEntity({
    //       positions: [dashPoint1, dashPoint3],
    //       style: {
    //         width: 3,
    //         clampToGround: true,
    //         material: new Cesium.PolylineDashMaterialProperty({
    //           color: Cesium.Color.RED,
    //         }),
    //         ...this.options.styleEx,
    //       },
    //     })
    //     this.graphicLayer.addGraphic(exLine)
    //     exLine._setPositionsToCallback()
    //     exLine._target = graphic
    //     exLine.hasEdit = true
    //     this.exLine = exLine
    //   }
    //   if (this.exLine2) {
    //     this.exLine2._positions_draw = [dashPoint2, dashPoint4]
    //   } else {
    //     let exLine2 = new PolylineEntity({
    //       positions: [dashPoint1, dashPoint3],
    //       style: {
    //         width: 3,
    //         clampToGround: true,
    //         material: new Cesium.PolylineDashMaterialProperty({
    //           color: Cesium.Color.RED,
    //         }),
    //         ...this.options.styleEx,
    //       },
    //     })
    //     this.graphicLayer.addGraphic(exLine2)
    //     exLine2._setPositionsToCallback()
    //     exLine2._target = graphic
    //     exLine2.hasEdit = true
    //     this.exLine2 = exLine2
    //   }
    // }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      graphic._totalLable = this.totalLable;
      this.totalLable = null; // graphic.arrEntityEx = [this.exLine, this.exLine2]

      this.fire(EventType.end, {
        mtype: this.type,
        graphic: graphic,
        value: graphic._totalLable.attr.value
      });
    } //编辑修改后

  }, {
    key: "updateForEditMouseMove",
    value: function updateForEditMouseMove(graphic) {
      this.updateForEdit(graphic);
    }
  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      this.totalLable = graphic._totalLable; // this.exLine = graphic.arrEntityEx[0]

      this.showMoveDrawing(graphic);
      this.totalLable = null; // this.exLine = null
    }
  }]);

  return MeasureAngle;
}(MeasureBase_MeasureBase);
// CONCATENATED MODULE: ./src/thing/measure/MeasureArea.js







function MeasureArea_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureArea_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureArea_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureArea_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureArea_createSuper(Derived) { var hasNativeReflectConstruct = MeasureArea_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureArea_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * 测量面积 控制类，
 * 非直接调用，由 Measure 类统一创建及管理
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
 *
 * @export
 * @class MeasureArea
 * @extends {MeasureBase}
 */

var MeasureArea_MeasureArea = /*#__PURE__*/function (_MeasureBase) {
  inherits_default()(MeasureArea, _MeasureBase);

  var _super = MeasureArea_createSuper(MeasureArea);

  //========== 构造方法 ==========
  function MeasureArea(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasureArea);

    _this = _super.call(this, opts, target);
    _this.totalLable = null; //面积label

    return _this;
  }
  /**
   * 类型
   * @type {String}
   * @readonly
   */


  createClass_default()(MeasureArea, [{
    key: "type",
    get: function get() {
      return 'area';
    }
    /**
     * 清除未完成的数据
     * @return {void}  无
     */

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      if (this.totalLable != null) {
        this.graphicLayer.removeGraphic(this.totalLable);
      }

      this.totalLable = null;
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var map = this._map;
      var graphicLbl = new LabelEntity_LabelEntity({
        style: MeasureArea_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
        }, this.labelStyle),
        attr: {
          unit: options.unit
        },
        show: false
      });
      this.graphicLayer.addGraphic(graphicLbl);
      graphicLbl._noMousePick = true;
      graphicLbl.hasEdit = false;

      graphicLbl.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var areastr = formatArea(this.attr.value, this.attr.unit, map.lang);
        this.text = map.getLangText('_面积') + ':' + areastr;
        return areastr;
      };

      this.totalLable = graphicLbl;
      return this._graphicLayer.startDraw({
        type: 'polygon',
        hasMoveEdit: false,
        style: MeasureArea_objectSpread({
          color: '#00fff2',
          outline: true,
          outlineColor: '#fafa5a',
          outlineWidth: 1,
          opacity: 0.4,
          clampToGround: false
        }, options.style)
      });
    } //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(graphic) {
      this.showMoveDrawing(graphic); //兼容手机端
    } //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      var _e$graphic;

      var positions = (_e$graphic = e.graphic) === null || _e$graphic === void 0 ? void 0 : _e$graphic.positionsShow;

      if ((positions === null || positions === void 0 ? void 0 : positions.length) < 3) {
        this.totalLable.show = false;
      }
    } //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      var positions = graphic.positionsShow;

      if (positions.length < 3) {
        this.totalLable.show = false;
        return;
      }

      var area = getArea(positions);
      this.totalLable.attr.value = area;
      var areastr = this.totalLable.showText(); //求中心点

      var ptcenter = centerOfMass(positions);
      this.totalLable.position = ptcenter;
      this.totalLable.show = true;
      this.fire(EventType.change, {
        mtype: this.type,
        value: area,
        label: areastr
      });
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      var _graphic$_totalLable, _graphic$_totalLable$;

      if (graphic.type != 'polygon') {
        return;
      }

      graphic._totalLable = this.totalLable;
      this.totalLable = null;
      this.fire(EventType.end, {
        mtype: this.type,
        graphic: graphic,
        value: (_graphic$_totalLable = graphic._totalLable) === null || _graphic$_totalLable === void 0 ? void 0 : (_graphic$_totalLable$ = _graphic$_totalLable.attr) === null || _graphic$_totalLable$ === void 0 ? void 0 : _graphic$_totalLable$.value
      });
    } //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      var positions = graphic.positionsShow;
      var totalLable = graphic._totalLable;
      var area = getArea(positions);
      totalLable.attr.value = area;
      totalLable.position = centerOfMass(positions); //求中心点

      var areastr = totalLable.showText();
      this.fire(EventType.change, {
        mtype: this.type,
        value: area,
        label: areastr
      });
    }
  }]);

  return MeasureArea;
}(MeasureBase_MeasureBase);
// CONCATENATED MODULE: ./src/thing/measure/MeasureAreaSurface.js








function MeasureAreaSurface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureAreaSurface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureAreaSurface_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureAreaSurface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureAreaSurface_createSuper(Derived) { var hasNativeReflectConstruct = MeasureAreaSurface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureAreaSurface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





 //贴地线

var MeasureAreaSurface_MeasureAreaSurface = /*#__PURE__*/function (_MeasureArea) {
  inherits_default()(MeasureAreaSurface, _MeasureArea);

  var _super = MeasureAreaSurface_createSuper(MeasureAreaSurface);

  function MeasureAreaSurface() {
    classCallCheck_default()(this, MeasureAreaSurface);

    return _super.apply(this, arguments);
  }

  createClass_default()(MeasureAreaSurface, [{
    key: "type",
    get: function get() {
      return 'areaSurface';
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      options.style.clampToGround = true;
      return get_default()(getPrototypeOf_default()(MeasureAreaSurface.prototype), "_startDraw", this).call(this, options);
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      if (graphic.type != 'polygon') {
        return;
      }

      graphic._totalLable = this.totalLable;
      this.totalLable = null;
      this.updateAreaForTerrain(graphic);
    } //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      get_default()(getPrototypeOf_default()(MeasureAreaSurface.prototype), "updateForEdit", this).call(this, graphic);

      this.updateAreaForTerrain(graphic);
    } //计算贴地面

  }, {
    key: "updateAreaForTerrain",
    value: function updateAreaForTerrain(graphic) {
      var _this$_map,
          _this = this;

      //更新lable等
      var totalLable = graphic._totalLable;
      var thisCenter = Object(PointUtil["getPositionValue"])(totalLable.position, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime);
      var positions = graphic.positionsShow;
      this.fire(EventType.start, {
        mtype: this.type
      }); //贴地总面积

      getClampArea(positions, {
        scene: this._map.scene,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        asyn: true,
        //异步求准确的
        callback: function callback(area, resultInter) {
          if (!_this._target || !totalLable) {
            //异步结束时，对象已经被释放
            return;
          }

          if (thisCenter && resultInter !== null && resultInter !== void 0 && resultInter.maxHeight) {
            //更新lable高度
            totalLable.position = Object(PointUtil["setPositionsHeight"])(thisCenter, resultInter.maxHeight);
          }

          totalLable.attr.value = area;
          var areastr = totalLable.showText();

          _this.fire(EventType.change, {
            mtype: _this.type,
            value: area,
            label: areastr
          });

          _this.fire(EventType.end, MeasureAreaSurface_objectSpread(MeasureAreaSurface_objectSpread({}, resultInter), {}, {
            mtype: _this.type,
            graphic: graphic,
            value: area
          }));
        }
      });
    }
  }]);

  return MeasureAreaSurface;
}(MeasureArea_MeasureArea);
// CONCATENATED MODULE: ./src/thing/measure/MeasureHeight.js







function MeasureHeight_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureHeight_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureHeight_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureHeight_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureHeight_createSuper(Derived) { var hasNativeReflectConstruct = MeasureHeight_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureHeight_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var MeasureHeight_MeasureHeight = /*#__PURE__*/function (_MeasureBase) {
  inherits_default()(MeasureHeight, _MeasureBase);

  var _super = MeasureHeight_createSuper(MeasureHeight);

  //========== 构造方法 ==========
  function MeasureHeight(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasureHeight);

    _this = _super.call(this, opts, target);
    _this.totalLable = null; //高度label

    return _this;
  }

  createClass_default()(MeasureHeight, [{
    key: "type",
    get: function get() {
      return 'height';
    } //清除未完成的数据

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      if (this.totalLable != null) {
        this.graphicLayer.removeGraphic(this.totalLable);
      }

      this.totalLable = null;
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var graphicLbl = new LabelEntity_LabelEntity({
        style: MeasureHeight_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
        }, this.labelStyle),
        attr: {
          unit: options.unit
        }
      });
      this.graphicLayer.addGraphic(graphicLbl);
      this.totalLable = graphicLbl;
      this.totalLable._noMousePick = true;
      this.totalLable.hasEdit = false;
      var map = this._map;

      this.totalLable.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var heightstr = formatDistance(this.attr.value, this.attr.unit, map.lang);
        this.text = map.getLangText('_高度差') + ':' + heightstr;
        return heightstr;
      };

      return this._graphicLayer.startDraw({
        type: 'polyline',
        maxPointNum: 2,
        hasMoveEdit: false,
        style: MeasureHeight_objectSpread({
          materialType: 'PolylineGlow',
          glowPower: 0.1,
          color: '#ebe12c',
          width: 9
        }, options.style)
      });
    } //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(graphic) {
      this.showMoveDrawing(graphic); //兼容手机端
    } //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      if (this.totalLable) {
        this.totalLable.show = false;
      }
    } //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      var positions = graphic.positionsShow;

      if (positions.length < 2) {
        this.totalLable.show = false;
        return;
      }

      var cartographic = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[0]);
      var cartographic1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[1]);
      var height = Math.abs(cartographic1.height - cartographic.height); //绑定值及text显示

      this.totalLable.attr.value = height;
      var heightstr = this.totalLable.showText(); //位置

      this.totalLable.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(positions[0], positions[1], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      this.totalLable.show = true;
      this.fire(EventType.change, {
        mtype: this.type,
        value: height,
        label: heightstr
      });
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      graphic._totalLable = this.totalLable;
      this.totalLable = null;
      this.fire(EventType.end, {
        mtype: this.type,
        graphic: graphic,
        value: graphic._totalLable.attr.value
      });
    } //编辑修改后

  }, {
    key: "updateForEditMouseMove",
    value: function updateForEditMouseMove(graphic) {
      this.updateForEdit(graphic);
    }
  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      var positions = graphic.positionsShow;
      var totalLable = graphic._totalLable;
      var cartographic = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[0]);
      var cartographic1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[1]);
      var height = Math.abs(cartographic1.height - cartographic.height); //绑定值及text显示

      totalLable.attr.value = height;
      totalLable.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(positions[0], positions[1], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      var heightstr = totalLable.showText();
      this.fire(EventType.change, {
        mtype: this.type,
        value: height,
        label: heightstr
      });
    }
  }]);

  return MeasureHeight;
}(MeasureBase_MeasureBase);
// CONCATENATED MODULE: ./src/thing/measure/MeasureHeightTriangle.js








function MeasureHeightTriangle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureHeightTriangle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureHeightTriangle_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureHeightTriangle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureHeightTriangle_createSuper(Derived) { var hasNativeReflectConstruct = MeasureHeightTriangle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureHeightTriangle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







var MeasureHeightTriangle_MeasureHeightTriangle = /*#__PURE__*/function (_MeasureHeight) {
  inherits_default()(MeasureHeightTriangle, _MeasureHeight);

  var _super = MeasureHeightTriangle_createSuper(MeasureHeightTriangle);

  //========== 构造方法 ==========
  function MeasureHeightTriangle(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasureHeightTriangle);

    _this = _super.call(this, opts, target);
    _this.totalLable = null; //高度差label

    _this.xLable = null; //空间距离label

    _this.hLable = null; //水平距离label

    return _this;
  }

  createClass_default()(MeasureHeightTriangle, [{
    key: "type",
    get: function get() {
      return 'heightTriangle';
    } //清除未完成的数据

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      if (this.totalLable != null) {
        this.graphicLayer.removeGraphic(this.totalLable);
      }

      if (this.xLable != null) {
        this.graphicLayer.removeGraphic(this.xLable);
      }

      if (this.hLable != null) {
        this.graphicLayer.removeGraphic(this.hLable);
      }

      this.totalLable = null;
      this.xLable = null;
      this.hLable = null;
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var map = this._map;
      this.xLable = new LabelEntity_LabelEntity({
        style: MeasureHeightTriangle_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM,
          pixelOffset: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, 0)
        }, this.labelStyle),
        attr: {
          unit: options.unit
        }
      });
      this.graphicLayer.addGraphic(this.xLable);
      this.xLable._noMousePick = true;
      this.xLable.hasEdit = false;

      this.xLable.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var heightstr = formatDistance(this.attr.value, this.attr.unit, map.lang);
        this.text = map.getLangText('_空间距离') + ':' + heightstr;
        return heightstr;
      };

      this.hLable = new LabelEntity_LabelEntity({
        style: MeasureHeightTriangle_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM,
          pixelOffset: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](0, 0)
        }, this.labelStyle),
        attr: {
          unit: options.unit
        }
      });
      this.graphicLayer.addGraphic(this.hLable);
      this.hLable._noMousePick = true;
      this.hLable.hasEdit = false;

      this.hLable.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var heightstr = formatDistance(this.attr.value, this.attr.unit, map.lang);
        this.text = map.getLangText('_水平距离') + ':' + heightstr;
        return heightstr;
      };

      return get_default()(getPrototypeOf_default()(MeasureHeightTriangle.prototype), "_startDraw", this).call(this, options);
    } //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      if (this.totalLable) {
        this.totalLable.show = false;
      }

      if (this.hLable) {
        this.hLable.show = false;
      }

      if (this.xLable) {
        this.xLable.show = false;
      }

      if (this.exLine) {
        this.exLine._positions_draw = null;
      }
    } //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      var positions = graphic.positionsShow;

      if (positions.length < 2) {
        this.showRemoveLastPointLength();
        return;
      }

      var carto1 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[0]);
      var height1 = carto1.height;
      var carto2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[1]);
      var height2 = carto2.height;
      var bottomPosition; //三角底部点

      var zPosition; //三角底部点 对应的高处的点

      var topPosion; //三角的顶部点

      if (height1 > height2) {
        zPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto2.longitude, carto2.latitude, height1);
        topPosion = positions[0];
        bottomPosition = positions[1];
      } else {
        zPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(carto1.longitude, carto1.latitude, height2);
        topPosion = positions[1];
        bottomPosition = positions[0];
      } //显示三角行 线


      this.updateExLine([bottomPosition, zPosition, topPosion, bottomPosition], graphic); //参考线
      //[垂直方向]高度差

      var height = Math.abs(height2 - height1);
      var midPoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(zPosition, bottomPosition, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      this.updateHeightLabel(this.totalLable, midPoint, height); //[水平方向]水平距离

      var distanceSP = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(zPosition, topPosion);
      var midPointSP = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(zPosition, topPosion, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      this.updateHeightLabel(this.hLable, midPointSP, distanceSP); //空间距离长度

      var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(positions[0], positions[1]);
      var midXPoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(positions[0], positions[1], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      this.updateHeightLabel(this.xLable, midXPoint, distance);
      this.fire(EventType.change, {
        mtype: this.type,
        value: height,
        //高度差
        distance: distance,
        //空间长度
        distanceSP: distanceSP //水平距离

      });
    }
  }, {
    key: "updateHeightLabel",
    value: function updateHeightLabel(currentLabel, position, value) {
      if (currentLabel == null) {
        return;
      }

      currentLabel.attr.value = value;
      currentLabel.showText();
      currentLabel.position = position; //位置

      currentLabel.show = true;
    }
  }, {
    key: "updateExLine",
    value: function updateExLine(positions, graphic) {
      if (this.exLine) {
        this.exLine._positions_draw = positions;
      } else {
        var exLine = new PolylineEntity_PolylineEntity({
          positions: positions,
          style: MeasureHeightTriangle_objectSpread({
            materialType: 'PolylineGlow',
            glowPower: 0.1,
            color: '#ebe12c',
            width: 9
          }, this.options.style)
        });
        this.graphicLayer.addGraphic(exLine);

        exLine._setPositionsToCallback();

        exLine._target = graphic;
        exLine.hasEdit = true;
        this.exLine = exLine;
      }
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      graphic.arrEntityEx = [this.totalLable, this.hLable, this.xLable, this.exLine];
      this.fire(EventType.end, {
        mtype: this.type,
        graphic: graphic,
        value: this.totalLable.attr.value
      });
      this.totalLable = null;
      this.hLable = null;
      this.xLable = null;
      this.exLine = null;
    } //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      this.totalLable = graphic.arrEntityEx[0];
      this.hLable = graphic.arrEntityEx[1];
      this.xLable = graphic.arrEntityEx[2];
      this.exLine = graphic.arrEntityEx[3];
      this.showMoveDrawing(graphic);
      this.totalLable = null;
      this.hLable = null;
      this.xLable = null;
      this.exLine = null;
    }
  }]);

  return MeasureHeightTriangle;
}(MeasureHeight_MeasureHeight);
// CONCATENATED MODULE: ./src/thing/measure/MeasureDistance.js







function MeasureDistance_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureDistance_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureDistance_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureDistance_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureDistance_createSuper(Derived) { var hasNativeReflectConstruct = MeasureDistance_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureDistance_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var MeasureDistance_MeasureDistance = /*#__PURE__*/function (_MeasureBase) {
  inherits_default()(MeasureDistance, _MeasureBase);

  var _super = MeasureDistance_createSuper(MeasureDistance);

  //========== 构造方法 ==========
  function MeasureDistance(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasureDistance);

    _this = _super.call(this, opts, target);
    _this.arrLables = []; //各线段label

    _this.totalLable = null; //总长label

    _this.disTerrainScale = 1.2; //贴地时的概略比例

    return _this;
  }

  createClass_default()(MeasureDistance, [{
    key: "type",
    get: function get() {
      return 'distance';
    } //清除未完成的数据

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.totalLable)) {
        this.graphicLayer.addGraphic(this.totalLable);
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.arrLables) && this.arrLables.length > 0) {
        var arrLables = this.arrLables;

        if (arrLables && arrLables.length > 0) {
          for (var i = 0, len = arrLables.length; i < len; i++) {
            this.graphicLayer.addGraphic(arrLables[i]);
          }
        }
      }

      this.totalLable = null;
      this.arrLables = [];
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      options.showAddText = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.showAddText, true);
      this.stopDraw();
      var map = this._map; //总长label

      this.totalLable = new LabelEntity_LabelEntity({
        style: MeasureDistance_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
        }, this.labelStyle),
        attr: {
          unit: options.unit
        }
      });
      this.graphicLayer.addGraphic(this.totalLable);
      this.totalLable._noMousePick = true;
      this.totalLable.hasEdit = false;

      this.totalLable.showText = function (unit) {
        if (unit) {
          this.attr.unit = unit;
        }

        var distancestr = formatDistance(this.attr.value, this.attr.unit, map.lang);

        if (this.attr.value != this.attr.valueFD) {
          var lastLenStr = formatDistance(this.attr.valueFD, this.attr.unit, map.lang);
          this.text = map.getLangText('_总长') + ':' + distancestr;

          if (options.showAddText) {
            this.text += '\n(+' + lastLenStr + ')';
          }
        } else {
          this.text = map.getLangText('_总长') + ':' + distancestr;
        }

        return distancestr;
      };

      this.arrLables = [];
      return this._graphicLayer.startDraw({
        type: 'polyline',
        addHeight: options.addHeight,
        maxPointNum: options.maxPointNum,
        hasMoveEdit: false,
        style: MeasureDistance_objectSpread({
          materialType: 'PolylineGlow',
          glowPower: 0.1,
          color: '#ebe12c',
          width: 9,
          clampToGround: false
        }, options.style)
      });
    } //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(graphic) {
      var that = this;
      var positions = graphic.positionsShow;
      var map = this._map;
      var graphicLbl = new LabelEntity_LabelEntity({
        position: positions[positions.length - 1],
        style: MeasureDistance_objectSpread({
          horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
          verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
        }, this.labelStyle),
        attr: {
          unit: this.options.unit
        }
      });
      this.graphicLayer.addGraphic(graphicLbl);
      graphicLbl._noMousePick = true;
      graphicLbl.hasEdit = false;

      if (positions.length == 1) {
        graphicLbl.text = map.getLangText('_起点'); //labelEntity.attr.value = 0;
      } else {
        var distance = getSurfaceDistance(positions);
        var lastLen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]); //最后2点间距离
        //屏蔽比较小的数值
        // if (lastLen < 5)
        //     labelEntity.show = false;

        graphicLbl.attr.value = distance;
        graphicLbl.attr.valueFD = lastLen;

        graphicLbl.showText = function (unit) {
          if (unit) {
            this.attr.unit = unit;
          }

          var distancestr = formatDistance(this.attr.value, this.attr.unit, map.lang);

          if (this.attr.value != this.attr.valueFD) {
            var lastLenStr = formatDistance(this.attr.valueFD, this.attr.unit, map.lang);
            this.text = distancestr;

            if (that.options.showAddText) {
              this.text += '\n(+' + lastLenStr + ')';
            }
          } else {
            this.text = distancestr;
          }
        };

        graphicLbl.showText();
      }

      this.arrLables.push(graphicLbl);
    }
  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      var label = this.arrLables.pop();
      this.graphicLayer.removeGraphic(label);
      this.showMoveDrawing(e.graphic);
      this.totalLable.position = e.cartesian;
    } //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      var positions = graphic.positionsShow;

      if (positions.length < 2) {
        this.totalLable.show = false;
        return;
      }

      var distance = getSurfaceDistance(positions);
      var distancestr = formatDistance(distance, this.options.unit, this._map.lang); //最后2点间距离

      var lastLen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]);

      if (lastLen == 0 && positions.length > 2) {
        lastLen = getSurfaceDistance([positions[positions.length - 3], positions[positions.length - 2]]);
      }

      this.totalLable.attr.value = distance;
      this.totalLable.attr.valueFD = lastLen;
      this.totalLable.showText();
      this.totalLable.position = positions[positions.length - 1];
      this.totalLable.show = true;
      this.fire(EventType.change, {
        mtype: this.type,
        value: distance,
        label: distancestr
      });
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      var positions = graphic.positionsShow;
      var count = this.arrLables.length - positions.length;

      if (count >= 0) {
        for (var i = this.arrLables.length - 1; i >= positions.length - 1; i--) {
          this.graphicLayer.removeGraphic(this.arrLables[i]);
        }

        this.arrLables.splice(positions.length - 1, count + 1);
      }

      graphic._totalLable = this.totalLable;
      graphic.arrEntityEx = this.arrLables;
      this.totalLable = null;
      this.arrLables = [];

      if (this.type == 'distance') {
        var _graphic$_totalLable, _graphic$_totalLable$;

        this.fire(EventType.end, {
          mtype: this.type,
          graphic: graphic,
          value: graphic === null || graphic === void 0 ? void 0 : (_graphic$_totalLable = graphic._totalLable) === null || _graphic$_totalLable === void 0 ? void 0 : (_graphic$_totalLable$ = _graphic$_totalLable.attr) === null || _graphic$_totalLable$ === void 0 ? void 0 : _graphic$_totalLable$.value
        });
      }
    } //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      var that = this;
      var positions = graphic.positionsShow;
      var arrLables = graphic.arrEntityEx;

      if (arrLables && arrLables.length > 0) {
        for (var i = 1, len = arrLables.length; i < len; i++) {
          this.graphicLayer.removeGraphic(arrLables[i]);
        }
      } //起点


      var qidian = arrLables[0];
      qidian.position = positions[0];
      graphic.arrEntityEx = [qidian];
      var alllen = 0;

      for (var _i = 1, _len = positions.length - 1; _i < _len; _i++) {
        var lastLen = getSurfaceDistance([positions[_i - 1], positions[_i]]); //2点间距离

        alllen += lastLen;
        var graphicLbl = new LabelEntity_LabelEntity({
          position: positions[_i],
          style: MeasureDistance_objectSpread({
            horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
            verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
          }, this.labelStyle),
          attr: {
            unit: this.options.unit
          }
        });
        this.graphicLayer.addGraphic(graphicLbl);
        graphicLbl._noMousePick = true;
        graphicLbl.hasEdit = false;
        graphicLbl.attr.value = alllen;
        graphicLbl.attr.valueFD = lastLen;

        graphicLbl.showText = function (unit) {
          if (unit) {
            this.attr.unit = unit;
          }

          var distancestr = formatDistance(this.attr.value, this.attr.unit, that._map.lang);

          if (this.attr.value != this.attr.valueFD) {
            var lastLenStr = formatDistance(this.attr.valueFD, this.attr.unit, that._map.lang);
            this.text = distancestr;

            if (that.options.showAddText) {
              this.text += '\n(+' + lastLenStr + ')';
            }
          } else {
            this.text = distancestr;
          }
        };

        graphicLbl.showText();
        graphic.arrEntityEx.push(graphicLbl);
      }

      var lastlen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]);
      alllen += lastlen;
      graphic._totalLable.attr.value = alllen;
      graphic._totalLable.attr.valueFD = lastlen;

      var alllenstr = graphic._totalLable.showText();

      graphic._totalLable.position = positions[positions.length - 1];
      this.fire(EventType.change, {
        mtype: this.type,
        value: alllen,
        label: alllenstr
      });
    }
  }]);

  return MeasureDistance;
}(MeasureBase_MeasureBase);
// CONCATENATED MODULE: ./src/thing/measure/MeasureDistanceSection.js







function MeasureDistanceSection_createSuper(Derived) { var hasNativeReflectConstruct = MeasureDistanceSection_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureDistanceSection_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var MeasureDistanceSection_MeasureDistanceSection = /*#__PURE__*/function (_MeasureDistance) {
  inherits_default()(MeasureDistanceSection, _MeasureDistance);

  var _super = MeasureDistanceSection_createSuper(MeasureDistanceSection);

  function MeasureDistanceSection() {
    classCallCheck_default()(this, MeasureDistanceSection);

    return _super.apply(this, arguments);
  }

  createClass_default()(MeasureDistanceSection, [{
    key: "type",
    get: function get() {
      return 'section';
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      options.style.clampToGround = true;
      options.splitNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.splitNum, 200);
      return get_default()(getPrototypeOf_default()(MeasureDistanceSection.prototype), "_startDraw", this).call(this, options);
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      get_default()(getPrototypeOf_default()(MeasureDistanceSection.prototype), "showDrawEnd", this).call(this, graphic);

      this.updateSectionForTerrain(graphic);
    } //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      get_default()(getPrototypeOf_default()(MeasureDistanceSection.prototype), "updateForEdit", this).call(this, graphic);

      this.updateSectionForTerrain(graphic);
    } //计算剖面

  }, {
    key: "updateSectionForTerrain",
    value: function updateSectionForTerrain(graphic) {
      var _this = this;

      var positions = graphic.positionsShow;

      if (positions.length < 2) {
        return;
      }

      var arrLables = graphic.arrEntityEx;
      var totalLable = graphic._totalLable;
      this.fire(EventType.start, {
        mtype: this.type
      });
      var all_distance = 0;
      var arrLen = [];
      var arrHB = [];
      var arrLX = [];
      var arrPoint = []; // var positionsNew = [];

      computeStepSurfaceLine({
        map: this._map,
        positions: positions,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        //计算每个分段后的回调方法
        endItem: function endItem(raisedPositions, noHeight, index) {
          var _Cesium$Cartographic$, _Cesium$Cartographic$2;

          if (!_this._target || !totalLable || !positions || !positions[index] || !positions[index + 1]) {
            //异步结束时，对象已经被释放
            return;
          }

          var h1 = (_Cesium$Cartographic$ = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[index])) === null || _Cesium$Cartographic$ === void 0 ? void 0 : _Cesium$Cartographic$.height;
          var h2 = (_Cesium$Cartographic$2 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[index + 1])) === null || _Cesium$Cartographic$2 === void 0 ? void 0 : _Cesium$Cartographic$2.height;
          var hstep = (h2 - h1) / raisedPositions.length;
          var this_distance = 0;

          for (var i = 0; i < raisedPositions.length; i++) {
            //长度
            if (i != 0) {
              var templen = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(raisedPositions[i], raisedPositions[i - 1]);
              all_distance += templen;
              this_distance += templen;
            }

            arrLen.push(Number(all_distance.toFixed(1))); //海拔高度

            var point = LatLngPoint["a" /* LatLngPoint */].fromCartesian(raisedPositions[i]);
            arrHB.push(point.alt);
            arrPoint.push(point); //路线高度

            var fxgd = Number((h1 + hstep * i).toFixed(1));
            arrLX.push(fxgd);
          }

          index++;
          var thisLabel = arrLables[index];

          if (thisLabel) {
            thisLabel.attr.value = all_distance;
            thisLabel.attr.valueFD = this_distance;
            thisLabel.showText();
          } else if (index == positions.length - 1 && totalLable) {
            //最后一个
            totalLable.attr.value = all_distance;
            totalLable.attr.valueFD = this_distance;
            totalLable.showText();
          }
        },
        //计算全部完成的回调方法
        end: function end() {
          if (!_this._target || !totalLable) {
            //异步结束时，对象已经被释放
            return;
          }

          var distancestr = totalLable.showText();
          var result = {
            mtype: _this.type,
            graphic: graphic,
            value: all_distance,
            label: distancestr,
            distancestr: distancestr,
            distance: all_distance,
            arrLen: arrLen,
            arrLX: arrLX,
            arrHB: arrHB,
            arrPoint: arrPoint
          };
          graphic.measureResult = result;

          _this.fire(EventType.change, result);

          _this.fire(EventType.end, result);
        }
      });
    }
  }]);

  return MeasureDistanceSection;
}(MeasureDistance_MeasureDistance);
// CONCATENATED MODULE: ./src/thing/measure/MeasureDistanceSurface.js







function MeasureDistanceSurface_createSuper(Derived) { var hasNativeReflectConstruct = MeasureDistanceSurface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureDistanceSurface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





 //贴地线

var MeasureDistanceSurface_MeasureDistanceSurface = /*#__PURE__*/function (_MeasureDistance) {
  inherits_default()(MeasureDistanceSurface, _MeasureDistance);

  var _super = MeasureDistanceSurface_createSuper(MeasureDistanceSurface);

  function MeasureDistanceSurface() {
    classCallCheck_default()(this, MeasureDistanceSurface);

    return _super.apply(this, arguments);
  }

  createClass_default()(MeasureDistanceSurface, [{
    key: "type",
    get: function get() {
      return 'distanceSurface';
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      options.style.clampToGround = true;
      return get_default()(getPrototypeOf_default()(MeasureDistanceSurface.prototype), "_startDraw", this).call(this, options);
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      get_default()(getPrototypeOf_default()(MeasureDistanceSurface.prototype), "showDrawEnd", this).call(this, graphic);

      this.updateLengthForTerrain(graphic);
    } //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      get_default()(getPrototypeOf_default()(MeasureDistanceSurface.prototype), "updateForEdit", this).call(this, graphic);

      this.updateLengthForTerrain(graphic);
    } //计算贴地线

  }, {
    key: "updateLengthForTerrain",
    value: function updateLengthForTerrain(graphic) {
      var _this = this;

      var positions = graphic.positionsShow;
      var arrLables = graphic.arrEntityEx;
      var totalLable = graphic._totalLable;
      this.fire(EventType.start, {
        mtype: this.type
      }); //求贴地线长度

      getClampDistance(positions, {
        scene: this._map.scene,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        disTerrainScale: this.disTerrainScale,
        //求高度失败，概略估算值
        //计算每个分段后的回调方法
        endItem: function endItem(result) {
          if (!_this._target || !totalLable) {
            //异步结束时，对象已经被释放
            return;
          }

          var index = result.index;
          var all_distance = result.all_distance;
          var distance = result.distance;
          index++;
          var thisLabel = arrLables[index];

          if (thisLabel) {
            thisLabel.attr.value = all_distance;
            thisLabel.attr.valueFD = distance;
            thisLabel.showText();
          } else if (index == positions.length - 1 && totalLable) {
            //最后一个
            totalLable.attr.value = all_distance;
            totalLable.attr.valueFD = distance;
            totalLable.showText();
          }
        },
        //计算全部完成的回调方法
        callback: function callback(all_distance) {
          if (!_this._target || !totalLable) {
            //异步结束时，对象已经被释放
            return;
          }

          var distancestr = totalLable.showText();
          var result = {
            mtype: _this.type,
            graphic: graphic,
            value: all_distance,
            label: distancestr
          };

          _this.fire(EventType.change, result);

          _this.fire(EventType.end, result);
        }
      });
    }
  }]);

  return MeasureDistanceSurface;
}(MeasureDistance_MeasureDistance);
// CONCATENATED MODULE: ./src/thing/measure/MeasurePoint.js







function MeasurePoint_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasurePoint_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasurePoint_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasurePoint_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasurePoint_createSuper(Derived) { var hasNativeReflectConstruct = MeasurePoint_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasurePoint_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var MeasurePoint_MeasurePoint = /*#__PURE__*/function (_MeasureBase) {
  inherits_default()(MeasurePoint, _MeasureBase);

  var _super = MeasurePoint_createSuper(MeasurePoint);

  //========== 构造方法 ==========
  function MeasurePoint(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasurePoint);

    _this = _super.call(this, opts, target);
    _this.totalLable = null; //角度label

    return _this;
  }

  createClass_default()(MeasurePoint, [{
    key: "type",
    get: function get() {
      return 'point';
    } //清除未完成的数据

  }, {
    key: "clearLastNoEnd",
    value: function clearLastNoEnd() {
      this._map.closePopup();
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var graphic = this._graphicLayer.startDraw({
        type: 'point',
        style: MeasurePoint_objectSpread({
          color: '#3388ff',
          pixelSize: 8,
          outlineColor: '#ffffff',
          outlineWidth: 2,
          visibleDepth: false
        }, options.style)
      });

      var map = this._map;
      graphic.bindPopup(function (event) {
        var point = event.target.point;
        point.format();
        var x2 = Object(PointTrans["degree2dms"])(point.lng).str;
        var y2 = Object(PointTrans["degree2dms"])(point.lat).str;
        return "<div class=\"tudou-popup-titile\">".concat(map.getLangText('_位置信息'), "</div>\n                <div class=\"tudou-popup-content\">\n                    <div><label>").concat(map.getLangText('_经度'), "</label>").concat(point.lng, "&nbsp;&nbsp;").concat(x2, "</div>\n                    <div><label>").concat(map.getLangText('_纬度'), "</label>").concat(point.lat, "&nbsp;&nbsp;&nbsp;&nbsp;").concat(y2, "</div>\n                    <div><label>").concat(map.getLangText('_海拔'), "</label>").concat(point.alt).concat(map.getLangText('_米'), "</div>\n                </div>");
      }, {
        anchor: [0, -15]
      });
      return graphic;
    } //绘制过程移动中

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(graphic) {
      graphic.openPopup();
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      graphic.openPopup();
      this.fire(EventType.end, {
        mtype: this.type,
        graphic: graphic
      });
    } //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(graphic) {
      graphic.openPopup();
    }
  }]);

  return MeasurePoint;
}(MeasureBase_MeasureBase);
// CONCATENATED MODULE: ./src/thing/measure/MeasureVolume.js








function MeasureVolume_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MeasureVolume_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MeasureVolume_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MeasureVolume_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function MeasureVolume_createSuper(Derived) { var hasNativeReflectConstruct = MeasureVolume_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MeasureVolume_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










/**
 * 体积测量（方量）控制类，
 * 1. 挖方量: 计算“基准面”到地表之间的凸出部分进行挖掉的体积。<br />
 * 2. 填方量：计算“基准面”与“墙底部”之间的缺少部分进行填平的体积。
 *
 * 非直接调用，由 Measure 类统一创建及管理
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
 * @param {PolygonEntity.StyleOptions} [options.polygon] 面的样式
 * @param {PolygonEntity.StyleOptions} [options.polygonJzmStyle] 基准面的样式
 * @param {Boolean} [options.heightLabel=true] 是否显示各边界点高度值文本
 * @param {LabelEntity.StyleOptions} [options.labelHeight] 各边界点高度结果文本的样式
 * @param {Boolean} [options.offsetLabel=false] 是否显示各边界点高度差文本
 *
 * @export
 * @class MeasureVolume
 * @extends {MeasureArea}
 */

var MeasureVolume_MeasureVolume = /*#__PURE__*/function (_MeasureArea) {
  inherits_default()(MeasureVolume, _MeasureArea);

  var _super = MeasureVolume_createSuper(MeasureVolume);

  function MeasureVolume(opts, target) {
    var _this;

    classCallCheck_default()(this, MeasureVolume);

    _this = _super.call(this, opts, target); //高度文本样式

    _this.labelHeightStyle = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, _this.labelStyle), {}, {
      font_size: 15,
      background: false
    });

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](opts.labelHeight)) {
      _this.labelHeightStyle = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, _this.labelHeightStyle), opts.labelHeight);
    } //面的样式


    _this.polygonStyle = {
      color: '#00fff2',
      opacity: 0.4
    };

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](opts.polygon)) {
      _this.polygonStyle = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, _this.polygonStyle), opts.polygon);
    } //基准面的样式


    _this.polygonJzmStyle = {
      color: '#00ff00',
      opacity: 0.3
    };

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](opts.polygonJzm)) {
      _this.polygonJzmStyle = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, _this.polygonJzmStyle), opts.polygonJzm);
    }

    _this.heightLabel = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](opts.heightLabel, true);
    _this.offsetLabel = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](opts.offsetLabel, false);
    _this._hasFX = false;
    return _this;
  } //========== 对外属性 ==========

  /**
   * 类型
   * @type {String}
   * @readonly
   */


  createClass_default()(MeasureVolume, [{
    key: "type",
    get: function get() {
      return 'volume';
    }
    /**
     *  面内的最高地表高度
     * @type {Number}
     * @readonly
     */

  }, {
    key: "polygonMaxHeight",
    get: function get() {
      if (this.interPolygonObj) {
        return this.interPolygonObj.maxHeight;
      } else {
        return this.maxHeight;
      }
    }
    /**
     * 基准面 高度，
     * 1. 挖方量: 计算“基准面”到地表之间的凸出部分进行挖掉的体积。<br />
     * 2. 填方量：计算“基准面”与“墙底部”之间的缺少部分进行填平的体积。
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      return this._jzmHeight;
    },
    set: function set(val) {
      this._jzmHeight = val;

      if (val > this.maxHeight) {
        this.maxHeight = val;
      }

      if (val < this.minHeight) {
        this.minHeight = val;
      }

      if (!this._hasFX) {
        return;
      }

      var newFillV = updateVolume(this.interPolygonObj, this.height);
      this.totalLable.attr.value = newFillV;
      this.totalLable.showText();

      if (this.arrLables) {
        for (var i = 0; i < this.arrLables.length; i++) {
          this.arrLables[i].showText();
        }
      }

      var result = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, newFillV), {}, {
        sourceTarget: this,
        mtype: this.type
      });

      this.fire(EventType.change, result);
    }
    /**
     * 底部高度，
     * 会影响 填方量：计算“基准面高度”与“底部高度”之间的缺少部分进行填平的体积。
     * @type {Number}
     */

  }, {
    key: "minHeight",
    get: function get() {
      return this._minHeight || 0;
    },
    set: function set(val) {
      this._minHeight = val;

      if (!this._hasFX) {
        return;
      }

      if (this.interPolygonObj) {
        this.interPolygonObj.minHeight = val;
        this.interPolygonObj = updateVolumeByMinHeight(this.interPolygonObj);
      }

      var newFillV = updateVolume(this.interPolygonObj, this.height);
      this.totalLable.attr.value = newFillV;
      this.totalLable.showText();

      var result = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, newFillV), {}, {
        sourceTarget: this,
        mtype: this.type
      });

      this.fire(EventType.change, result);
    }
    /**
     * 最高高度，对应墙的高度，
     * 不影响测量结果，只是显示效果的区别。
     * @type {Number}
     */

  }, {
    key: "maxHeight",
    get: function get() {
      return this._maxHeight || 0;
    },
    set: function set(val) {
      this._maxHeight = val;
    } //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      this.clear();
      options.style = this.polygonStyle || options.style;
      return get_default()(getPrototypeOf_default()(MeasureVolume.prototype), "_startDraw", this).call(this, options);
    } //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(graphic) {
      var _this2 = this;

      if (graphic.type != 'polygon') {
        return;
      }

      this.totalLable.label.text = this._map.getLangText('_正在计算体积') + '…';
      var positions = graphic.positionsShow;
      setTimeout(function () {
        _this2.calcVolume(positions, function () {
          _this2._graphicLayer.removeGraphic(graphic);
        });
      }, 500);
    }
    /**
     * 直接传positons方式进行计算体积
     *
     * @param {Object} options 参数
     * @param {Cesium.Cartesian3[]} options.positions 坐标数组
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start(options) {
      this.options = options;
      this.calcVolume(this.options.positions);
    } //计算贴地面

  }, {
    key: "calcVolume",
    value: function calcVolume(positions, _callback) {
      var _this3 = this;

      this.fire(EventType.start, {
        mtype: this.type,
        sourceTarget: this,
        positions: positions
      });
      this._hasFX = true; //计算体积

      var result = interPolygon(MeasureVolume_objectSpread(MeasureVolume_objectSpread({
        positions: positions,
        scene: this._map.scene,
        asyn: true
      }, this.options), {}, {
        callback: function callback(interPolygonObj) {
          if (!_this3._target) {
            //异步结束时，对象已经被释放
            return;
          }

          if (_callback) {
            _callback();
          }

          if (!_this3._hasFX) {
            return;
          }

          _this3.showVolume(positions, interPolygonObj);
        }
      }));

      if (result._has3dtiles) {
        this._map.scene.globe.depthTestAgainstTerrain = false;
      } else {
        this._map.scene.globe.depthTestAgainstTerrain = true;
      }
    }
  }, {
    key: "showVolume",
    value: function showVolume(positions, interPolygonObj) {
      var _this$options$minHeig,
          _this$options$maxHeig,
          _this$options$height,
          _this4 = this;

      this.interPolygonObj = updateVolumeByMinHeight(interPolygonObj);
      this._minHeight = (_this$options$minHeig = this.options.minHeight) !== null && _this$options$minHeig !== void 0 ? _this$options$minHeig : this.interPolygonObj.minHeight;
      this._maxHeight = (_this$options$maxHeig = this.options.maxHeight) !== null && _this$options$maxHeig !== void 0 ? _this$options$maxHeig : this.interPolygonObj.maxHeight;
      this._jzmHeight = (_this$options$height = this.options.height) !== null && _this$options$height !== void 0 ? _this$options$height : this.interPolygonObj.minHeight;
      var minDiffHeight = Math.floor(0.3 * external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].chordLength(interPolygonObj.granularity, this._map.scene.globe.ellipsoid.maximumRadius));

      if (this._maxHeight - this._minHeight < minDiffHeight) {
        this._maxHeight = this._minHeight + minDiffHeight;
      }

      var fillV = updateVolume(this.interPolygonObj, this.height); // 显示基准面

      var entityattr = PolygonStyleConver_PolygonStyleConver.toCesiumVal(this.polygonJzmStyle, {
        hierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](positions),
        height: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time, result) {
          return _this4.height;
        }, false)
      }, true);
      delete entityattr.perPositionHeight;
      this.dataSource.entities.add({
        polygon: entityattr
      }); // 显示立体边界

      delete this.polygonStyle.clampToGround;
      var entityattr3 = PolygonStyleConver_PolygonStyleConver.toCesiumVal(this.polygonStyle, {
        hierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](positions),
        height: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time, result) {
          return _this4.minHeight;
        }, false),
        extrudedHeight: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time, result) {
          return _this4.maxHeight;
        }, false),
        closeTop: false,
        closeBottom: true
      }, true);
      this.dataSource.entities.add({
        polygon: entityattr3
      }); //显示各点的贴地高度文本

      if (this.heightLabel) {
        this.showPointHeightLabel(positions, this.interPolygonObj.minHeight);
      } //显示计算结果文本


      if (!this.totalLable) {
        var graphicLbl = new LabelEntity_LabelEntity({
          style: MeasureVolume_objectSpread({
            horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].CENTER,
            verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
          }, this.labelStyle),
          attr: {}
        });
        this.graphicLayer.addGraphic(graphicLbl);
        graphicLbl._noMousePick = true;
        graphicLbl.hasEdit = false;
        this.totalLable = graphicLbl;
      }

      var map = this._map;
      this.totalLable.attr.value = fillV;

      this.totalLable.showText = function (unit) {
        var fillV = this.attr.value;
        var fillText = '';

        if (fillV.fillVolume > 0) {
          fillText += map.getLangText('_填方体积') + '：' + formatVolume(fillV.fillVolume, null, map.lang) + '\n';
        }

        if (fillV.digVolume > 0) {
          fillText += map.getLangText('_挖方体积') + '：' + formatVolume(fillV.digVolume, null, map.lang) + '\n';
        }

        fillText += map.getLangText('_横切面积') + '：' + formatArea(fillV.totalArea, null, map.lang);
        this.text = fillText;
        return fillText;
      };

      this.totalLable.showText();
      this.totalLable.position = centerOfMass(positions, this.interPolygonObj.maxHeight); //求中心点

      var result = MeasureVolume_objectSpread(MeasureVolume_objectSpread({}, fillV), {}, {
        sourceTarget: this,
        mtype: this.type
      });

      this.fire(EventType.change, result);
      this.fire(EventType.end, result);
    } //显示各点的贴地高度文本

  }, {
    key: "showPointHeightLabel",
    value: function showPointHeightLabel(positions, minHeight) {
      var _this5 = this;

      var arrLable = [];

      var _loop = function _loop(i) {
        var height = Math.max(Object(PointUtil["getSurfaceHeight"])(_this5._map.scene, positions[i]), minHeight);
        var cartographic = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[i]);
        var position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(cartographic.longitude, cartographic.latitude, height); //各点的文本

        var label = new LabelEntity_LabelEntity({
          position: position,
          style: MeasureVolume_objectSpread({
            horizontalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HorizontalOrigin"].LEFT,
            verticalOrigin: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VerticalOrigin"].BOTTOM
          }, _this5.labelHeightStyle),
          attr: {
            value: height
          }
        });

        _this5.graphicLayer.addGraphic(label); // label.attr.value = height;


        var that = _this5;

        label.showText = function (unit) {
          var height = this.attr.value;

          var text = that._map.getLangText('_海拔') + '：' + height.toFixed(2) + that._map.getLangText('_米');

          if (that.offsetLabel) {
            var offset = height - that.height;

            if (offset > 0) {
              text += '\n' + that._map.getLangText('_高度') + '：' + offset.toFixed(2) + that._map.getLangText('_米') + '(' + that._map.getLangText('_面上') + ')';
            } else {
              text += '\n' + that._map.getLangText('_高度') + '：' + Math.abs(offset).toFixed(2) + that._map.getLangText('_米') + '(' + that._map.getLangText('_面下') + ')';
            }
          }

          this.text = text;
          return text;
        };

        label.showText();
        arrLable.push(label);
      };

      for (var i = 0; i < positions.length; i++) {
        _loop(i);
      }

      this.arrLables = arrLable;
    }
    /**
     * 通过鼠标拾取高度，赋值给基准面
     *
     * @param {Function} callback 拾取完成后的回调方法
     * @return {void}  无
     */

  }, {
    key: "selecteHeight",
    value: function selecteHeight(callback) {
      var _this6 = this;

      //拾取高度
      this._graphicLayer.startDraw({
        type: 'point',
        style: {
          color: '#00fff2'
        },
        success: function success(graphic) {
          if (!graphic.point) {
            return;
          }

          var point = graphic.point;
          _this6.height = point.alt;

          _this6._graphicLayer.removeGraphic(graphic);

          if (callback) {
            callback(point.alt);
          }
        }
      });
    }
    /**
     * 清除测量
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      delete this.interPolygonObj;
      delete this._maxHeight;
      delete this._minHeight;
      delete this._jzmHeight;
      delete this.totalLable;
      delete this.arrLables;

      get_default()(getPrototypeOf_default()(MeasureVolume.prototype), "clear", this).call(this);

      this._hasFX = false;
    }
  }]);

  return MeasureVolume;
}(MeasureArea_MeasureArea);
// CONCATENATED MODULE: ./src/thing/measure/Measure.js








function Measure_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Measure_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Measure_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Measure_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Measure_createSuper(Derived) { var hasNativeReflectConstruct = Measure_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Measure_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }















/**
 * @typedef {Object} Measure.EventType
 * @property {String} remove 移除对象
 * @property {String} change 测量值变化了
 * @property {String} start 异步测量中，开始测量
 * @property {String} end 异步测量中，完成了测量后
 *
 * @property {GraphicLayer.EventType} 其他 支持的父类的事件类型
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('发送了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 图上量算
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Boolean} [options.hasEdit=false] 是否可编辑
 * @param {Boolean} [options.isAutoEditing=true] 完成测量时是否自动启动编辑(需要hasEdit:true时)
 * @param {Boolean} [options.isContinued=false] 是否连续测量
 * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
 *
 * @param {PolygonEntity.StyleOptions} [options.polygon] 体积测量时，面的样式
 * @param {PolygonEntity.StyleOptions} [options.polygonJzmStyle] 体积测量时，基准面的样式
 * @param {Boolean} [options.heightLabel=true] 体积测量时，是否显示各边界点高度值文本
 * @param {LabelEntity.StyleOptions} [options.labelHeight] 体积测量时，各边界点高度结果文本的样式
 * @param {Boolean} [options.offsetLabel=false] 体积测量时，是否显示各边界点高度差文本
 *
 * @export
 * @class Measure
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link Measure.EventType}
 */

var Measure_Measure = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(Measure, _BaseThing);

  var _super = Measure_createSuper(Measure);

  function Measure() {
    classCallCheck_default()(this, Measure);

    return _super.apply(this, arguments);
  }

  createClass_default()(Measure, [{
    key: "graphicLayer",
    get:
    /**
     * 对应的矢量图层
     * @type {GraphicLayer}
     * @readonly
     */
    function get() {
      return this._graphicLayer;
    }
    /**
     * 图层内的Graphic集合对象
     *
     * @type {BaseGraphic[]}
     * @readonly
     */

  }, {
    key: "graphics",
    get: function get() {
      return this._graphicLayer.graphics;
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {}
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      if (!this._cache) {
        this._cache = {};
      } // 标绘对象类


      this._graphicLayer = new GraphicLayer_GraphicLayer(Measure_objectSpread(Measure_objectSpread({
        hasEdit: true,
        stopPropagation: true
      }, this.options), {}, {
        isContinued: false,
        isAutoEditing: !this.options.isContinued
      }));

      this._graphicLayer.addEventParent(this);

      if (this._graphicLayer.hasEdit) {
        this._graphicLayer.bindContextMenu([{
          text: this._map.getLangText('_删除测量'),
          iconCls: 'fa fa-trash-o',
          show: function show(event) {
            var graphic = event.graphic;

            if (graphic.inProgress && !graphic.editing) {
              return false;
            } else {
              return true;
            }
          },
          callback: function callback(event) {
            var graphic = event.graphic;

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic._target)) {
              _this._graphicLayer.removeGraphic(graphic);

              graphic = graphic._target;
            }

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic._totalLable)) {
              _this._graphicLayer.removeGraphic(graphic._totalLable);

              delete graphic._totalLable;
            }

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.arrEntityEx) && graphic.arrEntityEx.length > 0) {
              var arrLables = graphic.arrEntityEx;

              if (arrLables && arrLables.length > 0) {
                for (var i = 0, len = arrLables.length; i < len; i++) {
                  _this._graphicLayer.removeGraphic(arrLables[i]);
                }
              }

              delete graphic.arrEntityEx;
            }

            _this._graphicLayer.removeGraphic(graphic);

            _this.fire(EventType.remove, {
              mtype: _this._measureType,
              graphic: graphic
            });
          }
        }]);
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      var _this2 = this;

      this._map.addLayer(this._graphicLayer);

      this.eachManager(function (manager) {
        manager._onAdd(_this2);
      });
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.eachManager(function (manager) {
        manager._onRemove();
      });

      this._map.removeLayer(this._graphicLayer);
    }
    /**
     * 测量 空间长度
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
     * @param {Boolean} [options.showAddText=true] 是否显示每一段的增加部分距离，如（+10.1km）
     *
     * @return {MeasureDistance} 长度测量控制类 对象
     */

  }, {
    key: "distance",
    value: function distance(opts) {
      this.stopDraw();

      if (!this._measureLength) {
        this._measureLength = new MeasureDistance_MeasureDistance(this.options, this);

        this._addManager(this._measureLength);
      }

      this._measureLength.startDraw(opts);

      return this._measureLength;
    }
    /**
     * 测量 贴地长度
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
     * @param {Boolean} [options.showAddText=true] 是否显示每一段的增加部分距离，如（+10.1km）
     * @param {Number} [options.splitNum=100]  插值数，将线段分割的个数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     *
     * @return {MeasureDistanceSurface} 贴地长度测量控制类 对象
     */

  }, {
    key: "distanceSurface",
    value: function distanceSurface(opts) {
      this.stopDraw();

      if (!this._measureLengthSurface) {
        this._measureLengthSurface = new MeasureDistanceSurface_MeasureDistanceSurface(this.options, this);

        this._addManager(this._measureLengthSurface);
      }

      this._measureLengthSurface.startDraw(opts);

      return this._measureLengthSurface;
    }
    /**
     * 剖面分析，测量线插值点的高程数据
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight=0] 在draw绘制时，在绘制点的基础上增加的高度值
     * @param {Number} [options.splitNum=200]  插值数，将线段分割的个数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     *
     * @return {MeasureDistanceSection} 剖面分析控制类 对象
     */

  }, {
    key: "section",
    value: function section(opts) {
      this.stopDraw();

      if (!this._measureLengthSection) {
        this._measureLengthSection = new MeasureDistanceSection_MeasureDistanceSection(this.options, this);

        this._addManager(this._measureLengthSection);
      }

      this._measureLengthSection.startDraw(opts);

      return this._measureLengthSection;
    }
    /**
     * 面积测量（水平面）
     * @param {Object} opts 控制参数
     * @param {PolygonEntity.StyleOptions} [opts.style] 面的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     *
     * @return {MeasureArea} 面积测量控制类 对象
     */

  }, {
    key: "area",
    value: function area(opts) {
      this.stopDraw();

      if (!this._measureArea) {
        this._measureArea = new MeasureArea_MeasureArea(this.options, this);

        this._addManager(this._measureArea);
      }

      this._measureArea.startDraw(opts);

      return this._measureArea;
    }
    /**
     * 贴地面积测量
     * @param {Object} opts 控制参数
     * @param {PolygonEntity.StyleOptions} [opts.style] 面的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     *
     * @return {MeasureArea} 面积测量控制类 对象
     */

  }, {
    key: "areaSurface",
    value: function areaSurface(opts) {
      this.stopDraw();

      if (!this._measureAreaSurface) {
        this._measureAreaSurface = new MeasureAreaSurface_MeasureAreaSurface(this.options, this);

        this._addManager(this._measureAreaSurface);
      }

      this._measureAreaSurface.startDraw(opts);

      return this._measureAreaSurface;
    }
    /**
     * 体积测量（方量分析）
     * @param {Object} opts 控制参数
     * @param {PolygonEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     *
     * @param {Number} [options.minHeight]  可以指定最低高度（单位：米）
     * @param {Number} [options.maxHeight]  可以指定最高高度（单位：米）
     * @param {Number} [options.height]  可以指定基准面高度（单位：米），默认是绘制后的最低高度值
     *
     * @return {MeasureVolume} 体积测量控制类 对象
     */

  }, {
    key: "volume",
    value: function volume(opts) {
      this.stopDraw();

      if (!this._measureVolume) {
        this._measureVolume = new MeasureVolume_MeasureVolume(this.options, this);

        this._addManager(this._measureVolume);
      }

      if (Array.isArray(opts.positions)) {
        this._measureVolume.start(opts);
      } else {
        this._measureVolume.startDraw(opts);
      }

      return this._measureVolume;
    }
    /**
     * 高度测量
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     *
     * @return {MeasureHeight} 高度测量控制类 对象
     */

  }, {
    key: "height",
    value: function height(opts) {
      this.stopDraw();

      if (!this._measureHeight) {
        this._measureHeight = new MeasureHeight_MeasureHeight(this.options, this);

        this._addManager(this._measureHeight);
      }

      this._measureHeight.startDraw(opts);

      return this._measureHeight;
    }
    /**
     * 三角高度测量，
     * 包括水平距离、空间距离、高度差。
     *
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式
     * @param {String} [opts.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     *
     * @return {MeasureHeightTriangle} 三角高度测量控制类 对象
     */

  }, {
    key: "heightTriangle",
    value: function heightTriangle(opts) {
      this.stopDraw();

      if (!this._measureHeightTriangle) {
        this._measureHeightTriangle = new MeasureHeightTriangle_MeasureHeightTriangle(this.options, this);

        this._addManager(this._measureHeightTriangle);
      }

      this._measureHeightTriangle.startDraw(opts);

      return this._measureHeightTriangle;
    }
    /**
     * 角度测量
     *
     * @param {Object} opts 控制参数
     * @param {PolylineEntity.StyleOptions} [opts.style] 路线的样式，默认为箭头线
     *
     * @return {MeasureAngle} 角度测量控制类 对象
     */

  }, {
    key: "angle",
    value: function angle(opts) {
      this.stopDraw();

      if (!this._measureAngle) {
        this._measureAngle = new MeasureAngle_MeasureAngle(this.options, this);

        this._addManager(this._measureAngle);
      }

      this._measureAngle.startDraw(opts);

      return this._measureAngle;
    }
    /**
     * 坐标测量
     *
     * @param {Object} opts 控制参数
     * @param {PointEntity.StyleOptions} [opts.style] 点的样式
     *
     * @return {MeasurePoint} 坐标测量控制类 对象
     */

  }, {
    key: "point",
    value: function point(opts) {
      this.stopDraw();

      if (!this._measurePoint) {
        this._measurePoint = new MeasurePoint_MeasurePoint(this.options, this);

        this._addManager(this._measurePoint);
      }

      this._measurePoint.startDraw(opts);

      return this._measurePoint;
    }
  }, {
    key: "_addManager",
    value: function _addManager(manager) {
      if (manager && !this._cache.hasOwnProperty(manager.type)) {
        manager._onAdd(this);

        this._cache[manager.type] = manager;
      }
    }
  }, {
    key: "eachManager",
    value: function eachManager(method, context) {
      var _this3 = this;

      Object.keys(this._cache).forEach(function (key) {
        method && method.call(context || _this3, _this3._cache[key], _this3);
      });
      return this;
    }
    /**
     * 取消并停止绘制，如有未完成的绘制会自动删除
     *
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      this.eachManager(function (manager) {
        if (manager._map) {
          manager.stopDraw();
        }
      });
      return this;
    }
    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {void}  无
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      this.eachManager(function (manager) {
        if (manager._map) {
          manager.endDraw();
        }
      });
    }
    /**
     * 清除测量
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.eachManager(function (manager) {
        if (manager._map) {
          manager.clear();
        }
      });
    }
    /**
     * 更新量测结果的单位
     *
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance}{@link MeasureUtil#formatArea} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */

  }, {
    key: "updateUnit",
    value: function updateUnit(unit) {
      this.eachManager(function (manager) {
        manager.options.unit = unit;
      });

      this._graphicLayer.eachGraphic(function (graphic) {
        if (graphic.showText) {
          graphic.showText(unit);
        }
      });
    } //销毁

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      this.clear();

      this._graphicLayer.destroy(noDel);

      get_default()(getPrototypeOf_default()(Measure.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return Measure;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/terrain/FloodByGraphic.js








function FloodByGraphic_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function FloodByGraphic_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FloodByGraphic_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FloodByGraphic_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function FloodByGraphic_createSuper(Derived) { var hasNativeReflectConstruct = FloodByGraphic_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FloodByGraphic_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









/**
 * @typedef {Object} FloodByGraphic.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始分析
 * @property {String} change 变化了
 * @property {String} end  完成分析
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.end, function (event) {
 *   console.log('分析完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 淹没分析，
 * 基于polygon矢量面抬高模拟，只支持单个区域
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 区域位置，坐标位置数组
 * @param {PolygonEntity.StyleOptions} [options.style] 淹没区域的样式
 * @param {Number} [options.speed] 淹没速度
 * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
 * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
 * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准），未设置时根据坐标自动判断（判断可能不准确）
 *
 * @export
 * @class FloodByGraphic
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link FloodByGraphic.EventType}
 */

var FloodByGraphic_FloodByGraphic = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(FloodByGraphic, _BaseThing);

  var _super = FloodByGraphic_createSuper(FloodByGraphic);

  function FloodByGraphic() {
    classCallCheck_default()(this, FloodByGraphic);

    return _super.apply(this, arguments);
  }

  createClass_default()(FloodByGraphic, [{
    key: "positions",
    get:
    /**
     * 淹没区域 坐标位置数组
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */
    function get() {
      return this.options.positions;
    },
    set: function set(val) {
      this.options.positions = val;
      var positions = LatLngArray_LatLngArray.toCartesians(val);
      this._hierarchyPositions = Object(PointUtil["setPositionsHeight"])(positions, this.height);
    }
    /**
     * 淹没平面高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      var _this$_extrudedHeight;

      return (_this$_extrudedHeight = this._extrudedHeight) !== null && _this$_extrudedHeight !== void 0 ? _this$_extrudedHeight : this.options.minHeight;
    },
    set: function set(val) {
      this._extrudedHeight = val;
      this.fire(EventType.change, {
        height: this._extrudedHeight
      });
    }
    /**
     * 淹没速度
     * @type {Number}
     */

  }, {
    key: "speed",
    get: function get() {
      return this.options.speed;
    },
    set: function set(val) {
      this.options.speed = val;
    } //========== 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      this._extrudedHeight = 0;
      this.graphicLayer = new GraphicLayer_GraphicLayer({
        name: "淹没分析",
        noLayerManage: true
      });
      this.graphicLayer._tudou3d_private = true;
      var polygonHierarchy = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"]();
      var graphic = new PolygonEntity_PolygonEntity({
        positions: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
          if (!_this._hierarchyPositions) {
            return null;
          }

          polygonHierarchy.positions = _this._hierarchyPositions;
          return polygonHierarchy;
        }, false),
        style: FloodByGraphic_objectSpread(FloodByGraphic_objectSpread({
          color: "#007be6",
          opacity: 0.5,
          outline: false
        }, this.options.style || {}), {}, {
          perPositionHeight: true,
          extrudedHeight: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CallbackProperty"](function (time) {
            return _this._extrudedHeight;
          }, false)
        })
      });
      this.graphic = graphic;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.minHeight) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.maxHeight) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.positions)) {
        this.setOptions();
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.addLayer(this.graphicLayer);

      this.graphicLayer.addGraphic(this.graphic);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.removeLayer(this.graphicLayer);

      this.clear();
    }
    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        this.options = FloodByGraphic_objectSpread(FloodByGraphic_objectSpread({}, this.options), options);
      }

      this.stop();
      var minHeight = this.options.minHeight;
      var maxHeight = this.options.maxHeight; //检查参数

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](minHeight)) {
        Object(Log["logError"])("minHeight 请传入有效数值！", minHeight);
        return;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maxHeight)) {
        Object(Log["logError"])("maxHeight 请传入有效数值！", maxHeight);
        return;
      }

      if (minHeight > maxHeight) {
        //互相交换数据
        var temp = minHeight;
        minHeight = maxHeight;
        maxHeight = temp;
      }

      this.minHeight = minHeight;
      this.maxHeight = maxHeight;
      this._extrudedHeight = minHeight;
      var positions = LatLngArray_LatLngArray.toCartesians(this.options.positions);
      this._hierarchyPositions = Object(PointUtil["setPositionsHeight"])(positions, minHeight); //修改高度值

      var _has3dtiles = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.has3dtiles, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._map.pick3DTileset(positions))); //是否在3ditiles上面


      if (!_has3dtiles) {
        if (this._last_depthTestAgainstTerrain == null) {
          this._last_depthTestAgainstTerrain = this._map.scene.globe.depthTestAgainstTerrain;
        }

        this._map.scene.globe.depthTestAgainstTerrain = true;
      }

      return this;
    }
    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      this.stop();
      this.isStart = true;
      this.fire(EventType.start);
      this._timeTik = setInterval(function () {
        if (_this2._extrudedHeight >= _this2.maxHeight) {
          _this2.stop();

          return;
        }

        var newHeight = _this2._extrudedHeight + _this2.speed;

        if (newHeight > _this2.maxHeight) {
          _this2._extrudedHeight = _this2.maxHeight;
        } else {
          _this2._extrudedHeight = newHeight;
        }

        _this2.fire(EventType.change, {
          height: _this2._extrudedHeight
        });
      }, 100);
    }
    /**
     * 停止播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this.isStart) {
        return;
      }

      if (this._timeTik) {
        clearInterval(this._timeTik);
        delete this._timeTik;
      }

      this.isStart = false;
      this.fire(EventType.end);
    }
    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "restart",
    value: function restart() {
      this.setOptions();
      this.start();
    }
    /**
     * 清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.positions = null;

      if (this._last_depthTestAgainstTerrain != null) {
        this._map.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
        delete this._last_depthTestAgainstTerrain;
      }

      this.stop();
    }
  }, {
    key: "destroy",
    value: function destroy(noDel) {
      if (this.graphicLayer) {
        this.graphicLayer.destroy(noDel);
      }

      get_default()(getPrototypeOf_default()(FloodByGraphic.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return FloodByGraphic;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/terrain/TerrainPlanClip.js






function TerrainPlanClip_createSuper(Derived) { var hasNativeReflectConstruct = TerrainPlanClip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TerrainPlanClip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 地形开挖 ，
 * 基于clippingPlanes接口，只支持单个开挖。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 *  @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 开挖区域的 坐标位置数组
 * @param {Boolean} [options.clipOutSide = false] 是否外切开挖
 * @param {String} [options.image]  开挖区域的井墙面贴图URL。未传入该值时，不显示开挖区域的井。
 * @param {String} [options.imageBottom] 当显示开挖区域的井时，井底面贴图URL
 * @param {Number} [options.diffHeight]  当显示开挖区域的井时，设置区域的挖掘深度（单位：米）
 * @param {Number} [splitNum = 30] 当显示开挖区域的井时，井墙面每两点之间插值个数
 *
 * @export
 * @class TerrainPlanClip
 * @extends {BaseThing}
 */

var TerrainPlanClip_TerrainPlanClip = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(TerrainPlanClip, _BaseThing);

  var _super = TerrainPlanClip_createSuper(TerrainPlanClip);

  function TerrainPlanClip() {
    classCallCheck_default()(this, TerrainPlanClip);

    return _super.apply(this, arguments);
  }

  createClass_default()(TerrainPlanClip, [{
    key: "positions",
    get: //========== 对外属性 ==========

    /**
     * 开挖区域的 坐标位置数组
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */
    function get() {
      return this._positions;
    },
    set: function set(val) {
      this.clear();
      this._positions = val;
      this.setPositions(val);
    }
    /**
     * 设置所有区域的挖掘深度（单位：米）
     * @type {Number}
     */

  }, {
    key: "diffHeight",
    get: function get() {
      return this.options.diffHeight;
    },
    set: function set(val) {
      this.options.diffHeight = val;

      if (this._graphicLayer) {
        this._graphicLayer.eachGraphic(function (pitPrimitive) {
          pitPrimitive.diffHeight = val;
        });
      }
    }
    /**
     * 是否外切开挖
     * @type {Boolean}
     */

  }, {
    key: "clipOutSide",
    get: function get() {
      return this.options.clipOutSide;
    },
    set: function set(val) {
      this.options.clipOutSide = val;

      if (this._map && this._positions) {
        this.setPositions(this._positions);
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (this._map.scene.globe.clippingPlanes) {
        this._map.scene.globe.clippingPlanes.enabled = val;
      }

      if (this._graphicLayer) {
        this._graphicLayer.show = val;
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      //开挖对应的井对象
      this._graphicLayer = new GraphicLayer_GraphicLayer(this.options);
      this._graphicLayer._tudou3d_private = true;

      this._map.addLayer(this._graphicLayer);

      if (this.options.positions && this.options.positions.length > 0) {
        this.setPositions(this.options.positions);
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear(); //开挖对应的井对象

      if (this._graphicLayer) {
        this._map.removeLayer(this._graphicLayer);

        delete this._graphicLayer;
      }
    } // 创建开挖面

  }, {
    key: "setPositions",
    value: function setPositions(positions) {
      this.clear();

      if (!positions || positions.length < 3) {
        Object(Log["logError"])("挖地坐标数据存在问题！", positions);
        return;
      }

      positions = LatLngArray_LatLngArray.toCartesians(positions);
      this._positions = positions;
      var clippingPlanes = [];
      var pointsLength = positions.length; //是否顺时针

      var direction;
      var startAngle = getAngle(positions[0], positions[1]);

      if (startAngle == 0) {
        direction = false;
      } else {
        var endAngle = getAngle(positions[0], positions[2]);
        direction = startAngle < endAngle;
      }

      if (this.clipOutSide) {
        direction = !direction;
      }

      for (var i = 0; i < pointsLength; ++i) {
        var nextIndex = (i + 1) % pointsLength;
        var midpoint = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].midpoint(positions[i], positions[nextIndex], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        var up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(midpoint, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        var right = void 0;

        if (direction) {
          right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(positions[i], midpoint, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); //顺时针
        } else {
          right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(positions[nextIndex], midpoint, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        }

        right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(right, right);
        var normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(right, up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(normal, normal);
        var originCenteredPlane = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Plane"](normal, 0.0);
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Plane"].getPointDistance(originCenteredPlane, midpoint);
        clippingPlanes.push(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](normal, distance));
      }

      this._map.scene.globe.clippingPlanes = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlaneCollection"]({
        planes: clippingPlanes,
        edgeWidth: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.edgeWidth, 1.0),
        edgeColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.edgeColor, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE),
        unionClippingRegions: this.clipOutSide,
        enabled: true
      });

      if (this.options.image) {
        var pitPrimitive = new Pit_Pit({
          style: this.options,
          positions: positions
        });

        this._graphicLayer.addGraphic(pitPrimitive);
      }
    }
    /**
     * 清除开挖
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      var _this$_map$scene$glob, _this$_map$scene$glob2;

      if (!this._map) {
        return;
      }

      this._positions = null;

      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }

      if ((_this$_map$scene$glob = this._map.scene.globe) !== null && _this$_map$scene$glob !== void 0 && (_this$_map$scene$glob2 = _this$_map$scene$glob.clippingPlanes) !== null && _this$_map$scene$glob2 !== void 0 && _this$_map$scene$glob2.enabled) {
        this._map.scene.globe.clippingPlanes.enabled = false;
      }

      this._map.scene.globe.clippingPlanes = undefined;
    }
  }]);

  return TerrainPlanClip;
}(BaseThing_BaseThing);
// EXTERNAL MODULE: ./src/shaders/TerrainEditVS.glsl
var TerrainEditVS = __webpack_require__(80);
var TerrainEditVS_default = /*#__PURE__*/__webpack_require__.n(TerrainEditVS);

// EXTERNAL MODULE: ./src/shaders/TerrainEditFS.glsl
var TerrainEditFS = __webpack_require__(81);
var TerrainEditFS_default = /*#__PURE__*/__webpack_require__.n(TerrainEditFS);

// CONCATENATED MODULE: ./src/thing/terrain/TerrainEditBase.js






function TerrainEditBase_createSuper(Derived) { var hasNativeReflectConstruct = TerrainEditBase_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TerrainEditBase_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 地形开挖、淹没等分析 基础类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
 *
 * @export
 * @class TerrainEditBase
 * @extends {BaseThing}
 */

var TerrainEditBase_TerrainEditBase = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(TerrainEditBase, _BaseThing);

  var _super = TerrainEditBase_createSuper(TerrainEditBase);

  //========== 构造方法 ==========
  function TerrainEditBase() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TerrainEditBase);

    _this = _super.call(this, options); //裁剪区域相关

    _this.floodVar = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.floodVar, [0, 0, 0, 500]); //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]

    _this._maxCanvasSize = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxCanvasSize, 4096); // 数值越大，剪裁越精确，占用显存越高

    _this._areaList = []; //区域数组

    _this._cache_id = 0;
    return _this;
  } //========== 对外属性 ==========
  //分析参数


  createClass_default()(TerrainEditBase, [{
    key: "terrainEditCtl",
    get: function get() {
      var _this$_map$scene$glob, _this$_map$scene$glob2;

      return ((_this$_map$scene$glob = this._map.scene.globe._surface) === null || _this$_map$scene$glob === void 0 ? void 0 : (_this$_map$scene$glob2 = _this$_map$scene$glob.tileProvider) === null || _this$_map$scene$glob2 === void 0 ? void 0 : _this$_map$scene$glob2.floodAnalysis) || {};
    }
    /**
     * 区域 列表
     * @type {Object[]}
     * @readonly
     */

  }, {
    key: "list",
    get: function get() {
      return this._areaList;
    }
    /**
     * 是否显示区域外的地图
     * @type {Boolean}
     */

  }, {
    key: "showElseArea",
    get: function get() {
      var _this$terrainEditCtl$, _this$terrainEditCtl;

      return (_this$terrainEditCtl$ = (_this$terrainEditCtl = this.terrainEditCtl) === null || _this$terrainEditCtl === void 0 ? void 0 : _this$terrainEditCtl.showElseArea) !== null && _this$terrainEditCtl$ !== void 0 ? _this$terrainEditCtl$ : true;
    },
    set: function set(val) {
      this.terrainEditCtl.showElseArea = val;
    }
    /**
     * 坐标位置数组，只显示单个区域【单个区域场景时使用】
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      if (this.length > 0) {
        return this._areaList[0].positions;
      } else {
        return null;
      }
    },
    set: function set(val) {
      this.clear();
      this.addArea(val);
    }
    /**
     * 已添加的区域个数
     * @type {Int}
     * @readonly
     */

  }, {
    key: "length",
    get: function get() {
      if (this._areaList) {
        var _this$_areaList;

        return (_this$_areaList = this._areaList) === null || _this$_areaList === void 0 ? void 0 : _this$_areaList.length;
      } else {
        return 0;
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      this.terrainEditCtl.enableFlood = val;
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this.terrainEditCtl.showElseArea = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.showElseArea, true);

      if (this.options.positions) {
        this.addArea(this.options.positions);
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear();

      if (this.tailorTex && this.tailorTex.destroy) {
        this.tailorTex.destroy();
      }

      this.yanmoFbo = null;
      this.terrainEditCtl.enableFlood = false;
      this.terrainEditCtl.inverFloodCenterMat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY;
      this.terrainEditCtl.floodArea = undefined;
    }
    /**
     * 清除所有区域
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this._map.scene.globe.material = null;

      this._map.scene.globe._surface.tileProvider.resetFloodAnalysis();

      this._map.scene.globe._surface.tileProvider.resetExcavateAnalysis();

      this._areaList = [];

      if (this.tailorTex && this.tailorTex.destroy()) {
        this.tailorTex.destroy();
      }
    }
    /**
     * 根据id获取区域对象
     *
     * @param {Number} id id值
     * @return {Object} 区域对象
     */

  }, {
    key: "getAreaById",
    value: function getAreaById(id) {
      for (var i = 0; i < this._areaList.length; i++) {
        var item = this._areaList[i];

        if (item.id == id) {
          return item;
        }
      }

      return null;
    }
    /**
     * 隐藏单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */

  }, {
    key: "hideArea",
    value: function hideArea(id) {
      var areaObj = this.getAreaById(id);

      if (areaObj) {
        areaObj.show = false;

        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = false;
        }

        this.drawPolygon();
      }
    }
    /**
     * 显示单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */

  }, {
    key: "showArea",
    value: function showArea(id) {
      var areaObj = this.getAreaById(id);

      if (areaObj) {
        areaObj.show = true;

        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = true;
        }

        this.drawPolygon();
      }
    } //移除单个区域后的钩子方法

  }, {
    key: "_removeAreaHook",
    value: function _removeAreaHook(areaObj) {}
    /**
     * 移除单个区域
     * @param {Number|Object} item 区域的id值，或 addArea返回的区域对象
     * @return {void}  无
     */

  }, {
    key: "removeArea",
    value: function removeArea(item) {
      if (Object(Util["isNumber"])(item)) {
        item = this.getAreaById(item);
      }

      if (!item) {
        return;
      }

      this._removeAreaHook(item);

      Object(Util["removeArrayItem"])(this._areaList, item);
      this.drawPolygon();
    } //添加单个区域后的钩子方法

  }, {
    key: "_addAreaHook",
    value: function _addAreaHook(areaObj) {}
    /**
     * 添加单个区域
     *
     * @param {String[]|Array[]|LatLngPoint[]|Cesium.Cartesian3[]} positions 坐标位置数组
     * @param {Object} [options={}] 控制的参数
     * @param {Object} [options.diffHeight] 开挖深度（地形开挖时，可以控制单个区域的开挖深度）
     * @return {Object} 添加区域的记录对象
     */

  }, {
    key: "addArea",
    value: function addArea(positions, options) {
      if (!positions || positions.length == 0) {
        return;
      }

      var areaObj = {
        show: true,
        id: ++this._cache_id,
        positions_original: positions,
        //原始的，用于井
        positions: LatLngArray_LatLngArray.toCartesians(positions)
      };

      this._areaList.push(areaObj);

      Object(Log["logInfo"])("添加地形处理区域", LatLngArray_LatLngArray.toArray(positions)); //打印下边界

      this.computedCenter();

      this._prepareFlood();

      this.prepareCamera();
      this.prepareFBO();
      this.drawPolygon();
      this.beginTailor();

      this._addAreaHook(areaObj, options);

      return areaObj;
    }
  }, {
    key: "computedCenter",
    value: function computedCenter() {
      var total = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();

      this._areaList.forEach(function (areaObj) {
        var arr = areaObj.positions;

        if (!arr) {
          return;
        } // let polygon = new Cesium.PolygonGeometry({
        //   polygonHierarchy: new Cesium.PolygonHierarchy(arr),
        // });
        // polygon = Cesium.PolygonGeometry.createGeometry(polygon);
        // const center = polygon.boundingSphere.center;


        var boundingSphere = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromPoints(arr);
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(total, boundingSphere.center, total);
      });

      this.totalCenter = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(total, 1 / this._areaList.length, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
    } //与处理顶点数组

  }, {
    key: "_prepareFlood",
    value: function _prepareFlood() {
      var _this2 = this;

      var context = this._map.scene.context;
      this.trans = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this.totalCenter);
      this.inverTrans = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(this.trans, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      var minX = 99999999;
      var minY = 99999999;
      var maxX = -99999999;
      var maxY = -99999999;

      this._areaList.forEach(function (areaObj) {
        var arr = areaObj.positions;
        var polygon = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"]({
          polygonHierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](arr)
        });
        polygon = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].createGeometry(polygon);
        var indexs = polygon.indices;
        var positionVal = polygon.attributes.position.values;
        var lenV = positionVal.length;
        var localPos = [];
        var localVertex = [];

        for (var i = 0; i < lenV; i += 3) {
          var currx = positionVal[i];
          var curry = positionVal[i + 1];
          var currz = positionVal[i + 2];
          var currCar = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](currx, curry, currz);
          var localp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(_this2.inverTrans, currCar, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
          localp.z = 0;
          localPos.push(localp);
          localVertex.push(localp.x);
          localVertex.push(localp.y);
          localVertex.push(localp.z);

          if (minX >= localp.x) {
            minX = localp.x;
          }

          if (minY >= localp.y) {
            minY = localp.y;
          }

          if (maxX <= localp.x) {
            maxX = localp.x;
          }

          if (maxY <= localp.y) {
            maxY = localp.y;
          }
        }

        areaObj.localPos = localPos;
        var lps = new Float64Array(localVertex);
        var bs = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"].fromVertices(lps);
        var localGeo = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Geometry"]({
          attributes: {
            position: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["GeometryAttribute"]({
              componentDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ComponentDatatype"].DOUBLE,
              componentsPerAttribute: 3,
              values: lps
            })
          },
          indices: indexs,
          primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
          boundingSphere: bs
        });
        var sp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"].fromCache({
          context: context,
          vertexShaderSource: TerrainEditVS_default.a,
          fragmentShaderSource: TerrainEditFS_default.a,
          attributeLocations: {
            position: 0
          }
        });
        var vao = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexArray"].fromGeometry({
          context: context,
          geometry: localGeo,
          attributeLocations: sp._attributeLocations,
          bufferUsage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW,
          interleave: true
        });
        var rs = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"]();
        rs.depthRange.near = -1000000.0;
        rs.depthRange.far = 1000000.0;
        areaObj.drawAreaCommand = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"]({
          boundingVolume: bs,
          primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
          vertexArray: vao,
          shaderProgram: sp,
          renderState: rs,
          pass: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Pass"].TRANSLUCENT
        });
      });

      this.ratio = (maxY - minY) / (maxX - minX);
      this.totalRect = [minX, minY, maxX, maxY];
    }
  }, {
    key: "prepareCamera",
    value: function prepareCamera() {
      var maxDis = 120000;
      this.ortCamera = {
        viewMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY,
        inverseViewMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY,
        frustum: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["OrthographicOffCenterFrustum"](),
        positionCartographic: {
          height: 0,
          latitude: 0,
          longitude: 0
        },
        positionWC: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, maxDis / 2),
        directionWC: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, -1),
        upWC: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 1, 0),
        rightWC: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](1, 0, 0),
        viewProjectionMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY
      };
      this.ortCamera.frustum.left = this.totalRect[0];
      this.ortCamera.frustum.top = this.totalRect[3];
      this.ortCamera.frustum.right = this.totalRect[2];
      this.ortCamera.frustum.bottom = this.totalRect[1];
      this.ortCamera.frustum.near = 0.1;
      this.ortCamera.frustum.far = -maxDis;
      this.floodRect = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"](this.totalRect[0], this.totalRect[1], this.totalRect[2] - this.totalRect[0], this.totalRect[3] - this.totalRect[1]);
    }
  }, {
    key: "prepareFBO",
    value: function prepareFBO() {
      var width;
      var height;

      if (this.ratio > 1) {
        width = this._maxCanvasSize / this.ratio;
        height = this._maxCanvasSize;
      } else {
        width = this._maxCanvasSize;
        height = width * this.ratio;
      }

      var context = this._map.scene.context;
      var tailorTex = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: context,
        width: width,
        height: height,
        pixelFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelFormat"].RGBA,
        pixelDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelDatatype"].HALF_FLOAT,
        flipY: false
      });
      this.tailorTex = tailorTex;
      this.yanmoFbo = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Framebuffer"]({
        context: context,
        colorTextures: [tailorTex],
        destroyAttachments: false
      });
      this._fboClearCommand = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClearCommand"]({
        color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.0),
        framebuffer: this.yanmoFbo
      });
    }
  }, {
    key: "drawPolygon",
    value: function drawPolygon() {
      var _this3 = this;

      var context = this._map.scene.context;
      var width;
      var height;

      if (this.ratio > 1) {
        width = this._maxCanvasSize / this.ratio;
        height = this._maxCanvasSize;
      } else {
        width = this._maxCanvasSize;
        height = width * this.ratio;
      }

      var passState = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PassState"](context);
      passState.viewport = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingRectangle"](0, 0, width, height);
      var us = context.uniformState;
      us.updateCamera(this.ortCamera);

      this._fboClearCommand.execute(context);

      this._areaList.forEach(function (areaObj) {
        var command = areaObj.drawAreaCommand;

        if (command && areaObj.show) {
          us.updatePass(command.pass);
          command.framebuffer = _this3.yanmoFbo;
          command.execute(context, passState);
        }
      });
    }
  }, {
    key: "beginTailor",
    value: function beginTailor() {
      this.terrainEditCtl.inverFloodCenterMat = this.inverTrans;
      this.terrainEditCtl.floodArea = this.yanmoFbo;
      this.terrainEditCtl.enableFlood = true;
      this.terrainEditCtl.floodRect = this.floodRect;
      this.terrainEditCtl.globe = false;
    } //设置高度

  }, {
    key: "_setFloodVar",
    value: function _setFloodVar() {
      this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
    }
  }]);

  return TerrainEditBase;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/terrain/FloodByMaterial.js








function FloodByMaterial_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function FloodByMaterial_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FloodByMaterial_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FloodByMaterial_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function FloodByMaterial_createSuper(Derived) { var hasNativeReflectConstruct = FloodByMaterial_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FloodByMaterial_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} FloodByMaterial.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始分析
 * @property {String} change 变化了
 * @property {String} end  完成分析
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.end, function (event) {
 *   console.log('分析完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 淹没分析 ，
 * 基于地球材质，可以多个区域
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
 * @param {Number} [options.speed] 淹没速度
 * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
 * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
 * @param {Boolean} [options.showElseArea = true] 是否显示区域外的地图
 *
 * @export
 * @class FloodByMaterial
 * @extends {TerrainEditBase}
 * @see [支持的事件类型]{@link FloodByMaterial.EventType}
 */

var FloodByMaterial_FloodByMaterial = /*#__PURE__*/function (_TerrainEditBase) {
  inherits_default()(FloodByMaterial, _TerrainEditBase);

  var _super = FloodByMaterial_createSuper(FloodByMaterial);

  function FloodByMaterial() {
    classCallCheck_default()(this, FloodByMaterial);

    return _super.apply(this, arguments);
  }

  createClass_default()(FloodByMaterial, [{
    key: "height",
    get:
    /**
     * 淹没高度（单位：米）
     * @type {Number}
     */
    function get() {
      var _this$floodVar$;

      return (_this$floodVar$ = this.floodVar[1]) !== null && _this$floodVar$ !== void 0 ? _this$floodVar$ : this.minHeight;
    },
    set: function set(val) {
      this.floodVar[1] = val;
      this.terrainEditCtl.floodVar[1] = val;
    }
    /**
     * 淹没速度
     * @type {Number}
     */

  }, {
    key: "speed",
    get: function get() {
      return this.options.speed || 1;
    },
    set: function set(val) {
      this.options.speed = Number(val);
    } //========== 方法 ==========

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        this.options = FloodByMaterial_objectSpread(FloodByMaterial_objectSpread({}, this.options), options);
      }

      this.stop();
      var minHeight = this.options.minHeight;
      var maxHeight = this.options.maxHeight; //检查参数

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](minHeight)) {
        Object(Log["logError"])("minHeight 请传入有效数值！", minHeight);
        return;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maxHeight)) {
        Object(Log["logError"])("maxHeight 请传入有效数值！", maxHeight);
        return;
      }

      if (minHeight > maxHeight) {
        //互相交换数据
        var temp = minHeight;
        minHeight = maxHeight;
        maxHeight = temp;
      }

      this.minHeight = minHeight;
      this.maxHeight = maxHeight; //设置淹没高度

      this._setFloodVar(); //开始淹没


      this.terrainEditCtl.floodVar[0] = this.floodVar[0];
      this.terrainEditCtl.floodVar[1] = this.floodVar[1];
      this.terrainEditCtl.floodSpeed = this.speed;
      this.terrainEditCtl.globe = false;
      this.terrainEditCtl.showElseArea = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.showElseArea, true);
      this._map.scene.globe.material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("YanMo");
      return this;
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      get_default()(getPrototypeOf_default()(FloodByMaterial.prototype), "_enabledHook", this).call(this, val);

      if (val) {
        this._map.scene.globe.material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("YanMo");
      } else {
        this._map.scene.globe.material = null;
      }
    }
    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start() {
      this.stop();
      this.isStart = true;
      this.fire(EventType.start);

      this._map.on(EventType.clockTick, this._onClockTickHandler, this);
    }
  }, {
    key: "_onClockTickHandler",
    value: function _onClockTickHandler(event) {
      this.floodVar[1] += this.speed / 50; //50帧每秒

      if (this.floodVar[1] > this.floodVar[2]) {
        this.floodVar[1] = this.floodVar[2];
        this.stop();
        return;
      }

      if (this.floodVar[1] < this.floodVar[0]) {
        this.floodVar[1] = this.floodVar[0];
        this.stop();
        return;
      }

      this.terrainEditCtl.floodVar[1] = this.floodVar[1];
      this.fire(EventType.change, {
        height: this.floodVar[1]
      });
    }
    /**
     * 暂停播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this.isStart) {
        return;
      }

      this._map.off(EventType.clockTick, this._onClockTickHandler, this);

      this.isStart = false;
      this.fire(EventType.end);
    }
    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "restart",
    value: function restart() {
      this.setOptions();
      this.start();
    }
    /**
     * 清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.stop();

      get_default()(getPrototypeOf_default()(FloodByMaterial.prototype), "clear", this).call(this);
    }
  }]);

  return FloodByMaterial;
}(TerrainEditBase_TerrainEditBase);
// CONCATENATED MODULE: ./src/thing/terrain/TerrainClip.js








function TerrainClip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function TerrainClip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TerrainClip_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TerrainClip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TerrainClip_createSuper(Derived) { var hasNativeReflectConstruct = TerrainClip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TerrainClip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 地形开挖，
 * 基于地球材质，可以多个区域开挖。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
 * @param {Boolean} [options.clipOutSide = false] 是否外切开挖
 * @param {String} [options.image]  开挖区域的井墙面贴图URL。未传入该值时，不显示开挖区域的井。
 * @param {String} [options.imageBottom] 当显示开挖区域的井时，井底面贴图URL
 * @param {Number} [options.diffHeight]  当显示开挖区域的井时，设置所有区域的挖掘深度（单位：米）
 * @param {Number} [splitNum = 30] 当显示开挖区域的井时，井墙面每两点之间插值个数
 *
 * @export
 * @class TerrainClip
 * @extends {TerrainEditBase}
 */

var TerrainClip_TerrainClip = /*#__PURE__*/function (_TerrainEditBase) {
  inherits_default()(TerrainClip, _TerrainEditBase);

  var _super = TerrainClip_createSuper(TerrainClip);

  //========== 构造方法 ==========
  function TerrainClip() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TerrainClip);

    _this = _super.call(this, options);
    _this._clipOutSide = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.clipOutSide, false);
    return _this;
  } //========== 对外属性 ==========
  //分析参数


  createClass_default()(TerrainClip, [{
    key: "terrainEditCtl",
    get: function get() {
      return this._map.scene.globe._surface.tileProvider.excavateAnalysis;
    }
    /**
     * 是否外切开挖
     * @type {Boolean}
     */

  }, {
    key: "clipOutSide",
    get: function get() {
      var _this$terrainEditCtl;

      return (_this$terrainEditCtl = this.terrainEditCtl) === null || _this$terrainEditCtl === void 0 ? void 0 : _this$terrainEditCtl.showTailorOnly;
    },
    set: function set(val) {
      this.terrainEditCtl.showTailorOnly = val;
    }
    /**
     * 设置所有区域的挖掘深度（单位：米）
     * @type {Number}
     */

  }, {
    key: "diffHeight",
    get: function get() {
      return this.options.diffHeight;
    },
    set: function set(val) {
      this.options.diffHeight = val;

      if (this._graphicLayer) {
        this._graphicLayer.eachGraphic(function (pitPrimitive) {
          pitPrimitive.diffHeight = val;
        });
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      this._map.scene.globe._surface.tileProvider.applyTailor = val;
      this.terrainEditCtl.enableTailor = val;

      if (this._graphicLayer) {
        this._graphicLayer.show = val;
      }

      if (val) {
        this._map.scene.globe.material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("WaJue");
      } else {
        this._map.scene.globe.material = null;
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      if (!this._map.scene.highDynamicRange) {
        this._map.scene.highDynamicRange = true;
        this._hasChangeHighDynamicRange = true;
      }

      if (!this._map.scene.globe.depthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = true;
        this._hasChangeDepthTestAgainstTerrain = true;
      } //开挖对应的井对象


      this._graphicLayer = new GraphicLayer_GraphicLayer(this.options);
      this._graphicLayer._tudou3d_private = true;

      this._map.addLayer(this._graphicLayer);

      get_default()(getPrototypeOf_default()(TerrainClip.prototype), "_addedHook", this).call(this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear();

      if (this.tailorTex && this.tailorTex.destroy) {
        this.tailorTex.destroy();
      }

      this.yanmoFbo = null;
      this._map.scene.globe._surface.tileProvider.applyTailor = false;
      this.terrainEditCtl.enableTailor = false;
      this.terrainEditCtl.inverTailorCenterMat = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY;
      this.terrainEditCtl.tailorArea = undefined; //开挖对应的井对象

      this._map.removeLayer(this._graphicLayer);

      delete this._graphicLayer;

      if (this._hasChangeHighDynamicRange) {
        this._map.scene.highDynamicRange = false;
        this._hasChangeHighDynamicRange = false;
      }

      if (this._hasChangeDepthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = false;
        this._hasChangeDepthTestAgainstTerrain = false;
      }
    }
    /**
     * 清除开挖
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      get_default()(getPrototypeOf_default()(TerrainClip.prototype), "clear", this).call(this);

      this._graphicLayer.clear();
    } //添加区域后的钩子方法

  }, {
    key: "_addAreaHook",
    value: function _addAreaHook(areaObj, options) {
      if (this.options.image) {
        areaObj.pitPrimitive = new Pit_Pit({
          style: TerrainClip_objectSpread(TerrainClip_objectSpread({}, this.options), options),
          positions: areaObj.positions_original
        });

        this._graphicLayer.addGraphic(areaObj.pitPrimitive);
      }
    } //移除单个区域后的钩子方法

  }, {
    key: "_removeAreaHook",
    value: function _removeAreaHook(areaObj) {
      if (areaObj !== null && areaObj !== void 0 && areaObj.pitPrimitive) {
        this._graphicLayer.removeGraphic(areaObj.pitPrimitive);
      }
    }
  }, {
    key: "beginTailor",
    value: function beginTailor() {
      this._map.scene.globe._surface.tileProvider.applyTailor = true;
      this.terrainEditCtl.inverTailorCenterMat = this.inverTrans;
      this.terrainEditCtl.tailorArea = this.yanmoFbo;
      this.terrainEditCtl.enableTailor = true;
      this.terrainEditCtl.tailorRect = this.floodRect;
    }
  }]);

  return TerrainClip;
}(TerrainEditBase_TerrainEditBase);
// CONCATENATED MODULE: ./src/thing/terrain/ContourLine.js







function ContourLine_createSuper(Derived) { var hasNativeReflectConstruct = ContourLine_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ContourLine_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 等高线
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
 * @param {Boolean} [options.contourShow = true] 是否显示等高线
 * @param {Number} [options.spacing = 100.0] 等高线 间隔（单位：米）
 * @param {Number} [options.width = 1.5] 等高线 线宽（单位：像素）
 * @param {Cesium.Color|String} [options.color = Cesium.Color.RED] 等高线 颜色
 * @param {String} [options.shadingType = 'none'] 地表渲染效果，可选值: 无none, 高程 elevation, 坡度slope, 坡向aspect
 * @param {Object} [options.colorScheme ] 地表渲染配色方案,默认值为：
 * {
      elevation: {
        step: [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0],
        color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
      },
      slope: {
        step: [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0],
        color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
      },
      aspect: {
        step: [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0],
        color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
      },
   }
 * @param {Boolean} [options.showElseArea = true] 是否显示区域外的地图
 * @param {Number} [options.minHeight = -414.0] 地表渲染配色方案中的 最低海拔高度
 * @param {Number} [options.maxHeight = 8777] 地表渲染配色方案中的 最高海拔高度
 *
 * @export
 * @class ContourLine
 * @extends {TerrainEditBase}
 */

var ContourLine_ContourLine = /*#__PURE__*/function (_TerrainEditBase) {
  inherits_default()(ContourLine, _TerrainEditBase);

  var _super = ContourLine_createSuper(ContourLine);

  //========== 构造方法 ==========
  function ContourLine() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ContourLine);

    _this = _super.call(this, options);
    _this._contourShow = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.contourShow, true);
    _this._contourSpacing = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.spacing, 100.0);
    _this._contourWidth = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.width, 1.5);
    _this._contourColor = Object(Util["getCesiumColor"])(options.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].RED);
    _this._shadingType = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.shadingType, "none");
    /**
     * 赵西洋
     * 20210910
     * 修改渲染图的透明度
     */

    _this._alpha = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.alpha, 1.0).toFixed(2); //配色方案

    _this.colorScheme = options.colorScheme || {
      elevation: {
        step: [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      },
      slope: {
        step: [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      },
      aspect: {
        step: [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      }
    };
    _this.minHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minHeight, -414.0); // approximate dead sea elevation

    _this.maxHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxHeight, 8777.0); // approximate everest elevation

    return _this;
  } //========== 对外属性 ==========

  /**
   * 是否显示等高线
   * @type {Boolean}
   */


  createClass_default()(ContourLine, [{
    key: "contourShow",
    get: function get() {
      return this._contourShow;
    },
    set: function set(val) {
      this._contourShow = val;
      this.updateMaterial();
    }
    /**
     * 地表渲染效果，可选值: 无none, 高程 elevation, 坡度slope, 坡向aspect
     * @type {String}
     */

  }, {
    key: "shadingType",
    get: function get() {
      return this._shadingType;
    },
    set: function set(val) {
      this._shadingType = val;
      this.updateMaterial();
    }
    /**
     * 等高线 线宽（单位：像素）
     * @type {Number}
     */

  }, {
    key: "width",
    get: function get() {
      return this._contourWidth;
    },
    set: function set(val) {
      this._contourWidth = val;

      if (this.contourUniforms) {
        this.contourUniforms.width = val;
      }
    }
    /**
     * 等高线 间隔（单位：米）
     * @type {Number}
     */

  }, {
    key: "spacing",
    get: function get() {
      return this._contourSpacing;
    },
    set: function set(val) {
      this._contourSpacing = val;

      if (this.contourUniforms) {
        this.contourUniforms.spacing = val;
      }
    }
    /**
     * 等高线 颜色
     * @type {Cesium.Color|String}
     */

  }, {
    key: "color",
    get: function get() {
      return this._contourColor;
    },
    set: function set(val) {
      this._contourColor = Object(Util["getCesiumColor"])(val);

      if (this.contourUniforms) {
        this.contourUniforms.color = val;
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      get_default()(getPrototypeOf_default()(ContourLine.prototype), "_enabledHook", this).call(this, val);

      this.updateMaterial();
    }
    /**
     * 清除数据
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      get_default()(getPrototypeOf_default()(ContourLine.prototype), "clear", this).call(this);

      this._map.scene.globe.material = null;
      this.contourUniforms = null;

      if (this.hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].now();
        delete this.hasResetEnableLighting;
      }
    } //添加区域后的钩子方法

  }, {
    key: "_addAreaHook",
    value: function _addAreaHook() {
      this._setFloodVar();

      this.updateMaterial();
    } //=========地球渲染材质相关==========

  }, {
    key: "updateMaterial",
    value: function updateMaterial() {
      var material;
      var contourUniforms;
      var shadingUniforms;
      var _shadingType = this._shadingType;

      if (this.contourShow) {
        if (_shadingType == "elevation") {
          material = this.getElevationContourMaterial();
          shadingUniforms = material.materials.elevationRampMaterial.uniforms;
          shadingUniforms.minimumHeight = this.minHeight;
          shadingUniforms.maximumHeight = this.maxHeight;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType == "slope") {
          material = this.getSlopeContourMaterial();
          shadingUniforms = material.materials.slopeRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType == "aspect") {
          material = this.getAspectContourMaterial();
          shadingUniforms = material.materials.aspectRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else {
          material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("ElevationContour");
          contourUniforms = material.uniforms;
        }

        contourUniforms.width = this._contourWidth;
        contourUniforms.spacing = this._contourSpacing;
        contourUniforms.color = this._contourColor;
      } else if (_shadingType == "elevation") {
        material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("ElevationRamp");
        shadingUniforms = material.uniforms;
        shadingUniforms.minimumHeight = this.minHeight;
        shadingUniforms.maximumHeight = this.maxHeight;
      } else if (_shadingType == "slope") {
        material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("SlopeRamp");
        shadingUniforms = material.uniforms;
      } else if (_shadingType == "aspect") {
        material = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"].fromType("AspectRamp");
        shadingUniforms = material.uniforms;
      }

      if (_shadingType != "none") {
        shadingUniforms.image = this.getColorRamp(_shadingType);
      }

      if (!this._map.scene.globe.enableLighting) {
        this._map.scene.globe.enableLighting = true;
        var now = new Date();
        now.setHours(10);
        this._map.clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(now));
        this.hasResetEnableLighting = true;
      }

      this.contourUniforms = contourUniforms;
      /**
       * 赵西洋
       * 设置透明度,未判断material是否存在
       * 20211218
       */
      // if (material) {
      //   material.translucent = this.true;
      //   material.shaderSource =
      //     "uniform sampler2D image_0;czm_material czm_getMaterial(czm_materialInput materialInput){" +
      //     " czm_material material = czm_getDefaultMaterial(materialInput);" +
      //     " vec4 rampColor = texture2D(image_0, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));" +
      //     "rampColor = czm_gammaCorrect(rampColor);" +
      //     "material.diffuse = rampColor.rgb;" +
      //     `material.alpha = ${this._alpha};` +
      //     "return material;" +
      //     "}";
      // }

      this._map.scene.globe.material = material;
    }
  }, {
    key: "getColorRamp",
    value: function getColorRamp(_shadingType) {
      var _colorScheme$step;

      var ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;
      var ctx = ramp.getContext("2d");
      var grd = ctx.createLinearGradient(0, 0, 100, 0);
      var colorScheme = this.colorScheme[_shadingType];

      if ((colorScheme === null || colorScheme === void 0 ? void 0 : (_colorScheme$step = colorScheme.step) === null || _colorScheme$step === void 0 ? void 0 : _colorScheme$step.length) > 0) {
        for (var i = 0, len = colorScheme.step.length; i < len; i++) {
          grd.addColorStop(colorScheme.step[i], colorScheme.color[i]);
        }
      }

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);
      return ramp;
    }
  }, {
    key: "getElevationContourMaterial",
    value: function getElevationContourMaterial() {
      // Creates a composite material with both elevation shading and contour lines
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
        fabric: {
          type: "ElevationColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            elevationRampMaterial: {
              type: "ElevationRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }, {
    key: "getSlopeContourMaterial",
    value: function getSlopeContourMaterial() {
      // Creates a composite material with both slope shading and contour lines
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
        fabric: {
          type: "SlopeColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            slopeRampMaterial: {
              type: "SlopeRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? slopeRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, slopeRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }, {
    key: "getAspectContourMaterial",
    value: function getAspectContourMaterial() {
      // Creates a composite material with both aspect shading and contour lines
      return new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Material"]({
        fabric: {
          type: "AspectColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            aspectRampMaterial: {
              type: "AspectRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? aspectRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, aspectRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }]);

  return ContourLine;
}(TerrainEditBase_TerrainEditBase);
// CONCATENATED MODULE: ./src/thing/tileset/LimitHeight.js







function LimitHeight_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function LimitHeight_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { LimitHeight_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { LimitHeight_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function LimitHeight_createSuper(Derived) { var hasNativeReflectConstruct = LimitHeight_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LimitHeight_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 限高分析
 * @param {Object} options 参数对象，包括以下：
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 限高区域坐标数组
 * @param {Number} [options.height] 限高高度（单位米）,相对于bottomHeight模型地面的海拔高度的相对高度。
 * @param {Number} [options.bottomHeight] 模型地面的海拔高度（单位米）
 *
 *
 * @export
 * @class LimitHeight
 * @extends {BaseThing}
 */

var LimitHeight_LimitHeight = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(LimitHeight, _BaseThing);

  var _super = LimitHeight_createSuper(LimitHeight);

  function LimitHeight() {
    classCallCheck_default()(this, LimitHeight);

    return _super.apply(this, arguments);
  }

  createClass_default()(LimitHeight, [{
    key: "layer",
    get:
    /**
     * 矢量数据图层
     * @type {GraphicLayer}
     * @readonly
     */
    function get() {
      return this._layer;
    }
    /**
     * 分析区域坐标数组
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this.options.positions;
    },
    set: function set(val) {
      this.options.positions = val;

      this._createGraphic();
    }
    /**
     * 限高高度（单位米）,相对于bottomHeight模型地面的海拔高度的相对高度。
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      return this.options.height || 0;
    },
    set: function set(val) {
      this.options.height = val;

      this._createGraphic();
    }
    /**
     * 模型地面的海拔高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "bottomHeight",
    get: function get() {
      return this.options.bottomHeight || 0;
    },
    set: function set(val) {
      this.options.bottomHeight = val;

      this._createGraphic();
    } //========== 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._layer = new GraphicLayer_GraphicLayer();
      this._layer._tudou3d_private = true;
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.addLayer(this._layer);

      if (this.options.positions) {
        this.positions = this.options.positions;
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);

        delete this._graphic;
      }

      this._map.removeLayer(this._layer);
    } //

  }, {
    key: "_createGraphic",
    value: function _createGraphic() {
      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);

        delete this._graphic;
      }

      if (!this.options.positions) {
        return;
      }

      var positions = LatLngArray_LatLngArray.toCartesians(this.options.positions);
      this._graphic = new PolygonPrimitive_PolygonPrimitive({
        positions: positions,
        style: LimitHeight_objectSpread(LimitHeight_objectSpread({}, this.options), {}, {
          height: this.bottomHeight + this.height,
          diffHeight: 10000,
          perPositionHeight: false,
          classification: true,
          classificationType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClassificationType"].CESIUM_3D_TILE
        }),
        asynchronous: false
      });

      this._layer.addGraphic(this._graphic);
    }
    /**
     *  清除限高分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.options.positions = null;

      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);

        delete this._graphic;
      }
    }
  }]);

  return LimitHeight;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/tileset/TilesetPlanClip.js






function TilesetPlanClip_createSuper(Derived) { var hasNativeReflectConstruct = TilesetPlanClip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetPlanClip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





 //裁剪模型 类型 枚举

var ClipType = {
  /** z水平面, 切底部 */
  Z: 1,

  /** z水平面，切顶部 */
  ZR: 2,

  /** x垂直面,切西向 */
  X: 3,

  /** x垂直面,切东向 */
  XR: 4,

  /** y垂直面, 切南向 */
  Y: 5,

  /** y垂直面，切北向*/
  YR: 6
};
/**
 * 3dtiles模型裁剪，
 * 基于clippingPlanes接口，只支持单个开挖。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 裁剪区域坐标数组(按面或线裁剪)
 * @param {Number} [options.height] 当有裁剪区域挖时，底面的高度（单位米），未设置时不显示底面。
 *
 * @param {TilesetPlanClip.Type} [options.type]  裁剪类型（按方向类型正方向单面裁剪）
 * @param {Number} [options.distance=0] 裁剪的距离
 *
 * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
 * @param {Number} [options.edgeWidth=0] 裁剪区域边线宽度，0时不显示
 * @param {Cesium.Color} [options.edgeColor=Cesium.Color.WHITE] 裁剪区域边线颜色
 *
 * @export
 * @class TilesetPlanClip
 * @extends {BaseThing}
 */

var TilesetPlanClip_TilesetPlanClip = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(TilesetPlanClip, _BaseThing);

  var _super = TilesetPlanClip_createSuper(TilesetPlanClip);

  function TilesetPlanClip() {
    classCallCheck_default()(this, TilesetPlanClip);

    return _super.apply(this, arguments);
  }

  createClass_default()(TilesetPlanClip, [{
    key: "clipTarget",
    get:
    /**
     * 裁剪的对象模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     * @private
     */
    function get() {
      return this._tileset;
    },
    set: function set(val) {
      this._tileset = val;
      this._inverseMatrix = null;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.positions)) {
        this.positions = this.options.positions;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.type)) {
        this.type = this.options.type;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.distance)) {
        this.distance = this.options.distance;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.normalZ)) {
        this.normalZ = this.options.normalZ;
      }
    }
    /**
     * 需要裁剪的对象（3dtiles图层）
     * @type {TilesetLayer}
     */

  }, {
    key: "layer",
    get: function get() {
      return this._layer;
    },
    set: function set(tilesetLayer) {
      var _this = this;

      this._layer = tilesetLayer;

      if (tilesetLayer.loadOk) {
        this.clipTarget = tilesetLayer.tileset;
      } else {
        tilesetLayer.on(EventType.load, function (e) {
          _this.clipTarget = tilesetLayer.tileset;
        });
      }
    }
    /**
     * 裁剪面集合
     * @type {Cesium.ClippingPlaneCollection}
     * @readonly
     */

  }, {
    key: "planes",
    get: function get() {
      return this.clippingPlanes;
    }
    /**
     * 获取当前转换计算模型逆矩阵，
     * 用于 局部坐标系 与 世界坐标系 的转换。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "inverseMatrix",
    get: function get() {
      if (!this._inverseMatrix) {
        var transform;
        var tmp = this._tileset.root.transform;

        if (tmp && tmp.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY) || !tmp) {
          // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
          transform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromArray(this._tileset.root.transform);
        }

        this._inverseMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverseTransformation(transform, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      }

      return this._inverseMatrix;
    }
    /**
     * 更新最后一个面的 裁剪距离 (单位：米)
     * @type {Number}
     */

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    },
    set: function set(val) {
      this._distance = val;

      if (this.clippingPlanes && this.clippingPlanes.length > 0) {
        var plane = this.clippingPlanes.get(this.clippingPlanes.length - 1);
        plane.distance = val;
      }
    }
    /**
     * 裁剪的斜面偏移量
     * @type {Number}
     */

  }, {
    key: "normalZ",
    get: function get() {
      return this._normalZ || 0;
    },
    set: function set(val) {
      this._normalZ = val;

      if (this.clippingPlanes && this.clippingPlanes.length > 0) {
        var plane = this.clippingPlanes.get(this.clippingPlanes.length - 1);
        plane.normal.z = val;
      }
    }
    /**
     * 裁剪类型（按方向类型正方向单面裁剪）
     * @type {TilesetPlanClip.Type}
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      this._type = val; //裁剪面

      var planes;

      switch (val) {
        default:
          break;

        case ClipType.Z:
          //水平切底部
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 1), 1) //z水平面
          ];
          break;

        case ClipType.ZR:
          //水平切顶部
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, -1), 1) //z水平面
          ];
          break;

        case ClipType.X:
          //东西方向切1
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](1, 0, 0), 1) //x垂直面
          ];
          break;

        case ClipType.XR:
          //东西方向切2
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](-1, 0, 0), 1) //x垂直面
          ];
          break;

        case ClipType.Y:
          //南北方向切1
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 1, 0), 1) //y垂直面
          ];
          break;

        case ClipType.YR:
          //南北方向切2
          planes = [new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, -1, 0), 1) //y垂直面
          ];
          break;
      }

      this.setPlanes(planes);
    }
    /**
     * 裁剪区域坐标数组(按面或线裁剪)
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = LatLngArray_LatLngArray.toCartesians(val);

      this._setPositions(this._positions);
    }
    /**
     * 是否外裁剪
     * @type {Boolean}
     */

  }, {
    key: "clipOutSide",
    get: function get() {
      return this.options.clipOutSide;
    },
    set: function set(val) {
      this.options.clipOutSide = val;

      if (this._map && this._positions) {
        this._setPositions(this._positions);
      }
    } //========== 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //tudou3d.layer.TilesetLayer 时
      if (this.options.layer) {
        this.layer = this.options.layer;
      } //Cesium.Cesium3DTileset 时
      else if (this.options.tileset) {
        this.clipTarget = this.options.tileset;
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      if (this.clipTarget) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.positions)) {
          this.positions = this.options.positions;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.type)) {
          this.type = this.options.type;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.distance)) {
          this.distance = this.options.distance;
        }
      }
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear();
    } //根据坐标 创建裁剪面

  }, {
    key: "_setPositions",
    value: function _setPositions(points) {
      if (points.length < 2) {
        return;
      }

      var planes = [];

      if (points.length == 2) {
        //线
        var plan = this._createPlaneByLine(points[0], points[1]);

        if (plan) {
          planes.push(plan);
        }
      } else {
        //面
        //是否顺时针
        var direction;
        var startAngle = getAngle(points[0], points[1]);

        if (startAngle == 0) {
          direction = false;
        } else {
          var endAngle = getAngle(points[0], points[2]);
          direction = startAngle < endAngle;
        }

        if (this.clipOutSide) {
          direction = !direction;
        }

        var _plan;

        for (var i = 0, len = points.length; i < len; ++i) {
          var nextIndex = (i + 1) % len;

          if (direction) {
            _plan = this._createPlaneByLine(points[nextIndex], points[i]);
          } else {
            _plan = this._createPlaneByLine(points[i], points[nextIndex]);
          }

          if (_plan) {
            if (this._normalZ) {
              _plan.normal.z = this._normalZ;
            }

            planes.push(_plan);
          }
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.height)) {
          _plan = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"](new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, -1), this.options.height); //底面

          planes.push(_plan);
        }
      }

      this.setPlanes(planes);
    }
  }, {
    key: "_createPlaneByLine",
    value: function _createPlaneByLine(p1, p2) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(p1, p2) < 0.1) {
        return null;
      } // 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象


      var inverseMatrix = this.inverseMatrix;
      var p1C3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(inverseMatrix, p1, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0));
      var p2C3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(inverseMatrix, p2, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 0)); // 定义一个垂直向上的向量up

      var up = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0, 0, 10); //  right 实际上就是由p1指向p2的向量

      var right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(p2C3, p1C3, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); // 计算normal， right叉乘up，得到平面法向量，这个法向量指向right的右侧

      var normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(right, up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      normal = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(normal, normal); //由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane

      var planeTmp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Plane"].fromPointNormal(p1C3, normal);
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlane"].fromPlane(planeTmp);
    }
  }, {
    key: "setPlanes",
    value: function setPlanes(planes) {
      if (!planes) {
        return;
      }

      var clippingPlanes = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClippingPlaneCollection"]({
        planes: planes,
        edgeWidth: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.edgeWidth, 0.0),
        edgeColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.edgeColor, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE),
        unionClippingRegions: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.clipOutSide, false)
      });
      this.clippingPlanes = clippingPlanes;

      if (this.clipTarget) {
        this.clipTarget.clippingPlanes = clippingPlanes;
      }
    }
    /**
     *  清除裁剪面
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      var _this$clipTarget, _this$clipTarget$clip;

      this._positions = null;
      this._normalZ = 0;
      this.options.clipOutSide = false;

      if (this.clippingPlanes) {
        delete this.clippingPlanes;
      }

      if ((_this$clipTarget = this.clipTarget) !== null && _this$clipTarget !== void 0 && (_this$clipTarget$clip = _this$clipTarget.clippingPlanes) !== null && _this$clipTarget$clip !== void 0 && _this$clipTarget$clip.enabled) {
        this.clipTarget.clippingPlanes.enabled = false;
      }

      this.clipTarget.clippingPlanes = undefined;
    }
    /**
     * 更新所有面的 裁剪距离 (单位：米)
     *
     * @param {Number} val 裁剪距离 (单位：米)
     * @return {void}  无
     */

  }, {
    key: "updateAllDistance",
    value: function updateAllDistance(val) {
      if (this.clippingPlanes == null) {
        return;
      }

      for (var i = 0; i < this.clippingPlanes.length; i++) {
        var plane = this.clippingPlanes.get(i);
        plane.distance = val;
      }
    }
    /**
     * 更新所有面的 裁剪的斜面偏移量
     *
     * @param {Number} val 斜面偏移量
     * @return {void}  无
     */

  }, {
    key: "updateAllNormalZ",
    value: function updateAllNormalZ(val) {
      if (this.clippingPlanes == null) {
        return;
      }

      for (var i = 0; i < this.clippingPlanes.length; i++) {
        var plane = this.clippingPlanes.get(i);
        plane.normal.z = val;
      }
    }
  }]);

  return TilesetPlanClip;
}(BaseThing_BaseThing);
/**
 * 裁剪模型 类型 枚举
 * @property {Number} 	Z  z水平面, 切底部
 * @property {Number} 	ZR z水平面，切顶部
 * @property {Number} 	X x垂直面,切西向
 * @property {Number} 	XR x垂直面,切东向
 * @property {Number} 	Y y垂直面, 切南向
 * @property {Number} 	YR y垂直面，切北向
 * @enum {Number}
 */

TilesetPlanClip_TilesetPlanClip.Type = ClipType;
// CONCATENATED MODULE: ./src/thing/tileset/ModelPlanClip.js






function ModelPlanClip_createSuper(Derived) { var hasNativeReflectConstruct = ModelPlanClip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ModelPlanClip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * Gltf模型剖切，
 * 基于clippingPlanes接口，只支持单个开挖。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {ModelEntity} options.graphic 需要裁剪的对象（gltf模型）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 裁剪区域坐标数组(按面或线裁剪)
 * @param {Number} [options.height] 当有裁剪区域挖时，底面的高度（单位米），未设置时不显示底面。
 *
 * @param {TilesetPlanClip.Type} [options.type]  裁剪类型（按方向类型正方向单面裁剪）
 * @param {Number} [options.distance=0] 裁剪的距离
 *
 * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
 * @param {Number} [options.edgeWidth=0] 裁剪区域边线宽度，0时不显示
 * @param {Cesium.Color} [options.edgeColor=Cesium.Color.WHITE] 裁剪区域边线颜色
 *
 * @export
 * @class ModelPlanClip
 * @extends {TilesetPlanClip}
 */

var ModelPlanClip_ModelPlanClip = /*#__PURE__*/function (_TilesetPlanClip) {
  inherits_default()(ModelPlanClip, _TilesetPlanClip);

  var _super = ModelPlanClip_createSuper(ModelPlanClip);

  function ModelPlanClip() {
    classCallCheck_default()(this, ModelPlanClip);

    return _super.apply(this, arguments);
  }

  createClass_default()(ModelPlanClip, [{
    key: "clipTarget",
    get: //========== 对外属性 ==========

    /**
     * 裁剪的对象模型 对应的Entity对象
     * @type {Cesium.Entity}
     * @private
     */
    function get() {
      return this._model;
    },
    set: function set(val) {
      this._model = val;
      this._inverseMatrix = null;

      if (this.clippingPlanes) {
        this._model.clippingPlanes = this.clippingPlanes;
      }
    }
    /**
     * 需要裁剪的对象（gltf模型）
     * @type {ModelEntity}
     */

  }, {
    key: "graphic",
    get: function get() {
      return this._graphic;
    },
    set: function set(value) {
      this._graphic = value;

      if (value.entity) {
        this._model = value.entity.model;
        this._modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(Object(PointUtil["getPositionValue"])(value.position));
      } else if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]) {
        this._model = value.model;
        this._modelMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(Object(PointUtil["getPositionValue"])(value.position));
      } else if (value.primitive) {
        this._model = value.primitive;
        this._modelMatrix = value.modelMatrix;
      } else if (value instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Model"]) {
        this._model = value;
        this._modelMatrix = value.modelMatrix;
      }
    }
    /**
     * 获取当前转换计算模型逆矩阵，
     * 用于 局部坐标系 与 世界坐标系 的转换。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "inverseMatrix",
    get: function get() {
      if (!this._inverseMatrix && this._modelMatrix) {
        this._inverseMatrix = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverseTransformation(this._modelMatrix, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      }

      return this._inverseMatrix;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //tudou3d.graphic.ModelEntity时
      if (this.options.graphic) {
        this.graphic = this.options.graphic;
      } //model entity时
      else if (this.options.entity) {
        this.clipTarget = this.options.entity;
      }
    }
  }]);

  return ModelPlanClip;
}(TilesetPlanClip_TilesetPlanClip);
/**
 * 裁剪模型 类型 枚举 同{@link TilesetPlanClip.Type}
 * @enum {Number}
 */

ModelPlanClip_ModelPlanClip.Type = TilesetPlanClip_TilesetPlanClip.Type;
// EXTERNAL MODULE: ./src/shaders/TilesetEditVS.glsl
var TilesetEditVS = __webpack_require__(82);
var TilesetEditVS_default = /*#__PURE__*/__webpack_require__.n(TilesetEditVS);

// EXTERNAL MODULE: ./src/shaders/TilesetEditFS.glsl
var TilesetEditFS = __webpack_require__(83);
var TilesetEditFS_default = /*#__PURE__*/__webpack_require__.n(TilesetEditFS);

// CONCATENATED MODULE: ./src/thing/tileset/TilesetEditBase.js






function TilesetEditBase_createSuper(Derived) { var hasNativeReflectConstruct = TilesetEditBase_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetEditBase_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * 3dtiles模型分析（裁剪、压平、淹没） 基础类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {TilesetLayer} options.layer 需要模型分析的对象（3dtiles图层）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只分析的单个区域【单个区域场景时使用】
 *
 * @export
 * @class TilesetEditBase
 * @extends {BaseThing}
 */

var TilesetEditBase_TilesetEditBase = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(TilesetEditBase, _BaseThing);

  var _super = TilesetEditBase_createSuper(TilesetEditBase);

  //========== 构造方法 ==========
  function TilesetEditBase() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TilesetEditBase);

    _this = _super.call(this, options);
    _this._areaList = []; //区域数组

    _this._cache_id = 0;
    return _this;
  } //========== 对外属性 ==========

  /**
   * 区域 列表
   * @type {Object[]}
   * @readonly
   */


  createClass_default()(TilesetEditBase, [{
    key: "list",
    get: function get() {
      return this._areaList;
    }
    /**
     * 需要分析的模型（3dtiles图层）
     * @type {TilesetLayer}
     */

  }, {
    key: "layer",
    get: function get() {
      return this._layer;
    },
    set: function set(tilesetLayer) {
      var _this2 = this;

      this._layer = tilesetLayer;

      if (tilesetLayer.loadOk) {
        this.tileset = tilesetLayer.tileset;
      } else {
        tilesetLayer.on(EventType.load, function (e) {
          _this2.tileset = tilesetLayer.tileset;
        });
      }
    }
    /**
     * 需要分析的模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     */

  }, {
    key: "tileset",
    get: function get() {
      return this._tileset;
    },
    set: function set(val) {
      this._tileset = val;
      this._inverseTransform = null;

      if (this.options.positions) {
        this.addArea(this.options.positions);
      }
    }
    /**
     * 获取当前转换计算模型矩阵。如果方向或位置未定义，则返回undefined。
     * @type {Cesium.Matrix4}
     * @readonly
     */

  }, {
    key: "matrix",
    get: function get() {
      if (!this._tileset) {
        return null;
      } //是否z轴向上，默认为y向上


      this.upZ = this._tileset.asset.gltfUpAxis == "Z" || this._tileset.asset.gltfUpAxis == "z";

      if (!this._inverseTransform) {
        var transform; // if (this.tileset.tudouEditor.useSelfMatrix) {
        //   transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center)
        //   this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4())
        // } else {

        var tmp = this._tileset.root.transform;

        if (!tmp || tmp.equals(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY)) {
          // 不存在 root.transform
          transform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].fromArray(this._tileset.root.transform);
        }

        this._inverseTransform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverseTransformation(transform, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]()); // }
      }

      return this._inverseTransform;
    }
    /**
     * 坐标位置数组，只显示单个区域【单个区域场景时使用】
     * @type {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]}
     */

  }, {
    key: "positions",
    get: function get() {
      if (this.length > 0) {
        return this._areaList[0].positions;
      } else {
        return null;
      }
    },
    set: function set(val) {
      this.clear();
      this.addArea(val);
    }
    /**
     * 已添加的区域个数
     * @type {Int}
     * @readonly
     */

  }, {
    key: "length",
    get: function get() {
      if (this._areaList) {
        var _this$_areaList;

        return (_this$_areaList = this._areaList) === null || _this$_areaList === void 0 ? void 0 : _this$_areaList.length;
      } else {
        return 0;
      }
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      var _this$tileset;

      if ((_this$tileset = this.tileset) !== null && _this$tileset !== void 0 && _this$tileset.tudouEditor) {
        this.tileset.tudouEditor.enable = val;
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //tudou3d.layer.TilesetLayer 时
      if (this.options.layer) {
        this.layer = this.options.layer;
      } //Cesium.Cesium3DTileset 时
      else if (this.options.tileset) {
        this.tileset = this.options.tileset;
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._enabledHook(this.enabled);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.clear();

      if (this._map.scene.primitives.contains(this)) {
        this._map.scene.primitives.remove(this);
      }

      if (this.graphicLayer) {
        this._map.removeLayer(this.graphicLayer);
      }
    }
    /**
     * 清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this._areaList = [];
      this._cache_id = 0;

      this._disable();
    }
    /**
     * 根据id获取区域对象
     *
     * @param {Number} id id值
     * @return {Object} 区域对象
     */

  }, {
    key: "getAreaById",
    value: function getAreaById(id) {
      for (var i = 0; i < this._areaList.length; i++) {
        var item = this._areaList[i];

        if (item.id == id) {
          return item;
        }
      }

      return null;
    }
    /**
     * 隐藏单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */

  }, {
    key: "hideArea",
    value: function hideArea(id) {
      var item = this.getAreaById(id);

      if (item) {
        item.show = false;
        this.drawed = false;
      }
    }
    /**
     * 显示单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */

  }, {
    key: "showArea",
    value: function showArea(id) {
      var item = this.getAreaById(id);

      if (item) {
        item.show = true;
        this.drawed = false;
      }
    }
    /**
     * 移除单个区域
     * @param {Number|Object} item 区域的id，或 addArea返回的区域对象
     * @return {void}  无
     */

  }, {
    key: "removeArea",
    value: function removeArea(item) {
      if (Object(Util["isNumber"])(item)) {
        item = this.getAreaById(item);
      }

      if (item) {
        Object(Util["removeArrayItem"])(this._areaList, item);

        this._disable();

        this._activete();
      }
    }
    /**
     * 添加区域
     *
     * @param {String[]|Array[]|LatLngPoint[]|Cesium.Cartesian3[]} positions 坐标位置数组
     * @return {Object} 添加区域的记录对象
     */

  }, {
    key: "addArea",
    value: function addArea(positions) {
      if (!positions || positions.length === 0) {
        return;
      }

      var areaObj = {
        show: true,
        id: ++this._cache_id,
        positions: LatLngArray_LatLngArray.toCartesians(positions)
      };

      this._areaList.push(areaObj);

      this._disable();

      this._activete();

      return areaObj;
    }
  }, {
    key: "_activete",
    value: function _activete() {
      if (!this._tileset) {
        return;
      }

      this._preparePos();

      this._createTexture();

      if (!this._map.scene.primitives.contains(this)) {
        this._map.scene.primitives.add(this);
      }
    }
  }, {
    key: "_disable",
    value: function _disable() {
      var _this$tileset2;

      if ((_this$tileset2 = this.tileset) !== null && _this$tileset2 !== void 0 && _this$tileset2.tudouEditor) {
        if (this.fbo && this.fbo.destroy) {
          this.fbo.destroy();
          this.fbo = null;
        }

        this.tileset.tudouEditor.IsYaPing = [false, false, false, false]; //[是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]

        this.tileset.tudouEditor.editVar = [false, false, false, false]; //[是否开启裁剪外部，是否开启淹没全局，]

        this.tileset.tudouEditor.floodColor = [0.0, 0.0, 0.0, 0.5]; //[淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]

        this.tileset.tudouEditor.floodVar = [0, 0, 0, 0]; //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]

        this.tileset.tudouEditor.heightVar = [0, 0]; //基础压平高度，调整压平高度值

        this.tileset.tudouEditor.enable = false;
      }

      this.drawed = false;
    } //更新

  }, {
    key: "update",
    value: function update(frameState) {
      var _this3 = this;

      if (this.drawed || !this._areaList || this._areaList.length == 0) {
        return;
      }

      this._createCommand();

      this._activeTudouEditor();

      this.drawed = true;
      var context = frameState.context;
      var width = 4096;
      var height = 4096;

      if (!this._passState) {
        this._passState = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PassState"](context);
      }

      this._passState.framebuffer = this.fbo;
      this._passState.viewport = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingRectangle"](0, 0, width, height);
      var us = context.uniformState;
      us.updateCamera(this._camera);

      this._fboClearCommand.execute(frameState.context);

      this._areaList.forEach(function (areaObj) {
        var command = areaObj.drawCommand;

        if (command && areaObj.show) {
          us.updatePass(command.pass);
          command.framebuffer = _this3.fbo;
          command.execute(context, _this3._passState);
        }
      });
    }
  }, {
    key: "_activeTudouEditor",
    value: function _activeTudouEditor() {}
  }, {
    key: "deActiveEdit",
    value: function deActiveEdit() {
      //激活
      this.tileset.tudouEditor.IsYaPing[0] = false;
    } //预处理顶点

  }, {
    key: "_preparePos",
    value: function _preparePos() {
      var _minLocalZ;

      var _minHeight = 99999; //2021-7-17

      var inverMAT = this.matrix;

      this._areaList.forEach(function (areaObj) {
        if (!areaObj.show) {
          return;
        }

        var localPos = [];
        var positions = areaObj.positions;

        if (positions && positions.length > 2) {
          for (var i = 0; i < positions.length; i++) {
            var cart = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(positions[i]);
            var height = cart.height;
            var currLocalPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(inverMAT, positions[i], new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
            localPos.push(currLocalPos);

            if (height < _minHeight) {
              _minHeight = height;
              _minLocalZ = currLocalPos.z;
            }
          }

          areaObj.localPos = localPos;
        }
      });

      this._minLocalZ = _minLocalZ;
    }
  }, {
    key: "_createTexture",
    value: function _createTexture() {
      //创建FBO以及清除指令
      var context = this._map.scene.context;
      var tt = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelFormat"].RGBA,
        pixelDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelDatatype"].FLOAT,
        sampler: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Sampler"]({
          wrapS: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TextureWrap"].CLAMP_TO_EDGE,
          wrapT: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TextureWrap"].CLAMP_TO_EDGE,
          minificationFilter: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TextureMinificationFilter"].NEAREST,
          magnificationFilter: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TextureMagnificationFilter"].NEAREST
        })
      });
      var depthStencilTexture = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Texture"]({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelFormat"].DEPTH_STENCIL,
        pixelDatatype: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PixelDatatype"].UNSIGNED_INT_24_8
      });
      this.fbo = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Framebuffer"]({
        context: context,
        colorTextures: [tt],
        depthStencilTexture: depthStencilTexture,
        destroyAttachments: false
      });
      this._fboClearCommand = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ClearCommand"]({
        color: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 0.0, 0.0, 0.0),
        framebuffer: this.fbo
      });
    }
  }, {
    key: "_createCommand",
    value: function _createCommand() {
      //创建指令
      var context = this._map.scene.context;
      var minX = 99999999;
      var minY = 99999999;
      var maxX = -99999999;
      var maxY = -99999999;

      this._areaList.forEach(function (areaObj) {
        var localPos = areaObj.localPos;

        if (localPos) {
          //创建geometry
          var flattenPolygon = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"]({
            polygonHierarchy: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonHierarchy"](localPos),
            perPositionHeight: true
          });
          var ppp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PolygonGeometry"].createGeometry(flattenPolygon);
          var sp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShaderProgram"].fromCache({
            context: context,
            vertexShaderSource: TilesetEditVS_default.a,
            fragmentShaderSource: TilesetEditFS_default.a,
            attributeLocations: {
              position: 0
            }
          });
          var vao = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["VertexArray"].fromGeometry({
            context: context,
            geometry: ppp,
            attributeLocations: sp._attributeLocations,
            bufferUsage: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BufferUsage"].STATIC_DRAW,
            interleave: true
          });
          var rs = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["RenderState"]();
          rs.depthTest.enabled = false;
          rs.depthRange.near = -1000000.0;
          rs.depthRange.far = 1000000.0;
          var bg = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingRectangle"].fromPoints(areaObj.localPos, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingRectangle"]());

          if (minX > bg.x) {
            minX = bg.x;
          }

          if (minY > bg.y) {
            minY = bg.y;
          }

          if (maxX < bg.x + bg.width) {
            maxX = bg.x + bg.width;
          }

          if (maxY < bg.y + bg.height) {
            maxY = bg.y + bg.height;
          }

          var _myPorjection = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].computeOrthographicOffCenter(bg.x, bg.x + bg.width, bg.y, bg.y + bg.height, 1, 500000000, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());

          areaObj.polygonBounds = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"](bg.x, bg.y, bg.x + bg.width, bg.y + bg.height);
          areaObj.drawCommand = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DrawCommand"]({
            boundingVolume: ppp.boundingVolume,
            primitiveType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PrimitiveType"].TRIANGLES,
            vertexArray: vao,
            shaderProgram: sp,
            renderState: rs,
            pass: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Pass"].CESIUM_3D_TILE,
            uniformMap: {
              myPorjection: function myPorjection() {
                return _myPorjection;
              }
            }
          });
        }
      }); //创建相机


      var _camera = {
        viewMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY,
        inverseViewMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY,
        frustum: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["OrthographicOffCenterFrustum"](),
        positionCartographic: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"](),
        positionWC: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](),
        directionWC: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z,
        upWC: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Y,
        rightWC: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_X,
        viewProjectionMatrix: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY
      };
      _camera.frustum.left = minX;
      _camera.frustum.top = maxY;
      _camera.frustum.right = maxX;
      _camera.frustum.bottom = minY;
      this.polygonBounds = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"](minX, minY, maxX, maxY);
      this._camera = _camera;
    }
  }]);

  return TilesetEditBase;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/tileset/TilesetClip.js






function TilesetClip_createSuper(Derived) { var hasNativeReflectConstruct = TilesetClip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetClip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 3dtiles模型裁剪
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只裁剪单个区域【单个区域场景时使用】
 *
 * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
 *
 * @export
 * @class TilesetClip
 * @extends {TilesetEditBase}
 */

var TilesetClip_TilesetClip = /*#__PURE__*/function (_TilesetEditBase) {
  inherits_default()(TilesetClip, _TilesetEditBase);

  var _super = TilesetClip_createSuper(TilesetClip);

  function TilesetClip() {
    classCallCheck_default()(this, TilesetClip);

    return _super.apply(this, arguments);
  }

  createClass_default()(TilesetClip, [{
    key: "clipOutSide",
    get:
    /**
     * 是否外裁剪
     * @type {Boolean}
     */
    function get() {
      return this.options.clipOutSide;
    },
    set: function set(val) {
      var _this$tileset;

      this.options.clipOutSide = val;

      if ((_this$tileset = this.tileset) !== null && _this$tileset !== void 0 && _this$tileset.tudouEditor) {
        this.tileset.tudouEditor.editVar[0] = val;
      }
    }
  }, {
    key: "_activeTudouEditor",
    value: function _activeTudouEditor() {
      this.tileset.tudouEditor.fbo = this.fbo;
      this.tileset.tudouEditor.polygonBounds = this.polygonBounds;
      this.tileset.tudouEditor.IsYaPing[0] = true;
      this.tileset.tudouEditor.IsYaPing[2] = true;
      this.tileset.tudouEditor.editVar[0] = this.clipOutSide;
      this.tileset.tudouEditor.enable = this.enabled; //Hao

      this.tileset.tudouEditor._inverseTransform = this.matrix;
      this.tileset.tudouEditor.upZ = this.upZ;
    }
  }]);

  return TilesetClip;
}(TilesetEditBase_TilesetEditBase);
// CONCATENATED MODULE: ./src/thing/tileset/TilesetFlat.js






function TilesetFlat_createSuper(Derived) { var hasNativeReflectConstruct = TilesetFlat_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetFlat_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 3dtiles模型压平
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {TilesetLayer} options.layer 需要压平的对象（3dtiles图层）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只压平单个区域【单个区域场景时使用】
 * @param {Number} [options.height] 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
 * @export
 * @class TilesetFlat
 * @extends {TilesetEditBase}
 */

var TilesetFlat_TilesetFlat = /*#__PURE__*/function (_TilesetEditBase) {
  inherits_default()(TilesetFlat, _TilesetEditBase);

  var _super = TilesetFlat_createSuper(TilesetFlat);

  function TilesetFlat() {
    classCallCheck_default()(this, TilesetFlat);

    return _super.apply(this, arguments);
  }

  createClass_default()(TilesetFlat, [{
    key: "height",
    get:
    /**
     * 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
     * @type {Number}
     */
    function get() {
      return this.options.height;
    },
    set: function set(val) {
      var _this$tileset;

      this.options.height = val;

      if ((_this$tileset = this.tileset) !== null && _this$tileset !== void 0 && _this$tileset.tudouEditor) {
        this.tileset.tudouEditor.heightVar[1] = val;
      }
    }
  }, {
    key: "_activeTudouEditor",
    value: function _activeTudouEditor() {
      this.tileset.tudouEditor.fbo = this.fbo;
      this.tileset.tudouEditor.polygonBounds = this.polygonBounds;
      this.tileset.tudouEditor.IsYaPing[0] = true;
      this.tileset.tudouEditor.IsYaPing[1] = true;
      this.tileset.tudouEditor.heightVar[0] = this._minLocalZ;
      this.tileset.tudouEditor.heightVar[1] = this.height || 0;
      this.tileset.tudouEditor.enable = this.enabled; //Hao

      this.tileset.tudouEditor._inverseTransform = this.matrix;
      this.tileset.tudouEditor.upZ = this.upZ;
    }
  }]);

  return TilesetFlat;
}(TilesetEditBase_TilesetEditBase);
// CONCATENATED MODULE: ./src/thing/tileset/TilesetFlood.js








function TilesetFlood_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function TilesetFlood_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TilesetFlood_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TilesetFlood_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TilesetFlood_createSuper(Derived) { var hasNativeReflectConstruct = TilesetFlood_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function TilesetFlood_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} TilesetFlood.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始分析
 * @property {String} change 变化了
 * @property {String} end  完成分析
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.end, function (event) {
 *   console.log('分析完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 3dtiles模型淹没分析
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
 * @param {Array[]|String[]|LatLngPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只淹没单个区域【单个区域场景时使用】
 * @param {Number} [options.speed] 淹没速度，米/秒（默认刷新频率为55Hz）
 * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
 * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
 * @param {Cesium.Color} [options.color=new Cesium.Color(0.15, 0.7, 0.95, 0.5)] 淹没颜色
 * @param {Boolean} [options.floodAll] 是否对整个模型进行分析
 *
 * @export
 * @class TilesetFlood
 * @extends {TilesetEditBase}
 * @see [支持的事件类型]{@link TilesetFlood.EventType}
 */

var TilesetFlood_TilesetFlood = /*#__PURE__*/function (_TilesetEditBase) {
  inherits_default()(TilesetFlood, _TilesetEditBase);

  var _super = TilesetFlood_createSuper(TilesetFlood);

  //========== 构造方法 ==========
  function TilesetFlood() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, TilesetFlood);

    _this = _super.call(this, options);
    _this.options.speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.speed, 5);
    _this.options.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.color, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.15, 0.7, 0.95, 0.5));
    return _this;
  }
  /**
   * 淹没速度，米/秒（默认刷新频率为55Hz）
   * @type {Number}
   */


  createClass_default()(TilesetFlood, [{
    key: "speed",
    get: function get() {
      return this.options.speed;
    },
    set: function set(val) {
      this.options.speed = val;
    }
    /**
     * 是否对整个模型进行分析
     * @type {Boolean}
     */

  }, {
    key: "floodAll",
    get: function get() {
      return this.options.floodAll;
    },
    set: function set(val) {
      var _this$tileset;

      this.options.floodAll = val;

      if ((_this$tileset = this.tileset) !== null && _this$tileset !== void 0 && _this$tileset.tudouEditor) {
        this.tileset.tudouEditor.editVar[1] = val;
      }
    }
    /**
     * 淹没高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "height",
    get: function get() {
      var _this$tileset2, _this$tileset2$tudouE;

      return ((_this$tileset2 = this.tileset) === null || _this$tileset2 === void 0 ? void 0 : (_this$tileset2$tudouE = _this$tileset2.tudouEditor) === null || _this$tileset2$tudouE === void 0 ? void 0 : _this$tileset2$tudouE.floodVar[1]) + this._localZOffset;
    },
    set: function set(val) {
      var _this$tileset3;

      if ((_this$tileset3 = this.tileset) !== null && _this$tileset3 !== void 0 && _this$tileset3.tudouEditor) {
        this.tileset.tudouEditor.floodVar[1] = val - this._localZOffset;
      }
    }
    /**
     * 淹没颜色
     * @type {Cesium.Color}
     */

  }, {
    key: "color",
    get: function get() {
      return this.options.color;
    },
    set: function set(val) {
      this.options.color = val;
    } //模型中心点

  }, {
    key: "center",
    get: function get() {
      return this.layer.position;
    }
    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        this.options = TilesetFlood_objectSpread(TilesetFlood_objectSpread({}, this.options), options);
      }

      this.stop();
      var minHeight = this.options.minHeight;
      var maxHeight = this.options.maxHeight; //检查参数

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](minHeight)) {
        Object(Log["logError"])("minHeight 请传入有效数值！", minHeight);
        return;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](maxHeight)) {
        Object(Log["logError"])("maxHeight 请传入有效数值！", maxHeight);
        return;
      }

      var car = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(this.center);
      this._minHeightLocalZ = this._getLocalZ(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, minHeight));
      this._maxHeightLocalZ = this._getLocalZ(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromRadians(car.longitude, car.latitude, maxHeight));
      this._localZOffset = minHeight - this._minHeightLocalZ;
      this.tileset.tudouEditor.floodColor = [this.color.red, this.color.green, this.color.blue, this.color.alpha];

      this._activeTudouEditor();

      if (!this.floodAll) {
        this._activete();
      }

      return this;
    }
  }, {
    key: "_getLocalZ",
    value: function _getLocalZ(position) {
      var currLocalPos = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].multiplyByPoint(this.matrix, position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      return Math.floor(currLocalPos.z);
    }
  }, {
    key: "_activeTudouEditor",
    value: function _activeTudouEditor() {
      //Hao
      var center = this.tileset.root.boundingSphere.center;
      var trans = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(center);
      this.tileset.tudouEditor.modelEditorInverse = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].inverse(trans, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"]());
      this.tileset.tudouEditor.modelEditorTrans = trans;
      this.tileset.tudouEditor.fbo = this.fbo;
      this.tileset.tudouEditor.polygonBounds = this.polygonBounds;
      this.tileset.tudouEditor.IsYaPing[0] = true;
      this.tileset.tudouEditor.IsYaPing[3] = true;
      this.tileset.tudouEditor.floodVar = [//相对模型的本地坐标系：（基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)）
      this._minHeightLocalZ, this._minHeightLocalZ, this._maxHeightLocalZ, 200]; // this.tileset.tudouEditor.floodColor = [this.color.red, this.color.green, this.color.blue, this.color.alpha]

      this.tileset.tudouEditor.editVar[1] = this.floodAll;
      this.tileset.tudouEditor.enable = this.enabled; //Hao

      this.tileset.tudouEditor._inverseTransform = this.matrix;
      this.tileset.tudouEditor.upZ = this.upZ;
    }
    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start() {
      this.stop();
      this.isStart = true;
      this.fire(EventType.start);

      this._map.on(EventType.clockTick, this._onClockTickHandler, this);
    }
  }, {
    key: "_onClockTickHandler",
    value: function _onClockTickHandler(event) {
      this.tileset.tudouEditor.floodVar[1] += this.speed / 50; //55帧每秒

      if (this.tileset.tudouEditor.floodVar[1] > this.tileset.tudouEditor.floodVar[2]) {
        this.tileset.tudouEditor.floodVar[1] = this.tileset.tudouEditor.floodVar[2];
        this.stop();
        return;
      }

      if (this.tileset.tudouEditor.floodVar[1] < this.tileset.tudouEditor.floodVar[0]) {
        this.tileset.tudouEditor.floodVar[1] = this.tileset.tudouEditor.floodVar[0];
        this.stop();
        return;
      }

      this.fire(EventType.change, {
        height: this.height
      });
    }
    /**
     * 暂停播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this.isStart) {
        return;
      }

      this._map.off(EventType.clockTick, this._onClockTickHandler, this);

      this.isStart = false;
      this.fire(EventType.end);
    }
    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */

  }, {
    key: "restart",
    value: function restart() {
      this.tileset.tudouEditor.floodVar[1] = this.tileset.tudouEditor.floodVar[0];
      this.start();
    }
    /**
     * 清除分析
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      this.stop();

      get_default()(getPrototypeOf_default()(TilesetFlood.prototype), "clear", this).call(this);
    }
  }]);

  return TilesetFlood;
}(TilesetEditBase_TilesetEditBase);
// CONCATENATED MODULE: ./src/thing/camera/FirstPersonRoam.js






function FirstPersonRoam_createSuper(Derived) { var hasNativeReflectConstruct = FirstPersonRoam_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FirstPersonRoam_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var scratchCurrentDirection = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
var scratchDeltaPosition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
var scratchNextPosition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
var scratchTerrainConsideredNextPosition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
var scratchNextCartographic = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();
var RoamType = {
  DIRECTION_NONE: 0,
  DIRECTION_FORWARD: 1,
  DIRECTION_BACKWARD: 2,
  DIRECTION_LEFT: 3,
  DIRECTION_RIGHT: 4
};
/**
 * 第一人称贴地漫游，
 * 键盘漫游时，先单击地图激活后 按 W前进、 S后退、A左移、D右移
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Number} [options.speed = 1.5] 速度
 * @param {Number} [options.rotateSpeed = -5] 旋转速度
 * @param {Number} [options.height = 10] 高度
 * @param {Number} [options.maxPitch = 88] 最大pitch角度（度数值）
 *
 * @export
 * @class FirstPersonRoam
 * @extends {BaseThing}
 */

var FirstPersonRoam_FirstPersonRoam = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(FirstPersonRoam, _BaseThing);

  var _super = FirstPersonRoam_createSuper(FirstPersonRoam);

  function FirstPersonRoam() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FirstPersonRoam);

    _this = _super.call(this, options);
    /**
     * 速度
     * @type {Number}
     */

    _this.speed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.speed, 1.5); //速度

    /**
     * 旋转速度
     * @type {Number}
     */

    _this.rotateSpeed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.rotateSpeed, -5);
    /**
     * 高度（单位：米）
     * @type {Number}
     */

    _this.height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.height, 10);
    /**
     * 最大pitch角度（度数值）
     * @type {Number}
     */

    _this.maxPitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.maxPitch, 88);
    return _this;
  } //========== 方法 ==========


  createClass_default()(FirstPersonRoam, [{
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (val) {
        this.activate();
      } else {
        this.disable();
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      if (this.enabled) {
        this.activate();
      }

      this._map.on(EventType.leftDown, this._onLeftDownHandler, this);

      this._map.on(EventType.leftUp, this._onLeftUpHandler, this);

      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this);

      this._map.on(EventType.keydown, this._onKeyDown, this);

      this._map.on(EventType.keyup, this._onKeyUp, this);

      this._map.on(EventType.clockTick, this._onClockTick, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.disable();

      this._map.off(EventType.leftDown, this._onLeftDownHandler, this);

      this._map.off(EventType.leftUp, this._onLeftUpHandler, this);

      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this);

      this._map.off(EventType.keydown, this._onKeyDown, this);

      this._map.off(EventType.keyup, this._onKeyUp, this);

      this._map.off(EventType.clockTick, this._onClockTick, this);
    }
  }, {
    key: "_onLeftDownHandler",
    value: function _onLeftDownHandler(event) {
      if (!this.enabled) {
        return;
      }

      this._looking = true;
      this._startMousePosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(event.position);
      this._mousePosition = this._startMousePosition;
    }
  }, {
    key: "_onDbClickHandler",
    value: function _onDbClickHandler(event) {
      if (!this.enabled) {
        return;
      }

      this._looking = true;
      this._startMousePosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(event.position);
      this._mousePosition = this._startMousePosition;
    }
  }, {
    key: "_onLeftUpHandler",
    value: function _onLeftUpHandler(event) {
      this._looking = false;
    }
  }, {
    key: "_onMouseMoveHandler",
    value: function _onMouseMoveHandler(event) {
      this._mousePosition = event.endPosition;
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this.enabled) {
        return;
      }

      var keyCode = event.keyCode;
      this._direction = RoamType.DIRECTION_NONE;

      switch (keyCode) {
        case "W".charCodeAt(0):
          this._direction = RoamType.DIRECTION_FORWARD;
          return;

        case "S".charCodeAt(0):
          this._direction = RoamType.DIRECTION_BACKWARD;
          return;

        case "D".charCodeAt(0):
          this._direction = RoamType.DIRECTION_RIGHT;
          return;

        case "A".charCodeAt(0):
          this._direction = RoamType.DIRECTION_LEFT;
          return;

        default:
          return;
      }
    }
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp() {
      if (!this.enabled) {
        return;
      }

      this._direction = RoamType.DIRECTION_NONE;
    }
  }, {
    key: "_onClockTick",
    value: function _onClockTick(clock) {
      if (!this.enabled) {
        return;
      }

      var dt = clock._clockStep;

      if (this._looking) {
        this._changeHeadingPitch(dt);
      }

      if (this._direction == RoamType.DIRECTION_NONE) {
        return;
      }

      var distance = this.speed * dt;

      if (this._direction == RoamType.DIRECTION_FORWARD) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(this._map.camera.direction, 1, scratchCurrentDirection);
      } else if (this._direction == RoamType.DIRECTION_BACKWARD) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(this._map.camera.direction, -1, scratchCurrentDirection);
      } else if (this._direction == RoamType.DIRECTION_LEFT) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(this._map.camera.right, -1, scratchCurrentDirection);
      } else if (this._direction == RoamType.DIRECTION_RIGHT) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(this._map.camera.right, 1, scratchCurrentDirection);
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(scratchCurrentDirection, distance, scratchDeltaPosition);
      var currentCameraPosition = this._map.camera.position;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(currentCameraPosition, scratchDeltaPosition, scratchNextPosition); // consider terrain height

      var globe = this._map.scene.globe;
      var ellipsoid = globe.ellipsoid; // get height for next update position

      ellipsoid.cartesianToCartographic(scratchNextPosition, scratchNextCartographic);
      var height = globe.getHeight(scratchNextCartographic);

      if (height == undefined) {
        // console.warn('height is undefined!');
        return;
      }

      if (height < 0) {// console.warn(`height is negative!`);
      }

      scratchNextCartographic.height = height + this.height;
      ellipsoid.cartographicToCartesian(scratchNextCartographic, scratchTerrainConsideredNextPosition);

      this._map.camera.setView({
        destination: scratchTerrainConsideredNextPosition,
        orientation: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRoll"](this._map.camera.heading, this._map.camera.pitch, this._map.camera.roll),
        endTransform: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].IDENTITY
      });
    }
  }, {
    key: "_changeHeadingPitch",
    value: function _changeHeadingPitch(dt) {
      var width = this._map.canvas.clientWidth;
      var height = this._map.canvas.clientHeight; // Coordinate (0.0, 0.0) will be where the mouse was clicked.

      var deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
      var deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;
      var currentHeadingInDegree = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.heading);
      var deltaHeadingInDegree = deltaX * this.rotateSpeed;
      var newHeadingInDegree = currentHeadingInDegree + deltaHeadingInDegree;
      var currentPitchInDegree = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.pitch);
      var deltaPitchInDegree = deltaY * this.rotateSpeed;
      var newPitchInDegree = currentPitchInDegree + deltaPitchInDegree; // console.log("rotationSpeed: " + this.rotateSpeed + " deltaY: " + deltaY + " deltaPitchInDegree" + deltaPitchInDegree);

      if (newPitchInDegree > this.maxPitch * 2 && newPitchInDegree < 360 - this.maxPitch) {
        newPitchInDegree = 360 - this.maxPitch;
      } else {
        if (newPitchInDegree > this.maxPitch && newPitchInDegree < 360 - this.maxPitch) {
          newPitchInDegree = this.maxPitch;
        }
      }

      this._map.camera.setView({
        orientation: {
          heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(newHeadingInDegree),
          pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(newPitchInDegree),
          roll: this._map.camera.roll
        }
      });
    }
  }, {
    key: "_enableScreenSpaceCameraController",
    value: function _enableScreenSpaceCameraController(enabled) {
      var scene = this._map.scene;
      scene.screenSpaceCameraController.enableRotate = enabled;
      scene.screenSpaceCameraController.enableTranslate = enabled;
      scene.screenSpaceCameraController.enableZoom = enabled;
      scene.screenSpaceCameraController.enableTilt = enabled;
      scene.screenSpaceCameraController.enableLook = enabled;
    }
  }, {
    key: "activate",
    value: function activate() {
      this._enabled = true;

      this._enableScreenSpaceCameraController(false);

      var currentCameraPosition = this._map.camera.position;
      var cartographic = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();
      var globe = this._map.scene.globe;
      globe.ellipsoid.cartesianToCartographic(currentCameraPosition, cartographic);
      var height = globe.getHeight(cartographic);

      if (height == undefined) {
        return false;
      }

      if (height < 0) {// console.warn(`height is negative`);
      }

      cartographic.height = height + this.height;
      var newCameraPosition = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      globe.ellipsoid.cartographicToCartesian(cartographic, newCameraPosition);
      var currentCameraHeading = this._map.camera.heading;
      this._heading = currentCameraHeading;

      this._map.camera.flyTo({
        destination: newCameraPosition,
        orientation: {
          heading: currentCameraHeading,
          pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(0),
          roll: 0.0
        }
      });

      return true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._enabled = false;

      this._enableScreenSpaceCameraController(true);
    }
    /**
     * 开始自动前进漫游
     * @return {void}  无
     */

  }, {
    key: "startAutoForward",
    value: function startAutoForward() {
      if (!this.enabled) {
        this.activate();
      }

      this._direction = RoamType.DIRECTION_FORWARD;
    }
    /**
     * 停止自动前进漫游
     * @return {void}  无
     */

  }, {
    key: "stopAutoForward",
    value: function stopAutoForward() {
      this._direction = RoamType.DIRECTION_NONE;
    }
  }]);

  return FirstPersonRoam;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/camera/RotatePoint.js






function RotatePoint_createSuper(Derived) { var hasNativeReflectConstruct = RotatePoint_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RotatePoint_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} RotatePoint.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始旋转
 * @property {String} change 变化了角度
 * @property {String} stop 停止了旋转
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.stop, function (event) {
 *   console.log('停止了旋转', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 相机绕 固定中心点 旋转
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
 * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
 * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
 * @param {Number} [options.distance] 可以指定旋转时相机到中心点的距离，默认不改变相对距离。
 *
 * @export
 * @class RotatePoint
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link RotatePoint.EventType}
 */

var RotatePoint_RotatePoint = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(RotatePoint, _BaseThing);

  var _super = RotatePoint_createSuper(RotatePoint);

  function RotatePoint() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RotatePoint);

    _this = _super.call(this, options);
    _this._direction = _this.options.direction ? 1 : -1;
    _this._angle = 360 / (_this.options.time || 60);
    _this._autoStopAngle = _this.options.autoStopAngle;
    return _this;
  }
  /**
   * 是否在旋转中
   * @type {Boolean}
   * @readonly
   */


  createClass_default()(RotatePoint, [{
    key: "isStart",
    get: function get() {
      return this._isStart;
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (val) {
        this.start();
      } else {
        this.stop();
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.mouseDown, this._map_mouseDownHandler, this);

      this._map.on(EventType.mouseUp, this._map_mouseUpHandler, this);

      this._mouseDown = false;
    }
  }, {
    key: "_map_mouseDownHandler",
    value: function _map_mouseDownHandler(event) {
      this._mouseDown = true;
    }
  }, {
    key: "_map_mouseUpHandler",
    value: function _map_mouseUpHandler(event) {
      this._mouseDown = false;
      this._startTime = this._map.clock.currentTime.clone();
      this._startHeading = this._map.camera.heading; // 相机的当前heading

      this._startPitch = this._map.camera.pitch;
      this._center = this._map.getCenter().toCartesian();
      this._distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._center, this._map.camera.positionWC); // 给定相机距离点多少距离飞行
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.mouseDown, this._map_mouseDownHandler, this);

      this._map.off(EventType.mouseUp, this._map_mouseUpHandler, this);

      this.stop();
    }
    /**
     * 开始旋转
     * @param {LatLngPoint|Cesium.Cartesian3} point 旋转的中心点
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start(point) {
      var _this$_map$getCenter,
          _this2 = this;

      if (this._isStart) {
        this.stop();
      }

      this._isStart = true;
      this._map.clock.shouldAnimate = true;

      var _mapcenter = (_this$_map$getCenter = this._map.getCenter()) === null || _this$_map$getCenter === void 0 ? void 0 : _this$_map$getCenter.toCartesian();

      if (!point) {
        this._center = _mapcenter;
      } else if (point instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]) {
        this._center = point;
      } else {
        this._center = LatLngPoint["a" /* LatLngPoint */].parse(point).toCartesian();
      }

      this._distance = this.options.distance || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(this._center, this._map.camera.positionWC); // 给定相机距离点多少距离飞行

      this._startHeading = this._map.camera.heading; // 相机的当前heading

      this._startPitch = this._map.camera.pitch;
      var duration = 2;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(_mapcenter, this._center) < this._distance * 0.01) {
        duration = 0;
      }

      this.fire(EventType.start);

      this._map.flyToPoint(this._center, {
        radius: this._distance,
        duration: duration,
        complete: function complete(e) {
          _this2._isStart = true;
          _this2._startTime = _this2._map.clock.currentTime.clone();

          _this2._map.on(EventType.clockTick, _this2.clock_onTickHandler, _this2);
        }
      });
    }
  }, {
    key: "clock_onTickHandler",
    value: function clock_onTickHandler(event) {
      if (this._mouseDown) {
        return;
      }

      var delTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this._map.clock.currentTime, this._startTime); // 当前已经过去的时间，单位 秒

      var angle = delTime * this._angle;

      if (this._autoStopAngle && angle >= this._autoStopAngle) {
        this.stop();
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(angle * this._direction) + this._startHeading;

      this._map.scene.camera.setView({
        destination: this._center,
        // 点的坐标
        orientation: {
          heading: heading,
          pitch: this._startPitch
        }
      });

      this._map.scene.camera.moveBackward(this._distance);

      this.fire(EventType.change);
    }
    /**
     * 停止旋转
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this._isStart) {
        return;
      }

      this._isStart = false;

      this._map.off(EventType.clockTick, this.clock_onTickHandler, this);

      this.fire(EventType.stop);
    }
  }]);

  return RotatePoint;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/camera/StreetView.js






function StreetView_createSuper(Derived) { var hasNativeReflectConstruct = StreetView_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function StreetView_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var MAX_PITCH_IN_DEGREE = 88;
/**
 * 街景视角模式控制,
 * 1、右键拖拽，以相机视角为中心进行旋转;
 * 2、中键拖拽，可以升高或降低相机高度;
 * 3、左键双击，飞行定位到该点;
 * 4、右键双击，围绕该点旋转。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Number} [options.rotateSpeed=30] 右键拖拽时，旋转速度，正负控制方向。
 * @param {Number} [options.heightStep=0.2]  中键拖拽时，高度移动比例，控制升高或降低相机高度的速度
 * @param {Number} [options.moveStep=0.1] 双击定位到点时，距离目标点的距离的移动比例 0.0-1.0
 * @param {Number} [options.moveDuration] 双击定位到点时，飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
 * @param {Object} [options.rotatePoint] 右键双击，围绕该点旋转时的参考，具体同{@link RotatePoint}类的构造参数。
 *
 * @export
 * @class StreetView
 * @extends {BaseThing}
 */

var StreetView_StreetView = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(StreetView, _BaseThing);

  var _super = StreetView_createSuper(StreetView);

  function StreetView() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, StreetView);

    _this = _super.call(this, options);
    /**
     * 右键拖拽时，旋转速度，正负控制方向。
     * @type {Number}
     */

    _this.rotateSpeed = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.rotateSpeed, 30);
    /**
     * 中键拖拽时，高度移动比例，控制升高或降低相机高度的速度
     * @type {Number}
     */

    _this.heightStep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.heightStep, 0.2);
    /**
     * 双击定位到点时，距离目标点的距离的移动比例 0.0-1.0
     * @type {Number}
     */

    _this.moveStep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.moveStep, 0.1);
    return _this;
  } //========== 方法 ==========


  createClass_default()(StreetView, [{
    key: "_enabledHook",
    value: function _enabledHook(value) {
      if (this._map.mouseZoom) {
        this._map.mouseZoom.enabled = !value;
      }

      if (value) {
        this._default_zoomEventTypes = this._map.scene.screenSpaceCameraController.zoomEventTypes;
        this._default_tiltEventTypes = this._map.scene.screenSpaceCameraController.tiltEventTypes; //去掉Cesium默认的中右键的操作

        this._map.scene.screenSpaceCameraController.zoomEventTypes = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].WHEEL, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].PINCH, {
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].RIGHT_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }];
        this._map.scene.screenSpaceCameraController.tiltEventTypes = [{
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].MIDDLE_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }];
      } else {
        //还原Cesium默认的中右键的操作
        if (this._default_zoomEventTypes) {
          this._map.scene.screenSpaceCameraController.zoomEventTypes = this._default_zoomEventTypes;
          delete this._default_zoomEventTypes;
        }

        if (this._default_tiltEventTypes) {
          this._map.scene.screenSpaceCameraController.tiltEventTypes = this._default_tiltEventTypes;
          delete this._default_tiltEventTypes;
        }
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._enabledHook(this.enabled); //按住右键不松手，拖拽，就可以以当前相机为中心旋转角度


      this._map.on(EventType.rightDown, this._onRightDownHandler, this);

      this._map.on(EventType.mouseMove, this._onMouseMove, this);

      this._map.on(EventType.rightUp, this._onRightUpHandler, this); //按住中键不松手，上下拖拽，可以“升高或降低”相机高度


      this._map.on(EventType.middleDown, this._onMiddleDownHandler, this);

      this._map.on(EventType.middleUp, this._onMiddleUpHandler, this); //左键双击一个点，就飞过去


      this._map.on(EventType.click, this._onClickHandler, this);

      this._map.on(EventType.dblClick, this._onDbClickHandler, this); //右键双击一个点，就围绕这个点旋转


      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._enabledHook(false); //按住右键不松手，拖拽，就可以以当前相机为中心旋转角度


      this._map.off(EventType.rightDown, this._onRightDownHandler, this);

      this._map.off(EventType.mouseMove, this._onMouseMove, this);

      this._map.off(EventType.rightUp, this._onRightUpHandler, this); //按住中键不松手，上下拖拽，可以“升高或降低”相机高度


      this._map.off(EventType.middleDown, this._onMiddleDownHandler, this);

      this._map.off(EventType.middleUp, this._onMiddleUpHandler, this); //左键双击一个点，就飞过去


      this._map.off(EventType.click, this._onClickHandler, this);

      this._map.off(EventType.dblClick, this._onDbClickHandler, this); //右键双击一个点，就围绕这个点旋转


      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      if (this.rotatePoint) {
        this._map.removeThing(this.rotatePoint, true);

        delete this.rotatePoint;
      }
    } //按住右键不松手，拖拽，就可以以当前相机为中心旋转角度

  }, {
    key: "_onRightDownHandler",
    value: function _onRightDownHandler(event) {
      if (!this.enabled) {
        return;
      }

      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      this._isMouseLeftButtonPressed = true;
      this._mousePosition = this._startMousePosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(event.position);
      this._headingWhenLeftClicked = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.heading);
      this._pitchWhenLeftClicked = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.pitch);
    }
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(event) {
      if (!this.enabled) {
        return;
      }

      this._mousePosition = event.endPosition;

      if (this._isMouseLeftButtonPressed) {
        var width = this._map.canvas.clientWidth;
        var height = this._map.canvas.clientHeight; // Coordinate (0.0, 0.0) will be where the mouse was clicked.

        var deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
        var deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].equalsEpsilon(deltaX, 0, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].EPSILON6) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].equalsEpsilon(deltaY, 0, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].EPSILON6)) {
          return;
        }

        var deltaHeadingInDegree = deltaX * this.rotateSpeed;
        var newHeadingInDegree = this._headingWhenLeftClicked + deltaHeadingInDegree;
        var deltaPitchInDegree = deltaY * this.rotateSpeed;
        var newPitchInDegree = this._pitchWhenLeftClicked + deltaPitchInDegree;

        if (newPitchInDegree > MAX_PITCH_IN_DEGREE * 2 && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
          newPitchInDegree = 360 - MAX_PITCH_IN_DEGREE;
        } else {
          if (newPitchInDegree > MAX_PITCH_IN_DEGREE && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
            newPitchInDegree = MAX_PITCH_IN_DEGREE;
          }
        }

        this._map.camera.setView({
          orientation: {
            heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(newHeadingInDegree),
            pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(newPitchInDegree),
            roll: this._map.camera.roll
          }
        });
      } else if (this._isMouseUpdownPressed) {
        var deltaHei = -(this._mousePosition.y - this._startMousePosition.y) / this._map.canvas.clientHeight;
        var lookFactor = this._map.camera.positionCartographic.height * this.heightStep;

        this._map.camera.moveDown(deltaHei * lookFactor);
      }
    }
  }, {
    key: "_onRightUpHandler",
    value: function _onRightUpHandler(event) {
      this._isMouseLeftButtonPressed = false;
    }
  }, {
    key: "_onMiddleDownHandler",
    value: function _onMiddleDownHandler(event) {
      if (!this.enabled) {
        return;
      }

      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      this._isMouseUpdownPressed = true;
      this._startMousePosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].clone(event.position);
      this._mousePosition = this._startMousePosition;
    }
  }, {
    key: "_onMiddleUpHandler",
    value: function _onMiddleUpHandler(event) {
      this._isMouseUpdownPressed = false;
    }
  }, {
    key: "_onClickHandler",
    value: function _onClickHandler(event) {
      if (!this.enabled) {
        return;
      }

      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }
    }
  }, {
    key: "_onDbClickHandler",
    value: function _onDbClickHandler(event) {
      if (!this.enabled) {
        return;
      }

      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      var position = Object(PointUtil["getCurrentMousePosition"])(this._map.scene, event.position);

      if (position) {
        var camera_distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(position, this._map.camera.positionWC) * this.moveStep; // if (camera_distance > 5000) camera_distance = 5000;

        this._map.flyToPoint(position, {
          radius: camera_distance,
          //距离目标点的距离
          maximumHeight: this._map.camera.positionCartographic.height,
          duration: this.options.moveDuration
        });
      }
    }
  }, {
    key: "_onRightClickHandler",
    value: function _onRightClickHandler(event) {
      if (!this.enabled) {
        return;
      }

      if (this.time) {
        var delTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this._map.clock.currentTime, this.time);

        if (delTime < 0.5) {
          this._map.closeContextMenu();

          if (!this.rotatePoint) {
            this.rotatePoint = new RotatePoint_RotatePoint(this.options.rotatePoint);

            this._map.addThing(this.rotatePoint);
          }

          this.rotatePoint.start(event.cartesian);
        }
      }

      this.time = this._map.clock.currentTime.clone();
    }
  }]);

  return StreetView;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/camera/CameraHistory.js






function CameraHistory_createSuper(Derived) { var hasNativeReflectConstruct = CameraHistory_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function CameraHistory_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * @typedef {Object} CameraHistory.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} change 变化了
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('记录发送了变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 相机视角记录及处理类，含 上一视图 下一视图 等
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Number} [options.maxCacheCount = 99] 保留的历史记录最多个数
 * @param {Object} [options.limit] 限定视角范围参数，包括以下：
 * @param {Cesium.Cartesian3} options.limit.position 中心点坐标
 * @param {Number} options.limit.radius 半径（单位：米）
 * @param {Boolean} [options.limit.debugExtent] 是否显示限定范围的边界
 *
 *
 * @export
 * @class CameraHistory
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link CameraHistory.EventType}
 */

var CameraHistory_CameraHistory = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(CameraHistory, _BaseThing);

  var _super = CameraHistory_createSuper(CameraHistory);

  function CameraHistory() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, CameraHistory);

    _this = _super.call(this, options);
    _this.step = 0; // 记录当前的视角在数组中的位置

    _this.views = []; // 保存视角

    _this.maxCacheCount = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.maxCacheCount, 99); //最多记录数

    return _this;
  } //========== 对外属性 ==========

  /**
   * 是否显示限定范围的边界
   * @type {Boolean}
   */


  createClass_default()(CameraHistory, [{
    key: "debugExtent",
    get: function get() {
      return this.options.limit && this.options.limit.debugExtent;
    },
    set: function set(val) {
      if (!this.options.limit) {
        return;
      }

      this.options.limit.debugExtent = val;

      if (!this.debugExtentEntity) {
        var radius = this.options.limit.radius;
        var position = this.options.limit.position;
        this.debugExtentEntity = this._map.entities.add({
          name: "限定的范围",
          position: position,
          ellipsoid: {
            radii: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](radius, radius, radius),
            maximumCone: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO,
            slicePartitions: 45,
            stackPartitions: 45,
            material: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 0),
            outline: true,
            outlineColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"](0.0, 1.0, 1.0, 1.0)
          }
        });
      }

      this.debugExtentEntity.show = val;
    } //========== 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      //显示限定范围的边界
      if (this.options.limit && this.options.limit.debugExtent) {
        this.debugExtent = this.options.limit.debugExtent;
      }

      this._limitGlobe();
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      // 绑定相机事件
      this._map.on(EventType.cameraMoveStart, this._cameraMoveStartHandler, this);

      this._map.on(EventType.cameraMoveEnd, this._cameraMoveEndHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      // 解除绑定相机事件
      this._map.off(EventType.cameraMoveStart, this._cameraMoveStartHandler, this);

      this._map.off(EventType.cameraMoveEnd, this._cameraMoveEndHandler, this);

      this.views = [];

      if (this.debugExtentEntity) {
        this._map.entities.remove(this.debugExtentEntity);

        delete this.debugExtentEntity;
      }
    }
  }, {
    key: "_cameraMoveStartHandler",
    value: function _cameraMoveStartHandler() {
      if (this._map) {
        this.isInPush = true;
        this.lastCameraView = this._map.getCameraView();
      }
    }
  }, {
    key: "_cameraMoveEndHandler",
    value: function _cameraMoveEndHandler() {
      this._limitGlobe();

      if (!this.isInPush) {
        return;
      }

      this._addCameraView();
    }
  }, {
    key: "_limitGlobe",
    value: function _limitGlobe() {
      var _this2 = this;

      if (!this.options.limit) {
        return;
      }

      var position = this.options.limit.position;
      var radius = this.options.limit.radius;
      var camera_distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(position, this._map.camera.position);

      if (this.options.limit.debugExtent) {// console.log(`视距为：${camera_distance}米`)
      }

      if (camera_distance <= radius) {
        return;
      }

      this.isInPush = false;

      if (this.lastCameraView) {
        this._map.setCameraView(this.lastCameraView, {
          duration: 0.5,
          complete: function complete() {
            _this2.lastCameraView = null;
            _this2.isInPush = true;
          }
        });
      } else {
        this._map.flyToPoint(position, {
          radius: radius * 0.6,
          //距离目标点的距离
          pitch: -60,
          //相机方向
          duration: 0.5,
          complete: function complete() {
            _this2.lastCameraView = null;
            _this2.isInPush = true;
          }
        });
      }
    }
  }, {
    key: "_addCameraView",
    value: function _addCameraView() {
      //console.log("添加新的视角记录");
      var cameraV = this._map.getCameraView();

      this.views.push(cameraV);

      if (this.views.length > this.maxCacheCount) {
        this.views.splice(0, 1);
      }

      this.step = this.views.length - 1;
      this.fire(EventType.change, {
        index: this.step,
        count: this.views.length
      });
    }
  }, {
    key: "_goHistoryView",
    value: function _goHistoryView() {
      var _this3 = this;

      //console.log("开始切换历史视角");
      this._map.camera.moveStart.removeEventListener(this._cameraMoveStartHandler, this);

      this._map.camera.moveEnd.removeEventListener(this._cameraMoveEndHandler, this);

      this.isInPush = false;

      this._map.setCameraView(this.views[this.step], {
        complete: function complete() {
          //console.log("完成切换历史视角");
          _this3._map.camera.moveStart.addEventListener(_this3._cameraMoveStartHandler, _this3);

          _this3._map.camera.moveEnd.addEventListener(_this3._cameraMoveEndHandler, _this3);

          _this3.fire(EventType.change, {
            index: _this3.step,
            count: _this3.views.length
          });
        }
      });
    }
    /**
     * 切换到 下一视角
     * @return {Boolean}  是否成功切换
     */

  }, {
    key: "goNext",
    value: function goNext() {
      if (this.step >= this.views.length - 1) {
        //当前已是最后一页了
        return false;
      } else {
        this.step++;

        this._goHistoryView();

        return true;
      }
    }
    /**
     * 切换到 上一视角
     * @return {Boolean}  是否成功切换
     */

  }, {
    key: "goLast",
    value: function goLast() {
      if (this.step <= 0) {
        //当前已是第一页了
        return false;
      } else {
        this.step--;

        this._goHistoryView();

        return true;
      }
    }
    /**
     * 回到当前视角（记录的最后一个视角）
     * @return {Boolean}  是否成功切换
     */

  }, {
    key: "goNow",
    value: function goNow() {
      if (this.step == this.views.length - 1) {
        //当前已是最后一页了
        return false;
      } else {
        this.step = this.views.length - 1;

        this._goHistoryView();

        return true;
      }
    }
    /**
     * 回到记录的第一个视角
     * @return {Boolean}  是否成功切换
     */

  }, {
    key: "goFirst",
    value: function goFirst() {
      if (this.step <= 0) {
        //当前已是第一页了
        return false;
      } else {
        this.step = 0;

        this._goHistoryView();

        return true;
      }
    }
  }]);

  return CameraHistory;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/camera/RotateOut.js






function RotateOut_createSuper(Derived) { var hasNativeReflectConstruct = RotateOut_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RotateOut_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * @typedef {Object} RotateOut.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} start 开始旋转
 * @property {String} change 变化了角度
 * @property {String} stop 停止了旋转
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.stop, function (event) {
 *   console.log('停止了旋转', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 相机位置不动，对外四周旋转
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
 * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
 * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
 *
 * @export
 * @class RotateOut
 * @extends {BaseThing}
 * @see [支持的事件类型]{@link RotateOut.EventType}

 */

var RotateOut_RotateOut = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(RotateOut, _BaseThing);

  var _super = RotateOut_createSuper(RotateOut);

  function RotateOut() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, RotateOut);

    _this = _super.call(this, options);
    _this._angle = 360 / (_this.options.time || 60);
    _this._direction = _this.options.direction ? -1 : 1; //控制方向, true逆时针，false顺时针

    _this._autoStopAngle = _this.options.autoStopAngle; //自动停止

    return _this;
  }
  /**
   * 是否在旋转中
   * @type {Boolean}
   * @readonly
   */


  createClass_default()(RotateOut, [{
    key: "isStart",
    get: function get() {
      return this._isStart;
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (val) {
        this.start();
      } else {
        this.stop();
      }
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.stop();
    }
    /**
     * 开始旋转
     * @return {void}  无
     */

  }, {
    key: "start",
    value: function start() {
      if (this._isStart) {
        this.stop();
      }

      this._isStart = true;
      this._map.clock.shouldAnimate = true;
      this._startTime = this._map.clock.currentTime.clone();
      this._startHeading = this._map.camera.heading; // 相机的当前heading

      this._startPitch = this._map.camera.pitch;

      this._map.on(EventType.clockTick, this.clock_onTickHandler, this);

      this.fire(EventType.start);
    }
  }, {
    key: "clock_onTickHandler",
    value: function clock_onTickHandler(event) {
      // 当前已经过去的时间，单位s
      var delTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].secondsDifference(this._map.clock.currentTime, this._startTime);
      var angle = delTime * this._angle;

      if (this._autoStopAngle && angle >= this._autoStopAngle) {
        this.stop();
      }

      var heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(angle * this._direction) + this._startHeading;

      this._map.scene.camera.setView({
        orientation: {
          heading: heading,
          pitch: this._startPitch
        }
      });

      this.fire(EventType.change);
    }
    /**
     * 停止旋转
     * @return {void}  无
     */

  }, {
    key: "stop",
    value: function stop() {
      if (!this._isStart) {
        return;
      }

      this._isStart = false;

      this._map.off(EventType.clockTick, this.clock_onTickHandler, this);

      this.fire(EventType.stop);
    }
  }]);

  return RotateOut;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/thing/index.js
























// CONCATENATED MODULE: ./src/effect/BaseEffect.js






function BaseEffect_createSuper(Derived) { var hasNativeReflectConstruct = BaseEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 特效 基类
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @export
 * @class BaseEffect
 * @extends {BaseThing}
 */

var BaseEffect_BaseEffect = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(BaseEffect, _BaseThing);

  var _super = BaseEffect_createSuper(BaseEffect);

  function BaseEffect() {
    classCallCheck_default()(this, BaseEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseEffect, [{
    key: "target",
    get:
    /**
     * 特效对象
     * @type {Cesium.PostProcessStage}
     * @readonly
     */
    function get() {
      return this._postProcessStage;
    }
    /**
     * 特效对象的uniforms
     * 一个对象，它的属性被用来设置片段着色器shader。
     * <p>
     * 对象属性值可以是常量或函数。这个函数将在每一帧后处理阶段执行之前被调用。
     * </p>
     * <p>
     *  常量值也可以是图像的URI、数据URI，或者可以用作纹理的HTML元素，如HTMLImageElement或HTMLCanvasElement。
     * </p>
     * <p>
     * 如果这个后处理阶段是{@link Cesium.PostProcessStageComposite}中不串行执行的部分，那么常量值也可以是复合程序中另一个阶段的名称。这将设置统一的输出纹理与该名称的舞台。
     * </p>
     * @type {Object}
     * @readonly
     */

  }, {
    key: "uniforms",
    get: function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms;
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(val) {
      if (this._postProcessStage) {
        this._postProcessStage.enabled = val;
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedBaseHook",
    value: function _addedBaseHook() {
      this._enabledHook(this.enabled);

      this._map.scene.postProcessStages.add(this._postProcessStage);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedBaseHook",
    value: function _removedBaseHook() {
      if (this._postProcessStage) {
        this._map.scene.postProcessStages.remove(this._postProcessStage);

        this._postProcessStage = undefined;
      }
    }
  }]);

  return BaseEffect;
}(BaseThing_BaseThing);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Fog.glsl
var Fog = __webpack_require__(84);
var Fog_default = /*#__PURE__*/__webpack_require__.n(Fog);

// CONCATENATED MODULE: ./src/effect/FogEffect.js






function FogEffect_createSuper(Derived) { var hasNativeReflectConstruct = FogEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function FogEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 雾场景效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Cesium.Cartesian4} [options.fogByDistance = new Cesium.Cartesian4(10, 0.0, 1000, 0.9)] 雾强度
 * @param {Cesium.Color} [options.color =  Cesium.Color.WHITE]  雾颜色
 * @param {Number} [options.maxHeight = 9000]  最高限定高度，超出该高度不显示雾场景效果
 *
 * @export
 * @class FogEffect
 * @extends {BaseEffect}
 */

var FogEffect_FogEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(FogEffect, _BaseEffect);

  var _super = FogEffect_createSuper(FogEffect);

  //========== 构造方法 ==========
  function FogEffect() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, FogEffect);

    _this = _super.call(this, options);
    /**
     * 雾强度
     * @type {Cesium.Cartesian4}
     */

    _this.fogByDistance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.fogByDistance, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"](10, 0.0, 1000, 0.9));
    /**
     * 雾颜色
     * @type {Cesium.Color}
     */

    _this.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.color, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].WHITE);
    /**
     * 最高限定高度，超出该高度不显示雾场景效果
     * @type {Number}
     */

    _this.maxHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxHeight, 9000);
    return _this;
  }
  /**
   * 创建_postProcessStage效果对象的方法
   * 只会调用一次
   * @return {void}  无
   * @private
   */


  createClass_default()(FogEffect, [{
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        name: this._id,
        fragmentShader: Fog_default.a,
        uniforms: {
          fogByDistance: function fogByDistance() {
            return _this2.fogByDistance;
          },
          fogColor: function fogColor() {
            return _this2.color;
          }
        },
        enabled: this.enabled
      });
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
    } //加控制，只在相机高度低于一定高度时才开启本效果

  }, {
    key: "camera_changedHandler",
    value: function camera_changedHandler(event) {
      if (this._map.camera.positionCartographic.height < this.maxHeight) {
        this._postProcessStage.enabled = this.enabled;
      } else {
        this._postProcessStage.enabled = false;
      }
    }
  }]);

  return FogEffect;
}(BaseEffect_BaseEffect);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Rain.glsl
var Rain = __webpack_require__(85);
var Rain_default = /*#__PURE__*/__webpack_require__.n(Rain);

// CONCATENATED MODULE: ./src/effect/RainEffect.js






function RainEffect_createSuper(Derived) { var hasNativeReflectConstruct = RainEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function RainEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 下雨效果
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.speed = 10]  速度
 * @param {Number} [options.size = 20]  雨粒子大小
 * @param {Number} [options.direction = -30]  雨的方向（度），0度垂直向下
 * @export
 * @class RainEffect
 * @extends {BaseEffect}
 */

var RainEffect_RainEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(RainEffect, _BaseEffect);

  var _super = RainEffect_createSuper(RainEffect);

  function RainEffect() {
    classCallCheck_default()(this, RainEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(RainEffect, [{
    key: "speed",
    get:
    /**
     * 速度
     * @type {Number}
     */
    function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.speed;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.speed = value;
      }
    }
    /**
     * 雨粒子大小
     * @type {Number}
     */

  }, {
    key: "size",
    get: function get() {
      var _this$_postProcessSta2;

      return (_this$_postProcessSta2 = this._postProcessStage) === null || _this$_postProcessSta2 === void 0 ? void 0 : _this$_postProcessSta2.uniforms.size;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.size = value;
      }
    }
    /**
     * 雨的方向（度），0度垂直向下
     * @type {Number}
     */

  }, {
    key: "direction",
    get: function get() {
      var _this$_postProcessSta3;

      return (_this$_postProcessSta3 = this._postProcessStage) === null || _this$_postProcessSta3 === void 0 ? void 0 : _this$_postProcessSta3.uniforms.direction;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(value);
      }
    }
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Rain_default.a,
        uniforms: {
          speed: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.speed, 10.0),
          size: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.size, 20.0),
          direction: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.direction, -30))
        },
        enabled: this.enabled
      });
    }
  }]);

  return RainEffect;
}(BaseEffect_BaseEffect);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Snow.glsl
var Snow = __webpack_require__(86);
var Snow_default = /*#__PURE__*/__webpack_require__.n(Snow);

// CONCATENATED MODULE: ./src/effect/SnowEffect.js






function SnowEffect_createSuper(Derived) { var hasNativeReflectConstruct = SnowEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function SnowEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 下雪效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.speed = 10]  速度
 * @export
 * @class SnowEffect
 * @extends {BaseEffect}
 */

var SnowEffect_SnowEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(SnowEffect, _BaseEffect);

  var _super = SnowEffect_createSuper(SnowEffect);

  function SnowEffect() {
    classCallCheck_default()(this, SnowEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(SnowEffect, [{
    key: "speed",
    get:
    /**
     * 速度
     * @type {Number}
     */
    function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.speed;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.speed = value;
      }
    }
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Snow_default.a,
        uniforms: {
          speed: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.speed, 10)
        },
        enabled: this.enabled
      });
    }
  }]);

  return SnowEffect;
}(BaseEffect_BaseEffect);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/SnowCover.glsl
var SnowCover = __webpack_require__(87);
var SnowCover_default = /*#__PURE__*/__webpack_require__.n(SnowCover);

// CONCATENATED MODULE: ./src/effect/SnowCoverEffect.js






function SnowCoverEffect_createSuper(Derived) { var hasNativeReflectConstruct = SnowCoverEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function SnowCoverEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //原理：法线越垂直与地面越白

/**
 * 地面积雪 效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.alpha =  1.0]  覆盖强度  0-1
 * @param {Number} [options.maxHeight = 9000]  最高限定高度，超出该高度不显示积雪效果
 * @export
 * @class SnowCoverEffect
 * @extends {BaseEffect}
 */

var SnowCoverEffect_SnowCoverEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(SnowCoverEffect, _BaseEffect);

  var _super = SnowCoverEffect_createSuper(SnowCoverEffect);

  //========== 构造方法 ==========
  function SnowCoverEffect() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, SnowCoverEffect);

    _this = _super.call(this, options);
    /**
     * 最高限定高度，超出该高度不显示积雪效果
     * @type {Number}
     */

    _this.maxHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.maxHeight, 9000);
    return _this;
  }
  /**
   * 覆盖强度  0-1
   * @type {Number}
   */


  createClass_default()(SnowCoverEffect, [{
    key: "alpha",
    get: function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.alpha;
    },
    set: function set(alpha) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.alpha = alpha;
      }
    }
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        name: this._id,
        fragmentShader: SnowCover_default.a,
        uniforms: {
          alpha: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.alpha, 1.0) //覆盖强度  0-1

        },
        enabled: this.enabled
      });
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
    } //加控制，只在相机高度低于一定高度时才开启本效果

  }, {
    key: "camera_changedHandler",
    value: function camera_changedHandler(event) {
      if (this._map.camera.positionCartographic.height < this.maxHeight) {
        this._postProcessStage.enabled = this.enabled;
      } else {
        this._postProcessStage.enabled = false;
      }
    }
  }]);

  return SnowCoverEffect;
}(BaseEffect_BaseEffect);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Inverted.glsl
var Inverted = __webpack_require__(88);
var Inverted_default = /*#__PURE__*/__webpack_require__.n(Inverted);

// CONCATENATED MODULE: ./src/effect/InvertedEffect.js






function InvertedEffect_createSuper(Derived) { var hasNativeReflectConstruct = InvertedEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function InvertedEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //原理：利用空间镜面反射技术，计算倒影射线的UV进行采样

/**
 * 倒影效果
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @export
 * @class InvertedEffect
 * @extends {BaseEffect}
 */

var InvertedEffect_InvertedEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(InvertedEffect, _BaseEffect);

  var _super = InvertedEffect_createSuper(InvertedEffect);

  function InvertedEffect() {
    classCallCheck_default()(this, InvertedEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(InvertedEffect, [{
    key: "_mountedHook",
    value:
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Inverted_default.a,
        enabled: this.enabled
      });
    }
  }]);

  return InvertedEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/NightVisionEffect.js






function NightVisionEffect_createSuper(Derived) { var hasNativeReflectConstruct = NightVisionEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function NightVisionEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 夜视效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @export
 * @class NightVisionEffect
 * @extends {BaseEffect}
 */

var NightVisionEffect_NightVisionEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(NightVisionEffect, _BaseEffect);

  var _super = NightVisionEffect_createSuper(NightVisionEffect);

  function NightVisionEffect() {
    classCallCheck_default()(this, NightVisionEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(NightVisionEffect, [{
    key: "_mountedHook",
    value:
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      this._postProcessStage = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStageLibrary"].createNightVisionStage();
    }
  }]);

  return NightVisionEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/BloomEffect.js






function BloomEffect_createSuper(Derived) { var hasNativeReflectConstruct = BloomEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BloomEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 泛光效果, 使明亮的区域更亮，黑暗的区域更暗。
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.contrast = 128]  对比度,取值范围[-255.0,255.0]
 * @param {Number} [options.brightness = -0.3]  亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中。
 * @param {Number} [options.delta =  1.0]  增量
 * @param {Number} [options.sigma =  3.78]  delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
 * @param {Number} [options.stepSize = 5.0]  步长,是下一个texel的距离
 *
 *
 * @export
 * @class BloomEffect
 * @extends {BaseEffect}
 */

var BloomEffect_BloomEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(BloomEffect, _BaseEffect);

  var _super = BloomEffect_createSuper(BloomEffect);

  //========== 构造方法 ==========
  function BloomEffect() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BloomEffect);

    return _super.call(this, options);
  }
  /**
   * 对比度,取值范围[-255.0,255.0]
   * @type {Number}
   */


  createClass_default()(BloomEffect, [{
    key: "contrast",
    get: function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.contrast;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.contrast = value;
      }
    }
    /**
     * 亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中
     * @type {Number}
     */

  }, {
    key: "brightness",
    get: function get() {
      var _this$_postProcessSta2;

      return (_this$_postProcessSta2 = this._postProcessStage) === null || _this$_postProcessSta2 === void 0 ? void 0 : _this$_postProcessSta2.uniforms.brightness;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.brightness = value;
      }
    }
    /**
     * 增量.方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */

  }, {
    key: "delta",
    get: function get() {
      var _this$_postProcessSta3;

      return (_this$_postProcessSta3 = this._postProcessStage) === null || _this$_postProcessSta3 === void 0 ? void 0 : _this$_postProcessSta3.uniforms.delta;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.delta = value;
      }
    }
    /**
     *delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */

  }, {
    key: "sigma",
    get: function get() {
      var _this$_postProcessSta4;

      return (_this$_postProcessSta4 = this._postProcessStage) === null || _this$_postProcessSta4 === void 0 ? void 0 : _this$_postProcessSta4.uniforms.sigma;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.sigma = value;
      }
    }
    /**
     * 步长,是下一个texel的距离
     * @type {Number}
     */

  }, {
    key: "stepSize",
    get: function get() {
      var _this$_postProcessSta5;

      return (_this$_postProcessSta5 = this._postProcessStage) === null || _this$_postProcessSta5 === void 0 ? void 0 : _this$_postProcessSta5.uniforms.stepSize;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.stepSize = value;
      }
    } //========== 方法 ==========

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = this._map.scene.postProcessStages.bloom;
      this._postProcessStage.uniforms.glowOnly = false;
      this._postProcessStage.uniforms.contrast = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.contrast, 128); //对比度

      this._postProcessStage.uniforms.brightness = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.brightness, -0.3); //亮度

      this._postProcessStage.uniforms.delta = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.delta, 1.0); //增量

      this._postProcessStage.uniforms.sigma = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.sigma, 3.78);
      this._postProcessStage.uniforms.stepSize = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.stepSize, 5.0); //步长
    }
  }, {
    key: "_addedBaseHook",
    value: function _addedBaseHook(map) {
      //不能删除，覆盖父类的
      this._postProcessStage.enabled = this.enabled;
    }
  }, {
    key: "_removedBaseHook",
    value: function _removedBaseHook() {
      //不能删除，覆盖父类的
      this._postProcessStage.enabled = false;
    }
  }]);

  return BloomEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/BrightnessEffect.js






function BrightnessEffect_createSuper(Derived) { var hasNativeReflectConstruct = BrightnessEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BrightnessEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 亮度
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.brightness = 2.0]  亮度值
 *
 * @export
 * @class BrightnessEffect
 * @extends {BaseEffect}
 */

var BrightnessEffect_BrightnessEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(BrightnessEffect, _BaseEffect);

  var _super = BrightnessEffect_createSuper(BrightnessEffect);

  function BrightnessEffect() {
    classCallCheck_default()(this, BrightnessEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(BrightnessEffect, [{
    key: "brightness",
    get:
    /**
     * 亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中
     * @type {Number}
     */
    function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.brightness;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.brightness = value;
      }
    } //========== 方法 ==========

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStageLibrary"].createBrightnessStage();
      this._postProcessStage.uniforms.brightness = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.brightness, 2.0);
    }
  }]);

  return BrightnessEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/BlackAndWhiteEffect.js






function BlackAndWhiteEffect_createSuper(Derived) { var hasNativeReflectConstruct = BlackAndWhiteEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BlackAndWhiteEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 黑白效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.gradations = 4.0]  渐变
 *
 * @export
 * @class BlackAndWhiteEffect
 * @extends {BaseEffect}
 */

var BlackAndWhiteEffect_BlackAndWhiteEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(BlackAndWhiteEffect, _BaseEffect);

  var _super = BlackAndWhiteEffect_createSuper(BlackAndWhiteEffect);

  function BlackAndWhiteEffect() {
    classCallCheck_default()(this, BlackAndWhiteEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(BlackAndWhiteEffect, [{
    key: "gradations",
    get:
    /**
     * 渐变
     * @type {Number}
     */
    function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.gradations;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.gradations = value;
      }
    } //========== 方法 ==========

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStageLibrary"].createBlackAndWhiteStage();
      this._postProcessStage.uniforms.gradations = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.gradations, 4.0);
    }
  }]);

  return BlackAndWhiteEffect;
}(BaseEffect_BaseEffect);
// EXTERNAL MODULE: ./src/shaders/PostProcessStage/Mosaic.glsl
var Mosaic = __webpack_require__(89);
var Mosaic_default = /*#__PURE__*/__webpack_require__.n(Mosaic);

// CONCATENATED MODULE: ./src/effect/MosaicEffect.js






function MosaicEffect_createSuper(Derived) { var hasNativeReflectConstruct = MosaicEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MosaicEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 马赛克效果
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @export
 * @class MosaicEffect
 * @extends {BaseEffect}
 */

var MosaicEffect_MosaicEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(MosaicEffect, _BaseEffect);

  var _super = MosaicEffect_createSuper(MosaicEffect);

  function MosaicEffect() {
    classCallCheck_default()(this, MosaicEffect);

    return _super.apply(this, arguments);
  }

  createClass_default()(MosaicEffect, [{
    key: "_mountedHook",
    value:
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    function _mountedHook() {
      this._postProcessStage = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStage"]({
        fragmentShader: Mosaic_default.a,
        enabled: this.enabled
      });
    }
  }]);

  return MosaicEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/DepthOfFieldEffect.js






function DepthOfFieldEffect_createSuper(Derived) { var hasNativeReflectConstruct = DepthOfFieldEffect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DepthOfFieldEffect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



/**
 * 景深
 * @param {Object} options 参数对象，包括以下：
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Number} [options.focalDistance = 87]  焦距，是以米为单位的距离来设定相机的焦距。
 * @param {Number} [options.delta =  1.0]  增量
 * @param {Number} [options.sigma =  3.78]  delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
 * @param {Number} [options.stepSize = 5.0]  步长,是下一个texel的距离
 *
 * @export
 * @class DepthOfFieldEffect
 * @extends {BaseEffect}
 */

var DepthOfFieldEffect_DepthOfFieldEffect = /*#__PURE__*/function (_BaseEffect) {
  inherits_default()(DepthOfFieldEffect, _BaseEffect);

  var _super = DepthOfFieldEffect_createSuper(DepthOfFieldEffect);

  //========== 构造方法 ==========
  function DepthOfFieldEffect() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, DepthOfFieldEffect);

    return _super.call(this, options);
  }
  /**
   * 焦距，是以米为单位的距离来设定相机的焦距。
   * @type {Number}
   */


  createClass_default()(DepthOfFieldEffect, [{
    key: "focalDistance",
    get: function get() {
      var _this$_postProcessSta;

      return (_this$_postProcessSta = this._postProcessStage) === null || _this$_postProcessSta === void 0 ? void 0 : _this$_postProcessSta.uniforms.focalDistance;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.focalDistance = value;
      }
    }
    /**
     * 增量.方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */

  }, {
    key: "delta",
    get: function get() {
      var _this$_postProcessSta2;

      return (_this$_postProcessSta2 = this._postProcessStage) === null || _this$_postProcessSta2 === void 0 ? void 0 : _this$_postProcessSta2.uniforms.delta;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.delta = value;
      }
    }
    /**
     *delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */

  }, {
    key: "sigma",
    get: function get() {
      var _this$_postProcessSta3;

      return (_this$_postProcessSta3 = this._postProcessStage) === null || _this$_postProcessSta3 === void 0 ? void 0 : _this$_postProcessSta3.uniforms.sigma;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.sigma = value;
      }
    }
    /**
     * 步长,是下一个texel的距离
     * @type {Number}
     */

  }, {
    key: "stepSize",
    get: function get() {
      var _this$_postProcessSta4;

      return (_this$_postProcessSta4 = this._postProcessStage) === null || _this$_postProcessSta4 === void 0 ? void 0 : _this$_postProcessSta4.uniforms.stepSize;
    },
    set: function set(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.stepSize = value;
      }
    } //========== 方法 ==========

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._postProcessStage = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["PostProcessStageLibrary"].createDepthOfFieldStage();
      this._postProcessStage.uniforms.focalDistance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.focalDistance, 87); //焦距

      this._postProcessStage.uniforms.delta = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.delta, 1);
      this._postProcessStage.uniforms.sigma = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.sigma, 3.78);
      this._postProcessStage.uniforms.stepSize = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.stepSize, 2.46); //步长
    }
  }]);

  return DepthOfFieldEffect;
}(BaseEffect_BaseEffect);
// CONCATENATED MODULE: ./src/effect/index.js
 //基类












// CONCATENATED MODULE: ./src/control/BaseControl.js







function BaseControl_createSuper(Derived) { var hasNativeReflectConstruct = BaseControl_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function BaseControl_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 控件 基类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Int} [options.insertIndex = null] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
 * @param {HTMLElement} [options.insertBefore = null] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
 *
 * @export
 * @class BaseControl
 * @extends {BaseThing}
 */

var BaseControl_BaseControl = /*#__PURE__*/function (_BaseThing) {
  inherits_default()(BaseControl, _BaseThing);

  var _super = BaseControl_createSuper(BaseControl);

  function BaseControl() {
    classCallCheck_default()(this, BaseControl);

    return _super.apply(this, arguments);
  }

  createClass_default()(BaseControl, [{
    key: "show",
    get:
    /**
     *  设置DOM容器的显示隐藏
     * @type {Boolean}
     *
     */
    function get() {
      return this._show;
    },
    set: function set(show) {
      if (this._show == show) {
        return;
      }

      this._show = show;

      if (this._container) {
        this._container.style.display = show ? "block" : "none";
      }

      this._showHook && this._showHook(show);
    }
    /**
     *  当前控件的DOM对象
     * @type {HTMLElement}
     * @readonly
     */

  }, {
    key: "container",
    get: function get() {
      return this._container;
    }
    /**
     *  父容器DOM对象
     * @type {HTMLElement}
     * @readonly
     */

  }, {
    key: "parentContainer",
    get: function get() {
      var _this$_map;

      return (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.container;
    }
    /**
     *  父容器DOM对象的ID
     * @type {String}
     * @readonly
     */

  }, {
    key: "parentContainerId",
    get: function get() {
      var _this$_map2, _this$_map2$container;

      return (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : (_this$_map2$container = _this$_map2.container) === null || _this$_map2$container === void 0 ? void 0 : _this$_map2$container.id;
    }
    /**
     * 添加到地图上，同 map.addControl
     *
     * @param {Map} map 地图对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addTo",
    value: function addTo(map) {
      if (map && map.addControl) {
        map.addControl(this);
      }

      return this;
    }
    /**
     * 从地图上移除，同map.removeControl
     *
     * @param {Boolean} destroy 是否调用destroy释放
     * @return {void}  无
     */

  }, {
    key: "remove",
    value: function remove(destroy) {
      if (this._map) {
        this._map.removeControl(this, destroy);
      }
    }
    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onAdd",
    value: function _onAdd(map) {
      if (this._state == State.ADDED) {
        return;
      }

      this._map = map;

      if (this._container) {
        if (!this._container.parentNode) {
          this._addChildContainer(this._container);
        }
      } else {
        this._mountedHook && this._mountedHook();

        if (this._container) {
          this._addChildContainer(this._container);
        }
      }

      this._addedHook && this._addedHook(); //挂载到map中

      if (this.type) {
        if (this._map.controls[this.type]) {
          Object(Log["logError"])("\u52A0\u8F7D\u591A\u4E2A".concat(this.type, "\u7C7B\u578B\u63A7\u4EF6\u5230\u5730\u56FE\u4E0A\u4E86"), this);
        }

        this._map.controls[this.type] = this;
      }

      this._state = State.ADDED;
    }
  }, {
    key: "_addChildContainer",
    value: function _addChildContainer(container) {
      if (this.options.insertBefore) {
        this.parentContainer.insertBefore(container, this.options.insertBefore);
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.insertIndex)) {
        var childNodes = this.parentContainer.childNodes;

        if (childNodes.length < this.options.insertIndex) {
          this.options.insertIndex = 0;
        }

        this.parentContainer.insertBefore(container, childNodes[this.options.insertIndex]);
      } else {
        this.parentContainer.appendChild(container);
      }
    }
    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */

  }, {
    key: "_onRemove",
    value: function _onRemove() {
      if (this._state == State.REMOVED) {
        return;
      }

      if (!this._map) {
        return;
      }

      if (this._container && this._container.parentNode) {
        this.parentContainer.removeChild(this._container);
      }

      this._removedHook && this._removedHook(); //移除挂载

      if (this.type) {
        this._map.controls[this.type] = null;
      }

      this._map = null;
      this._state = State.REMOVED;
    }
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {}
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {}
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {}
    /**
      * 设置新的css样式信息
      *
      * @param {Object} style css样式
      * @return {void}  无
      */

  }, {
    key: "setCss",
    value: function setCss(style) {
      Object(Util["merge"])(this._container.style, style);
      return this;
    }
    /**
     * 设置新的css样式信息
     *
     * @param {Object} style css样式
     * @return {void}  无
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      Object(Util["merge"])(this._container.style, style);
      return this;
    } //销毁

  }, {
    key: "destroy",
    value: function destroy(noDel) {
      this.enabled = false;

      get_default()(getPrototypeOf_default()(BaseControl.prototype), "destroy", this).call(this, noDel);
    }
  }]);

  return BaseControl;
}(BaseThing_BaseThing);
// CONCATENATED MODULE: ./src/control/LocationBar.js






function LocationBar_createSuper(Derived) { var hasNativeReflectConstruct = LocationBar_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function LocationBar_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








/**
 * @typedef {Object} LocationBar.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} change 数据变化了
 *
 * @example
 * //绑定监听事件
 * thing.on(tudou3d.EventType.change, function (event) {
 *   console.log('数据变化了', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 鼠标经纬度等信息状态栏,
 * 一般在页面下侧区域
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Boolean} [options.fps = false] 是否显示实时FPS帧率
 * @param {Number} [options.latDecimal = LatLngPoint.FormatLength]  保留的{lat}和{lng}的小数位
 * @param {Sring|Sring[]} [options.template] 展示的内容格式化字符串, 为数组时按多语言顺序定义，如[中文、繁体、英文]
 * 支持以下模版配置：
 * 【鼠标所在位置】 经度:{lng}， 纬度:{lat}， 海拔：{alt}米，
 * 【相机的】 方向角度：{heading}， 俯仰角度：{pitch}， 视高：{cameraHeight}米，
 * 【地图的】 层级：{level}，
 *
 *
 * @param {String|CRS} [options.crs] 按指定坐标系显示坐标值,  配置后template可以加模板：【鼠标所在位置对应的crs坐标系】 X或经度值：{crsx}， Y或纬度值：{crsy}
 * @param {Number} [options.crsDecimal = 1]  保留的{crsx}和{crsy}的小数位
 * @param {Number} [options.cacheTime = 100]  鼠标移动的缓存时间
 * @param {Object} [options.style] 可以CSS样式，如:
 * @param {String} [options.style.top]   css定位top位置, 如 top: '10px'
 * @param {String} [options.style.bottom]   css定位bottom位置
 * @param {String} [options.style.left]   css定位left位置
 * @param {String} [options.style.right]   css定位right位置
 *
 *
 * @export
 * @class LocationBar
 * @extends {BaseControl}
 *
 * @see [支持的事件类型]{@link LocationBar.EventType}
 */

var LocationBar_LocationBar = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(LocationBar, _BaseControl);

  var _super = LocationBar_createSuper(LocationBar);

  //========== 构造方法 ==========
  function LocationBar() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, LocationBar);

    _this = _super.call(this, options); //默认值

    _this.options.cacheTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.cacheTime, 100);
    /**
     * 显示的数据
     * @type {Object}
     * @readonly
     */

    _this.locationData = {};
    return _this;
  }

  createClass_default()(LocationBar, [{
    key: "type",
    get: function get() {
      return "locationBar";
    } //========== 方法 ==========

    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      if (Array.isArray(this.options.template)) {
        this.template = this.options.template[this._map.lang];
      } else {
        this.template = this.options.template;
      }

      if (!this.template) {
        this.template = "<div>经度:{lng}</div> <div>纬度:{lat}</div> <div>海拔：{alt}米</div> <div>方向：{heading}度</div>";
      }

      this._container = create("div", "tudou3d-locationbar animation-slide-bottom no-print");
      this._containerCon = create("div", "tudou3d-locationbar-content", this._container);

      if (this.options.style) {
        this.setStyle(this.options.style);
      } else {
        this.setStyle({
          left: this._map.viewer.animation ? "170px" : "0",
          right: "0",
          bottom: this._map.viewer.timeline ? "25px" : "0"
        });
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.pitch).toFixed(0); //帧率

      if (this.options.fps) {
        // 帧率的计算借助了Cesium中的东西，需要开启debugShowFramesPerSecond
        this._map.scene.debugShowFramesPerSecond = true;
        var timeTik = setInterval(function () {
          var _domFPS;

          if (!_this2._map || !_this2._map.scene._performanceDisplay) {
            return;
          }

          clearInterval(timeTik);
          _this2.timeTik = null;
          var domFPS = document.getElementsByClassName("cesium-performanceDisplay");

          if (domFPS && ((_domFPS = domFPS) === null || _domFPS === void 0 ? void 0 : _domFPS.length) > 0) {
            domFPS = domFPS[0];
          } //修改样式


          addClass(domFPS, "tudou3d-locationbar-content");
          removeClass(domFPS, "cesium-performanceDisplay"); //移除空节点

          var throttled = domFPS.querySelector(".cesium-performanceDisplay-throttled");
          remove(throttled); //添加到状态栏

          domFPS.parentNode.removeChild(domFPS);

          _this2._container.insertBefore(domFPS, _this2._containerCon);
        }, 500);
        this.timeTik = timeTik;
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.mouseMove, this._mouseMoveHandler, this);

      this._map.on(EventType.cameraMoveEnd, this._cameraHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.mouseMove, this._mouseMoveHandler, this);

      this._map.off(EventType.cameraMoveEnd, this._cameraHandler, this);

      if (this.options.fps) {
        this._map.scene.debugShowFramesPerSecond = false;
      }

      if (this.timeTik) {
        clearInterval(this.timeTik);
        this.timeTik = null;
      }
    } //========== 内部方法 ==========

  }, {
    key: "_cameraHandler",
    value: function _cameraHandler() {
      if (!this.enabled) {
        return;
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.pitch).toFixed(0);
      this.locationData.level = this._map.level;

      if (this.locationData.lat == null) {
        return;
      }

      this._templateHtml();
    } //鼠标移动事件，setTimeout是为了优化效率

  }, {
    key: "_mouseMoveHandler",
    value: function _mouseMoveHandler(event) {
      var _this3 = this;

      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }

      this.moveTimer = setTimeout(function () {
        delete _this3.moveTimer;

        _this3._updateHtml(event);
      }, this.options.cacheTime);
    }
  }, {
    key: "_updateHtml",
    value: function _updateHtml(event) {
      var _this$options$latDeci;

      if (!this.enabled) {
        return;
      }

      var cartesian = event.cartesian;

      if (!cartesian) {
        return;
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(LatLngPoint["a" /* LatLngPoint */].FormatAltLength);
      this.locationData.heading = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(this._map.camera.pitch).toFixed(0);
      this.locationData.level = this._map.level;
      var cartographic = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"].fromCartesian(cartesian);
      this.locationData.alt = Object(Util["formatNum"])(cartographic.height, LatLngPoint["a" /* LatLngPoint */].FormatAltLength); //赵西洋 cesium1.85后取消terrainExaggeration变量
      // if (this._map.scene.globe?.terrainExaggeration) {
      //   this.locationData.alt = formatNum(this.locationData.alt / this._map.scene.globe.terrainExaggeration, LatLngPoint.FormatAltLength);
      // }

      var jd = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(cartographic.longitude);
      var wd = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(cartographic.latitude);
      var fixedLen = (_this$options$latDeci = this.options.latDecimal) !== null && _this$options$latDeci !== void 0 ? _this$options$latDeci : LatLngPoint["a" /* LatLngPoint */].FormatLength;
      this.locationData.lng = jd.toFixed(fixedLen);
      this.locationData.lat = wd.toFixed(fixedLen);

      if (this.options.crs) {
        var _this$options$crsDeci;

        //其他坐标系
        var _fixedLen = (_this$options$crsDeci = this.options.crsDecimal) !== null && _this$options$crsDeci !== void 0 ? _this$options$crsDeci : 1;

        var ptNew = Object(PointTrans["proj4Trans"])([jd, wd], "EPSG:4326", this.options.crs);

        if (ptNew[0] == jd) {
          this.locationData.crsx = "";
        } else {
          this.locationData.crsx = ptNew[0].toFixed(_fixedLen);
        }

        if (ptNew[1] == wd) {
          this.locationData.crsy = "";
        } else {
          this.locationData.crsy = ptNew[1].toFixed(_fixedLen);
        }
      }

      this._templateHtml();
    }
  }, {
    key: "_templateHtml",
    value: function _templateHtml() {
      var inhtml;

      if (typeof this.template == "function") {
        //回调方法
        inhtml = this.template(this.locationData);
      } else {
        if (this.options.formatData) {
          this.locationData = this.options.formatData(this.locationData);
        }

        inhtml = Object(Util["template"])(this.template, this.locationData);
      }

      this._containerCon.innerHTML = inhtml;
      this.fire(EventType.change);
    }
  }]);

  return LocationBar;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/MouseDownView.js






function MouseDownView_createSuper(Derived) { var hasNativeReflectConstruct = MouseDownView_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MouseDownView_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 鼠标旋转、放大时的按键效果美化图标
 *
 * @export
 * @class MouseDownView
 * @extends {BaseControl}
 */

var MouseDownView_MouseDownView = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(MouseDownView, _BaseControl);

  var _super = MouseDownView_createSuper(MouseDownView);

  function MouseDownView() {
    classCallCheck_default()(this, MouseDownView);

    return _super.apply(this, arguments);
  }

  createClass_default()(MouseDownView, [{
    key: "type",
    get: function get() {
      return "mouseDownView";
    } //========== 方法 ==========

    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div", "tudou3d-mousedownview");
      this._container.id = this.parentContainerId + "-tudou3d-mousedownview";
      create("div", "tudou3d-mousedownview-img", this._container);
    } //改变鼠标操作后调用

  }, {
    key: "changeMouseModel",
    value: function changeMouseModel() {
      if (this.isAdded) {
        this._removedHook();

        this._addedHook();
      }
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.wheel, this._mousWheelHandler, this);

      if (this._map._hasRightTilt) {
        this._map.on(EventType.rightDown, this._mousMiddleDownHandler, this);

        this._map.on(EventType.rightUp, this._mousMiddleUpHandler, this);
      } else {
        this._map.on(EventType.middleDown, this._mousMiddleDownHandler, this);

        this._map.on(EventType.middleUp, this._mousMiddleUpHandler, this);
      }

      this._mousMiddleUpHandler();
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.wheel, this._mousWheelHandler, this);

      if (this._map._hasRightTilt) {
        this._map.off(EventType.rightDown, this._mousMiddleDownHandler, this);

        this._map.off(EventType.rightUp, this._mousMiddleUpHandler, this);
      } else {
        this._map.off(EventType.middleDown, this._mousMiddleDownHandler, this);

        this._map.off(EventType.middleUp, this._mousMiddleUpHandler, this);
      }
    }
  }, {
    key: "_mousWheelHandler",
    value: function _mousWheelHandler(evnet) {
      var _this = this;

      if (!this.enabled) {
        return;
      }

      addClass(this._container, "tudou3d-mousedownview-show");
      clearTimeout(this.timetik);
      this.timetik = setTimeout(function () {
        removeClass(_this._container, "tudou3d-mousedownview-show");
      }, 200);
    }
  }, {
    key: "_mousMiddleDownHandler",
    value: function _mousMiddleDownHandler(evnet) {
      if (!this.enabled) {
        return;
      }

      var position = Object(PointUtil["getCurrentMousePosition"])(this._map.scene, evnet.position);

      if (!position) {
        return;
      }

      if (this._map.camera.positionCartographic.height > this._map.scene.screenSpaceCameraController.minimumCollisionTerrainHeight) {
        return;
      }

      this._map.off(EventType.mouseMove, this._mouseMoveHandler, this);

      clearTimeout(this.timetik);
      this._container.style.top = evnet.position.y + "px";
      this._container.style.left = evnet.position.x + "px";
      addClass(this._container, "tudou3d-mousedownview-show");
    }
  }, {
    key: "_mousMiddleUpHandler",
    value: function _mousMiddleUpHandler(evnet) {
      removeClass(this._container, "tudou3d-mousedownview-show");

      this._map.on(EventType.mouseMove, this._mouseMoveHandler, this);
    }
  }, {
    key: "_mouseMoveHandler",
    value: function _mouseMoveHandler(evnet) {
      this._container.style.top = evnet.endPosition.y + "px";
      this._container.style.left = evnet.endPosition.x + "px";
    }
  }]);

  return MouseDownView;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/Zoom.js






function Zoom_createSuper(Derived) { var hasNativeReflectConstruct = Zoom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Zoom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * 放大缩小按钮控件
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {String} [options.zoomOutClass='fa fa-minus'] 缩小按钮字体图标class名
 * @param {String} [options.zoomInClass='fa fa-plus'] 放大按钮字体图标class名
 *
 * @export
 * @class Zoom
 * @extends {BaseControl}
 */

var Zoom_Zoom = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(Zoom, _BaseControl);

  var _super = Zoom_createSuper(Zoom);

  function Zoom() {
    classCallCheck_default()(this, Zoom);

    return _super.apply(this, arguments);
  }

  createClass_default()(Zoom, [{
    key: "type",
    get: function get() {
      return "zoom";
    }
  }, {
    key: "parentContainer",
    get: function get() {
      return document.getElementsByClassName("cesium-viewer-toolbar")[0];
    }
    /**
     * 创建_container控件容器对象的方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      //缩小
      this._container = create("div", "cesium-button cesium-toolbar-button");
      this._container.style.display = "inline-block";

      this._container.setAttribute("title", this._map.getLangText("_缩小"));

      create("i", this.options.zoomOutClass || "fa fa-minus", this._container);

      this._container.addEventListener("click", function (e) {
        _this._map.zoomOut();
      }); //放大


      this._container2 = create("div", "cesium-button cesium-toolbar-button");
      this._container2.style.display = "inline-block";

      this._container2.setAttribute("title", this._map.getLangText("_放大"));

      create("i", this.options.zoomInClass || "fa fa-plus", this._container2);

      this._container2.addEventListener("click", function (e) {
        _this._map.zoomIn();
      });
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this.parentContainer.insertBefore(this._container2, this._container);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this.parentContainer.removeChild(this._container2);
    }
  }]);

  return Zoom;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/ToolButton.js







function ToolButton_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ToolButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ToolButton_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ToolButton_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ToolButton_createSuper(Derived) { var hasNativeReflectConstruct = ToolButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ToolButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





/**
 * @typedef {Object} ToolButton.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} click 单击了按钮
 *
 * @example
 * //绑定监听事件
 * control.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了按钮', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * 工具栏 单个按钮控件
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {String} [options.title=''] 按钮标题
 * @param {String} [options.icon='fa fa-tasks'] 按钮字体图标class名
 * @param {Function} [options.click] 按钮单击后的回调方法
 * @export
 * @class ToolButton
 * @extends {BaseControl}
 *
 * @see [支持的事件类型]{@link ToolButton.EventType}
 */

var ToolButton_ToolButton = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(ToolButton, _BaseControl);

  var _super = ToolButton_createSuper(ToolButton);

  function ToolButton() {
    classCallCheck_default()(this, ToolButton);

    return _super.apply(this, arguments);
  }

  createClass_default()(ToolButton, [{
    key: "parentContainer",
    get: function get() {
      return document.getElementsByClassName("cesium-viewer-toolbar")[0];
    }
    /**
     * 创建_container控件容器对象的方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      //缩小
      this._container = create("div", "cesium-button cesium-toolbar-button");
      this._container.id = this.id || this.uuid;
      this._container.style.display = "inline-block";

      this._container.setAttribute("title", this.options.title || "");

      create("i", this.options.icon || "fa fa-tasks", this._container); //单击事件

      this._container.addEventListener("click", function (e) {
        if (_this.options.click) {
          _this.options.click(_this.options);
        }

        _this.fire(EventType.click, ToolButton_objectSpread({}, _this.options));
      }); //鼠标移入移出


      var cacheTarget;

      this._container.addEventListener("mouseover", function (e) {
        //缓存，提高效率
        if (cacheTarget == _this.uuid) {
          return;
        }

        cacheTarget = _this.uuid;

        if (_this.options.mouseOver) {
          _this.options.mouseOver(_this.options);
        }

        _this.fire(EventType.mouseOver, ToolButton_objectSpread({}, _this.options));
      });

      this._container.addEventListener("mouseout", function (e) {
        //缓存，提高效率
        cacheTarget = null;

        if (_this.options.mouseOut) {
          _this.options.mouseOut(_this.options);
        }

        _this.fire(EventType.mouseOut, ToolButton_objectSpread({}, _this.options));
      });
    }
  }]);

  return ToolButton;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/icon/compass_outer.js
var icon = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"162px\" height=\"162px\" viewBox=\"0 0 162 162\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>\u62D6\u62FD\u8C03\u6574\u56DB\u5468\u65B9\u5411\u89D2\uFF0C\u53CC\u51FB\u56DE\u6B63\u5317</title>\n    <desc>tudou3d.cn</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"compass-outer\" fill-rule=\"nonzero\">\n            <path d=\"M80.8410544,161.682109 C36.1937731,161.682109 0,125.488336 0,80.8410544 C0,36.1937731 36.1937731,0 80.8410544,0 C125.488336,0 161.682109,36.1937731 161.682109,80.8410544 C161.682109,125.488336 125.488336,161.682109 80.8410544,161.682109 Z M81.1836011,134.620909 C110.696211,134.620909 134.620909,110.696211 134.620909,81.1836011 C134.620909,51.6709916 110.696211,27.7462941 81.1836011,27.7462941 C51.6709916,27.7462941 27.7462941,51.6709916 27.7462941,81.1836011 C27.7462941,110.696211 51.6709916,134.620909 81.1836011,134.620909 Z\" id=\"Oval-108\"></path>\n            <circle id=\"Oval-74\" fill=\"#FFFFFF\" cx=\"129.493683\" cy=\"127.952092\" r=\"1.54159147\"></circle>\n            <circle id=\"Oval-74-Copy-3\" fill=\"#FFFFFF\" cx=\"129.493683\" cy=\"35.4566038\" r=\"1.54159147\"></circle>\n            <circle id=\"Oval-74-Copy-5\" fill=\"#FFFFFF\" cx=\"30.8318294\" cy=\"127.952092\" r=\"1.54159147\"></circle>\n            <circle id=\"Oval-74-Copy-4\" fill=\"#FFFFFF\" cx=\"30.8318294\" cy=\"35.4566038\" r=\"1.54159147\"></circle>\n            <polygon id=\"N\" fill=\"#FFFFFF\" points=\"84.9318072 23.1238721 84.9318072 13.1321362 82.5623385 13.1321362 82.5623385 19.2984646 77.951866 13.1321362 75.7108625 13.1321362 75.7108625 23.1238721 78.0946053 23.1238721 78.0946053 16.9718176 82.6908037 23.1238721\"></polygon>\n            <polygon id=\"Line\" fill=\"#FFFFFF\" points=\"143.368007 82.1093476 152.617555 82.1093476 152.617555 81.2993476 143.368007 81.2993476\"></polygon>\n            <polygon id=\"Line-Copy-8\" fill=\"#FFFFFF\" points=\"9.24954884 82.1093476 18.4990976 82.1093476 18.4990976 81.2993476 9.24954884 81.2993476\"></polygon>\n            <polygon id=\"Line\" fill=\"#FFFFFF\" points=\"81.2993476 143.368007 81.2993476 152.617555 82.1093476 152.617555 82.1093476 143.368007\"></polygon>\n        </g>\n    </g>\n</svg>\n";
// CONCATENATED MODULE: ./src/control/icon/compass_inner.js
var compass_inner_icon = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"17px\" height=\"17px\" viewBox=\"0 0 17 17\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>\u62D6\u62FD\u8C03\u6574\u4FEF\u4EF0\u89D2</title>\n    <desc>tudou3d.cn</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"compass-inner\" fill-rule=\"nonzero\">\n            <path d=\"M8.5,16.5 C4.081722,16.5 0.5,12.918278 0.5,8.5 C0.5,4.081722 4.081722,0.5 8.5,0.5 C12.918278,0.5 16.5,4.081722 16.5,8.5 C16.5,12.918278 12.918278,16.5 8.5,16.5 Z M8.5,15.5 C12.3659932,15.5 15.5,12.3659932 15.5,8.5 C15.5,4.63400675 12.3659932,1.5 8.5,1.5 C4.63400675,1.5 1.5,4.63400675 1.5,8.5 C1.5,12.3659932 4.63400675,15.5 8.5,15.5 Z\" id=\"Oval-96\"></path>\n            <path d=\"M9.92599835,7.09066832 C12.7122872,9.87695712 14.3709388,12.5452228 13.4497471,13.4664145 C12.5285555,14.3876061 9.86028979,12.7289545 7.074001,9.94266568 C4.2877122,7.15637688 2.62906055,4.48811119 3.55025221,3.56691953 C4.47144386,2.64572788 7.13970955,4.30437952 9.92599835,7.09066832 Z M9.21889157,7.7977751 C6.92836458,5.50724811 4.52075769,4.01062761 4.25735899,4.27402631 C3.99396029,4.53742501 5.49058078,6.9450319 7.78110778,9.2355589 C10.0716348,11.5260859 12.4792417,13.0227064 12.7426404,12.7593077 C13.0060391,12.495909 11.5094186,10.0883021 9.21889157,7.7977751 Z\" id=\"Oval-96-Copy-2\"></path>\n            <path d=\"M9.92599835,9.94266568 C7.13970955,12.7289545 4.47144386,14.3876061 3.55025221,13.4664145 C2.62906055,12.5452228 4.2877122,9.87695712 7.074001,7.09066832 C9.86028979,4.30437952 12.5285555,2.64572788 13.4497471,3.56691953 C14.3709388,4.48811119 12.7122872,7.15637688 9.92599835,9.94266568 Z M9.21889157,9.2355589 C11.5094186,6.9450319 13.0060391,4.53742501 12.7426404,4.27402631 C12.4792417,4.01062761 10.0716348,5.50724811 7.78110778,7.7977751 C5.49058078,10.0883021 3.99396029,12.495909 4.25735899,12.7593077 C4.52075769,13.0227064 6.92836458,11.5260859 9.21889157,9.2355589 Z\" id=\"Oval-96-Copy-3\"></path>\n            <path d=\"M15.1464466,1.1464466 L14.3453364,1.94755684 L13.9608692,2.33202401 L14.667976,3.03913077 L15.0524431,2.65466362 L15.8535534,1.8535534 L15.1464466,1.1464466 Z M2.29760014,13.995293 L1.85311902,14.4397742 L1.004311,15.2885822 L1.71141776,15.995689 L2.56022581,15.146881 L3.00470698,14.7023998 L2.29760014,13.995293 Z\" id=\"Line\"></path>\n            <circle id=\"Oval-432\" cx=\"16\" cy=\"1\" r=\"1\"></circle>\n            <circle id=\"Oval-432-Copy\" cx=\"1\" cy=\"16\" r=\"1\"></circle>\n        </g>\n    </g>\n</svg>\n";
// CONCATENATED MODULE: ./src/control/icon/compass_rotation_arc.js
var compass_rotation_arc_icon = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"53px\" height=\"53px\" viewBox=\"0 0 53 53\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n    <title>\u5BFC\u822A\u7403</title>\n    <desc>tudou3d.cn</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"compass-rotation-marker\">\n            <path d=\"M52.4399986,26.2199993 C52.4399986,11.7390936 40.7009051,0 26.2199993,0 C11.7390936,0 0,11.7390936 0,26.2199993 C0,40.7009051 11.7390936,52.4399986 26.2199993,52.4399986 C40.7009051,52.4399986 52.4399986,40.7009051 52.4399986,26.2199993 Z\" id=\"rotator\" stroke-opacity=\"0.135841259\" stroke=\"#E2A549\" stroke-width=\"9\" opacity=\"0.201434235\"></path>\n            <path d=\"M0,26.2199993 C0,11.7390936 11.7390936,0 26.2199993,0 L26.2199993,9 C16.7096563,9 9,16.7096563 9,26.2199993\" id=\"Shape\" opacity=\"0.634561567\" fill=\"#4990E2\"></path>\n        </g>\n    </g>\n</svg>\n";
// CONCATENATED MODULE: ./src/control/Compass.js






function Compass_createSuper(Derived) { var hasNativeReflectConstruct = Compass_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Compass_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





 //外部圆环

 //中心球

 //调整俯仰角的对外部圆环的半弧遮盖

/**
 * 导航球控件
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 * @param {Boolean} [options.rotation = true] 是否启用调整俯仰角（按中间区域往四周拖拽）
 *
 * @param {String} [options.className='tudou3d-compass']  样式名称，可以外部自定义样式。
 * @param {String} [options.top]   css定位top位置, 如 top: '10px'
 * @param {String} [options.bottom]   css定位bottom位置，支持配置'toolbar'自动跟随cesium-viewer-toolbar
 * @param {String} [options.left]   css定位left位置
 * @param {String} [options.right]   css定位right位置
 *
 * @param {String} [options.outerSvg]  外部圆环区域的SVG图片
 * @param {String} [options.innerSvg]  中心球区域的SVG图片
 * @param {String} [options.rotationArcSvg] rotation为true时，按中间区域往四周拖拽时，调整俯仰角的对外部圆环的半弧遮盖SVG图片
 *
 * @export
 * @class Compass
 * @extends {BaseControl}
 */

var Compass_Compass = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(Compass, _BaseControl);

  var _super = Compass_createSuper(Compass);

  function Compass() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Compass);

    _this = _super.call(this, options);
    _this._orbitCursorAngle = 0;
    _this._orbitCursorOpacity = 0.0;
    _this._orbitLastTimestamp = 0;
    _this.options.rotation = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.rotation, true);
    return _this;
  }

  createClass_default()(Compass, [{
    key: "type",
    get: function get() {
      return "compass";
    } //获取css定位值

  }, {
    key: "_getCssText",
    value: function _getCssText() {
      var css = {};

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.top)) {
        css.top = this.options.top;
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.bottom)) {
        css.bottom = this.options.bottom; //跟随toolbar时

        if (css.bottom == "toolbar") {
          var _domToolbar;

          var domToolbar = document.getElementsByClassName("cesium-viewer-toolbar");

          if (domToolbar && ((_domToolbar = domToolbar) === null || _domToolbar === void 0 ? void 0 : _domToolbar.length) > 0) {
            domToolbar = domToolbar[0];
            var height = domToolbar.offsetHeight + 40;
            css.bottom = height + "px";
            this.domToolbar = domToolbar;
          }
        }
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.left)) {
        css.left = this.options.left;
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.right)) {
        css.right = this.options.right;
      }

      var cssText = "";

      for (var key in css) {
        cssText += "".concat(key, ": ").concat(css[key], ";");
      }

      return cssText || "top: 10px;right: 10px;";
    }
  }, {
    key: "updateSize",
    value: function updateSize() {
      if (this.domToolbar) {
        var height = this.domToolbar.offsetHeight + 40;
        this._container.style.bottom = height + "px";
      }
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this2 = this;

      this._container = create("div", this.options.className || "tudou3d-compass");
      this._container.style.cssText = this._getCssText();

      this._container.onmousedown = function (e) {
        _this2._handleMouseDown(e);
      };

      this._container.ondblclick = function (e) {
        _this2._handleDoubleClick(e);
      };

      this._container_outer = parseDom(this.options.outerSvg || icon, true, "tudou3d-compass-outer");

      this._container.appendChild(this._container_outer);

      this._container_inner = parseDom(this.options.innerSvg || compass_inner_icon, true, "tudou3d-compass-inner");

      this._container.appendChild(this._container_inner);

      if (this.options.rotation) {
        this._container_rotationArc = parseDom(this.options.rotationArcSvg || compass_rotation_arc_icon, true, "tudou3d-compass-rotation-arc");

        this._container.appendChild(this._container_rotationArc);

        this._container_rotationArc.style.visibility = "hidden";
      }
    }
    /**
     * 更新 外部圆环区域的SVG图片
     * @param {String} svg SVG图片
     * @return {void}  无
     */

  }, {
    key: "setOuterSvg",
    value: function setOuterSvg(svg) {
      this._container_outer.innerHTML = svg;
    }
    /**
     * 更新 中心球区域的SVG图片
     * @param {String} svg SVG图片
     * @return {void}  无
     */

  }, {
    key: "setInnerSvg",
    value: function setInnerSvg(svg) {
      this._container_inner.innerHTML = svg;
    }
    /**
     * 更新 按中间区域往四周拖拽时，调整俯仰角的对外部圆环的半弧遮盖SVG图片，rotation为true时有效
     * @param {String} svg SVG图片
     * @return {void}  无
     */

  }, {
    key: "setRotationSvg",
    value: function setRotationSvg(svg) {
      this._container_rotationArc.innerHTML = svg;
    }
  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.postRender, this._postRenderHandler, this);
    }
  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.postRender, this._postRenderHandler, this);
    }
  }, {
    key: "_postRenderHandler",
    value: function _postRenderHandler() {
      var heading = this._map.camera.heading;
      this._container_outer && (this._container_outer.style.cssText = "\n      transform : rotate(-".concat(heading, "rad);\n      -webkit-transform : rotate(-").concat(heading, "rad);\n      "));
    }
  }, {
    key: "_handleMouseDown",
    value: function _handleMouseDown(e) {
      var scene = this._map.scene;

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING) {
        return true;
      }

      this._compassRectangle = e.currentTarget.getBoundingClientRect();
      var maxDistance = this._compassRectangle.width / 2.0;

      var vector = this._getVector(e);

      var distanceFraction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"].magnitude(vector) / maxDistance;

      if (this.options.rotation && distanceFraction < 50 / 145) {
        this._orbit(vector);
      } else if (distanceFraction < 1.0) {
        this._rotate(vector);
      } else {
        return true;
      }
    }
  }, {
    key: "_handleDoubleClick",
    value: function _handleDoubleClick(event) {
      var scene = this._map.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING || !sscc.enableInputs) {
        return true;
      }

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW && !sscc.enableTranslate) {
        return;
      }

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D || scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW) {
        if (!sscc.enableLook) {
          return;
        }

        if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
          if (!sscc.enableRotate) {
            return;
          }
        }
      }

      var center = this._getCameraFocus(true);

      if (!center) {
        return;
      }

      var cameraPosition = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic);
      var surfaceNormal = scene.globe.ellipsoid.geodeticSurfaceNormal(center);
      var focusBoundingSphere = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"](center, 0);
      camera.flyToBoundingSphere(focusBoundingSphere, {
        offset: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeadingPitchRange"](0, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO - external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].angleBetween(surfaceNormal, camera.directionWC), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(cameraPosition, center)),
        duration: 1.5
      });
    }
  }, {
    key: "_getCameraFocus",
    value: function _getCameraFocus(inWorldCoordinates) {
      var result = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
      var scene = this._map.scene;
      var camera = scene.camera;

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING) {
        return undefined;
      }

      if (this._map.trackedEntity) {
        result = this._map.trackedEntity.position.getValue(this._map.clock.currentTime);
      } else {
        var rayScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"]();
        rayScratch.origin = camera.positionWC;
        rayScratch.direction = camera.directionWC;
        result = scene.globe.pick(rayScratch, scene);
      }

      if (!result) {
        return undefined;
      }

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D || scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW) {
        result = camera.worldToCameraCoordinatesPoint(result);
        var unprojectedScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();

        if (inWorldCoordinates) {
          result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch));
        }
      } else {
        if (!inWorldCoordinates) {
          result = camera.worldToCameraCoordinatesPoint(result);
        }
      }

      return result;
    }
  }, {
    key: "_orbit",
    value: function _orbit(vector) {
      var _this3 = this;

      var scene = this._map.scene;
      var sscc = scene.screenSpaceCameraController;
      var camera = scene.camera;

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING || !sscc.enableInputs) {
        return;
      }

      switch (scene.mode) {
        default:
        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D:
          if (sscc.enableLook) {
            break;
          }

          if (!sscc.enableTilt || !sscc.enableRotate) {
            return;
          }

          break;

        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D:
          if (!sscc.enableTranslate) {
            return;
          }

          break;

        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW:
          if (sscc.enableLook) {
            break;
          }

          if (!sscc.enableTranslate || !sscc.enableTilt) {
            return;
          }

          break;
      }

      this._mouseMoveHandle = function (e) {
        _this3._orbitMouseMoveFunction(e);
      };

      this._mouseUpHandle = function () {
        _this3._orbitMouseUpFunction();
      };

      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);
      this._orbitLastTimestamp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["getTimestamp"]();

      if (this._map.trackedEntity) {
        this._orbitFrame = undefined;
        this._orbitIsLook = false;
      } else {
        var center = this._getCameraFocus(true);

        if (!center) {
          this._orbitFrame = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid);
          this._orbitIsLook = true;
        } else {
          this._orbitFrame = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(center, scene.globe.ellipsoid);
          this._orbitIsLook = false;
        }
      }

      this._container_rotationArc.style.visibility = "visible";
      this._container_inner.className += " compass-inner-active";
      document.addEventListener("mousemove", this._mouseMoveHandle, false);
      document.addEventListener("mouseup", this._mouseUpHandle, false);

      this._map.clock.onTick.addEventListener(this._orbitTickFunction, this);

      this._updateAngleAndOpacity(vector, this._compassRectangle.width);
    }
  }, {
    key: "_orbitTickFunction",
    value: function _orbitTickFunction(e) {
      var scene = this._map.scene;
      var camera = this._map.camera;
      var timestamp = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["getTimestamp"]();
      var deltaT = timestamp - this._orbitLastTimestamp;
      var rate = (this._orbitCursorOpacity - 0.5) * 2.5 / 1000;
      var distance = deltaT * rate;
      var angle = this._orbitCursorAngle + external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO;
      var x = Math.cos(angle) * distance;
      var y = Math.sin(angle) * distance;
      var oldTransform;

      if (this._orbitFrame) {
        oldTransform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].clone(camera.transform);
        camera.lookAtTransform(this._orbitFrame);
      }

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D) {
        camera.move(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](x, y, 0), Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100 * camera.positionCartographic.height * distance);
      } else {
        if (this._orbitIsLook) {
          camera.look(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].UNIT_Z, -x);
          camera.look(camera.right, -y);
        } else {
          camera.rotateLeft(x);
          camera.rotateUp(y);
        }
      }

      if (this._orbitFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }

      this._orbitLastTimestamp = timestamp;
    }
  }, {
    key: "_updateAngleAndOpacity",
    value: function _updateAngleAndOpacity(vector, compassWidth) {
      var angle = Math.atan2(-vector.y, vector.x);
      this._orbitCursorAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].zeroToTwoPi(angle - external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].PI_OVER_TWO);
      var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"].magnitude(vector);
      var maxDistance = compassWidth / 2.0;
      var distanceFraction = Math.min(distance / maxDistance, 1.0);
      this._orbitCursorOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
      this._container_rotationArc.style.cssText = "\n      transform: rotate(-".concat(this._orbitCursorAngle, "rad);\n      opacity: ").concat(this._orbitCursorOpacity);
    }
  }, {
    key: "_orbitMouseMoveFunction",
    value: function _orbitMouseMoveFunction(e) {
      this._updateAngleAndOpacity(this._getVector(e), this._compassRectangle.width);
    }
  }, {
    key: "_orbitMouseUpFunction",
    value: function _orbitMouseUpFunction() {
      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);

      this._map.clock.onTick.removeEventListener(this._orbitTickFunction, this);

      this._mouseMoveHandle = undefined;
      this._mouseUpHandle = undefined;
      this._container_rotationArc.style.visibility = "hidden";
      this._container_inner.className = this._container_inner.className.replace(" compass-inner-active", "");
    }
  }, {
    key: "_rotate",
    value: function _rotate(vector) {
      var _this4 = this;

      var scene = this._map.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;

      if (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING || scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D || !sscc.enableInputs) {
        return;
      }

      if (!sscc.enableLook && (scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW || scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D && !sscc.enableRotate)) {
        return;
      }

      this._mouseMoveHandle = function (e) {
        _this4._rotateMouseMoveFunction(e);
      };

      this._mouseUpHandle = function () {
        _this4._rotateMouseUpFunction();
      };

      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);
      this._rotateInitialCursorAngle = Math.atan2(-vector.y, vector.x);

      if (this._map.trackedEntity) {
        this._rotateFrame = undefined;
      } else {
        var center = this._getCameraFocus(true);

        if (!center || scene.mode === external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW && !sscc.enableLook && !sscc.enableTranslate) {
          this._rotateFrame = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid);
        } else {
          this._rotateFrame = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Transforms"].eastNorthUpToFixedFrame(center, scene.globe.ellipsoid);
        }
      }

      var oldTransform;

      if (this._rotateFrame) {
        oldTransform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].clone(camera.transform);
        camera.lookAtTransform(this._rotateFrame);
      }

      this._rotateInitialCameraAngle = -camera.heading;

      if (this._rotateFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }

      document.addEventListener("mousemove", this._mouseMoveHandle, false);
      document.addEventListener("mouseup", this._mouseUpHandle, false);
    }
  }, {
    key: "_rotateMouseMoveFunction",
    value: function _rotateMouseMoveFunction(e) {
      var camera = this._map.camera;

      var vector = this._getVector(e);

      var angle = Math.atan2(-vector.y, vector.x);
      var angleDifference = angle - this._rotateInitialCursorAngle;
      var newCameraAngle = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].zeroToTwoPi(this._rotateInitialCameraAngle - angleDifference);
      var oldTransform;

      if (this._rotateFrame) {
        oldTransform = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Matrix4"].clone(camera.transform);
        camera.lookAtTransform(this._rotateFrame);
      }

      var currentCameraAngle = -camera.heading;
      camera.rotateRight(newCameraAngle - currentCameraAngle);

      if (this._rotateFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }
    }
  }, {
    key: "_rotateMouseUpFunction",
    value: function _rotateMouseUpFunction() {
      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);
      this._mouseMoveHandle = undefined;
      this._mouseUpHandle = undefined;
    }
  }, {
    key: "_getVector",
    value: function _getVector(e) {
      var compassRectangle = this._compassRectangle;
      var center = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
      var clickLocation = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
      var vector = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"]();
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"].subtract(clickLocation, center, vector);
      return vector;
    }
  }]);

  return Compass;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/DistanceLegend.js







function DistanceLegend_createSuper(Derived) { var hasNativeReflectConstruct = DistanceLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function DistanceLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var DistanceLegend_geodesic = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidGeodesic"]();
var BASE = [1, 2, 3, 5];
var DIS = [].concat(BASE, toConsumableArray_default()(BASE.map(function (item) {
  return item * 10;
})), toConsumableArray_default()(BASE.map(function (item) {
  return item * 100;
})), toConsumableArray_default()(BASE.map(function (item) {
  return item * 1000;
})), toConsumableArray_default()(BASE.map(function (item) {
  return item * 10000;
})), toConsumableArray_default()(BASE.map(function (item) {
  return item * 100000;
})), toConsumableArray_default()(BASE.map(function (item) {
  return item * 1000000;
})));
/**
 * @typedef {Object} DistanceLegend.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} change 比例尺发生变化
 *
 *
 * @example
 * //绑定监听事件
 * distanceLegend.on(tudou3d.EventType.change, function (event) {
 *   console.log('比例尺发生变化', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 *
 * 比例尺 控件
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {String} [options.top]   css定位top位置, 如 top: '10px'
 * @param {String} [options.bottom]   css定位bottom位置
 * @param {String} [options.left]   css定位left位置
 * @param {String} [options.right]   css定位right位置
 *
 *
 * @export
 * @class DistanceLegend
 * @extends {BaseControl}
 * @see [支持的事件类型]{@link DistanceLegend.EventType}
 */

var DistanceLegend_DistanceLegend = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(DistanceLegend, _BaseControl);

  var _super = DistanceLegend_createSuper(DistanceLegend);

  function DistanceLegend() {
    classCallCheck_default()(this, DistanceLegend);

    return _super.apply(this, arguments);
  }

  createClass_default()(DistanceLegend, [{
    key: "type",
    get: function get() {
      return "distanceLegend";
    }
    /**
     * 当前比例尺值（单位：米）
     * @type {Number}
     * @readonly
     */

  }, {
    key: "distance",
    get: function get() {
      return this._currDistance;
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div", "tudou3d-distance-legend");
      this._container.style.cssText = this._getCssText();
      this._labelEl = create("div", "legend-label", this._container);
      this._scaleBarEl = create("div", "legend-scale-bar", this._container);
      this._container.style.visibility = "hidden";
      this._lastUpdate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["getTimestamp"]();
    } //获取css定位值

  }, {
    key: "_getCssText",
    value: function _getCssText() {
      var css = {};

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.top)) {
        css.top = this.options.top;
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.bottom)) {
        css.bottom = this.options.bottom;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.left)) {
        css.left = this.options.left;
      } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.options.right)) {
        css.right = this.options.right;
      }

      var cssText = "";

      for (var key in css) {
        cssText += "".concat(key, ": ").concat(css[key], ";");
      }

      return cssText || "left: 120px; bottom: 2px;";
    }
  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.postRender, this._updateContent, this);
    }
  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.postRender, this._updateContent, this);
    }
  }, {
    key: "_updateContent",
    value: function _updateContent(scene, time) {
      var now = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["getTimestamp"]();

      if (now < this._lastUpdate + 250) {
        return;
      }

      if (!this._labelEl || !this._scaleBarEl) {
        return;
      }

      this._lastUpdate = now;
      var width = scene.canvas.width;
      var height = scene.canvas.height;
      var left = scene.camera.getPickRay(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](width / 2 | 0, height - 1));
      var right = scene.camera.getPickRay(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian2"](1 + width / 2 | 0, height - 1));
      var leftPosition = scene.globe.pick(left, scene);
      var rightPosition = scene.globe.pick(right, scene);

      if (!leftPosition || !rightPosition) {
        return;
      }

      DistanceLegend_geodesic.setEndPoints(scene.globe.ellipsoid.cartesianToCartographic(leftPosition), scene.globe.ellipsoid.cartesianToCartographic(rightPosition));
      var pixelDistance = DistanceLegend_geodesic.surfaceDistance;
      var maxBarWidth = 100;
      var distance = 0;

      for (var i = DIS.length - 1; i >= 0; --i) {
        if (DIS[i] / pixelDistance < maxBarWidth) {
          distance = DIS[i];
          break;
        }
      }

      if (distance) {
        if (this._currDistance != distance) {
          this._currDistance = distance;
          this.fire(EventType.change, {
            distance: distance
          });
        }

        this._container.style.visibility = "visible";
        this._labelEl.innerHTML = distance >= 1000 ? "".concat(distance / 1000, " km") : "".concat(distance, " m");
        var barWidth = distance / pixelDistance | 0;
        this._scaleBarEl.style.cssText = "width: ".concat(barWidth, "px; left: ").concat((125 - barWidth) / 2, "px;");
      }
    }
  }]);

  return DistanceLegend;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/icon/splitter.js
var splitter_icon = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"10px\" height=\"20px\" viewBox=\"0 0 19 28\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <path d=\"M0.6551724,2.3448276 L0.6551724,25.6551724 C0.6551724,26.6454761 1.4579722,27.4482759 2.4482759,27.4482759 C3.4385796,27.4482759 4.2413793,26.6454761 4.2413793,25.6551724 L4.2413793,2.3448276 C4.2413793,1.3545239 3.4385796,0.5517241 2.4482759,0.5517241 C1.4579722,0.5517241 0.6551724,1.3545239 0.6551724,2.3448276 L0.6551724,2.3448276 Z M7.6551724,2.3448276 L7.6551724,25.6551724 C7.6551724,26.6454761 8.4579722,27.4482759 9.4482759,27.4482759 C10.4385796,27.4482759 11.2413793,26.6454761 11.2413793,25.6551724 L11.2413793,2.3448276 C11.2413793,1.3545239 10.4385796,0.5517241 9.4482759,0.5517241 C8.4579722,0.5517241 7.6551724,1.3545239 7.6551724,2.3448276 L7.6551724,2.3448276 Z M14.6551724,2.3448276 L14.6551724,25.6551724 C14.6551724,26.6454761 15.4579722,27.4482759 16.4482759,27.4482759 C17.4385796,27.4482759 18.2413793,26.6454761 18.2413793,25.6551724 L18.2413793,2.3448276 C18.2413793,1.3545239 17.4385796,0.5517241 16.4482759,0.5517241 C15.4579722,0.5517241 14.6551724,1.3545239 14.6551724,2.3448276 L14.6551724,2.3448276 Z\" id=\"splitter\"></path>\n</svg>\n";
// CONCATENATED MODULE: ./src/control/MapSplit.js






function MapSplit_createSuper(Derived) { var hasNativeReflectConstruct = MapSplit_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function MapSplit_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






/**
 * 卷帘对比 控件
 * @param {Object} options 参数对象，包括以下：
 * @param {String|Number} [options.id = uuid()] 对象的id标识
 * @param {Boolean} [options.enabled = true] 对象的启用状态
 *
 * @param {BaseTileLayer} [options.leftLayer] 左侧区域瓦片图层
 * @param {BaseTileLayer} [options.leftLayer] 右侧区域瓦片图层
 *
 * @export
 * @class MapSplit
 * @extends {BaseControl}
 */

var MapSplit_MapSplit = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(MapSplit, _BaseControl);

  var _super = MapSplit_createSuper(MapSplit);

  function MapSplit() {
    classCallCheck_default()(this, MapSplit);

    return _super.apply(this, arguments);
  }

  createClass_default()(MapSplit, [{
    key: "type",
    get: function get() {
      return "mapSplit";
    }
    /**
     * 左侧区域瓦片图层
     * @type {BaseTileLayer}
     */

  }, {
    key: "leftLayer",
    get: function get() {
      return this._leftLayer;
    },
    set: function set(layer) {
      var _this = this;

      if (this._leftLayer) {
        this._leftLayer.remove();

        this._leftLayer = null;
      }

      if (layer) {
        this._leftLayer = layer;

        if (!layer.isAdded && this._map) {
          layer.once(EventType.load, function (event) {
            _this.setLayerSplitDirection(layer, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SplitDirection"].LEFT);
          });

          this._map.addLayer(layer);
        }

        this.setLayerSplitDirection(layer, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SplitDirection"].LEFT);
      }
    }
    /**
     * 右侧区域瓦片图层
     * @type {BaseTileLayer}
     */

  }, {
    key: "rightLayer",
    get: function get() {
      return this._rightLayer;
    },
    set: function set(layer) {
      var _this2 = this;

      if (this._rightLayer) {
        this._rightLayer.remove();

        this._rightLayer = null;
      }

      if (layer) {
        this._rightLayer = layer;

        if (!layer.isAdded && this._map) {
          layer.once(EventType.load, function (event) {
            _this2.setLayerSplitDirection(layer, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SplitDirection"].RIGHT);
          });

          this._map.addLayer(layer);
        }

        this.setLayerSplitDirection(layer, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SplitDirection"].RIGHT);
      }
    }
  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div", "tudou3d-slider");
      var splitter = parseDom(splitter_icon, true, "slider-splitter");

      this._container.appendChild(splitter);

      var handler = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventHandler"](splitter);
      var self = this;
      handler.setInputAction(function () {
        self._moveActive = true;
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_DOWN);
      handler.setInputAction(function () {
        self._moveActive = true;
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_START);
      handler.setInputAction(function (movement) {
        self._moveHandler(movement);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].MOUSE_MOVE);
      handler.setInputAction(function (movement) {
        self._moveHandler(movement);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_MOVE);
      handler.setInputAction(function () {
        self._moveActive = false;
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_UP);
      handler.setInputAction(function () {
        self._moveActive = false;
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_END);
    }
  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.scene.splitPosition = 0.5;
      this._container.style.left = "50%";

      this._moveHandler();

      if (this.options.leftLayer) {
        this.leftLayer = this.options.leftLayer;
      }

      if (this.options.rightLayer) {
        this.rightLayer = this.options.rightLayer;
      }
    }
  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.scene.splitPosition = 0;
      this.leftLayer = null;
      this.rightLayer = null;
    }
  }, {
    key: "_moveHandler",
    value: function _moveHandler(movement) {
      if (!this._moveActive || !this.enabled) {
        return;
      }

      var relativeOffset = movement ? movement.endPosition.x : 0;
      var splitPosition = (this._container.offsetLeft + relativeOffset) / this._container.parentElement.offsetWidth;
      this._container.style.left = 100.0 * splitPosition + "%";
      this._map.scene.splitPosition = splitPosition;
    }
    /**
     * 对瓦片图层设置卷帘方向
     * @param {BaseTileLayer|GroupLayer} layer 图层
     * @param {Cesium.SplitDirection} splitDirection 图层显示的方向
     * @return {void}  无
     */

  }, {
    key: "setLayerSplitDirection",
    value: function setLayerSplitDirection(layer, splitDirection) {
      if (layer.hasChildLayer) {
        for (var i = 0; i < layer.arrLayer.length; i++) {
          var imageryLayer = layer.arrLayer[i].layer;

          if (imageryLayer) {
            imageryLayer.splitDirection = splitDirection;
          }
        }
      } else {
        var _imageryLayer = layer.layer;

        if (_imageryLayer) {
          _imageryLayer.splitDirection = splitDirection;
        }
      }
    }
  }]);

  return MapSplit;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/control/index.js
 //基类








// CONCATENATED MODULE: ./src/query/BaiduPOI.js




function BaiduPOI_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function BaiduPOI_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaiduPOI_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaiduPOI_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







/**
 * 百度 POI查询 工具类 ，
 * 参考文档： https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-placeapi
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String[]} [options.key = tudou3d.Token.baiduArr] 百度KEY,实际项目中请使用自己申请的百度KEY，因为我们的key不保证长期有效。
 * @param {String} [options.city = '全国' ] 限定查询的区域，支持城市及对应百度编码（Citycode）（指定的区域的返回结果加权，可能返回其他城市高权重结果。若要对返回结果区域严格限制，请使用city_limit参数）
 * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 * @export
 * @class BaiduPOI
 */

var BaiduPOI_BaiduPOI = /*#__PURE__*/function () {
  //构造方法
  function BaiduPOI() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, BaiduPOI);

    this._key_index = 0;
    this._keys = options.key || baiduArr;
    this._city = options.city || "全国"; //默认全国,可改为具体城市
  }
  /**
   * 百度key数组，内部轮询使用
   * @type {String[]}
   */


  createClass_default()(BaiduPOI, [{
    key: "keys",
    get: function get() {
      return this._keys;
    },
    set: function set(val) {
      this._keys = val;
    }
    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */

  }, {
    key: "key",
    get: function get() {
      var thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx];
    } //【内部】格式化返回的数据

  }, {
    key: "_formatPOIData",
    value: function _formatPOIData(arr) {
      var arrNew = [];

      for (var i = 0; i < arr.length; i++) {
        var _item$detail_info$tag, _item$detail_info, _item$detail_info2;

        var item = arr[i];
        var coor = [];

        if (item.location) {
          coor = Object(PointTrans["gcj2wgs"])([item.location.lng, item.location.lat]);
        } //坐标


        arrNew.push({
          id: item.uid,
          name: item.name,
          //名称
          lng: coor[0],
          lat: coor[1],
          type: (_item$detail_info$tag = (_item$detail_info = item.detail_info) === null || _item$detail_info === void 0 ? void 0 : _item$detail_info.tag) !== null && _item$detail_info$tag !== void 0 ? _item$detail_info$tag : item.tag,
          //类别
          xzqh: item.province + item.city + item.district,
          //行政区域
          address: item.address,
          //地址
          tel: item.telephone || "",
          detailUrl: (_item$detail_info2 = item.detail_info) === null || _item$detail_info2 === void 0 ? void 0 : _item$detail_info2.detail_url,
          //详情url
          info: item,
          //兼容老版本
          x: coor[0],
          y: coor[1],
          detail_info: item.detail_info
        });
      }

      return arrNew;
    }
  }, {
    key: "_getKeywords",
    value: function _getKeywords(text) {
      if (Object(Util["isString"])(text)) {
        return text.replace(new RegExp(" ", "gm"), "$").replace(new RegExp(",", "gm"), "$");
      } else if (Array.isArray(text)) {
        return text.join("$");
      }

      return text;
    }
    /**
     * 根据经纬度坐标获取地址，逆地理编码
     *
     * @param {Object} queryOptions 查询参数
     * @param {LatLngPoint} [queryOptions.location = null] 经纬度坐标
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "getAddress",
    value: function getAddress(queryOptions) {
      var _this = this;

      if (this._getAddress_ing) {
        //正在查询中，屏蔽下
        return;
      }

      var filter = {
        ak: this.key,
        //请求服务权限标识
        output: "json",
        language: "zh-CN",
        coordtype: "wgs84ll",
        ret_coordtype: "gcj02ll"
      };
      var point = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
      filter.location = point.lat + "," + point.lng; //40.04785,116.3135
      // console.log(filter)

      this._getAddress_ing = true;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJsonp(BaiduPOI_objectSpread(BaiduPOI_objectSpread({
        url: "http://api.map.baidu.com/reverse_geocoding/v3/"
      }, this.options), {}, {
        queryParameters: filter
      })).then(function (data) {
        _this._getAddress_ing = false;

        if (data.status != 0) {
          console.log("未查询到相关结果！");
          return;
        }

        if (queryOptions.success) {
          var info = data.result;
          queryOptions.success({
            address: info.formatted_address,
            city: info.cityCode,
            // info.addressComponent?.adcode,
            component: info.addressComponent
          });
        }
      })["catch"](function (error) {
        _this._getAddress_ing = false;
        Object(Log["logError"])("BaiduPOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 搜索提示查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 输入建议关键字（支持拼音）
     * @param {LatLngPoint} [queryOptions.location = null] 传入location参数后，返回结果将以距离进行排序
     * @param {String} [queryOptions.city = null] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "autoTip",
    value: function autoTip(queryOptions) {
      var _this2 = this;

      var filter = {
        ak: this.key,
        //请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll"
      };

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._city)) {
        filter.region = this._city;
        filter.city_limit = true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.city)) {
        filter.region = queryOptions.city;
        filter.city_limit = true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.citylimit)) {
        filter.city_limit = queryOptions.citylimit;
      }

      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      }

      if (queryOptions.location) {
        filter.coord_type = 1; //标识是WGS84ll即GPS经纬度

        var point = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; //40.04785,116.3135
      } // console.log(filter)


      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJsonp(BaiduPOI_objectSpread(BaiduPOI_objectSpread({
        url: "http://api.map.baidu.com/place/v2/suggestion"
      }, this.options), {}, {
        queryParameters: filter
      })).then(function (data) {
        if (data.status != 0) {
          console.log("未查询到相关结果！");
          return;
        }

        var arr = _this2._formatPOIData(data.result);

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.total,
            count: arr.length,
            list: arr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("BaiduPOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 关键字搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {Object} [queryOptions.location = null] 圆形区域检索中心点，不支持多个点
     * @param {Number} queryOptions.location.lat 纬度
     * @param {Number} queryOptions.location.lng 经度
     * @param {Number} [queryOptions.radius=null] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.radiuslimit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     * @param {String} [queryOptions.city = null] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回20条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "queryText",
    value: function queryText(queryOptions) {
      var _this3 = this;

      var filter = {
        ak: this.key,
        //请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll",
        scope: 2,
        //检索结果详细程度。取值为1 或空，则返回基本信息；取值为2，返回检索POI详细信息
        page_num: queryOptions.page || 0,
        page_size: queryOptions.count || 20,
        tag: queryOptions.types || ""
      };

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._city)) {
        filter.region = this._city;
        filter.city_limit = true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.city)) {
        filter.region = queryOptions.city;
        filter.city_limit = true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.citylimit)) {
        filter.city_limit = queryOptions.citylimit;
      }

      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      }

      if (queryOptions.location) {
        filter.coord_type = 1; //标识是WGS84ll即GPS经纬度

        var point = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; //40.04785,116.3135
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.radius)) {
        if (queryOptions.radius > 5000000) {
          delete filter.location;
        } else {
          filter.radius = queryOptions.radius;
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.radiuslimit)) {
          filter.radius_limit = queryOptions.radiuslimit;
        }
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJsonp(BaiduPOI_objectSpread(BaiduPOI_objectSpread({
        url: "http://api.map.baidu.com/place/v2/search"
      }, this.options), {}, {
        queryParameters: filter
      })).then(function (data) {
        if (data.status != 0) {
          var meg = "POI 请求失败(" + data.status + ")：" + data.message;

          if (queryOptions.error) {
            queryOptions.error(meg);
          }

          return;
        }

        if (!data.results || data.result_type == "city_type" || data.results.length == 0) {
          if (queryOptions._sendCount) {
            // console.log("未查询到相关结果！");
            if (queryOptions.success) {
              queryOptions.success({
                allcount: 0,
                count: 0,
                list: []
              });
            }
          } else {
            delete queryOptions.radius;
            delete queryOptions.location;
            queryOptions._sendCount = 1;

            _this3.queryText(queryOptions);
          }

          return;
        }

        var arr = _this3._formatPOIData(data.results);

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.total,
            count: arr.length,
            list: arr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("BaiduPOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 周边搜索(圆形搜索)
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {LatLngPoint} [queryOptions.location = null] 圆形区域检索中心点，取值范围:0-50000。规则：大于50000按默认值，单位：米
     * @param {Number} [queryOptions.radius=3000] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "queryCircle",
    value: function queryCircle(queryOptions) {
      var _this4 = this;

      var filter = {
        ak: this.key,
        //请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll",
        scope: 2,
        //检索结果详细程度。取值为1 或空，则返回基本信息；取值为2，返回检索POI详细信息
        radius: queryOptions.radius || 3000,
        radius_limit: queryOptions.limit,
        page_num: queryOptions.page || 0,
        page_size: queryOptions.count || 20,
        tag: queryOptions.types || ""
      }; //坐标构造 location

      if (queryOptions.location) {
        filter.coord_type = 1; //标识是WGS84ll即GPS经纬度

        var point = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; //40.04785,116.3135
      } else {
        Object(Log["logError"])("BaiduPOI: 请传入参location数");
      } //关键字构造


      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      } else {
        //无关键字时，指定类别
        filter.query = "行政地标";
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJsonp(BaiduPOI_objectSpread(BaiduPOI_objectSpread({
        url: "http://api.map.baidu.com/place/v2/search"
      }, this.options), {}, {
        queryParameters: filter
      })).then(function (data) {
        if (data.status != 0) {
          var meg = "POI 请求失败(" + data.status + ")：" + data.message;

          if (queryOptions.error) {
            queryOptions.error(meg);
          }

          return;
        }

        if (!data.results || data.result_type == "city_type" || data.results.length == 0) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var arr = _this4._formatPOIData(data.results);

        var resArr;

        if (queryOptions.limit) {
          resArr = _this4._filterPOIData_circle(arr, queryOptions.location, filter.radius);
        } else {
          resArr = arr;
        }

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.total,
            count: resArr.length,
            list: resArr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("BaiduPOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    } //圆形搜索筛选

  }, {
    key: "_filterPOIData_circle",
    value: function _filterPOIData_circle(arr, center, radius) {
      if (!arr || !center || !radius) {
        return arr;
      }

      center = center.toCartesian();
      var arrNew = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var c3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(item.x, item.y);
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(c3, center);

        if (distance < radius) {
          //表示在圆内
          arrNew.push(item);
        }
      }

      return arrNew;
    }
  }]);

  return BaiduPOI;
}();
// CONCATENATED MODULE: ./src/query/GaodePOI.js




function GaodePOI_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GaodePOI_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GaodePOI_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GaodePOI_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








/**
 * 高德 POI查询 工具类，
 * 参考文档： https://lbs.amap.com/api/webservice/guide/api/search
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String[]} [options.key = tudou3d.Token.gaodeArr] 百度KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
 * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 * @export
 * @class GaodePOI
 */

var GaodePOI_GaodePOI = /*#__PURE__*/function () {
  function GaodePOI() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GaodePOI);

    this._key_index = 0;
    this._keys = options.key || gaodeArr;
  }
  /**
   * 高德key数组，内部轮询使用
   * @type {String[]}
   */


  createClass_default()(GaodePOI, [{
    key: "keys",
    get: function get() {
      return this._keys;
    },
    set: function set(val) {
      this._keys = val;
    }
    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */

  }, {
    key: "key",
    get: function get() {
      var thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx];
    } //【内部】格式化返回的数据

  }, {
    key: "_formatPOIData",
    value: function _formatPOIData(arr) {
      var arrNew = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var coor = [];

        if (item.location && item.location.length > 0) {
          coor = Object(PointTrans["gcj2wgs"])(item.location.split(","));
        } //坐标


        arrNew.push({
          id: item.id,
          name: item.name,
          //名称
          lng: Number(coor[0]),
          lat: Number(coor[1]),
          type: item.type,
          //类别
          xzqh: item.pname + item.cityname + item.adname,
          //行政区域
          address: item.address,
          //地址
          tel: item.tel || "",
          info: item,
          // detailUrl: "https://www.amap.com/detail/" + item.id, //详情url
          //兼容老版本
          x: Number(coor[0]),
          y: Number(coor[1])
        });
      }

      return arrNew;
    }
  }, {
    key: "_getKeywords",
    value: function _getKeywords(text) {
      if (Object(Util["isString"])(text)) {
        return text.replace(new RegExp(" ", "gm"), "|").replace(new RegExp(",", "gm"), "|");
      } else if (Array.isArray(text)) {
        return text.join("|");
      }

      return text;
    }
    /**
     * 根据经纬度坐标获取地址，逆地理编码
     *
     * @param {Object} queryOptions 查询参数
     * @param {LatLngPoint} [queryOptions.location = null] 经纬度坐标
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "getAddress",
    value: function getAddress(queryOptions) {
      var _this = this;

      if (this._getAddress_ing) {
        //正在查询中，屏蔽下
        return;
      }

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json"
      };
      queryOptions.location = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
      var cartg = Object(PointTrans["wgs2gcj"])([queryOptions.location.lng, queryOptions.location.lat]);
      filter.location = cartg[0] + "," + cartg[1]; // console.log(filter)

      this._getAddress_ing = true;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJsonp(GaodePOI_objectSpread(GaodePOI_objectSpread({
        url: "https://restapi.amap.com/v3/geocode/regeo"
      }, this.options), {}, {
        queryParameters: filter
      })).then(function (data) {
        _this._getAddress_ing = false;

        if (data.infocode != "10000") {
          console.log("未查询到相关结果！");
          return;
        }

        if (queryOptions.success) {
          var _info$addressComponen;

          var info = data.regeocode;
          queryOptions.success({
            address: info.formatted_address,
            city: (_info$addressComponen = info.addressComponent) === null || _info$addressComponen === void 0 ? void 0 : _info$addressComponen.adcode,
            component: info.addressComponent
          });
        }
      })["catch"](function (error) {
        _this._getAddress_ing = false;
        Object(Log["logError"])("BaiduPOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 高德搜索提示
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 输入建议关键字（支持拼音）
     * @param {LatLngPoint} [queryOptions.location = null] 建议使用location参数，可在此location附近优先返回搜索关键词信息,在请求参数city不为空时生效
     * @param {String} [queryOptions.city = null] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "autoTip",
    value: function autoTip(queryOptions) {
      var _this2 = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json"
      };

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.city)) {
        filter.city = queryOptions.city;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.citylimit)) {
        filter.citylimit = queryOptions.citylimit;
      }

      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        //无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      if (queryOptions.location) {
        queryOptions.location = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
        var cartg = Object(PointTrans["wgs2gcj"])([queryOptions.location.lng, queryOptions.location.lat]);
        filter.location = cartg[0] + "," + cartg[1];
      } // console.log(filter)


      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodePOI_objectSpread({
        url: "https://restapi.amap.com/v3/assistant/inputtips",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (!data.tips) {
          console.log("未查询到相关结果！");
          return;
        }

        var arr = _this2._formatPOIData(data.tips);

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.count,
            count: arr.length,
            list: arr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodePOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 按限定区域搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     *
     * @param {BaseGraphic} [queryOptions.graphic] 限定的搜索区域
     * @param {Boolean} [queryOptions.limit = false] 取值为"true"，严格返回限定区域内检索结果
     *
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，默认为10条记录，最大返回20条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "query",
    value: function query(queryOptions) {
      var graphic = queryOptions.graphic;

      if (graphic) {
        if (graphic.type == "rectangle") {
          queryOptions.polygon = graphic.outlineCoordinates;
          this.queryPolygon(queryOptions);
        } else if (graphic.type == "polygon") {
          queryOptions.polygon = graphic.coordinates;
          this.queryPolygon(queryOptions);
        } else if (graphic.type == "circle") {
          queryOptions.location = graphic.point;
          queryOptions.radius = graphic.radius;
          this.queryCircle(queryOptions);
        }
      } else if (queryOptions.polygon) {
        this.queryPolygon(queryOptions);
      } else {
        this.queryText(queryOptions);
      }

      return this;
    }
    /**
     * 关键字搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {String} [queryOptions.city = null] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "queryText",
    value: function queryText(queryOptions) {
      var _this3 = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json",
        page: queryOptions.page || 1,
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      };

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.city)) {
        filter.city = queryOptions.city;
        filter.citylimit = true;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](queryOptions.citylimit)) {
        filter.citylimit = queryOptions.citylimit;
      } //关键字构造


      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        //无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodePOI_objectSpread({
        url: "https://restapi.amap.com/v3/place/text",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          var meg = "POI 请求失败(" + data.infocode + ")：" + data.info;

          if (queryOptions.error) {
            queryOptions.error(meg);
          }

          return;
        }

        if (!data.pois) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var arr = _this3._formatPOIData(data.pois);

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.count,
            count: arr.length,
            list: arr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodePOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    }
    /**
     * 周边搜索(圆形搜索)
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {LatLngPoint} [queryOptions.location = null] 圆形区域检索中心点，取值范围:0-50000。规则：大于50000按默认值，单位：米
     * @param {Number} [queryOptions.radius=3000] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "queryCircle",
    value: function queryCircle(queryOptions) {
      var _this4 = this;

      var filter = {
        output: "json",
        key: this.key,
        //请求服务权限标识
        radius: queryOptions.radius || 3000,
        page: queryOptions.page || 1,
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      }; //坐标构造 location

      if (queryOptions.location) {
        queryOptions.location = LatLngPoint["a" /* LatLngPoint */].parse(queryOptions.location);
        var cartg = Object(PointTrans["wgs2gcj"])([queryOptions.location.lng, queryOptions.location.lat]);
        filter.location = cartg[0] + "," + cartg[1];
      } else {
        Object(Log["logError"])("GaodePOI: 请传入参location数");
      } //关键字构造


      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        //无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodePOI_objectSpread({
        url: "https://restapi.amap.com/v3/place/around",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          if (queryOptions.error) {
            var msg = "POI 请求失败(" + data.infocode + ")：" + data.info;
            queryOptions.error(msg);
          }

          return;
        }

        if (!data.pois) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var arr = _this4._formatPOIData(data.pois);

        var resArr;

        if (queryOptions.limit) {
          resArr = _this4._filterPOIData_circle(arr, queryOptions.location, filter.radius);
        } else {
          resArr = arr;
        }

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.count,
            count: resArr.length,
            list: resArr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodePOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    } //圆形搜索筛选

  }, {
    key: "_filterPOIData_circle",
    value: function _filterPOIData_circle(arr, center, radius) {
      if (!arr || !center || !radius) {
        return arr;
      }

      center = center.toCartesian();
      var arrNew = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var c3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(item.x, item.y);
        var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(c3, center);

        if (distance < radius) {
          //表示在圆内
          arrNew.push(item);
        }
      }

      return arrNew;
    }
    /**
     * 多边形搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {Array[]} queryOptions.polygon  经纬度数组，经纬度小数点后不得超过6位。多边形为矩形时，可传入左上右下两顶点坐标对；其他情况下首尾坐标对需相同。
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索的多边形或矩形范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "queryPolygon",
    value: function queryPolygon(queryOptions) {
      var _this5 = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json",
        page: queryOptions.page || 1,
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      }; //坐标构造 polygon

      var coors = queryOptions.polygon;
      var coorArr = [];

      if (coors.length == 2) {
        //矩形
        var cartg1 = Object(PointTrans["wgs2gcj"])(coors[0]);
        var cartg2 = Object(PointTrans["wgs2gcj"])(coors[1]);
        filter.polygon = cartg1[0] + "," + cartg1[1] + "|" + cartg2[0] + "," + cartg2[1];
        coorArr = [coors[0], [coors[0][0], coors[1][1]], coors[1], [coors[1][0], coors[0][1]]];
      } else {
        //多边形
        coorArr = coors;
        var polygon = "";
        var newCoors = coors.concat([coors[coors.length - 1]]);

        for (var i = 0; i < newCoors.length; i++) {
          var cartg = Object(PointTrans["wgs2gcj"])(newCoors[i]);

          if (i == newCoors.length - 1) {
            polygon += cartg[0] + "," + cartg[1];
          } else {
            polygon += cartg[0] + "," + cartg[1] + "|";
          }
        }

        filter.polygon = polygon;
      } //关键字构造


      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        //无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodePOI_objectSpread({
        url: "https://restapi.amap.com/v3/place/polygon",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          if (queryOptions.error) {
            var msg = "POI 请求失败(" + data.infocode + ")：" + data.info;
            queryOptions.error(msg);
          }

          return;
        }

        if (!data.pois) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var arr = _this5._formatPOIData(data.pois);

        var resArr;

        if (queryOptions.limit) {
          resArr = _this5._filterPOIData_polygon(arr, coorArr);
        } else {
          resArr = arr;
        }

        if (queryOptions.success) {
          queryOptions.success({
            allcount: data.count,
            count: resArr.length,
            list: resArr
          });
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodePOI 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
      return this;
    } //多边形与矩形的二次筛选

  }, {
    key: "_filterPOIData_polygon",
    value: function _filterPOIData_polygon(arr, coors) {
      if (!arr || !coors) {
        return;
      } //判断tur库是否存在 start


      try {
        if (!turf_root_turf_["booleanPointInPolygon"]) {
          throw new Error("turf不存在");
        }
      } catch (e) {
        Object(Log["logError"])("GaodePOI：该方法依赖turf库，请引入该库。", e);
        return arr;
      } //判断tur库是否存在 end


      coors = coors.concat([coors[0]]);
      var turfPolygon = {
        type: "Polygon",
        coordinates: [coors]
      };
      var arrNew = [];

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var turfPoint = {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [item.x, item.y]
          }
        };

        if (Object(turf_root_turf_["booleanPointInPolygon"])(turfPoint, turfPolygon)) {
          arrNew.push(item);
        }
      }

      return arrNew;
    }
  }]);

  return GaodePOI;
}();
// CONCATENATED MODULE: ./src/query/GaodeRoute.js




function GaodeRoute_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GaodeRoute_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GaodeRoute_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GaodeRoute_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var RouteType = {
  Walking: 1,
  //步行
  Bicycling: 2,
  //骑行
  Driving: 3 //驾车

};
/**
 * 高德 路径规划  工具类，
 * 参考文档：https://lbs.amap.com/api/webservice/guide/api/direction
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String[]} [options.key = tudou3d.Token.gaodeArr] 百度KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
 * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 *
 * @export
 * @class GaodeRoute
 */

var GaodeRoute_GaodeRoute = /*#__PURE__*/function () {
  function GaodeRoute() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GaodeRoute);

    this._key_index = 0;
    this._keys = opts.key || gaodeArr;
  }
  /**
   * 高德key数组，内部轮询使用
   * @type {String[]}
   */


  createClass_default()(GaodeRoute, [{
    key: "keys",
    get: function get() {
      return this._keys;
    },
    set: function set(val) {
      this._keys = val;
    }
    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */

  }, {
    key: "key",
    get: function get() {
      var thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx];
    } //【内部】格式化返回的数据

  }, {
    key: "_formatRouteData",
    value: function _formatRouteData(start, end, resultPaths) {
      var wgs_origin, wgs_destination;
      var paths = [];

      if (start) {
        wgs_origin = Object(PointTrans["gcj2wgs"])(start.split(","));
      }

      if (end) {
        wgs_destination = Object(PointTrans["gcj2wgs"])(end.split(","));
      }

      if (resultPaths && resultPaths.length > 0) {
        for (var i = 0; i < resultPaths.length; i++) {
          var route = [];
          route.push(wgs_origin); //连接起点

          var item = resultPaths[i];
          var steps = item.steps;
          var newSteps = [];
          var roadInfo = []; //途径地方

          for (var index = 0; index < steps.length; index++) {
            var obj = {
              instruction: steps[index].instruction,
              //路段步行指示
              distance: steps[index].distance,
              //路段距离 米
              duration: steps[index].duration,
              //路段预计时间 秒
              points: [],
              route: steps[index].road
            };
            var polyline = steps[index].polyline;
            var polylineArr = polyline.split(";");

            for (var ind = 0; ind < polylineArr.length; ind++) {
              var one = polylineArr[ind];
              var wgs = Object(PointTrans["gcj2wgs"])(one.split(","));
              route.push(wgs);
              obj.points.push(wgs);
            }

            roadInfo.push(obj.route);
            newSteps.push(obj);
          }

          route.push(wgs_destination); //连接终点

          paths.push({
            allDistance: item.distance,
            //总距离
            allDuration: item.duration,
            //全部所需时间
            steps: newSteps,
            //每一段的数据
            points: route,
            //包含起点和终点的 完整路径的wgs84坐标数组
            road: roadInfo
          });
        }
      }

      return {
        origin: wgs_origin,
        //起点
        destination: wgs_destination,
        //终点
        paths: paths //所有方案

      };
    }
    /**
     * 按指定类别自动查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {GaodeRoute.RouteType} queryOptions.type 类型
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "query",
    value: function query(queryOptions) {
      switch (queryOptions.type) {
        default:
        case RouteType.Walking:
          //步行
          this.queryWalking(queryOptions);
          break;

        case RouteType.Bicycling:
          //骑行
          this.queryBicycling(queryOptions);
          break;

        case RouteType.Driving:
          //驾车
          this.queryDriving(queryOptions);
          break;
      }

      return this;
    }
    /**
     * 按指定类别自动查询(多个路线数组，递归处理)
     *
     * @param {Object} queryOptions 查询参数
     * @param {GaodeRoute.RouteType} queryOptions.type 类型
     * @param {Array[]} queryOptions.points 多条，按起点终点 顺序的坐标数组,如[
     *  [ [117.500244, 40.417801],[117.500244, 40.417801] ],
     *  [ [117.500244, 40.417801],[117.500244, 40.417801] ]
     * ]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {void}  无
     */

  }, {
    key: "queryArr",
    value: function queryArr(queryOptions) {
      var that = this;
      var index = -1;
      var newOpts = {};

      for (var key in queryOptions) {
        if (key == "points" || key == "success" || key == "error") {
          continue;
        }

        newOpts[key] = queryOptions[key];
      }

      var arrPoints = queryOptions.points;
      var arrResult = [];

      function queryNextLine() {
        index++;
        newOpts.points = arrPoints[index];

        newOpts.success = function (data) {
          if (data && data.paths && data.paths.length > 0) {
            arrResult.push(data.paths[0]);
          } else {
            arrResult.push(null);
          }

          if (index >= arrPoints.length - 1) {
            if (queryOptions.success) {
              queryOptions.success(arrResult);
            }
          } else {
            queryNextLine();
          }
        };

        newOpts.error = newOpts.success;
        that.query(newOpts);
      }

      queryNextLine();
    }
    /**
     * 计算结果中的最短距离的导航路径
     *
     * @param {Object[]} data queryArr返回的结果数组
     * @return {Object} 返回路线数据和index顺序
     */

  }, {
    key: "getShortestPath",
    value: function getShortestPath(data) {
      var mindis = Number.MAX_VALUE;
      var lineData = null;
      var index = -1;

      for (var i = 0; i < data.length; i++) {
        var item = data[i];

        if (item) {
          if (item.allDistance <= mindis) {
            lineData = item;
            index = i;
            mindis = item.allDistance;
          }
        }
      }

      return {
        lineData: lineData,
        index: index
      };
    }
    /**
     * 步行路径规划 (单个查询)
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {void}  无
     */

  }, {
    key: "queryWalking",
    value: function queryWalking(queryOptions) {
      var _this = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json"
      }; //坐标构造

      var startP = Object(PointTrans["wgs2gcj"])(queryOptions.points[0]);
      var endP = Object(PointTrans["wgs2gcj"])(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1];
      filter.destination = endP[0] + "," + endP[1];
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodeRoute_objectSpread({
        url: "http://restapi.amap.com/v3/direction/walking",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          if (queryOptions.error) {
            var msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;
            queryOptions.error(msg);
          }

          return;
        }

        if (!data.route || !data.route.paths) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var result = _this._formatRouteData(filter.origin, filter.destination, data.route.paths);

        if (queryOptions.success) {
          queryOptions.success(result);
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodeRoute 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
    }
    /**
     * 骑行路径查询 (单个查询)
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {void}  无
     */

  }, {
    key: "queryBicycling",
    value: function queryBicycling(queryOptions) {
      var _this2 = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json"
      };
      var startP = Object(PointTrans["wgs2gcj"])(queryOptions.points[0]);
      var endP = Object(PointTrans["wgs2gcj"])(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1];
      filter.destination = endP[0] + "," + endP[1];
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodeRoute_objectSpread({
        url: "https://restapi.amap.com/v4/direction/bicycling",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          var msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;

          if (queryOptions.error) {
            queryOptions.error(msg);
          }

          return;
        }

        if (!data.route || !data.route.paths) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var result = _this2._formatRouteData(filter.origin, filter.destination, data.route.paths);

        if (queryOptions.success) {
          queryOptions.success(result);
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodeRoute 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
    }
    /**
     * 驾车路径规划查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、途经点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     * @param {Array[]} queryOptions.avoidpolygons 区域避让数组(支持多个)，支持32个避让区域，每个区域最多可有16个顶点。避让区域不能超过81平方公里，否则避让区域会失效。
     *
     * @param {String} [queryOptions.extensions='base'] 返回结果控制,可选值：core/all  base:返回基本信息；all：返回全部信息
     * @param {String} [queryOptions.strategy=0] 驾车选择策略，参考高德官网说明，默认为0：速度优先，不考虑当时路况，此路线不一定距离最短
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {void}  无
     */

  }, {
    key: "queryDriving",
    value: function queryDriving(queryOptions) {
      var _queryOptions$avoidpo,
          _this3 = this;

      var filter = {
        key: this.key,
        //请求服务权限标识
        output: "json",
        extensions: queryOptions.extensions || "base",
        strategy: queryOptions.strategy || 0 //0 返回一条速度优先的路径

      };
      var startP = Object(PointTrans["wgs2gcj"])(queryOptions.points[0]);
      var endP = Object(PointTrans["wgs2gcj"])(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1]; //出发点

      filter.destination = endP[0] + "," + endP[1]; //目的地

      if (queryOptions.points.length > 2) {
        var waypoints = "";

        for (var i = 1, len = queryOptions.points.length - 1; i < len; i++) {
          var item = Object(PointTrans["wgs2gcj"])(queryOptions.points[i]);
          waypoints += item[0] + "," + item[1] + ";";
        }

        filter.waypoints = waypoints; //途经点
      }

      if (((_queryOptions$avoidpo = queryOptions.avoidpolygons) === null || _queryOptions$avoidpo === void 0 ? void 0 : _queryOptions$avoidpo.length) > 0) {
        var avoidpolygons = ""; //坐标点之间用";"分隔，区域之间用"|"分隔。

        for (var k = 0, _len = queryOptions.avoidpolygons.length; k < _len; k++) {
          if (k > 0) {
            avoidpolygons += "|"; //区域之间用"|"分隔。
          }

          var _item = queryOptions.avoidpolygons[k];

          for (var j = 0, len2 = _item.length; j < len2; j++) {
            var item2 = Object(PointTrans["wgs2gcj"])(_item[j]);
            avoidpolygons += item2[0] + "," + item2[1] + ";"; //坐标点之间用";"分隔
          }
        }

        filter.avoidpolygons = avoidpolygons; //区域避让
      }

      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(GaodeRoute_objectSpread({
        url: "https://restapi.amap.com/v3/direction/driving",
        queryParameters: filter
      }, this.options)).then(function (data) {
        if (data.infocode != "10000") {
          if (queryOptions.error) {
            var msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;
            queryOptions.error(msg);
          }

          return;
        }

        if (!data.route || !data.route.paths || data.route.paths.length == 0) {
          if (queryOptions.error) {
            queryOptions.error("未查询到相关结果！");
          }

          return;
        }

        var result = _this3._formatRouteData(filter.origin, filter.destination, data.route.paths);

        if (queryOptions.success) {
          queryOptions.success(result);
        }
      })["catch"](function (error) {
        Object(Log["logError"])("GaodeRoute 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
    }
  }]);

  return GaodeRoute;
}();
/**
 * 路径规划方式
 * @property {Number} 	Walking 步行
 * @property {Number} 	Bicycling 骑行
 * @property {Number} 	Driving 驾车
 * @enum
 */

GaodeRoute_GaodeRoute.RouteType = RouteType;
// CONCATENATED MODULE: ./src/query/QueryGeoServer.js







function QueryGeoServer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function QueryGeoServer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { QueryGeoServer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { QueryGeoServer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function QueryGeoServer_createSuper(Derived) { var hasNativeReflectConstruct = QueryGeoServer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function QueryGeoServer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var Def_Parameters = {
  service: "WFS",
  request: "GetFeature",
  version: "1.0.0",
  outputFormat: "application/json",
  maxFeatures: 1000
};
/**
 * GeoServer WFS服务查询类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String} options.layer 图层名称（命名空间:图层名称），多个图层名称用逗号隔开
 * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 * @param {*} [options.图层参数] layer属性获取的图层对应的构造参数，参考{@link GeoJsonLayer}
 *
 * @export
 * @class QueryGeoServer
 * @extends {BaseClass}
 */

var QueryGeoServer_QueryGeoServer = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(QueryGeoServer, _BaseClass);

  var _super = QueryGeoServer_createSuper(QueryGeoServer);

  function QueryGeoServer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, QueryGeoServer);

    _this = _super.call(this, options);
    _this.options = options;
    _this.name = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.name, "");
    return _this;
  }
  /**
   * 用于显示查询结果的GeoJsonLayer图层，图层参数在当前类构造方法中传入
   * @type {GeoJsonLayer}
   * @readonly
   */


  createClass_default()(QueryGeoServer, [{
    key: "layer",
    get: function get() {
      if (!this._geoJsonLayer) {
        var layerOptions = QueryGeoServer_objectSpread({
          popup: "all"
        }, this.options);

        delete layerOptions.url;
        delete layerOptions.data;
        this._geoJsonLayer = new GeoJsonLayer_GeoJsonLayer(layerOptions);

        this._geoJsonLayer.on(EventType.load, this.geoJsonLayer_onLoadHandler, this);

        this._geoJsonLayer.on(EventType.click, this.geoJsonLayer_onClickHandler, this);
      }

      return this._geoJsonLayer;
    }
    /**
     * 按指定类别自动查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} [queryOptions.text] 检索关键字。
     * @param {String} [queryOptions.column] 检索关键字的属性名称(PropertyName)。
     * @param {Boolean} [queryOptions.like=true] 检索关键字时，是否模糊匹配，false时精确查询。
     * @param {BaseGraphic} [queryOptions.graphic] 限定的搜索区域
     * @param {String} [queryOptions.geoColumn='the_geom'] 搜索区域的属性名称(PropertyName)。
     * @param {Number} [queryOptions.maxFeatures=1000] 最多返回结果个数
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "query",
    value: function query(queryOptions) {
      var _this2 = this;

      //请求的wfs参数
      var filter = '<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><And>'; //关键字

      if (queryOptions.text) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](queryOptions.like, true)) {
          filter += " <PropertyIsLike wildCard=\"*\" singleChar=\"#\" escapeChar=\"!\">\n            <PropertyName>".concat(queryOptions.column, "</PropertyName>\n            <Literal>*").concat(queryOptions.text, "*</Literal>\n        </PropertyIsLike>");
        } else {
          filter += " <PropertyIsLike wildCard=\"*\" singleChar=\"#\" escapeChar=\"!\">\n            <PropertyName>".concat(queryOptions.column, "</PropertyName>\n            <Literal>").concat(queryOptions.text, "</Literal>\n        </PropertyIsLike>");
        }
      } //限定区域范围


      if (queryOptions.graphic) {
        var graphic = queryOptions.graphic;
        var coordinates;

        if (graphic.type == "rectangle") {
          coordinates = graphic.outlineCoordinates;
        } else if (graphic.type == "polygon") {
          coordinates = graphic.coordinates;
        } else if (graphic.type == "circle") {
          coordinates = graphic.getOutlineCoordinates(true, 30);
        } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.xmax) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.xmin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.ymin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.ymax)) {
          coordinates = [[graphic.xmin, graphic.ymax], [graphic.xmin, graphic.ymin], [graphic.xmax, graphic.ymin], [graphic.xmax, graphic.ymax]];
        }

        if (coordinates) {
          coordinates.push(coordinates[0]);
          var polygon = "";

          for (var i = 0; i < coordinates.length; i++) {
            polygon += coordinates[i][0] + "," + coordinates[i][1] + " ";
          }

          filter += "<Intersects>\n                      <PropertyName>".concat(queryOptions.geoColumn || "the_geom", "</PropertyName>\n                      <gml:Polygon>\n                          <gml:outerBoundaryIs>\n                              <gml:LinearRing>\n                                  <gml:coordinates>").concat(polygon, "</gml:coordinates>\n                              </gml:LinearRing>\n                          </gml:outerBoundaryIs>\n                      </gml:Polygon>\n                  </Intersects>");
        }
      }

      filter += "</And></Filter>"; //请求参数

      var parameters = QueryGeoServer_objectSpread(QueryGeoServer_objectSpread(QueryGeoServer_objectSpread({}, Def_Parameters), queryOptions), {}, {
        typeName: this.options.layer,
        filter: filter
      });

      delete parameters.graphic;
      delete parameters.success;
      delete parameters.error;
      delete parameters.text;
      delete parameters.column;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(QueryGeoServer_objectSpread(QueryGeoServer_objectSpread({}, this.options), {}, {
        queryParameters: parameters
      })).then(function (featureCollection) {
        _this2.processFeatureCollection(featureCollection, queryOptions);
      })["catch"](function (error) {
        Object(Log["logError"])("QueryGeoServer 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error("请求出错", error);
        }
      });
    }
  }, {
    key: "processFeatureCollection",
    value: function processFeatureCollection(featureCollection, queryOptions) {
      if (featureCollection && featureCollection.type == "Feature") {
        featureCollection = {
          type: "FeatureCollection",
          features: [featureCollection]
        };
      }

      if (featureCollection == undefined || featureCollection == null || featureCollection.features == null || featureCollection.features.length == 0) {
        if (queryOptions.success) {
          queryOptions.success({
            count: 0
          });
        }
      } else {
        //剔除有问题数据
        var featuresOK = [];

        for (var i = 0; i < featureCollection.features.length; i++) {
          var feature = featureCollection.features[i];

          if (feature == null || feature.geometry == null || feature.geometry.coordinates == null || feature.geometry.coordinates.length == 0) {
            continue;
          }

          featuresOK.push(feature);
        }

        featureCollection.features = featuresOK;

        if (this._geoJsonLayer) {
          this._last_success = function (list) {
            if (queryOptions.success) {
              queryOptions.success({
                geojson: featureCollection,
                count: featureCollection.features.length,
                list: list
              });
            }
          };

          this._geoJsonLayer.load({
            data: featureCollection
          });
        } else {
          if (queryOptions.success) {
            queryOptions.success({
              geojson: featureCollection,
              count: featureCollection.features.length
            });
          }
        }
      }
    }
  }, {
    key: "geoJsonLayer_onLoadHandler",
    value: function geoJsonLayer_onLoadHandler(event) {
      if (this._last_success) {
        this._last_success(event.list);

        this._last_success = null;
      }

      this.fire(EventType.load, event);
    }
  }, {
    key: "geoJsonLayer_onClickHandler",
    value: function geoJsonLayer_onClickHandler(event) {
      this.fire(EventType.click, QueryGeoServer_objectSpread(QueryGeoServer_objectSpread({}, event), {}, {
        layer: this._geoJsonLayer
      }));
    }
    /**
     * 清除
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this._last_success) {
        this._last_success = null;
      }

      if (this._geoJsonLayer) {
        this._geoJsonLayer.clear();
      }
    }
  }]);

  return QueryGeoServer;
}(BaseClass_BaseClass);
// CONCATENATED MODULE: ./src/query/QueryArcServer.js







function QueryArcServer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function QueryArcServer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { QueryArcServer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { QueryArcServer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function QueryArcServer_createSuper(Derived) { var hasNativeReflectConstruct = QueryArcServer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function QueryArcServer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }







/**
 * @typedef {Object} QueryArcServer.EventType
 * 当前类支持的{@link EventType}事件类型
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} load 完成加载，执行所有内部处理后
 *
 * @example
 * //绑定监听事件
 * layer.on(tudou3d.EventType.load, function (event) {
 *   console.log('矢量数据对象加载完成', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */

/**
 * ArcGIS WFS矢量服务查询类
 *
 * @param {Object} options 参数对象，包括以下：
 * @param {String} options.url ArcGIS服务地址, 示例：'http://server.tudou3d.cn/arcgis/rest/services/tudou/hefei/MapServer/37', *
 * @param {Number} [options.pageSize=10] 每页条数 *
 * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
 * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
 * @param {*} [options.图层参数] layer属性获取的图层对应的构造参数，参考{@link GeoJsonLayer}
 *
 * @export
 * @class QueryArcServer
 * @extends {BaseClass}
 * @see [支持的事件类型]{@link QueryArcServer.EventType}
 */

var QueryArcServer_QueryArcServer = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(QueryArcServer, _BaseClass);

  var _super = QueryArcServer_createSuper(QueryArcServer);

  function QueryArcServer() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, QueryArcServer);

    _this = _super.call(this, options);
    _this.options = options;
    _this.name = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.name, "");
    _this._pageSize = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.pageSize, 10); // 每页条数

    _this._allCount = 0; //总记录数

    _this._allPage = 0; //总页数

    _this._pageIndex = 1; //当前第几页

    _this.arrIDS = [];
    return _this;
  } //========== 对外属性 =========

  /**
   * ArcGIS服务地址
   * @type {String}
   */


  createClass_default()(QueryArcServer, [{
    key: "url",
    get: function get() {
      return this.options.url;
    },
    set: function set(val) {
      this.options.url = val;
    }
    /**
     * 分页的 每页条数
     * @type {Number}
     */

  }, {
    key: "pageSize",
    get: function get() {
      return this._pageSize;
    },
    set: function set(val) {
      this._pageSize = val;
    }
    /**
     * 总记录数
     * @type {Number}
     * @readonly
     */

  }, {
    key: "allCount",
    get: function get() {
      return this._allCount;
    }
    /**
     * 总页数
     * @type {Number}
     * @readonly
     */

  }, {
    key: "allPage",
    get: function get() {
      return this._allPage;
    }
    /**
     * 页码，当前第几页
     * @type {Number}
     * @readonly
     */

  }, {
    key: "pageIndex",
    get: function get() {
      return this._pageIndex;
    },
    set: function set(val) {
      this._pageIndex = val;
      this.showPage(val);
    }
    /**
     * 用于显示查询结果的GeoJsonLayer图层，图层参数在当前类构造方法中传入
     * @type {GeoJsonLayer}
     * @readonly
     */

  }, {
    key: "layer",
    get: function get() {
      if (!this._geoJsonLayer) {
        var layerOptions = QueryArcServer_objectSpread({
          popup: "all"
        }, this.options);

        delete layerOptions.url;
        delete layerOptions.data;
        this._geoJsonLayer = new GeoJsonLayer_GeoJsonLayer(layerOptions);

        this._geoJsonLayer.on(EventType.load, this.geoJsonLayer_onLoadHandler, this);

        this._geoJsonLayer.on(EventType.click, this.geoJsonLayer_onClickHandler, this);
      }

      return this._geoJsonLayer;
    } //========== 方法 ==========

    /**
     * 首页，查看第1页数据
     * @return {void}  无
     */

  }, {
    key: "showFirstPage",
    value: function showFirstPage() {
      this.showPage(1);
    }
    /**
     * 上一页
     * @return {void}  无
     */

  }, {
    key: "showPretPage",
    value: function showPretPage() {
      this._pageIndex = this._pageIndex - 1;

      if (this._pageIndex < 1) {
        this._pageIndex = 1;
      }

      this.showPage(this._pageIndex);
    }
    /**
     * 下一页
     * @return {void}  无
     */

  }, {
    key: "showNextPage",
    value: function showNextPage() {
      this._pageIndex = this._pageIndex + 1;

      if (this._pageIndex > this.allPage) {
        this._pageIndex = this.allPage;
      }

      this.showPage(this._pageIndex);
    }
    /**
     * 跳转到指定页
     * @param {Number} pageIndex 指定页
     * @return {void}  无
     */

  }, {
    key: "showPage",
    value: function showPage(pageIndex) {
      this._pageIndex = pageIndex;

      this._queryPageByIds();
    }
    /**
     * 按指定类别自动查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} [queryOptions.text] 检索关键字。
     * @param {String} [queryOptions.column] 检索关键字的字段名称。
     * @param {Boolean} [queryOptions.like=true] 检索关键字时，是否模糊匹配，false时精确查询。
     * @param {String} [queryOptions.where] 自定义的检索条件，与text二选一
     * @param {BaseGraphic} [queryOptions.graphic] 限定的搜索区域
     * @param {Boolean} [queryOptions.page=true] 是否分页查询,false时不分页，一次性查询返回
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "query",
    value: function query(queryOptions) {
      var _this2 = this;

      this._pageIndex = 1;
      this.arrIDS = []; //请求的wfs参数

      var parameters = {
        f: "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: queryOptions.where || "1=1"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      } //查询关键字


      if (queryOptions.column) {
        var where = "";

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](queryOptions.like, true)) {
          // 根据关键字进行查询
          where = queryOptions.column + "  like '%" + queryOptions.text + "%' ";
        } else {
          //根据某个属性类别进行查询
          where = queryOptions.column + "='" + queryOptions.text + "'";
        }

        parameters.where = where;
      } //限定范围


      if (queryOptions.graphic) {
        var graphic = queryOptions.graphic;
        parameters.spatialRel = "esriSpatialRelIntersects"; //包含或交叉关系

        if (graphic.type === "rectangle") {
          var coor = graphic.outlineCoordinates;
          parameters.geometryType = "esriGeometryEnvelope"; //矩形边界

          parameters.geometry = JSON.stringify({
            xmin: coor[0][0],
            ymin: coor[0][1],
            xmax: coor[2][0],
            ymax: coor[2][1],
            spatialReference: {
              wkid: 4326
            }
          });
        } else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.xmax) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.xmin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.ymin) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](graphic.ymax)) {
          parameters.geometryType = "esriGeometryEnvelope"; //矩形边界

          parameters.geometry = JSON.stringify({
            xmin: graphic.xmin,
            ymin: graphic.ymin,
            xmax: graphic.xmax,
            ymax: graphic.ymax,
            spatialReference: {
              wkid: 4326
            }
          });
        } else {
          var geojson;

          if (graphic.type === "polygon") {
            geojson = graphic.toGeoJSON();
          } else if (graphic.type === "circle") {
            geojson = {
              type: "Feature",
              geometry: {
                type: "Polygon",
                coordinates: [graphic.outlineCoordinates]
              }
            };
          } else {
            //geojson
            geojson = queryOptions.graphic;
          }

          parameters.geometry = JSON.stringify(Object(t_arcgis_esm["b" /* geojsonToArcGIS */])(geojson.geometry));
          parameters.geometryType = geojsonTypeToArcGIS(geojson.geometry.type);
        }
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](queryOptions.page, true)) {
        //分页
        parameters.returnIdsOnly = true; //只返回id

        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(QueryArcServer_objectSpread(QueryArcServer_objectSpread({}, this.options), {}, {
          url: this.url + "/query",
          queryParameters: parameters
        })).then(function (result) {
          var arrIDS = result.objectIds;

          if (arrIDS) {
            _this2.arrIDS = arrIDS;
            _this2._allCount = arrIDS.length; //总记录数

            _this2._allPage = Math.ceil(_this2._allCount / _this2._pageSize); //总页数
          }

          delete parameters.returnIdsOnly;

          _this2._queryPageByIds(parameters, queryOptions);
        })["catch"](function (error) {
          Object(Log["logError"])("QueryArcServer 请求出错", error);

          if (queryOptions.error) {
            queryOptions.error(error, error.message);
          }
        });
      } else {
        //不分页
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(QueryArcServer_objectSpread(QueryArcServer_objectSpread({}, this.options), {}, {
          url: this.url + "/query",
          queryParameters: parameters
        })).then(function (result) {
          var featureCollection = Object(t_arcgis_esm["a" /* arcgisToGeoJSON */])(result);

          _this2.processFeatureCollection(featureCollection, queryOptions);
        })["catch"](function (error) {
          Object(Log["logError"])("QueryArcServer 请求出错", error);

          if (queryOptions.error) {
            queryOptions.error(error, error.message);
          }
        });
      }
    } //根据id数组，进行单页查询数据

  }, {
    key: "_queryPageByIds",
    value: function _queryPageByIds(parameters, queryOptions) {
      var _this3 = this;

      if (parameters) {
        this.lastParameters = parameters;
      } else if (this.lastParameters) {
        parameters = this.lastParameters;
      }

      if (queryOptions) {
        this.lastQueryOpts = queryOptions;
      } else if (this.lastParameters) {
        queryOptions = this.lastQueryOpts;
      }

      if (!this.arrIDS) {
        return;
      }

      if (this._pageIndex < 1 || this._pageIndex > this.allPage) {
        return;
      } //计算 id集合中 该页所在起止位置，找到需要获取的id数组


      var startNum = (this._pageIndex - 1) * this._pageSize;
      var endNum = this._pageIndex * this._pageSize;
      var ids = this.arrIDS.slice(startNum, endNum); //查询该id集合内的数据

      parameters.objectIds = ids.join(",");
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"].fetchJson(QueryArcServer_objectSpread(QueryArcServer_objectSpread({}, this.options), {}, {
        url: this.url + "/query",
        queryParameters: parameters
      })).then(function (result) {
        var featureCollection = Object(t_arcgis_esm["a" /* arcgisToGeoJSON */])(result);

        _this3.processFeatureCollection(featureCollection, queryOptions);
      })["catch"](function (error) {
        Object(Log["logError"])("QueryArcServer 请求出错", error);

        if (queryOptions.error) {
          queryOptions.error(error, error.message);
        }
      });
    }
  }, {
    key: "processFeatureCollection",
    value: function processFeatureCollection(featureCollection, queryOptions) {
      if (featureCollection === undefined || featureCollection == null || featureCollection.features == null || featureCollection.features.length === 0) {
        if (queryOptions.success) {
          queryOptions.success({
            geojson: null,
            count: 0,
            allCount: this.allCount,
            pageSize: this.pageSize,
            allPage: this.allPage,
            pageIndex: this.pageIndex
          });
        }
      } else {
        //剔除有问题数据
        var featuresOK = [];

        for (var i = 0; i < featureCollection.features.length; i++) {
          var feature = featureCollection.features[i];

          if (feature == null || feature.geometry == null || feature.geometry.coordinates == null || feature.geometry.coordinates.length == 0) {
            continue;
          }

          featuresOK.push(feature);
        }

        featureCollection.features = featuresOK;
        var result = {
          geojson: featureCollection,
          count: featureCollection.features.length,
          allCount: this.allCount,
          pageSize: this.pageSize,
          allPage: this.allPage,
          pageIndex: this.pageIndex
        };

        if (this._geoJsonLayer) {
          this._last_success = function (list) {
            if (queryOptions.success) {
              result.list = list;
              queryOptions.success(result);
            }
          };

          this._geoJsonLayer.load({
            data: featureCollection
          });
        } else {
          if (queryOptions.success) {
            queryOptions.success(result);
          }
        }
      }
    }
  }, {
    key: "geoJsonLayer_onLoadHandler",
    value: function geoJsonLayer_onLoadHandler(event) {
      if (this._last_success) {
        this._last_success(event.list);

        this._last_success = null;
      }

      this.fire(EventType.load, event);
    }
  }, {
    key: "geoJsonLayer_onClickHandler",
    value: function geoJsonLayer_onClickHandler(event) {
      this.fire(EventType.click, QueryArcServer_objectSpread(QueryArcServer_objectSpread({}, event), {}, {
        layer: this._geoJsonLayer
      }));
    }
    /**
     * 清除
     * @return {void}  无
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this._last_success) {
        this._last_success = null;
      }

      if (this._geoJsonLayer) {
        this._geoJsonLayer.clear();
      }
    }
  }]);

  return QueryArcServer;
}(BaseClass_BaseClass);

function geojsonTypeToArcGIS(geoJsonType) {
  var arcgisGeometryType;

  switch (geoJsonType) {
    default:
    case "Point":
      arcgisGeometryType = "esriGeometryPoint";
      break;

    case "MultiPoint":
      arcgisGeometryType = "esriGeometryMultipoint";
      break;

    case "LineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;

    case "MultiLineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;

    case "Polygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;

    case "MultiPolygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;
  }

  return arcgisGeometryType;
}
// CONCATENATED MODULE: ./src/query/index.js





// CONCATENATED MODULE: ./src/map/core/SceneEvent.js




var SceneEvent_SceneEvent = /*#__PURE__*/function () {
  function SceneEvent(map) {
    classCallCheck_default()(this, SceneEvent);

    this._map = map;
    this._camera = map.camera;
    this._scene = map.scene;
    this._clock = map.clock;
  } //绑定事件


  createClass_default()(SceneEvent, [{
    key: "on",
    value: function on(type, callback, context) {
      if (!callback) {
        return;
      }

      var removeCallback;

      switch (type) {
        case EventType.cameraMoveStart:
          removeCallback = this._camera.moveStart.addEventListener(callback, context || this);
          break;

        case EventType.cameraMoveEnd:
          removeCallback = this._camera.moveEnd.addEventListener(callback, context || this);
          break;

        case EventType.cameraChanged:
          removeCallback = this._camera.changed.addEventListener(callback, context || this);
          break;

        case EventType.preUpdate:
          removeCallback = this._scene.preUpdate.addEventListener(callback, context || this);
          break;

        case EventType.postUpdate:
          removeCallback = this._scene.postUpdate.addEventListener(callback, context || this);
          break;

        case EventType.preRender:
          removeCallback = this._scene.preRender.addEventListener(callback, context || this);
          break;

        case EventType.postRender:
          removeCallback = this._scene.postRender.addEventListener(callback, context || this);
          break;

        case EventType.renderError:
          removeCallback = this._scene.renderError.addEventListener(callback, context || this);
          break;

        case EventType.morphStart:
          removeCallback = this._scene.morphStart.addEventListener(callback, context || this);
          break;

        case EventType.morphComplete:
          removeCallback = this._scene.morphComplete.addEventListener(callback, context || this);
          break;

        case EventType.clockTick:
          removeCallback = this._clock.onTick.addEventListener(callback, context || this);
          break;

        default:
          break;
      }

      return removeCallback;
    } //移除释放事件

  }, {
    key: "off",
    value: function off(type, callback, context) {
      var removed;

      switch (type) {
        case EventType.cameraMoveStart:
          removed = this._camera.moveStart.removeEventListener(callback, context || this);
          break;

        case EventType.cameraMoveEnd:
          removed = this._camera.moveEnd.removeEventListener(callback, context || this);
          break;

        case EventType.cameraChanged:
          removed = this._camera.changed.removeEventListener(callback, context || this);
          break;

        case EventType.preUpdate:
          removed = this._scene.preUpdate.removeEventListener(callback, context || this);
          break;

        case EventType.postUpdate:
          removed = this._scene.postUpdate.removeEventListener(callback, context || this);
          break;

        case EventType.preRender:
          removed = this._scene.preRender.removeEventListener(callback, context || this);
          break;

        case EventType.postRender:
          removed = this._scene.postRender.removeEventListener(callback, context || this);
          break;

        case EventType.renderError:
          removed = this._scene.renderError.removeEventListener(callback, context || this);
          break;

        case EventType.morphStart:
          removed = this._scene.morphStart.removeEventListener(callback, context || this);
          break;

        case EventType.morphComplete:
          removed = this._scene.morphComplete.removeEventListener(callback, context || this);
          break;

        case EventType.clockTick:
          removed = this._clock.onTick.removeEventListener(callback, context || this);
          break;

        default:
          break;
      }

      return removed;
    }
  }]);

  return SceneEvent;
}();
// CONCATENATED MODULE: ./src/map/core/MouseEvent.js




function MouseEvent_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function MouseEvent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { MouseEvent_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { MouseEvent_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







/**
 *  地图鼠标事件 统一管理类
 *
 * @export
 * @class MouseEvent
 */

var MouseEvent_MouseEvent = /*#__PURE__*/function () {
  function MouseEvent(map) {
    classCallCheck_default()(this, MouseEvent);

    this._map = map;
    this._viewer = map.viewer;
    this._selected = undefined;
    this._enabledMoveTarget = true;
    this.highlighted = {
      feature: undefined,
      originalColor: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"]()
    };
    this.defaultHighlightedClr = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString("#95e40c");

    this._setInputAction();
  }
  /**
   * 是否开启鼠标移动事件的拾取矢量数据
   * @type {Boolean}
   */


  createClass_default()(MouseEvent, [{
    key: "enabledMoveTarget",
    get: function get() {
      return this._enabledMoveTarget;
    },
    set: function set(value) {
      this._enabledMoveTarget = value;

      if (this._moveDelayTik) {
        clearTimeout(this._moveDelayTik);
        this._moveDelayTik = null;
      }
    }
    /**
     * 是否不拾取数据
     * @type {Boolean}
     */

  }, {
    key: "noPickEntity",
    get: function get() {
      return this._noPickEntity;
    },
    set: function set(value) {
      this._noPickEntity = value;
    }
  }, {
    key: "_setInputAction",
    value: function _setInputAction() {
      var _this = this;

      this.handler = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventHandler"](this._viewer.canvas); //LEFT 左键

      this.handler.setInputAction(function (event) {
        _this._clickHandler(event); //默认处理,用于单击选中矢量数据和popup等

      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_CLICK);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.dblClick, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_DOUBLE_CLICK);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.leftDown, event);

        _this._map.fire(EventType.mouseDown, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_DOWN);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.leftUp, event);

        _this._map.fire(EventType.mouseUp, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_UP); //鼠标移动事件

      this.handler.setInputAction(function (event) {
        var cartesian = Object(PointUtil["getCurrentMousePosition"])(_this._viewer.scene, event.endPosition, _this.noPickEntity);
        event.cartesian = cartesian; //拾取目标，并延迟处理

        if (_this.enabledMoveTarget) {
          if (_this._moveDelayTik) {
            clearTimeout(_this._moveDelayTik);
            _this._moveDelayTik = null;
          }

          _this._moveDelayTik = setTimeout(function (e) {
            _this._moveDelayTik = null;

            _this._mouseMoveHandler(event); //默认处理,用于鼠标移入高亮矢量数据和tooltip等

          }, 100);
        } //直接抛出mouseMove


        _this._map.fire(EventType.mouseMove, MouseEvent_objectSpread(MouseEvent_objectSpread({}, event), {}, {
          cartesian: cartesian,
          windowPosition: event.endPosition
        }));
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].MOUSE_MOVE);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.wheel, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].WHEEL); //RIGHT 右键

      this.handler.setInputAction(function (event) {
        _this._rightClickHandler(event); //默认处理，用于右击菜单

      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].RIGHT_CLICK);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.rightDown, event);

        _this._map.fire(EventType.mouseDown, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].RIGHT_DOWN);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.rightUp, event);

        _this._map.fire(EventType.mouseUp, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].RIGHT_UP); //MIDDLE 中键

      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.middleClick, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].MIDDLE_CLICK);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.middleDown, event);

        _this._map.fire(EventType.mouseDown, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].MIDDLE_DOWN);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.middleUp, event);

        _this._map.fire(EventType.mouseUp, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].MIDDLE_UP); //PINCH

      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.pinchStart, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_START);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.pinchEnd, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_END);
      this.handler.setInputAction(function (event) {
        _this._map.fire(EventType.pinchMove, event);
      }, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].PINCH_MOVE);

      this._viewer.canvas.addEventListener("keydown", this._onKeyDown.bind(this), this);

      this._viewer.canvas.addEventListener("keyup", this._onKeyUp.bind(this), this);
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      this._map.fire(EventType.keydown, {
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,
        code: event.code,
        key: event.key,
        keyCode: event.keyCode
      });
    }
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp(event) {
      this._map.fire(EventType.keyup, {
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,
        code: event.code,
        key: event.key,
        keyCode: event.keyCode
      });
    } //获取单击到的矢量数据

  }, {
    key: "getPickTarget",
    value: function getPickTarget(windowPosition, event, type) {
      var _event$cartesian;

      var sourceTarget; //cesium 本身的 entity、primitive对象

      var layer; //tudou3d 的 BaseGraphicLayer 继承对象

      var graphic; //tudou3d 的 BaseGraphic 继承对象

      var pickedObject;
      var pickedId;

      try {
        pickedObject = this._viewer.scene.pick(windowPosition, 5, 5); // let pickedObjects = this._viewer.scene.drillPick(windowPosition, 2) //可拾取多个
        // if (pickedObjects && pickedObjects.length > 0) {
        //   pickedObject = pickedObjects[pickedObjects.length - 1]
        // }
      } catch (e) {//
      }

      var cartesian = (_event$cartesian = event === null || event === void 0 ? void 0 : event.cartesian) !== null && _event$cartesian !== void 0 ? _event$cartesian : Object(PointUtil["getCurrentMousePosition"])(this._viewer.scene, windowPosition, this.noPickEntity);
      var hasClickEvent = false; //存在单击的对象

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickedObject)) {
        //普通entity对象 && viewer.scene.pickPositionSupported
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickedObject.id) && pickedObject.id instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Entity"]) {
          sourceTarget = pickedObject.id;
          pickedId = sourceTarget.id;
        } //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
        else if (pickedObject instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cesium3DTileFeature"]) {
          var _layer;

          sourceTarget = pickedObject;
          pickedId = "Cesium3DTileFeature_" + pickedObject._batchId;
          var tileset = pickedObject.tileset; //Cesium.Cesium3DTileset对象

          layer = this._map.getLayerById(tileset._tudou3d_layerId);
          var layerOptions = (_layer = layer) === null || _layer === void 0 ? void 0 : _layer.options; //对应的配置参数
          //取属性

          var attr = {};
          var names = pickedObject.getPropertyNames();

          for (var i = 0; i < names.length; i++) {
            var name = names[i];

            if (!pickedObject.hasProperty(name)) {
              continue;
            }

            var val = pickedObject.getProperty(name);

            if (val == null) {
              continue;
            }

            attr[name] = val;
          }

          graphic = {
            attr: attr,
            //回调方法中用
            feature: pickedObject
          }; //高亮显示单体对象

          if (layerOptions && this.enabledMoveTarget) {
            if (type == "click" && layerOptions.showClickFeature) {
              this.showFeatureFor3dtiles(pickedObject, layerOptions.pickFeatureStyle);
            } //高亮显示单体对象


            if (type == "move" && layerOptions.showMoveFeature) {
              this.showFeatureFor3dtiles(pickedObject, layerOptions.pickFeatureStyle);
            }
          } else {
            this.removeFeatureFor3dtiles();
          }
        } //primitive对象
        else if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](pickedObject.primitive)) {
          sourceTarget = pickedObject.primitive;
          pickedId = pickedObject.id;
        } else {
          //未单击到矢量或模型数据时
          Object(Log["logInfo"])("getPickTarget:拾取到了对象，请确认是否要做处理", pickedObject);
        }

        if (pickedObject.click) {
          hasClickEvent = true;
        }

        if (sourceTarget) {
          var _layer2, _layer3, _layer4;

          layer = layer || this._map.getLayerById(sourceTarget._tudou3d_layerId);

          if ((_layer2 = layer) !== null && _layer2 !== void 0 && _layer2.listens(EventType.click, true)) {
            hasClickEvent = true;
          }

          if ((_layer3 = layer) !== null && _layer3 !== void 0 && _layer3.hasPopup && (_layer4 = layer) !== null && _layer4 !== void 0 && _layer4.hasPopup()) {
            hasClickEvent = true;
          }

          if (layer && layer.getGraphicById) {
            graphic = graphic || layer.getGraphicById(sourceTarget._tudou3d_graphicId);

            if (graphic) {
              pickedId = graphic.uuid;

              if (graphic.getPickedObject) {
                var instanceId = pickedObject.id || pickedObject.instanceId;

                if (instanceId) {
                  var _pickedObject$data;

                  pickedId = instanceId;
                  pickedObject.data = graphic.getPickedObject(instanceId);
                  graphic.attr = (_pickedObject$data = pickedObject.data) === null || _pickedObject$data === void 0 ? void 0 : _pickedObject$data.attr;
                }
              }

              if (graphic.listens(EventType.click, true)) {
                hasClickEvent = true;
              }

              if (graphic.hasPopup && graphic.hasPopup()) {
                hasClickEvent = true;
              }
            }
          }
        }
      }

      return MouseEvent_objectSpread(MouseEvent_objectSpread({}, event), {}, {
        id: pickedId,
        sourceTarget: sourceTarget,
        pickedObject: pickedObject,
        czmObject: sourceTarget,
        layer: layer,
        graphic: graphic,
        cartesian: cartesian,
        windowPosition: windowPosition,
        hasClickEvent: hasClickEvent
      });
    } //瓦片图层上的矢量对象，动态获取

  }, {
    key: "pickImageryLayerFeatures",
    value: function pickImageryLayerFeatures(position, event) {
      var _this2 = this;

      var scene = this._viewer.scene;
      var pickRay = scene.camera.getPickRay(position); //position : Cesium.Cartesian2

      var imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](imageryLayerFeaturePromise)) {
        return;
      } //赵西洋 Cesium.when切换为promise   20220805
      // Cesium.when(
      //   imageryLayerFeaturePromise,


      imageryLayerFeaturePromise.then(function (features) {
        _this2._clickTileGraphic(features, position, event);
      }, function (e) {
        Object(Log["logError"])("pickImageryLayerFeatures:出错了", e);
      });
    }
  }, {
    key: "_clickTileGraphic",
    value: function _clickTileGraphic(features, position, event) {
      var _cfg$pickFeatureStyle;

      this.removeFeatureForImageryLayer();

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](features) || features.length == 0) {
        return;
      } //单击的要素对象


      var feature = features[0];
      var imageryLayer = feature.imageryLayer; //所在的图层 ceiusm对象
      //对应的tudou3d图层 BaseTileLayer

      var tileLayer = this._map.getLayerById(imageryLayer._tudou3d_layerId);

      var cfg = tileLayer === null || tileLayer === void 0 ? void 0 : tileLayer.options;
      var graphicsOptions = Object(Util["geoJsonToGraphics"])(feature.data, {
        type: cfg === null || cfg === void 0 ? void 0 : (_cfg$pickFeatureStyle = cfg.pickFeatureStyle) === null || _cfg$pickFeatureStyle === void 0 ? void 0 : _cfg$pickFeatureStyle.type,
        style: cfg === null || cfg === void 0 ? void 0 : cfg.pickFeatureStyle
      });

      if (cfg !== null && cfg !== void 0 && cfg.showClickFeature && (graphicsOptions === null || graphicsOptions === void 0 ? void 0 : graphicsOptions.length) > 0) {
        this.showFeatureForImageryLayer(graphicsOptions, cfg === null || cfg === void 0 ? void 0 : cfg.pickFeatureStyle);
      }

      var result = {
        sourceTarget: imageryLayer,
        layer: tileLayer,
        graphic: graphicsOptions.length > 0 ? graphicsOptions[0] : null,
        graphics: graphicsOptions,
        features: features,
        cartesian: event === null || event === void 0 ? void 0 : event.cartesian,
        windowPosition: position
      }; //1.图层上抛出事件

      if (tileLayer) {
        tileLayer.fire(EventType.click, result, false);
      } //2.map上抛出事件


      this._map.fire(EventType.clickTileGraphic, result);
    }
  }, {
    key: "_clickHandler",
    value: function _clickHandler(event) {
      this.removeHighlighted();

      if (!event || !event.position) {
        return false;
      }

      var position = event.position;
      var result = this.getPickTarget(position, event, "click");
      var target = result.sourceTarget;

      if (target) {
        var _result$czmObject$eve, _result$graphic, _result$layer;

        //1.target上抛出事件
        //target上如果直接有click回调方法，直接调用
        if (target.click && typeof target.click == "function") {
          target.click(result);
        } //target上如果有关联的事件类(基于BaseClass)，进行事件抛出。


        (_result$czmObject$eve = result.czmObject.eventTarget) === null || _result$czmObject$eve === void 0 ? void 0 : _result$czmObject$eve.fire(EventType.click, result);

        if ((_result$graphic = result.graphic) !== null && _result$graphic !== void 0 && _result$graphic.fire) {
          //2.在graphic上抛出事件
          result.graphic.fire(EventType.click, result, true);
        } else if ((_result$layer = result.layer) !== null && _result$layer !== void 0 && _result$layer.fire) {
          //3.在layer上抛出事件(会自动冒泡)
          result.layer.fire(EventType.click, result, true);
        } else {
          //4.在map上抛出事件
          this._map.fire(EventType.click, result);
        } //在map上抛出事件clickGraphic


        this._map.fire(EventType.clickGraphic, result);
      } else {
        //在map上抛出事件click
        this._map.fire(EventType.click, result); //单击地图空白（未单击到矢量或模型数据）时


        this._map.fire(EventType.clickMap, result); //瓦片图层上的矢量对象去服务中动态获取


        this.pickImageryLayerFeatures(position, result);
      }
    }
  }, {
    key: "_mouseMoveHandler",
    value: function _mouseMoveHandler(event) {
      if (!event || !event.endPosition) {
        return false;
      }

      var result = this.getPickTarget(event.endPosition, event, "move");
      var target = result.sourceTarget; //noMouseMove用于排除标识了不处理其移入事件的对象 ，比如高亮对象本身

      if (target && !target.noMouseMove) {
        //鼠标样式
        if (result.hasClickEvent || target.cursorCSS) {
          this._map.container.style.cursor = target.cursorCSS || "pointer";
        }

        this.activateMouseOver(result);
      } else {
        this.activateMouseOut();
      }

      this._map.fire(EventType.mouseMoveTarget, MouseEvent_objectSpread(MouseEvent_objectSpread({
        czmObject: target
      }, event), result));
    } //鼠标移入

  }, {
    key: "activateMouseOver",
    value: function activateMouseOver(result) {
      var _result$czmObject$eve2, _result$graphic2, _result$layer2;

      if (this._lastMouseOverItem && result.id && result.id == this._lastMouseOverItem.id) {
        return;
      }

      this.activateMouseOut(); //result?.layer?.uuid
      //1.target上抛出事件
      // target上如果直接有mouseOver回调方法，直接调用

      if (result.czmObject.mouseOver && typeof result.czmObject.mouseOver == "function") {
        result.czmObject.mouseOver(result);
      } //target上如果有关联的事件类(基于BaseClass)，进行事件抛出。


      (_result$czmObject$eve2 = result.czmObject.eventTarget) === null || _result$czmObject$eve2 === void 0 ? void 0 : _result$czmObject$eve2.fire(EventType.mouseOver, result);

      if ((_result$graphic2 = result.graphic) !== null && _result$graphic2 !== void 0 && _result$graphic2.fire) {
        //2.在graphic上抛出事件(会自动冒泡)
        result.graphic.fire(EventType.mouseOver, result, true);
      } else if ((_result$layer2 = result.layer) !== null && _result$layer2 !== void 0 && _result$layer2.fire) {
        //3.在layer上抛出事件(会自动冒泡)
        result.layer.fire(EventType.mouseOver, result, true);
      } else {
        //4.在map上抛出事件
        this._map.fire(EventType.mouseOver, result);
      }

      this._lastMouseOverItem = result;
    } //鼠标移出

  }, {
    key: "activateMouseOut",
    value: function activateMouseOut() {
      var _result$czmObject$eve3, _result$graphic3, _result$layer3;

      if (this._lastMouseOverItem == null) {
        return;
      }

      this._map.container.style.cursor = "default";
      var result = this._lastMouseOverItem; //1.target上抛出事件
      // target上如果直接有mouseOut回调方法，直接调用

      if (result.czmObject.mouseOut && typeof result.czmObject.mouseOut == "function") {
        result.czmObject.mouseOut(result);
      } //target上如果有关联的事件类(基于BaseClass)，进行事件抛出。


      (_result$czmObject$eve3 = result.czmObject.eventTarget) === null || _result$czmObject$eve3 === void 0 ? void 0 : _result$czmObject$eve3.fire(EventType.mouseOut, result);

      if (result !== null && result !== void 0 && (_result$graphic3 = result.graphic) !== null && _result$graphic3 !== void 0 && _result$graphic3.fire) {
        //2.在graphic上抛出事件
        result.graphic.fire(EventType.mouseOut, result, true);
      } else if ((_result$layer3 = result.layer) !== null && _result$layer3 !== void 0 && _result$layer3.fire) {
        //3.在layer上抛出事件
        result.layer.fire(EventType.mouseOut, result, true);
      } else {
        //4.在map上抛出事件
        this._map.fire(EventType.mouseOut, result);
      }

      this._lastMouseOverItem = null;
    }
  }, {
    key: "_rightClickHandler",
    value: function _rightClickHandler(event) {
      if (!event || !event.position) {
        return false;
      }

      var position = event.position;
      var result = this.getPickTarget(position, event, "click");
      var target = result.sourceTarget;

      if (target) {
        var _result$czmObject$eve4, _result$graphic4, _result$layer4;

        //1.target上抛出事件
        //target上如果直接有rightClick回调方法，直接调用
        if (target.rightClick && typeof target.rightClick == "function") {
          target.rightClick(result);
        } //target上如果有关联的事件类(基于BaseClass)，进行事件抛出。


        (_result$czmObject$eve4 = result.czmObject.eventTarget) === null || _result$czmObject$eve4 === void 0 ? void 0 : _result$czmObject$eve4.fire(EventType.rightClick, result);

        if ((_result$graphic4 = result.graphic) !== null && _result$graphic4 !== void 0 && _result$graphic4.fire) {
          //2.在graphic上抛出事件
          result.graphic.fire(EventType.rightClick, result, true);
        } else if ((_result$layer4 = result.layer) !== null && _result$layer4 !== void 0 && _result$layer4.fire) {
          //3.在layer上抛出事件(会自动冒泡)
          result.layer.fire(EventType.rightClick, result, true);
        } else {
          //4.在map上抛出事件
          this._map.fire(EventType.rightClick, result);
        }
      } else {
        this._map.fire(EventType.rightClick, result);
      }
    } //=====================单击高亮对象处理========================
    //单击Tile瓦片时同步，高亮显示要素处理

  }, {
    key: "removeFeatureForImageryLayer",
    value: function removeFeatureForImageryLayer() {
      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }
    }
  }, {
    key: "showFeatureForImageryLayer",
    value: function showFeatureForImageryLayer(graphicOptions, style) {
      var _graphicOptions$0$pos,
          _this3 = this;

      var maxLength = (style === null || style === void 0 ? void 0 : style.maxLength) || 800;

      if (((_graphicOptions$0$pos = graphicOptions[0].positions) === null || _graphicOptions$0$pos === void 0 ? void 0 : _graphicOptions$0$pos.length) > maxLength) {
        Object(Log["logInfo"])("showFeatureForImageryLayer:已屏蔽大数据，避免卡顿", graphicOptions);
        return;
      }

      if (!this._graphicLayer) {
        this._graphicLayer = new GraphicLayer_GraphicLayer({
          name: "高亮对象图层",
          noLayerManage: true
        });

        this._map.addLayer(this._graphicLayer);
      }

      this._graphicLayer.addGraphic(graphicOptions);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](style === null || style === void 0 ? void 0 : style.showTime)) {
        //定时自动关闭
        setTimeout(function () {
          _this3.removeFeatureForImageryLayer();
        }, style.showTime);
      }
    } //单击3dtiles单体化，高亮显示构件处理

  }, {
    key: "removeFeatureFor3dtiles",
    value: function removeFeatureFor3dtiles() {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.highlighted.feature)) {
        try {
          this.highlighted.feature.color = this.highlighted.originalColor;
        } catch (ex) {//
        }

        this.highlighted.feature = undefined;
      }
    }
  }, {
    key: "showFeatureFor3dtiles",
    value: function showFeatureFor3dtiles(pickedFeature, style) {
      this.removeFeatureFor3dtiles();
      this.highlighted.feature = pickedFeature;
      external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].clone(pickedFeature.color, this.highlighted.originalColor);

      if (style) {
        pickedFeature.color = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.color, "#FFFF00")).withAlpha(Number(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](style.opacity, 1.0)));
      } else {
        pickedFeature.color = this.defaultHighlightedClr;
      }
    }
  }, {
    key: "removeHighlighted",
    value: function removeHighlighted() {
      this.removeFeatureForImageryLayer();
      this.removeFeatureFor3dtiles();
    } //销毁资源

  }, {
    key: "destroy",
    value: function destroy() {
      if (!this._graphicLayer) {
        this._map.removeLayer(this._graphicLayer, true);

        delete this._graphicLayer;
      }

      this.removeHighlighted();
      this.handler.destroy();
      delete this.handler;

      this._map.canvas.removeEventListener("keydown", this._onKeyDown);

      this._map.canvas.removeEventListener("keyup", this._onKeyUp);
    }
  }]);

  return MouseEvent;
}();
// CONCATENATED MODULE: ./src/map/core/ZoomNavigation.js



var ZoomNavigation_unprojectedScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartographic"]();
var ZoomNavigation_rayScratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"]();
var cartesian3Scratch = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
/**
 * gets the focus point of the camera
 * @param {Viewer|Widget} viewer The viewer
 * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, catch get it in projection-specific map coordinates, in meters.
 * @param {Cesium.Cartesian3} [result] The object in which the result will be stored.
 * @return {Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
 *
 * @private
 */

function getCameraFocus(viewer, inWorldCoordinates, result) {
  var scene = viewer.scene;
  var camera = scene.camera;

  if (scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING) {
    return undefined;
  }

  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
    result = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
  } // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
  // TODO bug when tracking: reset should reset to default view of tracked entity


  if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](viewer.trackedEntity)) {
    result = viewer.trackedEntity.position.getValue(viewer.clock.currentTime, result);
  } else {
    ZoomNavigation_rayScratch.origin = camera.positionWC;
    ZoomNavigation_rayScratch.direction = camera.directionWC;
    result = scene.globe.pick(ZoomNavigation_rayScratch, scene, result);
  }

  if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](result)) {
    return undefined;
  }

  if (scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D || scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW) {
    result = camera.worldToCameraCoordinatesPoint(result, result);

    if (inWorldCoordinates) {
      result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, ZoomNavigation_unprojectedScratch), result);
    }
  } else {
    if (!inWorldCoordinates) {
      result = camera.worldToCameraCoordinatesPoint(result, result);
    }
  }

  return result;
}
/**
 *  缩放控制类
 * @private
 */


var ZoomNavigation_ZoomNavigation = /*#__PURE__*/function () {
  //========== 构造方法 ==========
  // is used for zooming in (true) or out (false)
  function ZoomNavigation(viewer) {
    classCallCheck_default()(this, ZoomNavigation);

    this.viewer = viewer;
  }

  createClass_default()(ZoomNavigation, [{
    key: "zoomIn",
    value: function zoomIn() {
      var relativeAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
      relativeAmount = 1 / relativeAmount;
      this.zoom(relativeAmount);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      var relativeAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
      this.zoom(relativeAmount);
    }
  }, {
    key: "zoom",
    value: function zoom(relativeAmount) {
      this.isActive = true;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.viewer)) {
        var scene = this.viewer.scene;
        var sscc = scene.screenSpaceCameraController; // do not zoom if it is disabled

        if (!sscc.enableInputs || !sscc.enableZoom) {
          return;
        } // TODO
        //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
        //                return;
        //            }


        var camera = scene.camera;
        var orientation;

        switch (scene.mode) {
          case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].MORPHING:
            break;

          case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D:
            camera.zoomIn(camera.positionCartographic.height * (1 - relativeAmount));
            break;

          default:
            {
              var focus;

              if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.viewer.trackedEntity)) {
                focus = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]();
              } else {
                focus = getCameraFocus(this.viewer, false);
              }

              if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](focus)) {
                // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                // the focal point.
                var ray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                focus = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["IntersectionTests"].grazingAltitudeLocation(ray, scene.globe.ellipsoid);

                if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](focus)) {
                  return;
                }

                orientation = {
                  heading: camera.heading,
                  pitch: camera.pitch,
                  roll: camera.roll
                };
              } else {
                orientation = {
                  direction: camera.direction,
                  up: camera.up
                };
              }

              var direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(camera.position, focus, cartesian3Scratch);
              var movementVector = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(direction, relativeAmount, direction);
              var endPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(focus, movementVector, focus);

              if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this.viewer.trackedEntity) || scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW) {
                // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                camera.position = endPosition;
              } else {
                camera.flyTo({
                  destination: endPosition,
                  orientation: orientation,
                  duration: 0.5,
                  convert: false
                });
              }

              break;
            }
        }
      } // this.viewer.notifyRepaintRequired();


      this.isActive = false;
    }
  }]);

  return ZoomNavigation;
}();
// CONCATENATED MODULE: ./src/map/core/ViewerOption.js




function ViewerOption_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ViewerOption_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ViewerOption_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ViewerOption_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var ViewerOption_ViewerOption = /*#__PURE__*/function () {
  function ViewerOption(map) {
    classCallCheck_default()(this, ViewerOption);

    this._map = map;
    this._viewer = map.viewer;
    this.options = {};

    this._init();
  } //需要初始的设置（一次性）


  createClass_default()(ViewerOption, [{
    key: "_init",
    value: function _init() {
      var _this$_viewer,
          _this$_viewer$homeBut,
          _this = this;

      this._viewer.cesiumWidget.creditContainer.style.display = "none"; //去cesium logo

      this._viewer.scene.screenSpaceCameraController.maximumZoomDistance = 50000000.0;
      this._viewer.scene.backgroundColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].TRANSPARENT; //二三维切换不用动画

      if (this._viewer.sceneModePicker) {
        this._viewer.sceneModePicker.viewModel.duration = 0.0;
      } //默认定位地点相关设置，默认home键和初始化镜头视角


      (_this$_viewer = this._viewer) === null || _this$_viewer === void 0 ? void 0 : (_this$_viewer$homeBut = _this$_viewer.homeButton) === null || _this$_viewer$homeBut === void 0 ? void 0 : _this$_viewer$homeBut.viewModel.command.beforeExecute.addEventListener(function (commandInfo) {
        _this._map.flyHome();

        commandInfo.cancel = true;
      }); //解决Cesium显示画面模糊的问题 https://zhuanlan.zhihu.com/p/41794242 【1.63已修复，1.66又出现了】

      this._viewer._cesiumWidget._supportsImageRenderingPixelated = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FeatureDetection"].supportsImageRenderingPixelated();
      this._viewer._cesiumWidget._forceResize = true;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["FeatureDetection"].supportsImageRenderingPixelated()) {
        var _dpr = window.devicePixelRatio; // 适度降低分辨率

        while (_dpr >= 2.0) {
          _dpr /= 2.0;
        }

        this._viewer.resolutionScale = _dpr;
      }
    } //重新赋值参数，同构造方法参数一致。

  }, {
    key: "setOptions",
    value: function setOptions(optionsAll, optionsNew) {
      optionsAll = optionsAll || {};
      optionsNew = optionsNew || {};
      this.options = optionsAll;

      this._setViewerOption(optionsNew)._setCanvasOption(optionsNew)._setSceneOption(optionsNew)._setGlobeOption(optionsNew)._setCameraOption(optionsNew)._setClockOption(optionsNew);

      return this;
    } //设置 Viewer 相关

  }, {
    key: "_setViewerOption",
    value: function _setViewerOption(optionsNew) {
      var _this$options$shadows;

      //定位到配置的默认视角
      if (optionsNew.center) {
        this._map.setCameraView(optionsNew.center, {
          duration: 0
        });
      } else if (optionsNew.extent) {
        this._map.flyToExtent(optionsNew.extent, {
          duration: 0
        });
      }

      this._viewer.shadows = (_this$options$shadows = this.options.shadows) !== null && _this$options$shadows !== void 0 ? _this$options$shadows : false;

      if (this.options.resolutionScale) {
        this._viewer.resolutionScale = this.options.resolutionScale;
      } //一些默认值的修改


      if (this.options.ionToken) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ion"].defaultAccessToken = this.options.ionToken;
      }

      if (this.options.animationTicks) {
        external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["AnimationViewModel"].defaultTicks = this.options.animationTicks;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.removeDblClick, true)) {
        this._viewer.screenSpaceEventHandler.removeInputAction(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ScreenSpaceEventType"].LEFT_DOUBLE_CLICK);
      }

      return this;
    } //设置 canvas 相关

  }, {
    key: "_setCanvasOption",
    value: function _setCanvasOption(optionsNew) {
      var canvas = this._viewer.canvas;
      canvas.setAttribute("tabindex", external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.tabIndex, 0));

      canvas.onclick = function (e) {
        canvas.focus();
      };

      return this;
    } //设置 scene 相关

  }, {
    key: "_setSceneOption",
    value: function _setSceneOption(optionsNew) {
      var _sceneOption$showSun, _sceneOption$showMoon, _sceneOption$showSkyB, _sceneOption$showSkyA, _sceneOption$fog, _sceneOption$fxaa, _sceneOption$highDyna;

      var scene = this._viewer.scene;
      var sceneOption = this.options;
      scene.sun.show = (_sceneOption$showSun = sceneOption.showSun) !== null && _sceneOption$showSun !== void 0 ? _sceneOption$showSun : true; //是否显示太阳

      scene.moon.show = (_sceneOption$showMoon = sceneOption.showMoon) !== null && _sceneOption$showMoon !== void 0 ? _sceneOption$showMoon : true; //是否显示月亮

      scene.skyBox.show = (_sceneOption$showSkyB = sceneOption.showSkyBox) !== null && _sceneOption$showSkyB !== void 0 ? _sceneOption$showSkyB : true; //是否显示天空盒

      scene.skyAtmosphere.show = (_sceneOption$showSkyA = sceneOption.showSkyAtmosphere) !== null && _sceneOption$showSkyA !== void 0 ? _sceneOption$showSkyA : true; //是否显示地球大气层外光圈

      scene.fog.enabled = (_sceneOption$fog = sceneOption.fog) !== null && _sceneOption$fog !== void 0 ? _sceneOption$fog : true; //是否启用雾化效果

      scene.postProcessStages.fxaa.enabled = (_sceneOption$fxaa = sceneOption.fxaa) !== null && _sceneOption$fxaa !== void 0 ? _sceneOption$fxaa : true; //快速抗锯齿

      scene.highDynamicRange = (_sceneOption$highDyna = sceneOption.highDynamicRange) !== null && _sceneOption$highDyna !== void 0 ? _sceneOption$highDyna : false; //是否关闭高动态范围渲染(不关闭时地图会变暗)
      //空间背景色

      if (sceneOption.backgroundColor) {
        scene.backgroundColor = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(sceneOption.backgroundColor);
      }

      switch (sceneOption.sceneMode) {
        default:
          break;

        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE2D:
          scene.morphTo2D(0);
          break;

        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].COLUMBUS_VIEW:
          scene.morphToColumbusView(0);
          break;

        case external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D:
          scene.morphTo3D(0);
          break;
      }

      return this;
    } //设置 globe 相关

  }, {
    key: "_setGlobeOption",
    value: function _setGlobeOption(optionsNew) {
      var _this$options$globe, _globeOption$show, _globeOption$depthTes, _globeOption$showGrou, _globeOption$enableLi;

      var globe = this._viewer.scene.globe;
      var globeOption = (_this$options$globe = this.options.globe) !== null && _this$options$globe !== void 0 ? _this$options$globe : {};
      Object(Util["merge"])(globe, ViewerOption_objectSpread(ViewerOption_objectSpread({}, globeOption), {}, {
        show: (_globeOption$show = globeOption.show) !== null && _globeOption$show !== void 0 ? _globeOption$show : true,
        depthTestAgainstTerrain: (_globeOption$depthTes = globeOption.depthTestAgainstTerrain) !== null && _globeOption$depthTes !== void 0 ? _globeOption$depthTes : false,
        //是否启用深度监测
        baseColor: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Color"].fromCssColorString(globeOption.baseColor || "#546a53"),
        //地球默认背景色
        showGroundAtmosphere: (_globeOption$showGrou = globeOption.showGroundAtmosphere) !== null && _globeOption$showGrou !== void 0 ? _globeOption$showGrou : true,
        //在地球上绘制的地面大气
        enableLighting: (_globeOption$enableLi = globeOption.enableLighting) !== null && _globeOption$enableLi !== void 0 ? _globeOption$enableLi : false //是否显示昼夜区域

      }));
      return this;
    } //设置 cameraController 相关

  }, {
    key: "_setCameraOption",
    value: function _setCameraOption(optionsNew) {
      var _this$options$cameraC, _cameraCrlOptions$min, _cameraCrlOptions$max, _cameraCrlOptions$min2, _cameraCrlOptions$ena, _cameraCrlOptions$ena2, _cameraCrlOptions$ena3, _cameraCrlOptions$ena4, _cameraCrlOptions$ena5;

      var screenSpaceCameraController = this._viewer.scene.screenSpaceCameraController;
      var cameraCrlOptions = (_this$options$cameraC = this.options.cameraController) !== null && _this$options$cameraC !== void 0 ? _this$options$cameraC : {};
      Object(Util["merge"])(screenSpaceCameraController, ViewerOption_objectSpread(ViewerOption_objectSpread({}, cameraCrlOptions), {}, {
        _zoomFactor: cameraCrlOptions.zoomFactor || 3.0,
        //鼠标滚轮放大的步长参数
        minimumZoomDistance: (_cameraCrlOptions$min = cameraCrlOptions.minimumZoomDistance) !== null && _cameraCrlOptions$min !== void 0 ? _cameraCrlOptions$min : 1.0,
        //变焦时相机位置的最小量级（以米为单位）。默认为1
        maximumZoomDistance: (_cameraCrlOptions$max = cameraCrlOptions.maximumZoomDistance) !== null && _cameraCrlOptions$max !== void 0 ? _cameraCrlOptions$max : 50000000.0,
        //变焦时相机位置的最大值（以米为单位）
        minimumCollisionTerrainHeight: (_cameraCrlOptions$min2 = cameraCrlOptions.minimumCollisionTerrainHeight) !== null && _cameraCrlOptions$min2 !== void 0 ? _cameraCrlOptions$min2 : 15000,
        //低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
        enableRotate: (_cameraCrlOptions$ena = cameraCrlOptions.enableRotate) !== null && _cameraCrlOptions$ena !== void 0 ? _cameraCrlOptions$ena : true,
        //2D和3D视图下，是否允许用户旋转相机
        enableTranslate: (_cameraCrlOptions$ena2 = cameraCrlOptions.enableTranslate) !== null && _cameraCrlOptions$ena2 !== void 0 ? _cameraCrlOptions$ena2 : true,
        //2D和哥伦布视图下，是否允许用户平移地图
        enableTilt: (_cameraCrlOptions$ena3 = cameraCrlOptions.enableTilt) !== null && _cameraCrlOptions$ena3 !== void 0 ? _cameraCrlOptions$ena3 : true,
        // 3D和哥伦布视图下，是否允许用户倾斜相机
        enableZoom: (_cameraCrlOptions$ena4 = cameraCrlOptions.enableZoom) !== null && _cameraCrlOptions$ena4 !== void 0 ? _cameraCrlOptions$ena4 : true,
        // 是否允许 用户放大和缩小视图
        enableCollisionDetection: (_cameraCrlOptions$ena5 = cameraCrlOptions.enableCollisionDetection) !== null && _cameraCrlOptions$ena5 !== void 0 ? _cameraCrlOptions$ena5 : true //是否允许 地形相机的碰撞检测

      })); //解除在南北极区域鼠标操作限制

      if (cameraCrlOptions.constrainedAxis == false) {
        this._viewer.camera.constrainedAxis = undefined;
      }

      return this;
    } //设置 clock 相关

  }, {
    key: "_setClockOption",
    value: function _setClockOption(optionsNew) {
      var _this$options$clock, _ref, _clockOptions$shouldA;

      var clock = this._viewer.clock;
      var clockOptions = (_this$options$clock = this.options.clock) !== null && _this$options$clock !== void 0 ? _this$options$clock : {};
      clockOptions.shouldAnimate = (_ref = (_clockOptions$shouldA = clockOptions.shouldAnimate) !== null && _clockOptions$shouldA !== void 0 ? _clockOptions$shouldA : this.options.shouldAnimate) !== null && _ref !== void 0 ? _ref : true;
      clock.shouldAnimate = clockOptions.shouldAnimate;

      if (clockOptions.currentTime) {
        if (Object(Util["isString"])(clockOptions.currentTime)) {
          if (clockOptions.currentTime.indexOf("Z") == -1) {
            clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromDate(new Date(clockOptions.currentTime));
          } else {
            clock.currentTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].fromIso8601(clockOptions.currentTime);
          }
        } else {
          clock.currentTime = clockOptions.currentTime;
        }
      }

      if (clockOptions.multiplier) {
        clock.multiplier = clockOptions.multiplier; //速度
      }

      return this;
    }
  }]);

  return ViewerOption;
}(); //一些默认值的修改

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ion"].defaultAccessToken = ion;
external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Camera"].DEFAULT_VIEW_RECTANGLE = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(89.5, 20.4, 110.4, 61.2); //更改默认视域

external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["AnimationViewModel"].defaultTicks = [0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.0];
// CONCATENATED MODULE: ./src/map/control/Popup.js








function Popup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Popup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Popup_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Popup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Popup_createSuper(Derived) { var hasNativeReflectConstruct = Popup_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Popup_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }








var PopupIdIndex = 1; //popup处理

var Popup_Popup = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(Popup, _BaseControl);

  var _super = Popup_createSuper(Popup);

  //========== 构造方法 ==========
  function Popup() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Popup);

    _this = _super.call(this, options);
    _this._isOnly = true;
    _this._depthTest = true;
    _this.objPopup = {};
    return _this;
  } //========== 对外属性 ==========
  //显示单个模式


  createClass_default()(Popup, [{
    key: "isOnly",
    get: function get() {
      return this._isOnly;
    },
    set: function set(val) {
      this._isOnly = val;
    } //是否打开深度判断（true时判断是否在球背面）

  }, {
    key: "depthTest",
    get: function get() {
      return this._depthTest;
    },
    set: function set(value) {
      this._depthTest = value;
    } //========== 方法 ==========

    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div");
      this._container.id = this.parentContainerId + "-tudou3d-pupup-all";
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      //单击事件
      this._map.on(EventType.click, this._mouseClickHandler, this);

      this._map.on(EventType.clickTileGraphic, this._mouseClickHandler, this); //移动事件


      this._map.on(EventType.postRender, this._postRenderHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      //单击事件
      this._map.off(EventType.click, this._mouseClickHandler, this);

      this._map.off(EventType.clickTileGraphic, this._mouseClickHandler, this); //移动事件


      this._map.off(EventType.postRender, this._postRenderHandler, this);
    }
  }, {
    key: "_showHook",
    value: function _showHook() {
      if (!this._show) {
        this.close();
      }
    } //========== 内部方法 ==========
    //鼠标点击事件

  }, {
    key: "_mouseClickHandler",
    value: function _mouseClickHandler(event) {
      var _event$layer;

      if (this._isOnly) {
        this.close();
      }

      if (!this.enabled) {
        return;
      }

      this._hasTilePopup = false;
      var czmObject = event.czmObject;
      var heightReference;

      if (czmObject) {
        heightReference = this.getHeightReference(event.czmObject);

        if (czmObject.billboard || czmObject.point) {
          event.cartesian = czmObject.position;
        } else if (czmObject.position && !(czmObject.position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ConstantPositionProperty"])) {
          event.cartesian = czmObject.position; //不是常量时，动态变化的坐标
        }
      } //cesium 本身的 entity、primitive对象


      if (this._openByClick(event.czmObject, event, {
        heightReference: heightReference
      })) {
        return;
      } //tudou3d 的 BaseGraphic 继承对象


      if (this._openByClick(event.graphic, event, {
        heightReference: heightReference
      })) {
        return;
      } //tudou3d 的 BaseGraphicLayer 继承对象


      if (this._openByClick(event.layer, event, {
        heightReference: heightReference
      })) {
        return;
      } //tudou3d 的 GroupLayer


      if (this._openByClick((_event$layer = event.layer) === null || _event$layer === void 0 ? void 0 : _event$layer.parent, event, {
        heightReference: heightReference
      })) {
        return;
      }

      this._hasTilePopup = true;
    }
  }, {
    key: "_openByClick",
    value: function _openByClick(target, event, options) {
      if (!target || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](target.popup)) {
        return false;
      }

      if (target.popup == false) {
        //false时关闭右键，不再往上冒泡
        return true;
      }

      this.open(event.cartesian, target, Popup_objectSpread(Popup_objectSpread({}, options), {}, {
        windowPosition: event.windowPosition,
        event: event
      }));
      return true;
    }
  }, {
    key: "getHeightReference",
    value: function getHeightReference(entity) {
      if (!entity) {
        return null;
      }

      var graphic = entity.billboard || entity.point || entity.model || entity.label;

      if (graphic) {
        var _graphic$heightRefere;

        return graphic === null || graphic === void 0 ? void 0 : (_graphic$heightRefere = graphic.heightReference) === null || _graphic$heightRefere === void 0 ? void 0 : _graphic$heightRefere._value;
      }

      return null;
    }
  }, {
    key: "getItem",
    value: function getItem(eleId) {
      return this.objPopup[eleId];
    } //=====================以下为单个popup的处理，以上为总体的管理===========================

  }, {
    key: "_getPopupId",
    value: function _getPopupId(target) {
      if (!target) {
        return;
      }

      target._popup_id = target._popup_id || "popup-" + PopupIdIndex++;
      return target._popup_id;
    } //popup处理

  }, {
    key: "open",
    value: function open(cartesian, target) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (target == null || target.popup == null) {
        return;
      }

      this.show = true;

      if (typeof cartesian == "string" || Array.isArray(cartesian) || cartesian instanceof LatLngPoint["a" /* LatLngPoint */]) {
        cartesian = LatLngPoint["a" /* LatLngPoint */].parse(cartesian).toCartesian();
      } //贴地对象的特殊处理


      options.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.heightReference, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].NONE);

      if (options.clampToGround) {
        options.heightReference = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND;
      }

      var eleId = this._getPopupId(target);

      this.close(eleId);
      var eventResult = options.event || {};
      delete options.event;
      this.objPopup[eleId] = Popup_objectSpread(Popup_objectSpread(Popup_objectSpread({}, eventResult), options), {}, {
        id: eleId,
        target: target,
        cartesian: cartesian
      }); //显示内容

      var inhtml;

      if (typeof_default()(target.popup) == "object") {
        for (var key in target.popup) {
          if (key == "html") {
            continue;
          }

          this.objPopup[eleId][key] = target.popup[key];
        }

        inhtml = target.popup.html;

        if (typeof target.popup.show == "function") {
          if (!target.popup.show(this.objPopup[eleId])) {
            return;
          }
        }
      } else {
        inhtml = target.popup;
      }

      if (!inhtml) {
        return;
      }

      if (typeof inhtml == "function") {
        //回调方法
        inhtml = inhtml(this.objPopup[eleId]);
      }

      if (inhtml instanceof Promise) {
        inhtml.then(function (inhtml) {
          _this2._camera_cache = null;
          remove(eleId);
          _this2.objPopup[eleId].content = inhtml;

          _this2._updateContent(eleId);
        });
        return;
      }

      if (!inhtml) {
        return;
      }

      this.objPopup[eleId].content = inhtml;

      this._updateContent(eleId);
    }
  }, {
    key: "_updateContent",
    value: function _updateContent(eleId) {
      var _item$graphic;

      var item = this.objPopup[eleId];

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](item.template, true)) {
        var closeHtml;

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](item.closeButton, true)) {
          closeHtml = "<span id=\"".concat(eleId, "-popup-close\" data-id=\"").concat(eleId, "\" class=\"tudou3d-popup-close-button tudou3d-popup-color closeButton\" >\xD7</span>");
        } else {
          closeHtml = "";
        }

        this._container.innerHTML = "\n      <div id=\"".concat(eleId, "\" class=\"tudou3d-popup tudou3d-popup-animation\">\n        ").concat(closeHtml, "\n        <div class=\"tudou3d-popup-content-wrapper tudou3d-popup-background\">\n          <div id=\"").concat(eleId, "-popup-content\"  class=\"tudou3d-popup-content tudou3d-popup-color\">").concat(item.content, "</div>\n        </div>\n        <div id=\"").concat(eleId, "-popup-btmtip\" class=\"tudou3d-popup-tip-container\">\n          <div class=\"tudou3d-popup-tip tudou3d-popup-background\"></div>\n        </div>\n      </div>");
      } else {
        this._container.innerHTML = "\n      <div id=\"".concat(eleId, "\" class=\"tudou3d-popup tudou3d-popup-animation\">\n        <div id=\"").concat(eleId, "-popup-content\" >").concat(item.content, "</div>\n      </div>");
      }

      var that = this; // let closeBtn = domUtil.get(eleId + "-popup-close");

      var closeBtn = this._container.querySelector(".closeButton");

      if (closeBtn) {
        closeBtn.addEventListener("click", function (e) {
          var eleId = this.getAttribute("data-id");
          that.close(eleId, true);
        });
      } //计算显示位置


      if (item.popupPosition) {
        //固定显示，类似弹窗
        this.showFixViewPoint(eleId, item);
        remove(eleId + "-popup-btmtip"); //去掉小箭头
      } else {
        this._camera_cache = null;

        var result = this._updatePosition(eleId, item);

        if (!result && this._depthTest) {
          this.close(eleId);
          return;
        }
      } //popup的DOM添加到页面的回调方法


      if (item.onAdd) {
        item.onAdd(item);
        delete item.onAdd;
      }

      if ((_item$graphic = item.graphic) !== null && _item$graphic !== void 0 && _item$graphic.fire) {
        item.graphic.fire(EventType.popupOpen, item, true);
      }
    }
  }, {
    key: "_updatePosition",
    value: function _updatePosition(eleId, item) {
      var _this$parentContainer, _this$parentContainer2;

      var popup = item.target.popup;

      if (!popup) {
        return false;
      }

      var _position;

      if (item.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].CLAMP_TO_GROUND) {
        var _this$_map;

        _position = Object(PointUtil["getSurfacePosition"])(this._map, Object(PointUtil["getPositionValue"])(item.cartesian, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime));
      } else if (item.heightReference == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["HeightReference"].RELATIVE_TO_GROUND) {
        var _this$_map2;

        _position = Object(PointUtil["getSurfacePosition"])(this._map, Object(PointUtil["getPositionValue"])(item.cartesian, (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : _this$_map2.clock.currentTime), {
          relativeHeight: true
        });
      } else {
        var _this$_map3;

        _position = Object(PointUtil["getPositionValue"])(item.cartesian, (_this$_map3 = this._map) === null || _this$_map3 === void 0 ? void 0 : _this$_map3.clock.currentTime);
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_position)) {
        return false;
      } //更新html ，实时更新


      if (typeof_default()(popup) == "object" && popup.timeRender && popup.html && typeof popup.html == "function") {
        var inhtml = popup.html(item, _position);
        item.content = inhtml;
        var containerContent = DomUtil_get("".concat(eleId, "-popup-content"));

        if (containerContent) {
          containerContent.innerHTML = inhtml;
        }
      } //如果视角和位置都没有变化，直接返回


      var camera = this._map.camera;

      var _thiscache = "".concat(_position.x).concat(_position.y).concat(_position.z).concat((_this$parentContainer = this.parentContainer) === null || _this$parentContainer === void 0 ? void 0 : _this$parentContainer.clientWidth).concat((_this$parentContainer2 = this.parentContainer) === null || _this$parentContainer2 === void 0 ? void 0 : _this$parentContainer2.clientHeight).concat(camera.positionWC.y).concat(camera.positionWC.z).concat(camera.heading).concat(camera.pitch).concat(camera.roll);

      if (_thiscache == this._camera_cache) {
        return true;
      }

      this._camera_cache = _thiscache; //如果视角和位置都没有变化，直接返回

      var windowPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneTransforms"].wgs84ToWindowCoordinates(this._map.scene, _position);

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](windowPosition)) {
        item.windowPosition = windowPosition;
      }

      var container = DomUtil_get(eleId);

      if (!container) {
        return;
      }

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](item.windowPosition)) {
        container.style.display = "none";
        Object(Log["logInfo"])("Cesium.SceneTransforms.wgs84ToWindowCoordinates 无法转换为屏幕坐标", _position);
        return true;
      } //判断是否在球的背面


      var scene = this._map.scene; //三维模式下

      if (this._depthTest && scene.mode == external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneMode"].SCENE3D) {
        var occluder = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EllipsoidalOccluder"](scene.globe.ellipsoid, scene.camera.positionWC); //判断点是否在地球的背面。

        if (!occluder.isPointVisible(_position)) {
          container.style.display = "none";
          return true;
        }
      } //判断是否在球的背面


      container.style.left = item.windowPosition.x + "px";
      container.style.top = item.windowPosition.y + "px";
      container.style.display = "block";
      var x = item.windowPosition.x - container.offsetWidth / 2;
      var y = item.windowPosition.y - container.offsetHeight;

      if (popup && typeof_default()(popup) == "object" && popup.anchor) {
        x += popup.anchor[0];
        y += popup.anchor[1];
      }

      container.style.left = x + "px";
      container.style.top = y + "px";
      return true;
    } //固定显示再一个配置的popupPosition位置（类似弹窗）

  }, {
    key: "showFixViewPoint",
    value: function showFixViewPoint(eleId, target) {
      var position = target.cartesian,
          popup = target.popup,
          popupPosition = target.popupPosition; //更新html ，实时更新

      if (typeof_default()(popup) == "object" && popup.timeRender && popup.html && typeof popup.html == "function") {
        var inhtml = popup.html(this.objPopup[eleId], position);
        var containerContent = DomUtil_get("".concat(eleId, "-popup-content"));

        if (containerContent) {
          containerContent.innerHTML = inhtml;
        }
      }

      var container = DomUtil_get(eleId);

      if (!container) {
        return;
      }

      var x = 0;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](popupPosition.left)) {
        x = popupPosition.left;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](popupPosition.right)) {
        x = document.documentElement.clientWidth - container.offsetWidth - popupPosition.right;
      }

      var y = 0;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](popupPosition.top)) {
        y = popupPosition.top;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](popupPosition.bottom)) {
        y = document.documentElement.clientHeight - container.offsetHeight - popupPosition.bottom;
      }

      container.style.left = x + "px";
      container.style.top = y + "px";
      return true;
    }
  }, {
    key: "_postRenderHandler",
    value: function _postRenderHandler() {
      for (var i in this.objPopup) {
        var item = this.objPopup[i];

        if (item.popupPosition) {
          continue;
        }

        var result = this._updatePosition(i, item);

        if (!result && this._depthTest) {
          this.close(i);
        }
      }
    }
  }, {
    key: "close",
    value: function close(eleId, removFea) {
      if (eleId) {
        if (typeof_default()(eleId) == "object") {
          //传入参数是eneity对象
          eleId = this._getPopupId(eleId);
        }

        for (var i in this.objPopup) {
          var item = this.objPopup[i];

          if (eleId == item.id || eleId == i) {
            if (DomUtil_get(i)) {
              var _item$graphic2;

              //popup的DOM从页面移除的回调方法
              if (item.onRemove) {
                item.onRemove(item);
                delete item.onRemove;
              }

              if ((_item$graphic2 = item.graphic) !== null && _item$graphic2 !== void 0 && _item$graphic2.fire) {
                item.graphic.fire(EventType.popupClose, item, true);
              }

              remove(i);
            } // delete this.objPopup[i]


            break;
          }
        }
      } else if (this._isOnly) {
        //移除全部
        for (var _i in this.objPopup) {
          var _item = this.objPopup[_i]; //popup的DOM从页面移除的回调方法

          if (_item && _item.onRemove && DomUtil_get(_i)) {
            _item.onRemove(_item);

            delete _item.onRemove;
          }
        }

        this._container.innerHTML = "";
        this.objPopup = {};
      }

      this._camera_cache = null;

      if (removFea) {
        this._map._mouseEvent.removeHighlighted();
      }
    }
  }]);

  return Popup;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/map/control/Tooltip.js







function Tooltip_createSuper(Derived) { var hasNativeReflectConstruct = Tooltip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Tooltip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var Tooltip_Tooltip = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(Tooltip, _BaseControl);

  var _super = Tooltip_createSuper(Tooltip);

  //========== 构造方法 ==========
  function Tooltip() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, Tooltip);

    _this = _super.call(this, options);
    _this.options.cacheTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.cacheTime, 20);
    return _this;
  } //========== 方法 ==========

  /**
   * 创建_container控件容器对象的方法，
   * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
   * @return {void}  无
   * @private
   */


  createClass_default()(Tooltip, [{
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div", "tudou3d-popup");
      this._container.id = this.parentContainerId + "-tudou3d-tooltip-view";
      this._container.style.display = "none";
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.mouseMoveTarget, this._mouseMoveHandler, this);

      this._map.on(EventType.mouseDown, this._mouseDownHandler, this);

      this._map.on(EventType.mouseUp, this._mouseUpHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.mouseMoveTarget, this._mouseMoveHandler, this);

      this._map.off(EventType.mouseDown, this._mouseDownHandler, this);

      this._map.off(EventType.mouseUp, this._mouseUpHandler, this);
    } //========== 内部方法 ==========

  }, {
    key: "_mouseDownHandler",
    value: function _mouseDownHandler(event) {
      this._isMouseUpdownPressed = true;
      this.close();
    }
  }, {
    key: "_mouseUpHandler",
    value: function _mouseUpHandler(event) {
      this._isMouseUpdownPressed = false;
    } //鼠标移动事件，setTimeout是为了优化效率

  }, {
    key: "_mouseMoveHandler",
    value: function _mouseMoveHandler(event) {
      var _this2 = this;

      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }

      if (this._isMouseUpdownPressed || !this._enabled || this._map.scene.screenSpaceCameraController.enableRotate == false || this._map.scene.screenSpaceCameraController.enableTilt == false || this._map.scene.screenSpaceCameraController.enableTranslate == false) {
        this.close();
        return;
      }

      this.moveTimer = setTimeout(function () {
        delete _this2.moveTimer;

        _this2._mouseMoveWork(event);
      }, this.options.cacheTime);
    } //鼠标移动事件

  }, {
    key: "_mouseMoveWork",
    value: function _mouseMoveWork(event) {
      var _event$layer;

      //cesium 本身的 entity、primitive对象
      if (this._openByMove(event.czmObject, event)) {
        return;
      } //tudou3d 的 BaseGraphic 继承对象


      if (this._openByMove(event.graphic, event)) {
        return;
      } //tudou3d 的 BaseGraphicLayer 继承对象


      if (this._openByMove(event.layer, event)) {
        return;
      } //tudou3d 的 GroupLayer


      if (this._openByMove((_event$layer = event.layer) === null || _event$layer === void 0 ? void 0 : _event$layer.parent, event)) {
        return;
      }

      this.close();
    }
  }, {
    key: "_openByMove",
    value: function _openByMove(target, event) {
      if (!target || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](target.tooltip)) {
        return false;
      }

      if (target.tooltip == false) {
        //false时关闭右键，不再往上冒泡
        return true;
      }

      this.open(event.cartesian, target, {
        windowPosition: event.windowPosition,
        event: event
      });
      return true;
    }
  }, {
    key: "_showHook",
    value: function _showHook() {
      if (!this._show) {
        if (this.moveTimer) {
          clearTimeout(this.moveTimer);
          delete this.moveTimer;
        }

        if (this.onRemove) {
          this.onRemove(this._last_eventResult);
          delete this.onRemove;
        }
      }
    }
  }, {
    key: "close",
    value: function close() {
      this.show = false;
    }
  }, {
    key: "open",
    value: function open(cartesian, target) {
      var _this$_map, _target$tooltip;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (target == null || target.tooltip == null) {
        return;
      }

      cartesian = Object(PointUtil["getPositionValue"])(cartesian, (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.clock.currentTime); //计算显示位置

      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.windowPosition)) {
        options.windowPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneTransforms"].wgs84ToWindowCoordinates(this._map.scene, cartesian);
      }

      if (options.windowPosition == null) {
        this.close();
        return;
      } // if (this._lastTooltipEntity != target) {


      var eventResult = options.event || {};
      delete options.event;
      eventResult.target = target;
      eventResult.cartesian = cartesian;
      this._last_eventResult = eventResult; //避免鼠标移动时重复构造DOM
      //显示内容

      var inhtml;
      var onAdd;

      if (typeof_default()(target.tooltip) == "object") {
        inhtml = target.tooltip.html;
        onAdd = target.tooltip.onAdd;
        this.onRemove = target.tooltip.onRemove;

        if (typeof target.tooltip.show == "function") {
          if (!target.tooltip.show(eventResult)) {
            this.close();
            return;
          }
        }
      } else {
        inhtml = target.tooltip;
      }

      if (typeof inhtml == "function") {
        inhtml = inhtml(eventResult); //回调方法
      }

      if (!inhtml) {
        this.close();
        return;
      }

      this.show = true;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"]((_target$tooltip = target.tooltip) === null || _target$tooltip === void 0 ? void 0 : _target$tooltip.template, true)) {
        this._container.innerHTML = "\n        <div class=\"tudou3d-popup-content-wrapper  tudou3d-popup-background\">\n            <div id=\"".concat(this.parentContainerId, "-tudou3d-tooltip-content\" class=\"tudou3d-popup-content tudou3d-popup-color\">").concat(inhtml, "</div>\n        </div>\n        <div class=\"tudou3d-popup-tip-container\"><div class=\"tudou3d-popup-tip  tudou3d-popup-background\"></div></div>\n        ");
      } else {
        this._container.innerHTML = inhtml;
      } //tooltip的DOM添加到页面的回调方法


      if (onAdd) {
        onAdd(eventResult);
      } // }
      // this._lastTooltipEntity = target
      //定位位置


      var x = options.windowPosition.x - this._container.offsetWidth / 2;
      var y = options.windowPosition.y - this._container.offsetHeight;
      var tooltip = target.tooltip;

      if (tooltip && typeof_default()(tooltip) == "object" && tooltip.anchor) {
        x += tooltip.anchor[0];
        y += tooltip.anchor[1];
      } else {
        y -= 15; //默认偏上10像素
      }

      this._container.style.left = x + "px";
      this._container.style.top = y + "px";
    }
  }]);

  return Tooltip;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/map/control/SmallTooltip.js






function SmallTooltip_createSuper(Derived) { var hasNativeReflectConstruct = SmallTooltip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function SmallTooltip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



 //小tooltip，一般用于鼠标操作的提示
//比如标绘中使用

var SmallTooltip_SmallTooltip = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(SmallTooltip, _BaseControl);

  var _super = SmallTooltip_createSuper(SmallTooltip);

  function SmallTooltip() {
    classCallCheck_default()(this, SmallTooltip);

    return _super.apply(this, arguments);
  }

  createClass_default()(SmallTooltip, [{
    key: "direction",
    get: //方向，默认false右侧，true为左侧
    function get() {
      return this.options.direction;
    },
    set: function set(value) {
      this.options.direction = value;

      if (value) {
        //left css时
        addClass(this._containerArrow, "tudou3d-smallTooltip-leftArrow");
        removeClass(this._containerArrow, "tudou3d-smallTooltip-rightArrow");
      } else {
        //right css时
        addClass(this._containerArrow, "tudou3d-smallTooltip-rightArrow");
        removeClass(this._containerArrow, "tudou3d-smallTooltip-leftArrow");
      }
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(show) {
      this.show = show;
    }
    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      var _this = this;

      this._container = create("div", "tudou3d-smallTooltip");
      this._container.style.display = "none";
      this._containerArrow = create("div", "tudou3d-smallTooltip-arrow tudou3d-smallTooltip-rightArrow", this._container);
      this._containerContent = create("div", "tudou3d-smallTooltip-inner", this._container); //鼠标的移入

      this._container.addEventListener("click", function (e) {
        _this.close();
      });
    }
  }, {
    key: "close",
    value: function close() {
      this._container.style.display = "none";
    }
  }, {
    key: "open",
    value: function open(position, message) {
      if (!this.enabled) {
        return;
      }

      if (position && message) {
        if (position instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]) {
          position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneTransforms"].wgs84ToWindowCoordinates(this._map.scene, position);
        }

        this._container.style.display = "block";
        this._containerContent.innerHTML = message;
        this._container.style.top = position.y - this._container.clientHeight / 2 + "px";

        if (this.options.direction) {
          //left css时
          this._container.style.left = position.x - this._container.clientWidth - 25 + "px";
        } else {
          //right css时
          this._container.style.left = position.x + 25 + "px";
        }
      } else {
        this._container.style.display = "none";
      }
    }
  }]);

  return SmallTooltip;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/map/control/ContextMenu.js







function ContextMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ContextMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ContextMenu_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ContextMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ContextMenu_createSuper(Derived) { var hasNativeReflectConstruct = ContextMenu_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ContextMenu_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var ContextMenu_ContextMenu = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(ContextMenu, _BaseControl);

  var _super = ContextMenu_createSuper(ContextMenu);

  //========== 构造方法 ==========
  function ContextMenu() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, ContextMenu);

    _this = _super.call(this, options);
    _this.menuIndex = 0;
    _this.objMenu = {};

    if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](_this.options.preventDefault, true)) {
      document.oncontextmenu = function (e) {
        e.preventDefault();
      };
    }

    return _this;
  } //========== 对外属性 ==========


  createClass_default()(ContextMenu, [{
    key: "target",
    get: function get() {
      return this._target;
    } //========== 方法 ==========

  }, {
    key: "_enabledHook",
    value: function _enabledHook() {
      this._target = null;
    }
    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */

  }, {
    key: "_mountedHook",
    value: function _mountedHook() {
      this._container = create("div", "tudou3d-contextmenu");
      this._container.style.display = "none";
      this._containerUl = create("ul", "tudou3d-contextmenu-ul", this._container);
      this._containerUl.id = this.parentContainerId + "-tudou3d-contextmenu-ul";
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.leftDown, this.close, this);

      this._map.on(EventType.middleDown, this.close, this);

      this._map.on(EventType.wheel, this.close, this);

      this._map.on(EventType.rightClick, this._rightClickHandler, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.leftDown, this.close, this);

      this._map.off(EventType.middleDown, this.close, this);

      this._map.off(EventType.wheel, this.close, this);

      this._map.off(EventType.rightClick, this._rightClickHandler, this);

      this._target = null;
    } //========== 内部方法 ==========

  }, {
    key: "_rightClickHandler",
    value: function _rightClickHandler(event) {
      var _event$layer;

      this.close();

      if (!this.enabled) {
        return;
      } //cesium 本身的 entity、primitive对象


      if (this._openByClick(event.czmObject, event)) {
        return;
      } //tudou3d 的 BaseGraphic 继承对象


      if (this._openByClick(event.graphic, event)) {
        return;
      } //tudou3d 的 BaseGraphicLayer 继承对象


      if (this._openByClick(event.layer, event)) {
        return;
      } //tudou3d 的 GroupLayer


      if (this._openByClick((_event$layer = event.layer) === null || _event$layer === void 0 ? void 0 : _event$layer.parent, event)) {
        return;
      }

      this._openByClick(this._map, event);
    }
  }, {
    key: "_openByClick",
    value: function _openByClick(target, event) {
      if (!target || !external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](target.contextmenuItems)) {
        return false;
      }

      if (target.contextmenuItems == false) {
        //false时关闭右键，不再往上冒泡
        return true;
      }

      this.open(event.cartesian, target, {
        windowPosition: event.windowPosition,
        event: event
      });
      return true;
    }
  }, {
    key: "close",
    value: function close() {
      this.show = false;
    }
  }, {
    key: "open",
    value: function open(cartesian, target) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var contextmenu = target.contextmenuItems;

      if (!contextmenu || contextmenu.length == 0) {
        this.close();
        return;
      } //计算显示位置


      if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.windowPosition)) {
        options.windowPosition = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["SceneTransforms"].wgs84ToWindowCoordinates(this._map.scene, cartesian);
      }

      var eventResult = ContextMenu_objectSpread(ContextMenu_objectSpread({}, options.event || {}), {}, {
        windowPosition: options.windowPosition,
        position: cartesian,
        target: target
      });

      var inhtml = "";

      for (var i = 0, len = contextmenu.length; i < len; i++) {
        var item = contextmenu[i];

        var result = this._getItemHtml(item, eventResult);

        if (result) {
          inhtml += result;
        }
      }

      if (inhtml == "") {
        this.close();
        return;
      }

      var that = this;
      this._containerUl.innerHTML = inhtml;

      var contextmenuItemList = this._containerUl.querySelectorAll(".contextmenu-item");

      for (var _i = 0; _i < contextmenuItemList.length; _i++) {
        var contextmenuItem = contextmenuItemList[_i];
        contextmenuItem.addEventListener("click", function (e) {
          var index = Number(this.getAttribute("data-index"));
          var item = that.objMenu[index];
          var callback = item.callback;

          if (callback) {
            callback(ContextMenu_objectSpread(ContextMenu_objectSpread({}, eventResult), {}, {
              data: item
            }));
          }

          that.close();
        }); //鼠标滑过弹出二级菜单

        contextmenuItem.addEventListener("mouseover", function (e) {
          //所有的二级菜单隐藏
          var oldsub = that._container.querySelectorAll(".tudou3d-sub-menu");

          for (var j = 0; j < oldsub.length; j++) {
            oldsub[j].style.display = "none";
          }

          var sub_menu = this.querySelector(".tudou3d-sub-menu");

          if (sub_menu) {
            sub_menu.style.display = "block";
          }

          removeClass(that._containerUl.querySelector(".active"), "active");
          addClass(this, "active");
        });
      } //不显示前，无法计算width和width


      this.show = true;
      var top = options.windowPosition.y;
      var left = options.windowPosition.x;
      this._container.style.left = left + "px";
      this._container.style.top = top + "px";
      this._target = target;
      var menuHeight = this._container.offsetHeight;
      var menuWidth = this._container.offsetWidth;

      var subItem = this._containerUl.querySelectorAll(".tudou3d-sub-menu");

      var subLeft = menuWidth + 3 + "px";

      for (var j = 0; j < subItem.length; j++) {
        subItem[j].style.left = subLeft;
      } //判断垂直方向 是否超过了 屏幕高度


      if (top + menuHeight > this._map.scene.canvas.clientHeight) {
        top -= menuHeight - 10;

        if (top <= 0) {
          top = 0;
        }
      } else {
        top += 10;
      } //判断水平方向 是否超过了屏幕宽度


      if (left + menuWidth > this._map.scene.canvas.clientWidth) {
        left -= menuWidth - 10;

        if (left <= 0) {
          left = 0;
        }
      } else {
        left += 10;
      }

      this._container.style.left = left + "px";
      this._container.style.top = top + "px";
    }
  }, {
    key: "_getItemHtml",
    value: function _getItemHtml(item, eventresult) {
      if (item.hasOwnProperty("show")) {
        var show = item.show;

        try {
          if (typeof show == "function") {
            //回调方法
            eventresult.data = item;
            show = item.show(eventresult);
          }
        } catch (e) {
          Object(Log["logError"])("右键菜单操作出错", e);
        }

        if (!show) {
          return null;
        }
      }

      var inhtml;

      if (item.text) {
        var childrenHtml = "";
        var childTip = "";

        if (item.children) {
          childrenHtml = '<ul class="tudou3d-contextmenu-ul tudou3d-sub-menu">';

          for (var j = 0, len2 = item.children.length; j < len2; j++) {
            var childitem = item.children[j];
            eventresult.data = childitem;

            var result = this._getItemHtml(childitem, eventresult);

            if (result) {
              childrenHtml += result;
            }
          }

          childrenHtml += "</ul>";
          childTip = '&nbsp;&nbsp;<i class="fa fa-caret-right"></i>';
        }

        this.menuIndex++;
        this.objMenu[this.menuIndex] = item;
        inhtml = "<li class=\"contextmenu-item\" data-index=\"".concat(this.menuIndex, "\">\n                        <a href=\"javascript:void(0)\"><i class=\"").concat(item.iconCls, "\"></i>").concat(item.text).concat(childTip, "</a>\n                        ").concat(childrenHtml, "\n                    </li>");
      } else {
        inhtml = '<li class="line"></li>';
      }

      return inhtml;
    }
  }]);

  return ContextMenu;
}(BaseControl_BaseControl);
// CONCATENATED MODULE: ./src/map/control/KeyboardRoam.js







function KeyboardRoam_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function KeyboardRoam_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { KeyboardRoam_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { KeyboardRoam_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function KeyboardRoam_createSuper(Derived) { var hasNativeReflectConstruct = KeyboardRoam_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function KeyboardRoam_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




/**
 * 相机旋转的类型
 *  @private
 */

var MoveType = {
  /**
   * 向屏幕中心靠近
   */
  ENLARGE: 0,

  /**
   * 向屏幕中心远离
   */
  NARROW: 1,

  /**
   * 相机原地左旋转
   */
  LEFT_ROTATE: 2,

  /**
   * 相机原地右旋转
   */
  RIGHT_ROTATE: 3,

  /**
   * 相机原地上旋转
   */
  TOP_ROTATE: 4,

  /**
   * 相机原地下旋转
   */
  BOTTOM_ROTATE: 5
};
/**
 * 键盘漫游控制类
 *
 * @export
 * @class KeyboardRoam
 * @extends {BaseControl}
 */

var KeyboardRoam_KeyboardRoam = /*#__PURE__*/function (_BaseControl) {
  inherits_default()(KeyboardRoam, _BaseControl);

  var _super = KeyboardRoam_createSuper(KeyboardRoam);

  //========== 构造方法 ==========
  function KeyboardRoam() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, KeyboardRoam);

    _this = _super.call(this, options); //赋值参数

    _this.setOptions(options);

    _this.flags = {
      moveForward: false,
      moveBackward: false,
      moveUp: false,
      moveDown: false,
      moveLeft: false,
      moveRight: false
    };
    return _this;
  } //========== 对外属性 ==========

  /**
   *  平移步长 (米)
   * @type {Number}
   */


  createClass_default()(KeyboardRoam, [{
    key: "moveStep",
    get: function get() {
      return this._moveStep;
    },
    set: function set(value) {
      this._moveStep = value;
    }
    /**
     * 相机原地旋转步长，值越大步长越小。
     * @type {Number}
     */

  }, {
    key: "dirStep",
    get: function get() {
      return this._dirStep;
    },
    set: function set(value) {
      this._dirStep = value;
    }
    /**
     * 相机围绕目标点旋转速率，0.3 - 2.0
     * @type {Number}
     */

  }, {
    key: "rotateStep",
    get: function get() {
      return this._rotateStep;
    },
    set: function set(value) {
      this._rotateStep = value;
    }
    /**
     * 最小仰角  0 - 1
     * @type {Number}
     */

  }, {
    key: "minPitch",
    get: function get() {
      return this._minPitch;
    },
    set: function set(value) {
      this._minPitch = value;
    }
    /**
     * 最大仰角  0 - 1
     * @type {Number}
     */

  }, {
    key: "maxPitch",
    get: function get() {
      return this._maxPitch;
    },
    set: function set(value) {
      this._maxPitch = value;
    }
    /**
     * 最低高度（单位：米）
     * @type {Number}
     */

  }, {
    key: "minHeight",
    get: function get() {
      return this._minHeight;
    },
    set: function set(value) {
      this._minHeight = value;
    } //========== 方法 ==========

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.options = KeyboardRoam_objectSpread(KeyboardRoam_objectSpread({}, this.options), options);
      this._moveStep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.moveStep, 10); //平移步长 (米)

      this._dirStep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.dirStep, 25); //相机原地旋转步长，值越大步长越小。

      this._rotateStep = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.rotateStep, 1.0); //相机围绕目标点旋转速率，0.3 - 2.0

      this._minPitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.minPitch, 0.1); //最小仰角  0 - 1

      this._maxPitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.maxPitch, 0.95); //最大仰角  0 - 1

      this._minHeight = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](this.options.minHeight, 0);
      return this;
    }
    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_addedHook",
    value: function _addedHook() {
      this._map.on(EventType.keydown, this._onKeyDown, this);

      this._map.on(EventType.keyup, this._onKeyUp, this);

      this._map.on(EventType.clockTick, this._onClockTick, this);
    }
    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */

  }, {
    key: "_removedHook",
    value: function _removedHook() {
      this._map.off(EventType.keydown, this._onKeyDown, this);

      this._map.off(EventType.keyup, this._onKeyUp, this);

      this._map.off(EventType.clockTick, this._onClockTick, this);
    } //=================相关事件回调方法======================

  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this.enabled) {
        return;
      }

      var flagName = this._getFlagForKeyCode(event.keyCode);

      if (typeof flagName != "undefined") {
        this.flags[flagName] = true;
      }
    }
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp(event) {
      if (!this.enabled) {
        return;
      }

      var flagName = this._getFlagForKeyCode(event.keyCode);

      if (typeof flagName != "undefined") {
        this.flags[flagName] = false;
      }
    }
    /**
     * 刘成蓉 2021-07-28
     * 修改键盘漫游键值 具体如下：
     * 1、视角平移
     * 向前W、向后S、向左A、向右D、升高Q、降低E
     * 对应MarsDemo： W、S、A、D、Q、E
     * 2、视角变化
     * 抬高I、降低K、向左J、向右L、拉近U、远离O
     * 对应MarsDemo：↑、↓、←、→、I、K
     * 3、中心旋转
     * 向左←、向右→、向上↑、向下↓
     * 对应MarsDemo：J、L、U、O
     *
     */

  }, {
    key: "_getFlagForKeyCode",
    value: function _getFlagForKeyCode(keyCode) {
      switch (keyCode) {
        //视角平移
        case "W".charCodeAt(0):
          //向前平移镜头，不改变相机朝向
          return "moveForward";

        case "S".charCodeAt(0):
          //向后平移镜头，不改变相机朝向
          return "moveBackward";

        case "D".charCodeAt(0):
          //向右平移镜头，不改变相机朝向
          return "moveRight";

        case "A".charCodeAt(0):
          //向左平移镜头，不改变相机朝向
          return "moveLeft";

        case "Q".charCodeAt(0):
          //向上平移镜头，不改变相机朝向
          return "moveUp";

        case "E".charCodeAt(0):
          //向下平移镜头，不改变相机朝向
          return "moveDown";
        //视角变化

        case "I".charCodeAt(0):
          this.rotateCamera(MoveType.TOP_ROTATE); //相机原地上旋转

          break;

        case "J".charCodeAt(0):
          this.rotateCamera(MoveType.LEFT_ROTATE); //相机原地左旋转

          break;

        case "L".charCodeAt(0):
          this.rotateCamera(MoveType.RIGHT_ROTATE); //相机原地右旋转

          break;

        case "K".charCodeAt(0):
          this.rotateCamera(MoveType.BOTTOM_ROTATE); //相机原地下旋转

          break;

        case "U".charCodeAt(0):
          this.moveCamera(MoveType.ENLARGE); //向屏幕中心靠近

          break;

        case "O".charCodeAt(0):
          this.moveCamera(MoveType.NARROW); //向屏幕中心远离

          break;
        //中心旋转

        case 37:
          //方向键左键
          //case 100: //数字键盘4
          this.moveCamera(MoveType.LEFT_ROTATE); //围绕屏幕中心左旋转

          break;

        case 39:
          //方向键右键
          //case 102: //数字键盘6
          this.moveCamera(MoveType.RIGHT_ROTATE); //围绕屏幕中心右旋转

          break;

        case 38:
          //方向键上键
          //case 103: //数字键盘7
          this.moveCamera(MoveType.TOP_ROTATE); //围绕屏幕中心上旋转

          break;

        case 40:
          //方向键下键
          //case 105: //数字键盘9
          this.moveCamera(MoveType.BOTTOM_ROTATE); //围绕屏幕中心下旋转

          break;

        default:
          break;
      }

      return undefined;
    } //=================平移======================

    /**
     * 开始自动向前平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "startMoveForward",
    value: function startMoveForward() {
      this.flags["moveForward"] = true;
    }
    /**
     * 停止自动向前平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "stopMoveForward",
    value: function stopMoveForward() {
      this.flags["moveForward"] = false;
    }
    /**
     * 开始自动向后平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "startMoveBackward",
    value: function startMoveBackward() {
      this.flags["moveBackward"] = true;
    }
    /**
     * 停止自动向后平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "stopMoveBackward",
    value: function stopMoveBackward() {
      this.flags["moveBackward"] = false;
    }
    /**
     *开始自动向右平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "startMoveRight",
    value: function startMoveRight() {
      this.flags["moveRight"] = true;
    }
    /**
     * 停止自动向右平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "stopMoveRight",
    value: function stopMoveRight() {
      this.flags["moveRight"] = false;
    }
    /**
     *开始自动向左平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "startMoveLeft",
    value: function startMoveLeft() {
      this.flags["moveLeft"] = true;
    }
    /**
     * 停止自动向左平移镜头，不改变相机朝向
     * @return {void}  无
     */

  }, {
    key: "stopMoveLeft",
    value: function stopMoveLeft() {
      this.flags["moveLeft"] = false;
    }
  }, {
    key: "moveForward",
    value: function moveForward(distance) {
      //和模型的相机移动不太一样  不是沿着相机目标方向，而是默认向上方向 和 向右 方向的插值方向
      var camera = this._map.camera;
      var direction = camera.direction; //获得此位置默认的向上方向

      var up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(camera.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); // right = direction * up

      var right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(direction, up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(up, right, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(direction, direction);
      direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].multiplyByScalar(direction, distance, direction);
      camera.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].add(camera.position, direction, camera.position);
    }
  }, {
    key: "_onClockTick",
    value: function _onClockTick(clock) {
      if (!this.enabled) {
        return;
      }

      var camera = this._map.camera; // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
      // var cameraHeight = this._map.scene.globe.ellipsoid.cartesianToCartographic(camera.position).height;
      // var moveRate = cameraHeight / this.moveStep;

      var moveRate = this.moveStep;

      if (this.flags.moveForward) {
        this.moveForward(moveRate);
      }

      if (this.flags.moveBackward) {
        this.moveForward(-moveRate);
      }

      if (this.flags.moveUp) {
        camera.moveUp(moveRate);
      }

      if (this.flags.moveDown) {
        if (camera.positionCartographic.height - moveRate >= this.minHeight) {
          camera.moveDown(moveRate);
        }
      }

      if (this.flags.moveLeft) {
        camera.moveLeft(moveRate);
      }

      if (this.flags.moveRight) {
        camera.moveRight(moveRate);
      }
    } //=================相对于屏幕或相机======================

  }, {
    key: "_resetCamera",
    value: function _resetCamera(newCamera) {
      if (!newCamera) {
        return;
      }

      this._map.scene.camera.position = newCamera.position;
      this._map.scene.camera.direction = newCamera.direction;
      this._map.scene.camera.right = newCamera.right;
      this._map.scene.camera.up = newCamera.up;
    }
  }, {
    key: "_limitAngle",
    value: function _limitAngle(up, position, type) {
      var dotNum = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].dot(up, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()));

      if (type == "up" && dotNum < this.minPitch) {
        return false;
      }

      if (type == "down" && dotNum > this.maxPitch) {
        return false;
      }

      return true;
    }
  }, {
    key: "_computedNewPos",
    value: function _computedNewPos(camera, dir, rotate) {
      // var step = this.rotateStep;
      var oldpos = camera.position;

      var winCenter = this._map.getCenter();

      if (!winCenter) {
        return;
      }

      var center = winCenter.toCartesian();

      if (!center) {
        return;
      }

      var oldDis = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(center, oldpos);
      var step = oldDis / 100;
      step = rotate ? step * this.rotateStep : step;
      var newCamera = {};
      var ray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](oldpos, dir);
      newCamera.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(ray, step); // var cheight = Cesium.Cartographic.fromCartesian(newCamera.position).height;
      // if (cheight < 500)   return;

      newCamera.direction = camera.direction;
      newCamera.right = camera.right;
      newCamera.up = camera.up;

      if (rotate) {
        var newDir = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].subtract(newCamera.position, center, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        ray = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"](center, newDir);
        newCamera.position = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Ray"].getPoint(ray, oldDis);
        newCamera.direction = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(newDir, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); // newCamera.up = camera.up;

        newCamera.up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(newCamera.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
        newCamera.right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(newCamera.direction, newCamera.up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      }

      return newCamera;
    }
    /**
     * 相对于屏幕中心点 转动
     *
     * @param {MoveType} type 旋转的方向
     * @return {void}  无
     */

  }, {
    key: "moveCamera",
    value: function moveCamera(type) {
      var camera = this._map.scene.camera;
      var newCamera;

      switch (type) {
        default:
        case MoveType.ENLARGE:
          newCamera = this._computedNewPos(camera, camera.direction);
          break;

        case MoveType.NARROW:
          newCamera = this._computedNewPos(camera, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(camera.direction, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()));
          break;

        case MoveType.LEFT_ROTATE:
          newCamera = this._computedNewPos(camera, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(camera.right, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), true);
          break;

        case MoveType.RIGHT_ROTATE:
          newCamera = this._computedNewPos(camera, camera.right, true);
          break;

        case MoveType.TOP_ROTATE:
          if (!this._limitAngle(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.up), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.position), "up")) {
            return;
          }

          newCamera = this._computedNewPos(camera, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.up), true);
          break;

        case MoveType.BOTTOM_ROTATE:
          if (!this._limitAngle(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.up), external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["clone"](camera.position), "down")) {
            return;
          }

          newCamera = this._computedNewPos(camera, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].negate(camera.up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()), true);
          break;
      }

      if (!newCamera) {
        return;
      }

      this._resetCamera(newCamera);
    }
    /**
     * 相对于相机本身 转动
     *
     * @param {MoveType} type 旋转的方向
     * @return {void}  无
     */

  }, {
    key: "rotateCamera",
    value: function rotateCamera(type) {
      var winPos = [0, 0];
      var width = this._map.scene.canvas.clientWidth;
      var height = this._map.scene.canvas.clientHeight;
      var step = (width + height) / this.dirStep;

      switch (type) {
        case MoveType.LEFT_ROTATE:
          winPos = [-step * width / height, 0];
          break;

        case MoveType.RIGHT_ROTATE:
          winPos = [step * width / height, 0];
          break;

        case MoveType.TOP_ROTATE:
          winPos = [0, step];
          break;

        case MoveType.BOTTOM_ROTATE:
          winPos = [0, -step];
          break;

        default:
          return;
      }

      var x = winPos[0] / width;
      var y = winPos[1] / height; //这计算了，分别向右 和 向上移动的

      var lookFactor = 0.05;
      var camera = this._map.camera;
      camera.lookRight(x * lookFactor);
      camera.lookUp(y * lookFactor); //获得direction 方向

      var direction = camera.direction; //获得此位置默认的向上方向

      var up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].normalize(camera.position, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); // right = direction * up

      var right = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(direction, up, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]()); // up = right * direction

      up = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].cross(right, direction, new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"]());
      camera.up = up;
      camera.right = right;
    }
  }]);

  return KeyboardRoam;
}(BaseControl_BaseControl);
/**
 * 相机旋转的类型
 * @property {Int} 	ENLARGE 向屏幕中心靠近
 * @property {Int} 	NARROW 向屏幕中心远离
 * @property {Int} 	LEFT_ROTATE 相机原地左旋转
 * @property {Int} 	RIGHT_ROTATE 相机原地右旋转
 * @property {Int} 	TOP_ROTATE 相机原地上旋转
 * @property {Int} 	BOTTOM_ROTATE 相机原地下旋转
 */

KeyboardRoam_KeyboardRoam.MoveType = MoveType;
// CONCATENATED MODULE: ./src/map/core/GaodePOIGeocoder.js




function GaodePOIGeocoder_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function GaodePOIGeocoder_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GaodePOIGeocoder_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GaodePOIGeocoder_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




 //高德POI查询 类

var GaodePOIGeocoder_GaodePOIGeocoder = /*#__PURE__*/function () {
  //========== 构造方法 ==========
  function GaodePOIGeocoder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    classCallCheck_default()(this, GaodePOIGeocoder);

    this.options = options;
    this.gaodekey = options.key || gaodeArr;
  }

  createClass_default()(GaodePOIGeocoder, [{
    key: "getArrayRandomOne",
    value: function getArrayRandomOne() {
      var arr = this.gaodekey;
      var n = Math.floor(Math.random() * arr.length + 1) - 1;
      return arr[n];
    }
  }, {
    key: "geocode",
    value: function geocode(query) {
      var key = this.getArrayRandomOne();
      var resource = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Resource"]({
        url: "https://restapi.amap.com/v3/place/text",
        queryParameters: GaodePOIGeocoder_objectSpread({
          count: 20,
          key: key,
          keywords: query,
          types: "110000|120000|130000|140000|180000|190000|"
        }, this.options.parameters || {})
      });
      var that = this;
      return resource.fetchJson().then(function (results) {
        if (results.infocode != "10000") {
          Object(Log["logError"])("请求失败(" + results.infocode + ")：" + results.info);
          return {};
        }

        if (results.pois.length == 0) {
          Object(Log["logInfo"])("未查询到“" + query + "”相关数据！");
          return {};
        }

        var height = 3000;

        if (that.map.camera.positionCartographic.height < height) {
          height = that.map.camera.positionCartographic.height;
        }

        return results.pois.map(function (resultObject) {
          var arrjwd = resultObject.location.split(",");
          arrjwd = Object(PointTrans["gcj2wgs"])(arrjwd); //纠偏

          return {
            displayName: resultObject.name,
            destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(arrjwd[0], arrjwd[1], height)
          };
        });
      });
    }
  }]);

  return GaodePOIGeocoder;
}();
// CONCATENATED MODULE: ./src/map/core/getDefaultContextMenu.js














 //获取平台内置的右键菜单

function getDefaultContextMenu_getDefaultContextMenu(map) {
  var viewer = map.viewer;
  var that = {};
  return [{
    text: map.getLangText("_查看此处坐标"),
    iconCls: "fa fa-info-circle",
    show: function show(e) {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](e.cartesian);
    },
    callback: function callback(e) {
      //经纬度
      var mpt = LatLngPoint["a" /* LatLngPoint */].fromCartesian(e.cartesian);
      var ptNew = Object(PointTrans["proj4Trans"])([mpt.lng, mpt.lat], "EPSG:4326", CRS["a" /* CRS */].CGCS2000_GK_Zone_3);
      var inhtml = "".concat(map.getLangText("_经度"), ":").concat(mpt.lng, ", ").concat(map.getLangText("_纬度"), ":").concat(mpt.lat, ", ").concat(map.getLangText("_海拔"), ":").concat(mpt.alt, " <br />\n                      ").concat(map.getLangText("_横坐标"), ":").concat(ptNew[0].toFixed(1), ", ").concat(map.getLangText("_纵坐标"), ":").concat(ptNew[1].toFixed(1), " (CGCS2000)");
      Object(Util["alert"])(inhtml, map.getLangText("_位置信息")); //打印方便测试

      var ptX = Object(Util["formatNum"])(e.cartesian.x, 1); //笛卡尔

      var ptY = Object(Util["formatNum"])(e.cartesian.y, 1);
      var ptZ = Object(Util["formatNum"])(e.cartesian.z, 1);
      Object(Log["logInfo"])("\u7ECF\u7EAC\u5EA6\uFF1A".concat(mpt.toString(), " , \u7B1B\u5361\u5C14\uFF1A").concat(ptX, ",").concat(ptY, ",").concat(ptZ));
    }
  }, {
    text: map.getLangText("_查看当前视角"),
    iconCls: "fa fa-camera-retro",
    callback: function callback(e) {
      var mpt = JSON.stringify(map.getCameraView());
      Object(Log["logInfo"])(mpt);
      Object(Util["alert"])(mpt, map.getLangText("_当前视角信息"));
    }
  }, {
    text: map.getLangText("_视角切换"),
    iconCls: "fa fa-street-view",
    children: [{
      text: map.getLangText("_禁止进入地下"),
      iconCls: "fa fa-ban",
      show: function show(e) {
        return !map.scene.screenSpaceCameraController.enableCollisionDetection;
      },
      callback: function callback(e) {
        map.scene.screenSpaceCameraController.enableCollisionDetection = true;
      }
    }, {
      text: map.getLangText("_允许进入地下"),
      iconCls: "fa fa-sort-amount-desc",
      show: function show(e) {
        return map.scene.screenSpaceCameraController.enableCollisionDetection;
      },
      callback: function callback(e) {
        map.scene.screenSpaceCameraController.enableCollisionDetection = false;
      }
    }, {
      text: map.getLangText("_绕此处环绕飞行"),
      iconCls: "fa fa-retweet",
      show: function show(e) {
        var _that$rotatePoint;

        return e.cartesian && (!that.rotatePoint || !((_that$rotatePoint = that.rotatePoint) !== null && _that$rotatePoint !== void 0 && _that$rotatePoint.isStart));
      },
      callback: function callback(e) {
        if (!that.rotatePoint) {
          that.rotatePoint = new RotatePoint_RotatePoint();
          map.addThing(that.rotatePoint);
        }

        that.rotatePoint.start(e.cartesian);
      }
    }, {
      text: map.getLangText("_关闭环绕飞行"),
      iconCls: "fa fa-remove",
      show: function show(e) {
        var _that$rotatePoint2;

        return (_that$rotatePoint2 = that.rotatePoint) === null || _that$rotatePoint2 === void 0 ? void 0 : _that$rotatePoint2.isStart;
      },
      callback: function callback(e) {
        if (that.rotatePoint) {
          that.rotatePoint.stop();
        }
      }
    }, {
      text: map.getLangText("_移动到此处"),
      iconCls: "fa fa-send-o",
      show: function show(e) {
        return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](e.cartesian);
      },
      callback: function callback(e) {
        var cameraDistance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(e.cartesian, viewer.camera.positionWC) * 0.1;
        map.flyToPoint(e.cartesian, {
          radius: cameraDistance,
          //距离目标点的距离
          maximumHeight: viewer.camera.positionCartographic.height
        });
      }
    }, {
      text: map.getLangText("_第一视角站到此处"),
      iconCls: "fa fa-male",
      show: function show(e) {
        return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](e.cartesian);
      },
      callback: function callback(e) {
        viewer.camera.flyTo({
          destination: Object(PointUtil["addPositionsHeight"])(e.cartesian, 10),
          //升高10米
          orientation: {
            heading: viewer.camera.heading,
            pitch: 0.0,
            roll: 0.0
          },
          maximumHeight: viewer.camera.positionCartographic.height
        });
      }
    }, {
      text: map.getLangText("_开启键盘漫游"),
      iconCls: "fa fa-keyboard-o",
      show: function show(e) {
        return !map.keyboardRoam.enabled;
      },
      callback: function callback(e) {
        map.keyboardRoam.enabled = true;
      }
    }, {
      text: map.getLangText("_关闭键盘漫游"),
      iconCls: "fa fa-keyboard-o",
      show: function show(e) {
        return map.keyboardRoam.enabled;
      },
      callback: function callback(e) {
        map.keyboardRoam.enabled = false;
      }
    }, {
      text: map.getLangText("_取消锁定"),
      iconCls: "fa fa-unlock-alt",
      show: function show(e) {
        return viewer.trackedEntity != undefined;
      },
      callback: function callback(e) {
        viewer.trackedEntity = undefined;
      }
    }]
  }, {
    text: map.getLangText("_三维模型"),
    iconCls: "fa fa-building-o",
    show: function show(e) {
      var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](model);
    },
    children: [{
      text: map.getLangText("_显示三角网"),
      iconCls: "fa fa-connectdevelop",
      show: function show(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        return !model.debugWireframe;
      },
      callback: function callback(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        model.debugWireframe = true;
      }
    }, {
      text: map.getLangText("_关闭三角网"),
      iconCls: "fa fa-connectdevelop",
      show: function show(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        return model.debugWireframe;
      },
      callback: function callback(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        model.debugWireframe = false;
      }
    }, {
      text: map.getLangText("_显示包围盒"),
      iconCls: "fa fa-codepen",
      show: function show(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        return !model.debugShowBoundingVolume;
      },
      callback: function callback(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        model.debugShowBoundingVolume = true;
      }
    }, {
      text: map.getLangText("_关闭包围盒"),
      iconCls: "fa fa-codepen",
      show: function show(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        return model.debugShowBoundingVolume;
      },
      callback: function callback(e) {
        var model = map.pick3DTileset(e.cartesian); //拾取绘制返回的模型

        model.debugShowBoundingVolume = false;
      }
    }]
  }, {
    text: map.getLangText("_地形服务"),
    iconCls: "fa fa-globe",
    show: function show(e) {
      return external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](e.cartesian);
    },
    children: [{
      text: map.getLangText("_开启地形"),
      iconCls: "fa fa-medium",
      show: function show(e) {
        return !map.hasTerrain;
      },
      callback: function callback(e) {
        map.hasTerrain = true;
      }
    }, {
      text: map.getLangText("_关闭地形"),
      iconCls: "fa fa-medium",
      show: function show(e) {
        return map.hasTerrain;
      },
      callback: function callback(e) {
        map.hasTerrain = false;
      }
    }, {
      text: map.getLangText("_显示三角网"),
      iconCls: "fa fa-connectdevelop",
      show: function show(e) {
        return !viewer.scene.globe._surface.tileProvider._debug.wireframe;
      },
      callback: function callback(e) {
        viewer.scene.globe._surface.tileProvider._debug.wireframe = true;
      }
    }, {
      text: map.getLangText("_关闭三角网"),
      iconCls: "fa fa-connectdevelop",
      show: function show(e) {
        return viewer.scene.globe._surface.tileProvider._debug.wireframe;
      },
      callback: function callback(e) {
        viewer.scene.globe._surface.tileProvider._debug.wireframe = false;
      }
    }]
  }, {
    text: map.getLangText("_图上标记"),
    iconCls: "fa fa-eyedropper",
    children: [{
      text: map.getLangText("_标记点"),
      iconCls: "fa fa-map-marker",
      callback: function callback(e) {
        map.graphicLayer.startDraw({
          type: "point",
          style: {
            pixelSize: 12,
            color: "#3388ff"
          },
          success: function success(graphic) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(graphic.coordinates));
          }
        });
      }
    }, {
      text: map.getLangText("_标记线"),
      iconCls: "fa fa-reorder",
      callback: function callback(e) {
        map.graphicLayer.startDraw({
          type: "polyline",
          style: {
            color: "#55ff33",
            width: 3
          },
          success: function success(graphic) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(graphic.coordinates));
          }
        });
      }
    }, {
      text: map.getLangText("_标记面"),
      iconCls: "fa fa-medium",
      callback: function callback(e) {
        map.graphicLayer.startDraw({
          type: "polygon",
          style: {
            color: "#29cf34",
            opacity: 0.5,
            outline: true,
            outlineWidth: 2.0
          },
          success: function success(graphic) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(graphic.coordinates));
          }
        });
      }
    }, {
      text: map.getLangText("_标记圆"),
      iconCls: "fa fa-genderless",
      callback: function callback(e) {
        map.graphicLayer.startDraw({
          type: "circle",
          style: {
            color: "#ffff00",
            opacity: 0.6
          },
          success: function success(graphic) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(graphic.coordinates));
          }
        });
      }
    }, {
      text: map.getLangText("_标记矩形"),
      iconCls: "fa fa-retweet",
      callback: function callback(e) {
        map.graphicLayer.startDraw({
          type: "rectangle",
          style: {
            color: "#ffff00",
            opacity: 0.6
          },
          success: function success(graphic) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(graphic.coordinates));
          }
        });
      }
    }, {
      text: map.getLangText("_允许编辑"),
      iconCls: "fa fa-pencil",
      show: function show(e) {
        return !map.graphicLayer.hasEdit;
      },
      callback: function callback(e) {
        map.graphicLayer.hasEdit = true;
      }
    }, {
      text: map.getLangText("_禁止编辑"),
      iconCls: "fa fa-pencil-square",
      show: function show(e) {
        return map.graphicLayer.hasEdit;
      },
      callback: function callback(e) {
        map.graphicLayer.hasEdit = false;
      }
    }, {
      text: map.getLangText("_导出GeoJSON"),
      iconCls: "fa fa-file-text-o",
      show: function show(e) {
        return map.graphicLayer.length > 0;
      },
      callback: function callback(e) {
        Object(Util["downloadFile"])("图上标记.json", JSON.stringify(map.graphicLayer.toGeoJSON()));
      }
    }, {
      text: map.getLangText("_清除所有标记"),
      iconCls: "fa fa-trash-o",
      show: function show(e) {
        return map.graphicLayer.length > 0;
      },
      callback: function callback(e) {
        map.graphicLayer.clear();
      }
    }]
  }, {
    text: map.getLangText("_特效效果"),
    iconCls: "fa fa-rss",
    children: [{
      text: map.getLangText("_开启下雨"),
      iconCls: "fa fa-tint",
      show: function show(e) {
        return !that.rainEffect;
      },
      callback: function callback(e) {
        if (!that.rainEffect) {
          that.rainEffect = new RainEffect_RainEffect();
          map.addEffect(that.rainEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭下雨"),
      iconCls: "fa fa-tint",
      show: function show(e) {
        return that.rainEffect;
      },
      callback: function callback(e) {
        if (that.rainEffect) {
          map.removeEffect(that.rainEffect, true);
          delete that.rainEffect;
        }
      }
    }, {
      text: map.getLangText("_开启下雪"),
      iconCls: "fa fa-yelp",
      show: function show(e) {
        return !that.snowEffect;
      },
      callback: function callback(e) {
        if (!that.snowEffect) {
          that.snowEffect = new SnowEffect_SnowEffect();
          map.addEffect(that.snowEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭下雪"),
      iconCls: "fa fa-yelp",
      show: function show(e) {
        return that.snowEffect;
      },
      callback: function callback(e) {
        if (that.snowEffect) {
          map.removeEffect(that.snowEffect, true);
          delete that.snowEffect;
        }
      }
    }, {
      text: map.getLangText("_开启雾天气"),
      iconCls: "fa fa-spinner",
      show: function show(e) {
        return !that.fogEffect;
      },
      callback: function callback(e) {
        if (!that.fogEffect) {
          var height = viewer.camera.positionCartographic.height * 2;
          that.fogEffect = new FogEffect_FogEffect({
            fogByDistance: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian4"](0.1 * height, 0.1, height, 0.8)
          });
          map.addEffect(that.fogEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭雾天气"),
      iconCls: "fa fa-spinner",
      show: function show(e) {
        return that.fogEffect;
      },
      callback: function callback(e) {
        if (that.fogEffect) {
          map.removeEffect(that.fogEffect, true);
          delete that.fogEffect;
        }
      }
    }, {
      text: map.getLangText("_开启泛光"),
      iconCls: "fa fa-ticket",
      show: function show(e) {
        return !that.bloomEffect;
      },
      callback: function callback(e) {
        if (!that.bloomEffect) {
          that.bloomEffect = new BloomEffect_BloomEffect();
          map.addEffect(that.bloomEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭泛光"),
      iconCls: "fa fa-ticket",
      show: function show(e) {
        return that.bloomEffect;
      },
      callback: function callback(e) {
        if (that.bloomEffect) {
          map.removeEffect(that.bloomEffect, true);
          delete that.bloomEffect;
        }
      }
    }, {
      text: map.getLangText("_开启亮度"),
      iconCls: "fa fa-trello",
      show: function show(e) {
        return !that.brightnessEffect;
      },
      callback: function callback(e) {
        if (!that.brightnessEffect) {
          that.brightnessEffect = new BrightnessEffect_BrightnessEffect();
          map.addEffect(that.brightnessEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭亮度"),
      iconCls: "fa fa-trello",
      show: function show(e) {
        return that.brightnessEffect;
      },
      callback: function callback(e) {
        if (that.brightnessEffect) {
          map.removeEffect(that.brightnessEffect, true);
          delete that.brightnessEffect;
        }
      }
    }, {
      text: map.getLangText("_开启夜视"),
      iconCls: "fa fa-dashboard",
      show: function show(e) {
        return !that.nightVisionEffect;
      },
      callback: function callback(e) {
        if (!that.nightVisionEffect) {
          that.nightVisionEffect = new NightVisionEffect_NightVisionEffect();
          map.addEffect(that.nightVisionEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭夜视"),
      iconCls: "fa fa-dashboard",
      show: function show(e) {
        return that.nightVisionEffect;
      },
      callback: function callback(e) {
        if (that.nightVisionEffect) {
          map.removeEffect(that.nightVisionEffect, true);
          delete that.nightVisionEffect;
        }
      }
    }, {
      text: map.getLangText("_开启黑白"),
      iconCls: "fa fa-star-half-full",
      show: function show(e) {
        return !that.blackAndWhiteEffect;
      },
      callback: function callback(e) {
        if (!that.blackAndWhiteEffect) {
          that.blackAndWhiteEffect = new BlackAndWhiteEffect_BlackAndWhiteEffect();
          map.addEffect(that.blackAndWhiteEffect);
        }
      }
    }, {
      text: map.getLangText("_关闭黑白"),
      iconCls: "fa fa-star-half-full",
      show: function show(e) {
        return that.blackAndWhiteEffect;
      },
      callback: function callback(e) {
        if (that.blackAndWhiteEffect) {
          map.removeEffect(that.blackAndWhiteEffect, true);
          delete that.blackAndWhiteEffect;
        }
      }
    }]
  }, {
    text: map.getLangText("_场景设置"),
    iconCls: "fa fa-gear",
    children: [{
      text: map.getLangText("_开启深度监测"),
      iconCls: "fa fa-eye-slash",
      show: function show(e) {
        return !viewer.scene.globe.depthTestAgainstTerrain;
      },
      callback: function callback(e) {
        viewer.scene.globe.depthTestAgainstTerrain = true;
      }
    }, {
      text: map.getLangText("_关闭深度监测"),
      iconCls: "fa fa-eye",
      show: function show(e) {
        return viewer.scene.globe.depthTestAgainstTerrain;
      },
      callback: function callback(e) {
        viewer.scene.globe.depthTestAgainstTerrain = false;
      }
    }, {
      text: map.getLangText("_显示星空背景"),
      iconCls: "fa fa-moon-o",
      show: function show(e) {
        return !viewer.scene.skyBox.show;
      },
      callback: function callback(e) {
        viewer.scene.skyBox.show = true; //天空盒

        viewer.scene.moon.show = true; //太阳

        viewer.scene.sun.show = true; //月亮
      }
    }, {
      text: map.getLangText("_关闭星空背景"),
      iconCls: "fa fa-moon-o",
      show: function show(e) {
        return viewer.scene.skyBox.show;
      },
      callback: function callback(e) {
        viewer.scene.skyBox.show = false; //天空盒

        viewer.scene.moon.show = false; //太阳

        viewer.scene.sun.show = false; //月亮
      }
    }, {
      text: map.getLangText("_开启日照阴影"),
      iconCls: "fa fa-sun-o",
      show: function show(e) {
        return !viewer.shadows;
      },
      callback: function callback(e) {
        viewer.shadows = true;
        viewer.terrainShadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].ENABLED;
        viewer.scene.globe.enableLighting = true;
      }
    }, {
      text: map.getLangText("_关闭日照阴影"),
      iconCls: "fa fa-sun-o",
      show: function show(e) {
        return viewer.shadows;
      },
      callback: function callback(e) {
        viewer.shadows = false;
        viewer.terrainShadows = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["ShadowMode"].RECEIVE_ONLY;
        viewer.scene.globe.enableLighting = false;
      }
    }, {
      text: map.getLangText("_开启大气渲染"),
      iconCls: "fa fa-soundcloud",
      show: function show(e) {
        return !viewer.scene.skyAtmosphere.show;
      },
      callback: function callback(e) {
        viewer.scene.skyAtmosphere.show = true;
        viewer.scene.globe.showGroundAtmosphere = true;
      }
    }, {
      text: map.getLangText("_关闭大气渲染"),
      iconCls: "fa fa-soundcloud",
      show: function show(e) {
        return viewer.scene.skyAtmosphere.show;
      },
      callback: function callback(e) {
        viewer.scene.skyAtmosphere.show = false;
        viewer.scene.globe.showGroundAtmosphere = false;
      }
    }, {
      text: map.getLangText("_场景出图"),
      iconCls: "fa fa-download",
      callback: function callback(e) {
        map.expImage();
      }
    }]
  }];
}
// EXTERNAL MODULE: ./src/map/core/addImage.js
var addImage = __webpack_require__(27);

// CONCATENATED MODULE: ./src/map/core/Chinesization.js

 //创建地球之前的汉化处理。

function toChineseBeforeCreate(options) {
  //时钟动画面板
  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["AnimationViewModel"].defaultDateFormatter = function (date, viewModel) {
    var jsdate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].toDate(date);
    return Object(Util["formatDate"])(jsdate, "yyyy-MM-dd");
  };

  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["AnimationViewModel"].defaultTimeFormatter = function (date, viewModel) {
    var jsdate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].toDate(date);
    return Object(Util["formatDate"])(jsdate, "HH:mm:ss");
  }; //时间线


  external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Timeline"].prototype.makeLabel = function (time) {
    var jsdate = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["JulianDate"].toDate(time);
    return Object(Util["formatDate"])(jsdate, "yyyy-MM-dd HH:mm:ss");
  };
} //创建地球之后的汉化处理。

function toChineseCreateEnd(options, viewer) {
  //初始视图
  updateAttribute(document, {
    "View Home": "初始视图"
  }, "cesium-home-button", "title"); //搜索按钮

  var geocoderTxt = {
    "Enter an address or landmark...": "请输入地址...",
    "Searching...": "查询中..."
  };
  updateAttribute(document, geocoderTxt, "cesium-geocoder-input", "placeholder"); //全屏按钮

  var fullscreenButtonTxt = {
    "Full screen": "全屏",
    "Exit full screen": "退出全屏",
    "Full screen unavailable": "全屏不可用"
  };
  updateAttributeByEvent(document, fullscreenButtonTxt, "cesium-fullscreenButton", "title", "onmouseover"); //VR

  var vrButtonTxt = {
    "Enter VR mode": "进入VR模式",
    "Exit VR mode": "退出VR模式",
    "VR mode is unavailable": "VR模式不可用"
  };
  updateAttributeByEvent(document, vrButtonTxt, "cesium-vrButton", "title", "onmouseover"); //视图切换按钮

  var sceneModePickerTxt = {
    "2D": "二维视图",
    "3D": "三维视图",
    "Columbus View": "哥伦布2.5D视图"
  };
  updateAttributeByEvent(document, sceneModePickerTxt, "cesium-sceneModePicker-button3D", "title", "onmouseover");
  updateAttribute(document, sceneModePickerTxt, "cesium-sceneModePicker-dropDown-icon", "title"); //帮助按钮和面板

  updateAttribute(document, {
    "Navigation Instructions": "帮助"
  }, "cesium-navigation-help-button", "title");
  var helpTxt = {
    Mouse: "鼠标操作",
    Touch: "触摸手势",
    "Pan view": "平移视图",
    "Left click + drag": "鼠标左键+拖拽",
    "Zoom view": "缩放视图",
    "Right click + drag, or": "右键+拖拽，或者",
    "Mouse wheel scroll": "中键滚动",
    "Rotate view": "旋转视图",
    "Middle click + drag, or": "中键按下拖拽，或者",
    "CTRL + Left/Right click + drag": "按Ctrl键 同时 左/右键拖拽",
    "One finger drag": "单指拖动",
    "Two finger pinch": "双指向内或向外滑动",
    "Tilt view": "倾斜视图",
    "Two finger drag, same direction": "双指按相同方向拖动",
    "Two finger drag, opposite direction": "双指按相反方向拖动"
  };
  var mouseButton = document.getElementsByClassName("cesium-navigation-button-left");

  if (mouseButton.length > 0) {
    mouseButton = mouseButton[0];

    if (helpTxt[mouseButton.textContent]) {
      mouseButton.innerHTML = mouseButton.children[0].outerHTML + helpTxt[mouseButton.textContent];
    }
  }

  var touchButton = document.getElementsByClassName("cesium-navigation-button-right");

  if (touchButton.length > 0) {
    touchButton = touchButton[0];

    if (helpTxt[touchButton.textContent]) {
      touchButton.innerHTML = touchButton.children[0].outerHTML + helpTxt[touchButton.textContent];
    }
  }

  updateHtml(document, helpTxt, "cesium-navigation-help-pan");
  updateHtml(document, helpTxt, "cesium-navigation-help-details");
  updateHtml(document, helpTxt, "cesium-navigation-help-zoom");
  updateHtml(document, helpTxt, "cesium-navigation-help-rotate");
  updateHtml(document, helpTxt, "cesium-navigation-help-tilt"); //图层选择

  var dropDownContainer = document.getElementsByClassName("cesium-baseLayerPicker-dropDown");

  if (dropDownContainer.length > 0) {
    dropDownContainer = dropDownContainer[0];
    var baseLayerPickerTxt = {
      //图层
      Imagery: "影像",
      "Cesium ion": "官方ION",
      Other: "其他",
      Terrain: "地形服务",
      "WGS84 Ellipsoid": "WGS84 椭球",
      "Cesium World Terrain": "Cesium 世界地形图",
      "WGS84 standard ellipsoid, also known as EPSG:4326": "WGS84标准椭球，又称EPSG：4326",
      "High-resolution global terrain tileset curated from several datasources and hosted by Cesium ion": "高分辨率全球地形图块集由几个数据源组成，由Cesium ion托管"
    }; //修改标题

    updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-sectionTitle"); //副标题

    updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-categoryTitle"); //具体标签

    updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-itemLabel"); //具体地图描述

    updateAttribute(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-item", "title"); //鼠标悬浮事件监听，解决选择不同影像title 动态修改无法固定汉化问题

    var selectLayerToolbar = document.getElementsByClassName("cesium-baseLayerPicker-selected");

    if (selectLayerToolbar.length > 0) {
      selectLayerToolbar[0].parentElement.onmouseover = function (event) {
        var currentTitle = event.currentTarget.getAttribute("title");
        var currentTargets = currentTitle.split("\n");
        var tempTitle1 = "";
        var tempTitle2 = "";

        if (baseLayerPickerTxt[currentTargets[0]]) {
          tempTitle1 += baseLayerPickerTxt[currentTargets[0]];
        } else {
          tempTitle1 += currentTargets[0];
        }

        if (baseLayerPickerTxt[currentTargets[0]]) {
          tempTitle2 += baseLayerPickerTxt[currentTargets[1]];
        } else {
          tempTitle2 += currentTargets[1];
        }

        event.currentTarget.setAttribute("title", tempTitle1 + "\n" + tempTitle2);
      };
    }
  } //时钟动画面板


  var parentContainer = document.getElementsByClassName("cesium-viewer-animationContainer");

  if (parentContainer.length > 0) {
    parentContainer = parentContainer[0];
    var animatioxtnTxt = {
      Today: "今天",
      "Today (real-time)": "今天（实际时间）",
      Pause: "暂停",
      "Play Reverse": "后退播放",
      "Play Forward": "前进播放",
      "Current time not in range": "当前时间不在范围内"
    };
    updateHtmlByTagName(parentContainer, animatioxtnTxt, "title");
  } //webgl渲染失败后，刷新页面


  viewer.scene.renderError.addEventListener(function (scene, error) {
    var errorPanelTxt = {
      "An error occurred while rendering.  Rendering has stopped.": "WebGL发生渲染错误,渲染已经停止,请刷新页面。",
      "Error constructing CesiumWidget.": "构造CesiumWidget时出错"
    };
    updateHtml(document, errorPanelTxt, "cesium-widget-errorPanel-header");
  });
} // /**
//  * 更新dom innerHtml
//  * @param {*} parent 父容器对象
//  * @param {*} map 汉化对象
//  * @param {*} className class名称
//  */

function updateHtml(parent, map, className) {
  if (!parent) {
    parent = document;
  }

  var doms = parent.getElementsByClassName(className);

  for (var i = 0; i < doms.length; i++) {
    if (map[doms[i].innerHTML]) {
      doms[i].innerHTML = map[doms[i].innerHTML];
    }
  }
} // /**
//  * 更新dom innerHtml
//  * @param {*} parent 父容器对象
//  * @param {*} map 汉化对象
//  * @param {*} tagName 标签名称
//  */


function updateHtmlByTagName(parent, map, tagName) {
  if (!parent) {
    parent = document;
  }

  var doms = parent.getElementsByTagName(tagName);

  for (var i = 0; i < doms.length; i++) {
    if (map[doms[i].innerHTML]) {
      doms[i].innerHTML = map[doms[i].innerHTML];
    }
  }
} // /**
//  * 更新dom innerHtml
//  * @param {*} parent 父容器对象
//  * @param {*} map 汉化对象
//  * @param {*} className class名称
//  * @param {*} attributeName 属性名称
//  */


function updateAttribute(parent, map, className, attributeName) {
  if (!parent) {
    parent = document;
  }

  var doms = parent.getElementsByClassName(className);

  for (var i = 0; i < doms.length; i++) {
    if (map[doms[i].getAttribute(attributeName)]) {
      doms[i].setAttribute(attributeName, map[doms[i].getAttribute(attributeName)]);
    }
  }
} // /**
//  * 通过事件更新属性
//  * @param {*} parent 父容器
//  * @param {*} map 汉化对象
//  * @param {*} className 样式名称
//  * @param {*} attributeName 属性名称
//  * @param {*} eventName 事件名称
//  */


function updateAttributeByEvent(parent, map, className, attributeName, eventName) {
  var doms = parent.getElementsByClassName(className);

  if (doms.length > 0) {
    for (var i = 0; i < doms.length; i++) {
      doms[i][eventName] = function (event) {
        var attr = event.currentTarget.getAttribute(attributeName);

        if (map[attr]) {
          event.currentTarget.setAttribute(attributeName, map[attr]);
        }
      };
    }
  }
}
// CONCATENATED MODULE: ./src/map/Map.js









function Map_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Map_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Map_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Map_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Map_createSuper(Derived) { var hasNativeReflectConstruct = Map_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Map_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }









 //内置的3个控件























 //如果options未设置时的默认参数[基本上默认都关闭]

var DefaultOptions = {
  animation: false,
  //是否创建动画小器件，左下角仪表
  timeline: false,
  //是否显示时间线控件
  fullscreenButton: false,
  //右下角全屏按钮
  vrButton: false,
  //右下角vr虚拟现实按钮
  geocoder: false,
  //是否显示地名查找控件
  sceneModePicker: false,
  //是否显示投影方式控件
  homeButton: false,
  //回到默认视域按钮
  navigationHelpButton: false,
  //是否显示帮助信息控件
  navigationInstructionsInitiallyVisible: false,
  //在用户明确单击按钮之前是否自动显示
  infoBox: false,
  //是否显示点击要素之后显示的信息
  selectionIndicator: false,
  //选择模型是是否显示绿色框,
  shouldAnimate: true,
  showRenderLoopErrors: true,
  //是否显示错误弹窗信息
  baseLayerPicker: false //地图底图

};
/**
 * 地图类 ，这是构造三维地球的一切的开始起点。
 *
 * @param {String|Cesium.Viewer} id 地图div容器的id 或 已构造好的Viewer对象
 * @param {Object} [options={}] 参数对象:
 * @param {Map.sceneOptions} options.scene 场景参数
 * @param {Map.controlOptions} options.control 控件参数
 * @param {Map.terrainOptions} options.terrain 地形服务配置
 * @param {Map.basemapOptions[]} options.basemaps 底图图层配置
 * @param {Map.layerOptions[]} options.layers 可以叠加显示的图层配置
 *
 * @param {Object} [options.templateValues] 图层中统一的url模版，。比如可以将服务url前缀统一使用模板，方便修改或动态配置。
 * @param {ChinaCRS} [options.chinaCRS=ChinaCRS.WGS84] 标识当前三维场景的国内坐标系（用于部分图层内对比判断来自动纠偏或加偏）
 * @param {LangType} [options.lang] 使用的语言（如中文、英文等）。
 *
 *
 * @export
 * @class Map
 * @extends {BaseClass} 基础类
 *
 * @see [支持的事件类型]{@link Map.EventType}
 */

var Map_Map = /*#__PURE__*/function (_BaseClass) {
  inherits_default()(Map, _BaseClass);

  var _super = Map_createSuper(Map);

  function Map(id) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    classCallCheck_default()(this, Map);

    _this = _super.call(this, options);
    _this.options = options; //汉化

    options.lang = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.lang, LangType.ZH);

    if (options.lang == LangType.ZH || options.lang == LangType.ZHHK) {
      toChineseBeforeCreate(options);
    }

    if (id instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Viewer"]) {
      _this._viewer = id;
    } else {
      _this._viewer = _this._createViewer(id, options);
    }

    _this._isFlyAnimation = false;
    _this._controlCache = {};
    _this._layerCache = {};
    _this._thingCache = {};
    _this._sceneEvent = new SceneEvent_SceneEvent(assertThisInitialized_default()(_this)); // Register scene events

    _this._mouseEvent = new MouseEvent_MouseEvent(assertThisInitialized_default()(_this)); // Register scene events

    _this._viewerOption = new ViewerOption_ViewerOption(assertThisInitialized_default()(_this)); // Initialize the viewer option

    _this._viewerOption.setOptions(_this.options.scene, _this.options.scene);

    _this._zoomNavigation = new ZoomNavigation_ZoomNavigation(_this._viewer); //当前三维场景的国内坐标系（用于部分图层内对比判断来自动纠偏或加偏）

    _this.chinaCRS = _this.options.chinaCRS || ChinaCRS["a" /* ChinaCRS */].WGS84; //汉化

    if (options.lang == LangType.ZH || options.lang == LangType.ZHHK) {
      toChineseCreateEnd(options, _this._viewer);
    } //添加土豆图片标识


    Object(addImage["a" /* addImage */])(_this._viewer); //处理图层

    _this._initLayers(); //绑定添加相关控件


    _this._initControls();

    return _this;
  } //========== 对外属性 ==========

  /**
   * 地图对应的Cesium原生的Viewer对象
   * @type {Cesium.Viewer}
   * @readonly
   */


  createClass_default()(Map, [{
    key: "viewer",
    get: function get() {
      return this._viewer;
    }
    /**
     * 获取地图DOM容器。
     *
     * @type {Element}
     * @readonly
     */

  }, {
    key: "container",
    get: function get() {
      return this._viewer.container;
    }
    /**
     * 获取场景。
     *
     * @type {Cesium.Scene}
     * @readonly
     */

  }, {
    key: "scene",
    get: function get() {
      return this._viewer.scene;
    }
    /**
     * 获取相机
     *
     * @type {Cesium.Camera}
     * @readonly
     */

  }, {
    key: "camera",
    get: function get() {
      return this._viewer.camera;
    }
    /**
     * 获取Canvas画布
     *
     * @type {HTMLCanvasElement}
     * @readonly
     */

  }, {
    key: "canvas",
    get: function get() {
      return this._viewer.scene.canvas;
    }
    /**
     * 获取将在地球上渲染的ImageryLayer图像图层的集合
     *
     * @type {Cesium.ImageryLayerCollection}
     * @readonly
     */

  }, {
    key: "imageryLayers",
    get: function get() {
      return this._viewer.imageryLayers;
    }
    /**
     * 获取要可视化的 DataSource 实例集。
     *
     * @type {Cesium.DataSourceCollection}
     * @readonly
     */

  }, {
    key: "dataSources",
    get: function get() {
      return this._viewer.dataSources;
    }
    /**
     * 获取未绑定到特定数据源的实体的集合。这是 dataSourceDisplay.defaultDataSource.entities 的快捷方式。
     *
     * @type {Cesium.EntityCollection}
     * @readonly
     */

  }, {
    key: "entities",
    get: function get() {
      return this._viewer.entities;
    }
    /**
     * 获取时钟。
     *
     * @type {Cesium.Clock}
     * @readonly
     */

  }, {
    key: "clock",
    get: function get() {
      return this._viewer.clock;
    }
    /**
     * 获取 CesiumWidget
     *
     * @type {Cesium.CesiumWidget}
     * @readonly
     */

  }, {
    key: "cesiumWidget",
    get: function get() {
      return this._viewer.cesiumWidget;
    }
    /**
     * 获取或设置相机当前正在跟踪的Entity实例。
     *
     * @type {Cesium.Entity}
     */

  }, {
    key: "trackedEntity",
    get: function get() {
      return this._viewer.trackedEntity;
    },
    set: function set(value) {
      this._viewer.trackedEntity = value;
    }
    /**
     * 获取或设置当前的地形服务
     *
     * @type {Cesium.TerrainProvider}
     */

  }, {
    key: "terrainProvider",
    get: function get() {
      return this._viewer.terrainProvider;
    },
    set: function set(value) {
      this._viewer.terrainProvider = value;
      this._defaultTerrainProvider = value;
    }
    /**
     *  是否开启地形
     * @type {Boolean}
     */

  }, {
    key: "hasTerrain",
    get: function get() {
      return Boolean(this._viewer.terrainProvider._layers);
    },
    set: function set(value) {
      if (value) {
        if (this._defaultTerrainProvider == null) {
          this._defaultTerrainProvider = Object(LayerUtil["createTerrainProvider"])(this.options.terrain, this.options.templateValues);
        }

        this._viewer.terrainProvider = this._defaultTerrainProvider;
      } else {
        this._viewer.terrainProvider = Object(LayerUtil["getNoTerrainProvider"])();
      }
    }
    /**
     *  获取或设置当前显示的底图，设置时可以传入图层id或name
     * @type {String|Number|BaseTileLayer}
     */

  }, {
    key: "basemap",
    get: function get() {
      var allLayers = this._cfgBasemapsArr;

      if (allLayers.length == 0) {
        if (this._viewer.baseLayerPicker) {
          return this._viewer.baseLayerPicker.viewModel.selectedImagery;
        }

        return undefined;
      }

      for (var i = 0; i < allLayers.length; i++) {
        var layer = allLayers[i];

        if (layer.hasEmptyGroup) {
          continue;
        }

        if (layer.isAdded) {
          return layer;
        }
      }

      return undefined;
    } //设置当前显示的底图
    //根据config配置的id或name属性，更新显示指定的地图底图
    ,
    set: function set(idorname) {
      var curr_id;
      var curr_name;

      if (idorname && Util["isObject"](idorname)) {
        curr_id = idorname.uuid || idorname.id;
        curr_name = idorname.name;
      } else {
        curr_id = idorname;
        curr_name = idorname;
      }

      var allLayers = this._cfgBasemapsArr;

      if (allLayers.length == 0) {
        if (this._viewer.baseLayerPicker) {
          var baseLayer = this._viewer.baseLayerPicker.viewModel;
          var sel;

          if (idorname) {
            var selectIndex,
                index = -1;

            for (var i = 0; i < this.options.basemaps.length; i++) {
              var item = this.options.basemaps[i];

              if (item.type == "group" && item.layers == null) {
                continue;
              }

              index++;

              if (curr_name == item.name || curr_id == item.id) {
                selectIndex = index;
                break;
              }
            }

            if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](selectIndex)) {
              sel = baseLayer.imageryProviderViewModels[selectIndex];
            }
          }

          baseLayer.selectedImagery = sel;
        }

        return;
      }

      for (var _i = 0; _i < allLayers.length; _i++) {
        var layer = allLayers[_i];

        if (layer.hasEmptyGroup) {
          continue;
        }

        if (curr_name == layer.name || curr_id == layer.id || curr_id == layer.uuid) {
          if (!layer.isAdded) {
            this.addLayer(layer);
          }
        } else {
          if (layer.isAdded) {
            this.removeLayer(layer);
          }
        }
      }
    }
    /**
     * 是否只拾取模型上的点
     * @type {Boolean}
     *
     */

  }, {
    key: "onlyPickModelPosition",
    get: function get() {
      return this._viewer.scene.onlyPickModelPosition;
    },
    set: function set(value) {
      this._viewer.scene.onlyPickModelPosition = value;
    }
    /**
     * 获取鼠标事件控制器
     *
     * @type {MouseEvent}
     * @readonly
     */

  }, {
    key: "mouseEvent",
    get: function get() {
      return this._mouseEvent;
    } //不公开

  }, {
    key: "popup",
    get: function get() {
      return this._popup;
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this._tooltip;
    }
  }, {
    key: "smallTooltip",
    get: function get() {
      return this._smallTooltip;
    }
  }, {
    key: "contextmenu",
    get: function get() {
      return this._contextmenu;
    }
    /**
     *  获取键盘漫游控制器
     *
     * @type {KeyboardRoam}
     * @readonly
     */

  }, {
    key: "keyboardRoam",
    get: function get() {
      return this._keyboardRoam;
    }
    /**
     *  获取config.json预先传入的构造完成的控件对象
     *
     * @type {KeyboardRoam}
     * @readonly
     */

  }, {
    key: "controls",
    get: function get() {
      return this._controls;
    }
    /**
     * 默认绑定的图层，简单场景时快捷方便使用
     *
     * @type {GraphicLayer}
     * @readonly
     */

  }, {
    key: "graphicLayer",
    get: function get() {
      if (this._graphicLayer == null) {
        this._graphicLayer = new GraphicLayer_GraphicLayer({
          name: "默认数据图层",
          noLayerManage: true
        });
        this.addLayer(this._graphicLayer);
      }

      return this._graphicLayer;
    }
    /**
     *  获取当前地图层级（概略），一般为0-21层
     *
     * @type {Int}
     * @readonly
     */

  }, {
    key: "level",
    get: function get() {
      var height = Math.abs(this._viewer.camera.positionCartographic.height);

      if (height == this._prevCameraHeight) {
        return this._level;
      }

      this._level = Util["heightToZoom"](height);
      this._prevCameraHeight = height;
      return this._level;
    }
    /**
     *  是否固定光照，
     *  true：可避免gltf、3dtiles模型随时间存在亮度不一致。
     *
     * @type {Boolean}
     */

  }, {
    key: "fixedLight",
    get: function get() {
      return this._fixedLight;
    },
    set: function set(val) {
      this._fixedLight = val;

      if (!this._sunlight) {
        this._sunlight = this.scene.light;
      }

      if (val) {
        var directionalLight = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["DirectionalLight"]({
          direction: new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"](0.35492591601301104, -0.8909182691839401, -0.2833588392420772)
        });
        this.scene.light = directionalLight; //固定光照
      } else {
        this.scene.light = this._sunlight;
      }
    }
    /**
     * 使用的语言（如中文、英文等）。
     * @type {LangType}
     * @readonly
     */

  }, {
    key: "lang",
    get: function get() {
      return this.options.lang || LangType.ZH;
    },
    set: function set(val) {
      this.options.lang = val;
    } //========== 方法 ==========

  }, {
    key: "_createViewer",
    value: function _createViewer(id, options) {
      if (!id) {
        throw new Error("Map：id 不能为空");
      }

      var viewerOption = Map_objectSpread(Map_objectSpread(Map_objectSpread({}, DefaultOptions), options.control || {}), options.scene || {});

      if (viewerOption.globe && !(viewerOption.globe instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Globe"])) {
        delete viewerOption.globe;
      }

      if (viewerOption.cameraController) {
        delete viewerOption.cameraController;
      }

      if (viewerOption.contextmenu) {
        delete viewerOption.contextmenu;
      }

      if (viewerOption.location) {
        delete viewerOption.location;
      }

      if (viewerOption.mouseDownView) {
        delete viewerOption.mouseDownView;
      }

      if (viewerOption.navigation) {
        delete viewerOption.navigation;
      } //自定义搜索栏Geocoder


      if (viewerOption.geocoder == true && options.lang == LangType.ZH) {
        viewerOption.geocoder = new GaodePOIGeocoder_GaodePOIGeocoder(viewerOption.geocoderConfig);
        viewerOption.geocoder.map = this;
      } //地图底图图层预处理


      var hasremoveimagery = false;

      if (viewerOption.baseLayerPicker) {
        var _options$basemaps;

        //有baseLayerPicker插件时
        if (!viewerOption.imageryProviderViewModels && ((_options$basemaps = options.basemaps) === null || _options$basemaps === void 0 ? void 0 : _options$basemaps.length) > 0) {
          //【土豆数据tudougis.cn】houyanqing 2022-05-24.多个屏幕共同显示时,开启多线程,将参数throttleByServer传递给ImageryLayer对象
          if (options.basemaps && Array.isArray(options.basemaps)) {
            options.basemaps.forEach(function (basemaps) {
              if (basemaps.layers && Array.isArray(basemaps.layers)) {
                basemaps.layers.forEach(function (layers) {
                  Object.assign(layers, {
                    throttleByServer: options.throttleByServer
                  });
                });
              }
            });
          }

          var imgOBJ = Object(LayerUtil["getImageryProviderViewModels"])(options.basemaps);
          viewerOption.imageryProviderViewModels = imgOBJ.imageryProviderViewModels;

          if (imgOBJ.selectedIndex == -1) {
            hasremoveimagery = true;
          } else {
            viewerOption.selectedImageryProviderViewModel = imgOBJ.imageryProviderViewModels[imgOBJ.selectedIndex];
          }
        }

        if (!viewerOption.terrainProviderViewModels) {
          var _options$terrain;

          viewerOption.terrainProviderViewModels = Object(LayerUtil["getTerrainProviderViewModels"])(options.terrain);
          viewerOption.selectedTerrainProviderViewModel = viewerOption.terrainProviderViewModels[(_options$terrain = options.terrain) !== null && _options$terrain !== void 0 && _options$terrain.show ? 1 : 0];
        }
      } //无baseLayerPicker插件时
      else {
        //未配底图时
        if (viewerOption.imageryProvider == null) {
          hasremoveimagery = true;
          viewerOption.imageryProvider = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["TileMapServiceImageryProvider"]({
            url: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["buildModuleUrl"]("Assets/Textures/NaturalEarthII")
          });
        } //地形


        var terrainProvider;

        if (options.terrain && options.terrain.show) {
          terrainProvider = Object(LayerUtil["createTerrainProvider"])(options.terrain, options.templateValues);
          viewerOption.terrainProvider = terrainProvider;
          this._defaultTerrainProvider = terrainProvider;
        } else {
          viewerOption.terrainProvider = Object(LayerUtil["getNoTerrainProvider"])();
        }
      } //地球初始化


      var viewer = new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Viewer"](id, viewerOption); //地图底图图层

      if (hasremoveimagery) {
        var imageryLayerCollection = viewer.imageryLayers;
        var length = imageryLayerCollection.length;

        for (var i = 0; i < length; i++) {
          var layer = imageryLayerCollection.get(0);
          imageryLayerCollection.remove(layer, true);
        }
      }

      return viewer;
    } ////////////////////一些常用方法//////////////////////

    /**
     * 设置Scene场景参数
     * @param {Map.sceneOptions} options 参数
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "setSceneOptions",
    value: function setSceneOptions(options) {
      if (!options || Object.keys(options).length == 0) {
        return this;
      }

      this.options.scene = Util["merge"](this.options.scene, options);

      this._viewerOption.setOptions(this.options.scene, options);

      return this;
    }
    /**
     * 获取地图的配置参数，即new Map传入的参数。
     * @return {Object} 地图的配置参数
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      return Util["clone"](this.options, ["parent"]);
    }
    /**
     * 获取平台内置的右键菜单
     * @return {Object[]} 右键菜单
     */

  }, {
    key: "getDefaultContextMenu",
    value: function getDefaultContextMenu() {
      return getDefaultContextMenu_getDefaultContextMenu(this);
    }
    /**
     * 取地图屏幕中心点坐标
     * @return {LatLngPoint} 屏幕中心点坐标
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      return MapUtil["c" /* getCenter */](this.scene);
    }
    /**
     * 提取地球当前视域边界,示例：{ xmin: 70,  xmax: 140,  ymin: 0,  ymax: 55, height: 0, }
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.formatNum=false] 是否格式化小数位，只保留6位小数
     * @return {Object} 当前视域边界
     */

  }, {
    key: "getExtent",
    value: function getExtent(options) {
      return MapUtil["d" /* getExtent */](this, options);
    }
    /**
     * 截图，导出地图场景图片
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.download=true] 是否自动下载图片
     * @param {String} [options.filename='场景出图_' + width + 'x' + height] 图片名称
     * @param {Number} [options.width=canvas.width] 图片的高度像素值
     * @param {Number} [options.height=canvas.height] 图片的高度像素值
     * @param {String} [options.type='image/jpeg'] 图片格式
     * @param {Number} [options.encoderOptions=0.92] 在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。
     * @param {Function} [options.callback] 截图完成后的回调方法
     * @return {void}  无
     */

  }, {
    key: "expImage",
    value: function expImage(options) {
      return MapUtil["a" /* expImage */](this._viewer, options);
    }
    /**
     * 设置鼠标状态为“+”号效果，比如标绘时切换
     * @param {Boolean} val 是否“+”号效果
     * @return {void}  无
     */

  }, {
    key: "setCursor",
    value: function setCursor(val) {
      this.container.style.cursor = val ? "crosshair" : "";
    }
    /**
     * 获取坐标位置的3dtiles模型对象
     *
     * @param {Cesium.Cartesian3|Cesium.Cartesian3[]} positions 坐标  或 坐标数组
     * @return {Cesium.Cesium3DTileset} 3dtiles模型对象
     */

  }, {
    key: "pick3DTileset",
    value: function pick3DTileset(positions) {
      return MapUtil["e" /* pick3DTileset */](this.scene, positions);
    } ////////////////////事件相关//////////////////////

  }, {
    key: "on",
    value: function on(type, callback, context) {
      var result = this._sceneEvent.on(type, callback, context || this);

      if (!result) {
        get_default()(getPrototypeOf_default()(Map.prototype), "on", this).call(this, type, callback, context);
      }

      return this;
    }
  }, {
    key: "off",
    value: function off(type, callback, context) {
      var result = this._sceneEvent.off(type, callback, context || this);

      if (!result) {
        get_default()(getPrototypeOf_default()(Map.prototype), "off", this).call(this, type, callback, context);
      }

      return this;
    } /////////////////layer 图层相关///////////////////////////
    //处理图层

  }, {
    key: "_initLayers",
    value: function _initLayers() {
      //赋值默认值
      this.options.basemaps = this.options.basemaps || [];
      this.options.layers = this.options.layers || [];
      this._layerIdx = 1;
      this._arrLayerIdx = [];
      var basemapsCfg = this.options.basemaps;
      var layersCfg = this.options.layers; //记录所有id，方便计算nextid

      for (var i = 0; i < basemapsCfg.length; i++) {
        var item = basemapsCfg[i];

        if (item.id) {
          this._arrLayerIdx.push(item.id);
        }
      }

      for (var _i2 = 0; _i2 < layersCfg.length; _i2++) {
        var _item = layersCfg[_i2];

        if (_item.id) {
          this._arrLayerIdx.push(_item.id);
        }
      }

      var allLayers = []; //计算order

      this._cfgBasemapsArr = [];
      this._cfgBasemapsObj = {};
      this._cfgLayersArr = [];
      this._cfgLayersObj = {}; //底图处理

      if (!this._viewer.baseLayerPicker) {
        //使用baseLayerPicker时无法切换了
        for (var _i3 = 0; _i3 < basemapsCfg.length; _i3++) {
          var _item2 = basemapsCfg[_i3];

          if (!_item2.name) {
            _item2.name = "未命名";
          }

          if (!_item2.id) {
            _item2.id = this.getNextLayerId();
          }

          var layer = Object(LayerUtil["create"])(_item2, this.options.templateValues);

          if (!layer) {
            continue;
          }

          if (_item2.show) {
            this.addLayer(layer);
          }

          this._cfgBasemapsObj[_item2.id] = layer;

          this._cfgBasemapsArr.push(layer);

          allLayers.push(_item2);

          if (layer.hasChildLayer && _item2.layers) {
            for (var idx = 0; idx < _item2.layers.length; idx++) {
              var childitem = _item2.layers[idx];
              childitem.pid = _item2.id;
              childitem.parent = layer;

              if (!childitem.id) {
                childitem.id = this.getNextLayerId();
              }

              allLayers.push(childitem);
            }
          }
        }
      } //可叠加图层


      for (var _i4 = 0; _i4 < layersCfg.length; _i4++) {
        var _item3 = layersCfg[_i4];

        if (!_item3.id) {
          _item3.id = this.getNextLayerId();
        }

        var _layer = Object(LayerUtil["create"])(_item3, this.options.templateValues);

        if (!_layer) {
          continue;
        }

        if (_item3.show) {
          this.addLayer(_layer);
        }

        this._cfgLayersObj[_item3.id] = _layer;

        this._cfgLayersArr.push(_layer);

        allLayers.push(_item3);

        if (_layer.hasChildLayer && _item3.layers) {
          for (var _idx = 0; _idx < _item3.layers.length; _idx++) {
            var _childitem = _item3.layers[_idx];
            _childitem.pid = _item3.id;
            _childitem.parent = _layer;

            if (!_childitem.id) {
              _childitem.id = this.getNextLayerId();
            }

            allLayers.push(_childitem);
          }
        }
      } //计算 顺序字段,


      for (var _i5 = 0; _i5 < allLayers.length; _i5++) {
        var _item4 = allLayers[_i5]; //计算层次顺序

        var zIndex = Number(_item4.zIndex);

        if (isNaN(zIndex)) {
          zIndex = _i5;
        }

        _item4.zIndex = zIndex; //图层的处理

        if (this._layerCache[_item4.id]) {
          this._layerCache[_item4.id].zIndex = zIndex;
        }
      }
    }
    /**
     * 重新设置basemps底图图层，对options.basemaps重新赋值
     *
     * @param {Map.basemapOptions[]} arr 底图图层配置
     * @return {BaseLayer[]} 图层数组
     */

  }, {
    key: "setBasemapsOptions",
    value: function setBasemapsOptions(arr) {
      if (!arr || arr.length == 0) {
        return;
      }

      for (var i = 0; i < this._cfgBasemapsArr.length; i++) {
        var layer = this._cfgBasemapsArr[i];
        this.removeLayer(layer, true);
      }

      this.options.basemaps = arr;
      this._cfgBasemapsArr = [];
      this._cfgBasemapsObj = {};

      for (var _i6 = 0; _i6 < arr.length; _i6++) {
        var item = arr[_i6];

        if (!item.name) {
          item.name = "未命名";
        }

        if (!item.id) {
          item.id = this.getNextLayerId();
        }

        var _layer2 = Object(LayerUtil["create"])(item, this.options.templateValues);

        if (!_layer2) {
          continue;
        }

        if (item.show) {
          this.addLayer(_layer2);
        }

        this._cfgBasemapsObj[item.id] = _layer2;

        this._cfgBasemapsArr.push(_layer2);

        if (_layer2.hasChildLayer && item.layers) {
          for (var idx = 0; idx < item.layers.length; idx++) {
            var childitem = item.layers[idx];
            childitem.pid = item.id;
            childitem.parent = _layer2;

            if (!childitem.id) {
              childitem.id = this.getNextLayerId();
            }
          }
        }
      }

      return this._cfgBasemapsArr;
    }
    /**
     * 重新设置layers图层，对options.layers重新赋值
     *
     * @param {Map.layerOptions[]} arr 可以叠加显示的图层配置
     * @return {BaseLayer[]} 图层数组
     */

  }, {
    key: "setLayersOptions",
    value: function setLayersOptions(arr) {
      if (!arr || arr.length == 0) {
        return;
      }

      for (var i = 0; i < this._cfgBasemapsArr.length; i++) {
        var layer = this._cfgBasemapsArr[i];
        this.removeLayer(layer, true);
      }

      this.options.layers = arr;
      this._cfgLayersArr = [];
      this._cfgLayersObj = {}; //可叠加图层

      for (var _i7 = 0; _i7 < arr.length; _i7++) {
        var item = arr[_i7];

        if (!item.id) {
          item.id = this.getNextLayerId();
        }

        var _layer3 = Object(LayerUtil["create"])(item, this.options.templateValues);

        if (!_layer3) {
          continue;
        }

        if (item.show) {
          this.addLayer(_layer3);
        }

        this._cfgLayersObj[item.id] = _layer3;

        this._cfgLayersArr.push(_layer3);

        if (_layer3.hasChildLayer && item.layers) {
          for (var idx = 0; idx < item.layers.length; idx++) {
            var childitem = item.layers[idx];
            childitem.pid = item.id;
            childitem.parent = _layer3;

            if (!childitem.id) {
              childitem.id = this.getNextLayerId();
            }
          }
        }
      }

      return this._cfgLayersArr;
    }
    /**
     * 获取图层ID值，按顺序取值。
     * 没有id的图层，会自动使用本方法进行id赋值处理
     * @return {Int} 图层ID
     */

  }, {
    key: "getNextLayerId",
    value: function getNextLayerId() {
      while (this._arrLayerIdx.indexOf(this._layerIdx) != -1) {
        this._layerIdx++;
      }

      this._arrLayerIdx.push(this._layerIdx);

      return this._layerIdx;
    }
    /**
     * 添加图层到地图上
     *
     * @param {BaseLayer} layer 图层对象
     * @param {Boolean} showVal 如果传值，覆盖图层的show属性
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addLayer",
    value: function addLayer(layer, showVal) {
      if (!layer) {
        return;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](showVal)) {
        layer.show = showVal;
      }

      if (layer._state === State.ADDED) {
        return;
      }

      layer._onAdd(this);

      if (this._layerCache[layer.id] && this._layerCache[layer.id] !== layer) {
        layer.id = this.getNextLayerId();
        Object(Log["logWarn"])("addLayer:图层id存在冲突，已重新赋值id", layer);
      }

      this._layerCache[layer.id] = layer;
      return this;
    }
    /**
     * 移除图层
     *
     * @param {BaseLayer} layer 需要移除的图层
     * @param {boolean} hasDestory 是否释放
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeLayer",
    value: function removeLayer(layer, hasDestory) {
      if (!layer) {
        return this;
      }

      if (Util["isString"](layer) || Util["isNumber"](layer)) {
        //直接传入id
        layer = this._layerCache[layer];

        if (!layer) {
          return this;
        }
      }

      if (layer._state !== State.ADDED) {
        return;
      }

      delete this._layerCache[layer.id];

      if (hasDestory && layer.clear) {
        layer.clear();
      }

      layer._onRemove();

      if (hasDestory) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgBasemapsObj[layer.id])) {
          //config.json已有的配置basemaps图层
          delete this._cfgBasemapsObj[layer.id];

          Util["removeArrayItem"](this._cfgBasemapsArr, layer);
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgLayersObj[layer.id])) {
          //config.json已有的配置layers图层
          delete this._cfgLayersObj[layer.id];

          Util["removeArrayItem"](this._cfgLayersArr, layer);
        }

        layer.destroy();
      }

      return this;
    }
    /**
     * 是否有指定的图层存在（就是已经addLayer的图层）
     *
     * @param {BaseLayer|String} layer 指定的图层或图层ID
     * @return {Boolean} 是否存在
     */

  }, {
    key: "hasLayer",
    value: function hasLayer(layer) {
      return layer && this._layerCache[layer.id || layer];
    }
    /**
     * 遍历每一个图层并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachLayer",
    value: function eachLayer(method, context) {
      var _this2 = this;

      Object.keys(this._layerCache).forEach(function (id, index) {
        var layer = _this2._layerCache[id];
        method.call(context, layer, index);
      });
      return this;
    }
    /**
     * 根据ID或取图层
     *
     * @param {String|Number} id 图层id或uuid
     * @return {BaseLayer} 图层对象
     */

  }, {
    key: "getLayerById",
    value: function getLayerById(id) {
      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._layerCache[id])) {
        return this._layerCache[id];
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgLayersObj[id])) {
        return this._cfgLayersObj[id]; //config.json已有的配置layers图层
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgBasemapsObj[id])) {
        return this._cfgBasemapsObj[id]; //config.json已有的配置basemaps图层
      }

      var layers = this.getLayers({
        basemaps: true,
        //是否取config.json中的basempas
        layers: true //是否取config.json中的layers

      });

      for (var i = 0, len = layers.length; i < len; i++) {
        var layer = layers[i];

        if (layer.uuid == id || layer.id == id) {
          return layer;
        }

        if (layer.hasChildLayer && layer.arrLayer) {
          for (var idx = 0; idx < layer.arrLayer.length; idx++) {
            var childLayer = layer.arrLayer[idx];

            if (childLayer.uuid == id || childLayer.id == id) {
              return childLayer;
            }
          }
        }
      }

      return undefined;
    }
    /**
     * 根据指定属性获取图层
     *
     * @param {Object|String|Number} key 图层值（如id、name值） 或  配置的图层参数对象
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseLayer} 图层对象
     */

  }, {
    key: "getLayer",
    value: function getLayer(key, attrName) {
      if (Util["isObject"](key)) {
        key = key.id;
        attrName = "id";
      } else {
        if (!external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](attrName)) {
          attrName = "name";
        }
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._layerCache[key])) {
        return this._layerCache[key];
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgLayersObj[key])) {
        return this._cfgLayersObj[key]; //config.json已有的配置layers图层
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](this._cfgBasemapsObj[key])) {
        return this._cfgBasemapsObj[key]; //config.json已有的配置basemaps图层
      }

      var layers = this.getLayers({
        basemaps: true,
        //是否取config.json中的basempas
        layers: true //是否取config.json中的layers

      });

      for (var i = 0, len = layers.length; i < len; i++) {
        var layer = layers[i];

        if (layer.options[attrName] == key) {
          return layer;
        }
      }

      return undefined;
    }
    /**
     * 获取所有图层
     *
     * @param {Object} options 参数对象，包括以下：
     * @param {Boolean} [options.basemaps = false] 是否包含basemps中配置的所有图层
     * @param {Boolean} [options.layers = false] 是否包含layers中配置的所有图层
     * @param {Boolean} [options.filter = false] 是否排除layers和baseps的图层
     * @return {BaseLayer[]} 图层数组
     */

  }, {
    key: "getLayers",
    value: function getLayers() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var result = [];

      if (options.basemaps) {
        result = result.concat(this._cfgBasemapsArr);
      }

      if (options.layers) {
        result = result.concat(this._cfgLayersArr);
      }

      Object.keys(this._layerCache).forEach(function (id) {
        if ((options.basemaps || options.filter) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this3._cfgBasemapsObj[id])) {
          return; //config.json已有的配置basemaps图层
        }

        if ((options.layers || options.filter) && external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this3._cfgLayersObj[id])) {
          return; //config.json已有的配置layers图层
        }

        var layer = _this3._layerCache[id];

        if (layer._tudou3d_private) {
          return;
        }

        result.push(layer);
      });
      return result;
    }
    /**
     * 获取所有basemps底图图层
     *
     * @param {Boolean} [removeEmptyGroup=false] 是否移除 空图层组
     * @return {BaseLayer[]} 图层数组
     */

  }, {
    key: "getBasemaps",
    value: function getBasemaps(removeEmptyGroup) {
      if (removeEmptyGroup) {
        var arr = [];

        for (var i = 0; i < this._cfgBasemapsArr.length; i++) {
          var layer = this._cfgBasemapsArr[i];

          if (layer.hasEmptyGroup) {
            continue;
          }

          arr.push(layer);
        }

        return arr;
      } else {
        return this._cfgBasemapsArr;
      }
    }
    /**
     * 获取所有瓦片图层，可以用于卷帘对比
     *
     * @return {BaseLayer[]} 图层数组
     */

  }, {
    key: "getTileLayers",
    value: function getTileLayers() {
      var _this4 = this;

      var result = [];
      result = result.concat(this.getBasemaps(true));

      this._cfgLayersArr.forEach(function (layer) {
        if (layer.isTile && !layer.options.noLayerManage) {
          result.push(layer);
        }
      });

      Object.keys(this._layerCache).forEach(function (id) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this4._cfgBasemapsObj[id])) {
          return; //config.json已有的配置basemaps图层
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](_this4._cfgLayersObj[id])) {
          return; //config.json已有的配置layers图层
        }

        var layer = _this4._layerCache[id];

        if (layer.isTile && !layer.options.noLayerManage) {
          result.push(layer);
        }
      });
      return result;
    } /////////////////control 控件相关///////////////////////////
    //按配置进行初始化相关控件

  }, {
    key: "_initControls",
    value: function _initControls() {
      var _this$options;

      this._controls = {}; //绑定popup

      this._popup = new Popup_Popup();
      this.addControl(this._popup); //绑定tooltip

      this._tooltip = new Tooltip_Tooltip();
      this.addControl(this._tooltip); //绑定右键菜单

      this._contextmenu = new ContextMenu_ContextMenu();
      this.addControl(this._contextmenu); //绑定小tooltip

      this._smallTooltip = new SmallTooltip_SmallTooltip();
      this.addControl(this._smallTooltip); //绑定键盘漫游

      this._keyboardRoam = new KeyboardRoam_KeyboardRoam({
        enabled: false
      });
      this.addControl(this._keyboardRoam); //===================其他普通control==================================

      var control = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.control;

      if (control) {
        if (control.defaultContextMenu) {
          this.bindContextMenu(this.getDefaultContextMenu()); //显示默认菜单
        }

        if (control.location || control.locationBar) {
          this.addControl(new LocationBar_LocationBar(control.location || control.locationBar)); //鼠标提示控件
        }

        if (control.compass) {
          this.addControl(new Compass_Compass(control.compass)); //导航球
        }

        if (control.distanceLegend) {
          this.addControl(new DistanceLegend_DistanceLegend(control.distanceLegend)); //比例尺
        }

        if (control.mouseDownView && Util["isPCBroswer"]()) {
          this.addControl(new MouseDownView_MouseDownView(control.mouseDownView)); //鼠标滚轮缩放美化样式
        }
      }
    }
    /**
     * 添加控件到地图上
     *
     * @param {BaseControl} control 控件对象
     * @param {Boolean} enabledVal 如果传值，覆盖控件的enabled属性
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addControl",
    value: function addControl(control, enabledVal) {
      if (control && control._onAdd) {
        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](enabledVal)) {
          control.enabled = enabledVal;
        }

        control._onAdd(this);

        this._controlCache[control.id] = control;
      }

      return this;
    }
    /**
     * 移除控件
     *
     * @param {BaseControl} control 需要移除的控件
     * @param {boolean} hasDestory 是否释放
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeControl",
    value: function removeControl(control, hasDestory) {
      if (!control) {
        return this;
      }

      delete this._controlCache[control.id];

      control._onRemove();

      if (hasDestory) {
        control.destroy();
      }

      return this;
    }
    /**
     * 是否有指定的控件存在（就是已经addControl的控件）
     *
     * @param {BaseLayer|String} control 指定的控件或控件ID
     * @return {Boolean} 是否存在
     */

  }, {
    key: "hasControl",
    value: function hasControl(control) {
      return control && this._controlCache[control.id || control];
    }
    /**
     * 遍历每一个控件并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachControl",
    value: function eachControl(method, context) {
      var _this5 = this;

      Object.keys(this._controlCache).forEach(function (id, index) {
        var control = _this5._controlCache[id];
        method.call(context, control, index);
      });
      return this;
    }
    /**
     * 根据指定属性获取控件
     *
     * @param {Object|String|Number} key 属性值（如id、name值）
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseControl} 控件对象
     */

  }, {
    key: "getControl",
    value: function getControl(key) {
      var attrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id";

      if (Util["isObject"](key)) {
        key = key.id;
        attrName = "id";
      }

      if (this._controlCache[key]) {
        return this._controlCache[key];
      }

      for (var i in this._controlCache) {
        var control = this._controlCache[i];

        if (control[attrName] == key) {
          return control;
        }
      }

      return undefined;
    } /////////////////其他的添加移除钩子方法///////////////////////////

    /**
     * 添加特效对象到地图上
     *
     * @param {BaseEffect} item 特效对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addEffect",
    value: function addEffect(item) {
      this.addThing(item);
    }
    /**
     * 移除特效对象
     *
     * @param {BaseEffect} item 需要移除的特效对象
     * @param {boolean} hasDestory 是否释放
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeEffect",
    value: function removeEffect(item, hasDestory) {
      this.removeThing(item, hasDestory);
    }
    /**
     * 根据指定属性获取Thing对象
     *
     * @param {String|*} key 属性值（如id、name值）
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseEffect} Thing对象
     */

  }, {
    key: "getEffect",
    value: function getEffect(key) {
      var attrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id";
      return this.getThing(key, attrName);
    }
    /**
     * 添加Thing对象到地图上
     *
     * @param {BaseThing} item Thing对象
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "addThing",
    value: function addThing(item) {
      if (item && item._onAdd) {
        item._onAdd(this);

        this._thingCache[item.id] = item;
      }

      return this;
    }
    /**
     * 移除Thing对象
     *
     * @param {BaseThing} item 需要移除的Thing对象
     * @param {boolean} hasDestory 是否释放
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "removeThing",
    value: function removeThing(item, hasDestory) {
      if (!item) {
        return this;
      }

      delete this._thingCache[item.id];

      if (hasDestory && item.clear) {
        item.clear();
      }

      item._onRemove();

      if (hasDestory) {
        item.destroy();
      }

      return this;
    }
    /**
     * 是否有指定的Thing对象存在（就是已经addThing的图层）
     *
     * @param {BaseThing|String} thing 指定的Thing对象或Thing对象ID
     * @return {Boolean} 是否存在
     */

  }, {
    key: "hasThing",
    value: function hasThing(thing) {
      return thing && this._thingCache[thing.id || thing];
    }
    /**
     * 遍历每一个Thing对象并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} context  侦听器的上下文(this关键字将指向的对象)。
     * @return {this} 当前对象本身,可以链式调用
     */

  }, {
    key: "eachThing",
    value: function eachThing(method, context) {
      var _this6 = this;

      Object.keys(this._thingCache).forEach(function (id, index) {
        var thing = _this6._thingCache[id];
        method.call(context, thing, index);
      });
      return this;
    }
    /**
     * 根据指定属性获取Thing对象
     *
     * @param {String|*} key 属性值（如id、name值）
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseThing} Thing对象
     */

  }, {
    key: "getThing",
    value: function getThing(key) {
      var attrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id";

      if (Util["isObject"](key)) {
        key = key.id;
        attrName = "id";
      }

      if (this._thingCache[key]) {
        return this._thingCache[key];
      }

      for (var i in this._thingCache) {
        var control = this._thingCache[i];

        if (control[attrName] == key) {
          return control;
        }
      }

      return undefined;
    }
    /**
     * 根据设置的lang参数，获取当前key对应语言的文本内容。
     * @param {String} key  文本key
     * @return {void}  lang参数指定的对应文本内容
     */

  }, {
    key: "getLangText",
    value: function getLangText(key) {
      return Util["getLangText"](key, this.lang);
    } /////////////////相机及视角 相关///////////////////////////

    /**
     * 放大地图
     * @param {Number} [relativeAmount=2]  相对量
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "zoomIn",
    value: function zoomIn(relativeAmount) {
      this._zoomNavigation.zoomIn(relativeAmount);

      return this;
    }
    /**
     * 缩小地图
     * @param {Number} [relativeAmount=2]  相对量
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "zoomOut",
    value: function zoomOut(relativeAmount) {
      this._zoomNavigation.zoomOut(relativeAmount);

      return this;
    }
    /**
     * 设置鼠标操作习惯方式。
     * 默认为中键旋转，右键拉伸远近。传`rightTilt:true`可以设置为右键旋转，中键拉伸远近。
     * @param {Boolean} [rightTilt=false]  是否右键旋转
     * @return {void}  无
     */

  }, {
    key: "changeMouseModel",
    value: function changeMouseModel(rightTilt) {
      this._hasRightTilt = rightTilt;

      if (rightTilt) {
        //旋转【右键】
        this._viewer.scene.screenSpaceCameraController.tiltEventTypes = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].RIGHT_DRAG, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].PINCH, {
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].LEFT_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }, {
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].RIGHT_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }]; //放大缩小【中键】

        this._viewer.scene.screenSpaceCameraController.zoomEventTypes = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].MIDDLE_DRAG, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].WHEEL, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].PINCH];
      } else {
        //旋转【中键】
        this._viewer.scene.screenSpaceCameraController.tiltEventTypes = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].MIDDLE_DRAG, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].PINCH, {
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].LEFT_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }, {
          eventType: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].RIGHT_DRAG,
          modifier: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["KeyboardEventModifier"].CTRL
        }]; //放大缩小【右键】

        this._viewer.scene.screenSpaceCameraController.zoomEventTypes = [external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].RIGHT_DRAG, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].WHEEL, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["CameraEventType"].PINCH];
      }

      if (this.controls.mouseDownView) {
        this.controls.mouseDownView.changeMouseModel();
      }
    }
    /**
     * 设置鼠标操作限定的Pitch范围
     * @param {Number} max  最大值（角度值）
     * @param {Number} [min=-90]  最小值（角度值）
     * @return {void}  无
     */

  }, {
    key: "setPitchRange",
    value: function setPitchRange(max) {
      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -90;
      this.clearPitchRange();
      this._pitch_max = max;
      this._pitch_min = min;

      if (this._hasRightTilt) {
        this.on(EventType.rightDown, this._setPitchRange_rightDownHandler, this);
        this.on(EventType.rightUp, this._setPitchRange_rightUpHandler, this);
      } else {
        this.on(EventType.middleDown, this._setPitchRange_rightDownHandler, this);
        this.on(EventType.middleUp, this._setPitchRange_rightUpHandler, this);
      }
    }
  }, {
    key: "_setPitchRange_rightDownHandler",
    value: function _setPitchRange_rightDownHandler(evnet) {
      this.on(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
    }
  }, {
    key: "_setPitchRange_rightUpHandler",
    value: function _setPitchRange_rightUpHandler(evnet) {
      this._viewer.scene.screenSpaceCameraController.enableTilt = true;
      this.off(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
    }
  }, {
    key: "_setPitchRange_mouseMoveHandler",
    value: function _setPitchRange_mouseMoveHandler(evnet) {
      var enableTilt = true;
      var isUp = evnet.endPosition.y < evnet.startPosition.y;

      if (isUp && this._viewer.camera.pitch > external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._pitch_max)) {
        enableTilt = false;
      } else if (!isUp && this._viewer.camera.pitch < external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(this._pitch_min)) {
        enableTilt = false;
      } else {
        enableTilt = true;
      }

      this._viewer.scene.screenSpaceCameraController.enableTilt = enableTilt;
    }
    /**
     * 设置相机pitch值，保持地图中心位置不变。
     * @param {Number} pitch 俯仰角度值， 0至360
     * @param {Object} [options] 具有以下属性的对象:
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @return {void}  无
     *
     */

  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var center = this.getCenter();
      var distance = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].distance(center.toCartesian(), this._viewer.camera.positionWC);
      this.flyToPoint(center, Map_objectSpread(Map_objectSpread({}, options), {}, {
        radius: distance,
        pitch: pitch
      }));
    }
    /**
     * 清除鼠标操作限定的Pitch范围
     * @return {void}  无
     */

  }, {
    key: "clearPitchRange",
    value: function clearPitchRange() {
      delete this._pitch_max;
      delete this._pitch_min;

      if (this._hasRightTilt) {
        this.off(EventType.rightDown, this._setPitchRange_rightDownHandler, this);
        this.off(EventType.rightUp, this._setPitchRange_rightUpHandler, this);
      } else {
        this.off(EventType.middleDown, this._setPitchRange_rightDownHandler, this);
        this.off(EventType.middleUp, this._setPitchRange_rightUpHandler, this);
      }

      this.off(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
    }
    /**
     * 停止视角定位等操作
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "cancelFlight",
    value: function cancelFlight() {
      this._isCenterAtArr = false;

      this._viewer.camera.cancelFlight(); //取消飞行


      return this;
    }
    /**
     * 获取当前相机视角参数，
     * 示例：{"lat":30.526361,"lng":116.335987,"alt":45187,"heading":0,"pitch":-45}
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.simplify=true] 是否简化，false时保留角度1位小数位
     * @return {Object} 当前相机视角参数
     */

  }, {
    key: "getCameraView",
    value: function getCameraView(options) {
      return MapUtil["b" /* getCameraView */](this.camera, options);
    }
    /**
     * 将相机本身定位至指定位置
     *
     * @param {Object} cameraView 飞行参数
     * @param {Number} cameraView.lng 经度值, 180 - 180
     * @param {Number} cameraView.lat 纬度值, -90 - 90
     * @param {Number} cameraView.alt 高度值
     * @param {Number} cameraView.heading 方向角度值，绕垂直于地心的轴旋转角度, 0-360
     * @param {Number} cameraView.pitch 俯仰角度值，绕纬度线旋转角度, 0-360
     * @param {Number} cameraView.roll 翻滚角度值，绕经度线旋转角度, 0-360
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     *
     * @exception {Cesium.DeveloperError} 如果给出了任何一个direction或up，那么这两个方向都是必需的。
     */

  }, {
    key: "setCameraView",
    value: function setCameraView(cameraView) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (cameraView == null) {
        return;
      }

      if (Util["isNumber"](options)) {
        //可以只传一个数字，代表duration时间
        options = {
          duration: options
        };
      }

      var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.minHeight, 2500);

      if (this._viewer.camera.positionCartographic.height < height) {
        height = this._viewer.camera.positionCartographic.height;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](cameraView.z)) {
        height = cameraView.z; //兼容旧z命名
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](cameraView.alt)) {
        height = cameraView.alt;
      }

      var flyToOptions = Map_objectSpread(Map_objectSpread({}, options), {}, {
        destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(cameraView.x || cameraView.lng, cameraView.y || cameraView.lat, height),
        //经度、纬度、高度
        orientation: {
          heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](cameraView.heading, 0)),
          //绕垂直于地心的轴旋转
          pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](cameraView.pitch, -90)),
          //绕纬度线旋转
          roll: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](cameraView.roll, 0)) //绕经度线旋转

        }
      });

      if (options.duration === 0) {
        this._viewer.camera.setView(flyToOptions);
      } else {
        this._viewer.camera.flyTo(flyToOptions);
      }
    }
    /**
     * 将相机本身定位至指定位置，同 setCameraView 方法
     * 为了兼容老版本用户习惯和center参数名称一致而用的别名方法。
     * @param {Object} cameraView 飞行参数，同 setCameraView 方法
     * @param {Object} [options={}] 参数对象，同 setCameraView 方法
     * @return {void}  无
     */

  }, {
    key: "centerAt",
    value: function centerAt(cameraView, options) {
      this.setCameraView(cameraView, options);
    }
    /**
     * 飞行到默认视角，
     * 一般为config.json中的center参数配置的视角。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration=null] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyHome",
    value: function flyHome(options) {
      var _this$options2, _this$options2$scene, _this$options3, _this$options3$scene;

      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && (_this$options2$scene = _this$options2.scene) !== null && _this$options2$scene !== void 0 && _this$options2$scene.center) {
        this.setCameraView(this.options.scene.center, options);
      } else if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && (_this$options3$scene = _this$options3.scene) !== null && _this$options3$scene !== void 0 && _this$options3$scene.extent) {
        this.flyToExtent(this.options.scene.extent, options);
      }
    }
    /**
     *  定位到多个相机视角位置，按数组顺序播放
     *
     * @param {Object[]} arr 视角参数数组，每个对象包含：
     * @param {Number} arr.lng 经度值, -180 至 180
     * @param {Number} arr.lat 纬度值, -90 至 90
     * @param {Number} arr.alt 高度值
     * @param {Number} arr.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} arr.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} arr.roll 翻滚角度值，绕经度线旋转角度, 0至360
     * @param {Number} [arr.duration=null] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Number} [arr.stop=1] 该步骤飞行结束的停留时间（单位：秒）。
     * @param {Function} [arr.onStart] 该步骤飞行开始前的回调方法
     * @param {Function} [arr.onEnd] 该步骤飞行开始结束后的回调方法
     *
     * @param {Function} enfun 执行完成的回调方法
     * @return {void}  无
     *
     */

  }, {
    key: "setCameraViewList",
    value: function setCameraViewList(arr, enfun) {
      this.cancelFlight();
      this.arrCenterTemp = arr;
      this._isCenterAtArr = true;

      this._setCameraViewListItem(0, enfun);
    }
  }, {
    key: "_setCameraViewListItem",
    value: function _setCameraViewListItem(i, enfun) {
      var that = this;

      if (!this._isCenterAtArr || i < 0 || i >= this.arrCenterTemp.length) {
        this._isCenterAtArr = false;

        if (enfun) {
          enfun();
        }

        return;
      }

      var cameraView = this.arrCenterTemp[i];

      if (cameraView.onStart) {
        cameraView.onStart();
      }

      this.setCameraView(cameraView, {
        easingFunction: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EasingFunction"].LINEAR_NONE,
        duration: cameraView.duration,
        complete: function complete() {
          if (cameraView.onEnd) {
            cameraView.onEnd();
          }

          var stopTime = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](cameraView.stop, 1);
          setTimeout(function () {
            that._setCameraViewListItem(++i, enfun);
          }, stopTime * 1000);
        },
        cancle: function cancle() {
          this._isCenterAtArr = false;

          if (enfun) {
            enfun();
          }
        }
      });
    }
    /**
     * 飞行至Cesium相关矢量对象处，是Cesium本身的flyTo方法。
     *
     * 将相机移至提供的一个或多个实体或数据源。如果数据源仍在加载过程中，或者可视化仍在加载中，此方法在执行飞行之前等待数据准备就绪。
     * 偏移量是在以边界球中心为中心的局部东北向上参考框中的航向/俯仰/范围。航向角和俯仰角是在局部的东西向北参考系中定义的。航向是从y轴到x轴的角度。间距是从xy平面开始的旋转。正螺距角度在平面上方。负俯仰角在平面下方。范围是到中心的距离。如果范围是零，则将计算范围以使整个边界球都可见。
     *
     * 在2D模式下，必须有一个俯视图。摄像机将被放置在目标上方并向下看。上方的高度目标将是范围。航向将根据偏移量确定。如果标题不能根据偏移量确定，航向将为北。
     *
     * @param {*} target 需要定位的Cesium内部对象。您还可以传递一个： Cesium.Entity|Cesium.Entity[]|Cesium.EntityCollection|Cesium.DataSource|Cesium.ImageryLayer|Cesium.Cesium3DTileset|Cesium.TimeDynamicPointCloud|Promise.<Entity|Entity[]|Cesium.EntityCollection|Cesium.DataSource|Cesium.ImageryLayer|Cesium.Cesium3DTileset|Cesium.TimeDynamicPointCloud>
     * @param {Object} [options] 具有以下属性的对象:
     * @param {Number} [options.duration=3.0] 飞行持续时间（秒）。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {HeadingPitchRange} [options.offset] 在局部东北朝上的参考框中，距目标的偏移量为中心。
     * @returns {Promise.<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise。 //TODO:清理实体提及
     */

  }, {
    key: "flyTo",
    value: function flyTo(target, options) {
      if (!target) {
        return;
      }

      return this._viewer.flyTo(target, options);
    }
    /**
     * 飞行定位到 Graphic矢量对象 处
     *
     * @param {BaseGraphic} graphic 矢量对象
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} options.radius 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.8] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToGraphic",
    value: function flyToGraphic(graphic) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!graphic || graphic.length == 0) {
        return;
      }

      if (graphic.flyTo) {
        var _graphic$style;

        options.clampToGround = (_graphic$style = graphic.style) === null || _graphic$style === void 0 ? void 0 : _graphic$style.clampToGround;
        graphic.flyTo(options);
        return;
      } //单个对象时


      if (!Array.isArray(graphic)) {
        graphic = [graphic];
      }

      if (graphic.length == 1 && graphic[0].flyTo) {
        graphic[0].flyTo(options);
      } else {
        var positions = [];

        for (var i = 0, len = graphic.length; i < len; i++) {
          var pts = graphic[i].positions;

          if (pts && Array.isArray(pts)) {
            positions = positions.concat(pts);
          } else if (graphic[i].positionsShow && Array.isArray(graphic[i].positionsShow)) {
            positions = positions.concat(graphic[i].positionsShow);
          }
        }

        this.flyToPositions(positions);
      }
    }
    /**
     * 定位至坐标数组
     *
     * @param {Cesium.Cartesian3[]} positions 坐标数组
     * @param {Object} [options={}] 参数对象:
     *
     * @param {Number} options.radius 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.8] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToPositions",
    value: function flyToPositions(positions) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!positions || positions.length == 0) {
        return;
      }

      if (positions.length == 1) {
        this.flyToPoint(positions[0], options);
        return;
      }

      var extent = getRectangle(positions, true);

      if (!extent) {
        return;
      }

      if (extent.xmin == extent.xmax || extent.ymin == extent.ymax || extent.xmax - extent.xmin > 200) {
        //是重合的多个点 或跨越了180度线时
        this.flyToPoint([extent.xmin, extent.ymin, extent.height], options);
      } else {
        //是矩形区域时
        extent.height = Object(PointUtil["getMaxHeight"])(positions);
        options.scale = options.scale || 1.8;
        this.flyToExtent(extent, options);
      }
    }
    /**
     * 相机飞行定位至矩形区域
     *
     * @param {Object|Cesium.Rectangle} extent 飞行参数, Object时可以传入：
     * @param {Number} extent.xmin 最小经度值, -180 至 180
     * @param {Number} extent.xmax 最大纬度值, -180 至 180
     * @param {Number} extent.ymin 最小纬度值, -90 至 90
     * @param {Number} extent.ymax 最大纬度值, -90 至 90
     * @param {Number} [extent.height=0] 矩形高度值
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.scale] 缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToExtent",
    value: function flyToExtent(extent) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (extent instanceof external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"]) {
        extent = formatRectangle(extent);
      }

      var xmin = extent.xmin;
      var xmax = extent.xmax;
      var ymin = extent.ymin;
      var ymax = extent.ymax;
      var centerx = (xmin + xmax) / 2;
      var centery = (ymin + ymax) / 2;
      var height = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](extent.height, options.height) || 0;

      if (height == 0) {
        height = Object(PointUtil["getSurfaceHeight"])(this._viewer.scene, external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(centerx, centery));
      } //求矩形最大边的边长


      var recta = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Rectangle"].fromDegrees(xmin, ymin, xmax, ymax);
      var granularity = Math.max(recta.height, recta.width);

      if (granularity > 0) {
        options.radius = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.radius, 0) + external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].chordLength(granularity, this._viewer.scene.globe.ellipsoid.maximumRadius);
      }

      this.flyToPoint(new LatLngPoint["a" /* LatLngPoint */](centerx, centery, height), options);
    }
    /**
     * 定位至目标点(非相机位置)
     *
     * @param {LatLngPoint|Cesium.Cartesian3} point 目标点位置（视角中心点）
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} options.radius 相机距离目标点的距离（单位：米）
     * @param {Number} options.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} options.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} options.roll 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Boolean} [options.clampToGround] 是否贴地对象,true时异步计算实际高度值后进行定位。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */

  }, {
    key: "flyToPoint",
    value: function flyToPoint(point) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!point) {
        return;
      }

      point = LatLngPoint["a" /* LatLngPoint */].parse(point);
      var position = point.toCartesian();

      if (options.clampToGround) {
        //求贴地高度
        Object(PointUtil["getSurfaceHeight"])(this._viewer.scene, position, {
          asyn: true,
          has3dtiles: true,
          callback: function callback(newHeight, cartOld) {
            point.alt = newHeight;
            delete options.clampToGround;

            _this7.flyToPoint(point, options);
          }
        });
        return;
      }

      var range = options.radius;

      if (!range) {
        range = point.height || 100;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.scale) && options.scale > 0) {
        range *= options.scale;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.minHeight) && range < options.minHeight) {
        range = options.minHeight;
      }

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.maxHeight) && range > options.maxHeight) {
        range = options.maxHeight;
      }

      var pitch;

      if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.pitch)) {
        pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(options.pitch);
      } else {
        pitch = this._viewer.camera.pitch;
        var pitchoDegrees = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toDegrees(pitch);

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.minPitch) && pitchoDegrees < options.minPitch) {
          pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(options.minPitch);
        }

        if (external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.maxPitch) && pitchoDegrees > options.maxPitch) {
          pitch = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(options.maxPitch);
        }
      }

      var flyToOptions = Map_objectSpread(Map_objectSpread({}, options), {}, {
        offset: {
          heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defined"](options.heading) ? external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(options.heading) : this._viewer.camera.heading,
          pitch: pitch,
          range: range
        }
      });

      this._viewer.camera.flyToBoundingSphere(new external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["BoundingSphere"](position, 0), flyToOptions);
    }
    /**
     *是否在调用了openFlyAnimation正在进行开场动画
     * @return {Boolean} 是否在开场动画
     */

  }, {
    key: "isFlyAnimation",
    value: function isFlyAnimation() {
      return this._isFlyAnimation;
    }
    /**
     * 执行开场动画，动画播放地球飞行定位到指定区域
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Object} [options.center=getCameraView()] 飞行到的指定区域视角参数
     * @param {Function} [options.callback=null] 飞行结束的回调方法
     * @return {void}  无
     */

  }, {
    key: "openFlyAnimation",
    value: function openFlyAnimation() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var viewer = this._viewer;
      var view = options.center || this.getCameraView(); //默认为原始视角

      this._isFlyAnimation = true;
      viewer.camera.setView({
        destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(-85.16, 13.71, 23000000.0)
      });
      viewer.camera.flyTo({
        destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(view.lng, view.lat, 23000000.0),
        duration: options.duration1 || 2,
        easingFunction: options.easingFunction1 || external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EasingFunction"].LINEAR_NONE,
        complete: function complete() {
          var z = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](view.alt, 90000);

          if (z < 200000 && view.pitch != -90) {
            z = z * 1.2 + 8000;
            viewer.camera.flyTo({
              destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(view.lng, view.lat, z),
              duration: options.duration2,
              easingFunction: options.easingFunction2,
              complete: function complete() {
                _this8.setCameraView(view, {
                  duration: options.duration3 || 2,
                  easingFunction: options.easingFunction3,
                  complete: function complete() {
                    _this8._isFlyAnimation = false;

                    if (options.callback) {
                      options.callback(true);
                    }

                    if (_this8.openFlyAnimationEndFun) {
                      _this8.openFlyAnimationEndFun();

                      delete _this8.openFlyAnimationEndFun;
                    }
                  },
                  cancel: function cancel() {
                    _this8._isFlyAnimation = false;

                    if (options.callback) {
                      options.callback(false);
                    }
                  }
                });
              },
              cancel: function cancel() {
                _this8._isFlyAnimation = false;

                if (options.callback) {
                  options.callback(false);
                }
              }
            });
          } else {
            _this8.setCameraView(view, {
              duration: options.duration3 || 2,
              easingFunction: options.easingFunction3,
              complete: function complete() {
                _this8._isFlyAnimation = false;

                if (options.callback) {
                  options.callback(true);
                }

                if (_this8.openFlyAnimationEndFun) {
                  _this8.openFlyAnimationEndFun();

                  delete _this8.openFlyAnimationEndFun;
                }
              },
              cancel: function cancel() {
                _this8._isFlyAnimation = false;

                if (options.callback) {
                  options.callback(false);
                }
              }
            });
          }
        },
        cancel: function cancel() {
          _this8._isFlyAnimation = false;

          if (options.callback) {
            options.callback(false);
          }
        }
      });
    }
    /**
     * 执行旋转地球动画
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration=10] 动画时长（单位：秒）
     * @param {Object} [options.center=getCameraView()] 飞行到的指定区域视角参数
     * @param {Function} [options.callback=null] 飞行结束的回调方法
     * @return {void}  无
     */

  }, {
    key: "rotateAnimation",
    value: function rotateAnimation() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var viewer = this._viewer;
      var first = options.center || this.getCameraView(); //默认为原始视角

      var duration3 = external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["defaultValue"](options.duration, 10) / 3; //动画 1/3

      viewer.camera.flyTo({
        destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(first.lng + 120, first.lat, first.alt),
        orientation: {
          heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.heading),
          pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.pitch),
          roll: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.roll)
        },
        duration: duration3,
        easingFunction: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EasingFunction"].LINEAR_NONE,
        complete: function complete() {
          //动画 2/3
          viewer.camera.flyTo({
            destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(first.lng + 240, first.lat, first.alt),
            orientation: {
              heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.heading),
              pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.pitch),
              roll: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.roll)
            },
            duration: duration3,
            easingFunction: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EasingFunction"].LINEAR_NONE,
            complete: function complete() {
              //动画 3/3
              viewer.camera.flyTo({
                destination: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Cartesian3"].fromDegrees(first.lng, first.lat, first.alt),
                orientation: {
                  heading: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.heading),
                  pitch: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.pitch),
                  roll: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["Math"].toRadians(first.roll)
                },
                duration: duration3,
                easingFunction: external_commonjs2_tudou3d_cesium_amd_tudou3d_cesium_commonjs_tudou3d_cesium_root_Cesium_["EasingFunction"].LINEAR_NONE,
                complete: function complete() {
                  if (options.callback) {
                    options.callback(true);
                  }
                }
              }); //动画3/3 end
            }
          }); //动画2/3 end
        }
      }); //动画1/3 end
    } //============== popup/tooltip/contextMenu ======================

    /**
     * 打开Popup弹窗
     *
     * @param {Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @param {String|Function|BaseGraphic|BaseGraphicLayer} content 弹窗内容html字符串，或者 回调方法 或者矢量对象/图层。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Boolean} [options.timeRender=false] 是否实时更新面板，此时需要绑定content回调方法处理。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "openPopup",
    value: function openPopup(position, content, options) {
      clearTimeout(this._popup_timeTik);

      if (content.id && content.popup) {
        this._popup.open(position, content, options);
      } else {
        this._popup.open(position, {
          id: "map",
          popup: content
        }, options);
      }

      return this;
    }
    /**
     * 关闭Popup弹窗
     * @param {Object} [targt=null] 可以只关闭指定对象上的Popup
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closePopup",
    value: function closePopup(targt) {
      var _this9 = this;

      if (!this._popup) {
        return;
      }

      this._popup.close(targt);

      this._popup_timeTik = setTimeout(function () {
        if (_this9._popup) {
          _this9._popup.close(targt);
        }
      }, 10);
      return this;
    }
    /**
     * 打开Tooltip弹窗
     *
     * @param {Cesium.Cartesian3} [position] 矢量对象 或 显示的位置
     * @param {String|Function|BaseGraphic|BaseGraphicLayer} content 弹窗内容html字符串，或者 回调方法 或者矢量对象/图层。
     * @param {Object} options 参数对象，包括以下：
     * @param {Number[]} [options.anchor=[0,0]] 窗口的XY轴偏移的像素位置。
     * @param {Function} [options.onAdd=null] popup的DOM添加到页面的回调方法,特殊需要操作dom的场景下使用（如视频video、echarts等）
     * @param {Function} [options.onRemove=null] popup的DOM从页面移除的回调方法
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "openTooltip",
    value: function openTooltip(position, content, options) {
      clearTimeout(this._tooltip_timeTik);

      if (content.id && content.tooltip) {
        this._tooltip.open(position, content, options);
      } else {
        this._tooltip.open(position, {
          id: "map",
          tooltip: content
        }, options);
      }

      return this;
    }
    /**
     * 关闭Tooltip弹窗
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeTooltip",
    value: function closeTooltip() {
      var _this10 = this;

      if (!this._tooltip) {
        return;
      }

      this._tooltip.close();

      this._tooltip_timeTik = setTimeout(function () {
        if (_this10._tooltip) {
          _this10._tooltip.close();
        }
      }, 10);
      return this;
    }
    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openSmallTooltip",
    value: function openSmallTooltip(position, message) {
      this._smallTooltip.open(position, message);

      return this;
    }
    /**
     * 关闭小提示窗
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeSmallTooltip",
    value: function closeSmallTooltip() {
      if (!this._smallTooltip) {
        return;
      }

      this._smallTooltip.close();

      return this;
    }
    /**
     * 获取绑定的右键菜单数组
     *
     * @return {Object[]} 右键菜单数组
     */

  }, {
    key: "getContextMenu",
    value: function getContextMenu() {
      return this.contextmenuItems;
    }
    /**
     * 绑定地图的默认右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
     * @param {String} [content.iconCls] 小图标css
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 参数对象(预留，目前未用)
     * @return {this} 当前对象本身，可以链式调用
     *
     * @example
     *
      //内置的默认右键菜单获取方法
      var defaultContextmenuItems =map.getDefaultContextMenu()
      map.bindContextMenu(defaultContextmenuItems)
     */

  }, {
    key: "bindContextMenu",
    value: function bindContextMenu(content, options) {
      this.contextmenuItems = content;
      return this;
    }
    /**
     * 解除绑定的右键菜单
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "unbindContextMenu",
    value: function unbindContextMenu() {
      this.contextmenuItems = null;
      return this;
    }
    /**
     * 打开右键菜单
     *
     * @param {Cesium.Cartesian3} [position] 矢量对象 或 显示的位置
     * @param {Object[]|BaseGraphic|BaseGraphicLayer} [content=getContextMenu()] 右键菜单配置数组 或 矢量数据/图层
     * @param {Object} [options={}] 可以覆盖bindContextMenu绑定的参数，具体参考bindContextMenu方法参数说明
     * @return {this} 当前对象本身，可以链式调用
     *
     */

  }, {
    key: "openContextMenu",
    value: function openContextMenu(position, content) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      clearTimeout(this._contextmenu_timeTik);

      if (content) {
        if (content.contextmenuItems) {
          this._contextmenu.open(position, content, options);
        } else {
          this._contextmenu.open(position, {
            contextmenuItems: content
          }, options);
        }
      } else {
        this._contextmenu.open(position, this, options);
      }

      return this;
    }
    /**
     *  关闭右键菜单
     *
     * @return {this} 当前对象本身，可以链式调用
     */

  }, {
    key: "closeContextMenu",
    value: function closeContextMenu() {
      var _this11 = this;

      if (!this._contextmenu) {
        return;
      }

      this._contextmenu.close();

      this._contextmenu_timeTik = setTimeout(function () {
        if (_this11._contextmenu) {
          _this11._contextmenu.close();
        }
      }, 10);
      return this;
    } //============== destroy ======================

    /**
     * 销毁地图
     * @return {void}  无
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this12 = this;

      Object.keys(this._layerCache).forEach(function (id) {
        var layer = _this12._layerCache[id];
        layer.destroy();
      });
      Object.keys(this._controlCache).forEach(function (id) {
        var control = _this12._controlCache[id];
        control.destroy();
      });
      Object.keys(this._thingCache).forEach(function (id) {
        var item = _this12._thingCache[id];
        item.destroy();
      });

      this._mouseEvent.destroy();

      this._viewer.destroy(); //删除所有绑定的数据


      for (var i in this) {
        delete this[i];
      }
    }
  }]);

  return Map;
}(BaseClass_BaseClass);
/**
 * @typedef {Object} Map.sceneOptions
 * 场景参数
 *
 * @property {Object} center 默认相机视角
 * @property {Number} center.lng 经度值, 180 - 180
 * @property {Number} center.lat 纬度值, -90 - 90
 * @property {Number} center.alt 高度值
 * @property {Number} center.heading 方向角度值，绕垂直于地心的轴旋转角度, 0-360
 * @property {Number} center.pitch 俯仰角度值，绕纬度线旋转角度, 0-360
 * @property {Number} center.roll 翻滚角度值，绕经度线旋转角度, 0-360
 *
 * @property { Boolean} [removeDblClick=false] 是否移除Cesium默认的双击事件
 * @property {String} [ionToken=null] Cesium Ion服务的 Token令牌
 * @property {Number} [resolutionScale=1.0] 获取或设置渲染分辨率的缩放比例。小于1.0的值可以改善性能不佳的设备上的性能，而值大于1.0则将以更高的速度呈现分辨率，然后缩小比例，从而提高视觉保真度。例如，如果窗口小部件的尺寸为640x480，则将此值设置为0.5将导致场景以320x240渲染，然后在设置时按比例放大设置为2.0将导致场景以1280x960渲染，然后按比例缩小。
 *
 * 以下是Cesium.Scene对象相关参数
 * @property {Boolean} showSun 是否显示太阳
 * @property {Boolean} showMoon 是否显示月亮
 * @property {Boolean} showSkyBox 是否显示天空盒
 * @property {Boolean} showSkyAtmosphere 是否显示地球大气层外光圈
 * @property {Boolean} fog 是否启用雾化效果
 * @property {Boolean} fxaa  是否开启快速抗锯齿
 * @property {Boolean} highDynamicRange 是否关闭高动态范围渲染(不关闭时地图会变暗)
 * @property {String} backgroundColor 空间背景色 ，css颜色值
 *
 * 以下是Cesium.Viewer所支持的options【控件相关的写在另外的control属性中】
 * @property {Cesium.SceneMode} [sceneMode=Cesium.SceneMode.SCENE3D] 初始场景模式。
 * @property {Boolean} [scene3DOnly=false] 为 true 时，每个几何实例将仅以3D渲染以节省GPU内存。
 * @property {Boolean} [shouldAnimate=true] 是否开启时钟动画
 * @property {Boolean} [shadows=false] 是否启用日照阴影
 * @property {Boolean} [useDefaultRenderLoop=true] 如果此小部件应控制渲染循环，则为true，否则为false。
 * @property {Number} [targetFrameRate] 	使用默认渲染循环时的目标帧速率。
 * @property {Boolean} [useBrowserRecommendedResolution=true] 如果为true，则以浏览器建议的分辨率渲染，并忽略 window.devicePixelRatio 。
 * @property {Boolean} [automaticallyTrackDataSourceClocks=true] 如果为true，则此小部件将自动跟踪新添加的数据源的时钟设置，并在数据源的时钟发生更改时进行更新。如果要独立配置时钟，请将其设置为false。
 * @property {Object} [contextOptions] WebGL创建属性 传递给 Cesium.Scene 的 options 。{@link Cesium.Scene}.
 * @property {Boolean} [orderIndependentTranslucency=true] 如果为true，并且配置支持它，则使用顺序无关的半透明性。
 * @property {Cesium.ShadowMode} [terrainShadows=Cesium.ShadowMode.RECEIVE_ONLY] 确定地形是否投射或接收来自光源的阴影。
 * @property {Cesium.MapMode2D} [mapMode2D=Cesium.MapMode2D.INFINITE_SCROLL] 确定2D地图是可旋转的还是可以在水平方向无限滚动。
 * @property {Boolean} [requestRenderMode=false] 如果为真，渲染帧只会在需要时发生，这是由场景中的变化决定的。启用可以减少你的应用程序的CPU/GPU使用量，并且在移动设备上使用更少的电池，但是需要使用 {@link Scene#requestRender} 在这种模式下显式地渲染一个新帧。在许多情况下，在API的其他部分更改场景后，这是必要的。参见 {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 * @property {Number} [maximumRenderTimeChange=0.0] 如果requestRenderMode为true，这个值定义了在请求渲染之前允许的模拟时间的最大变化。参见 {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 *
 * 以下是Cesium.Globe对象相关参数
 * @property {Object} globe globe地球相关参数
 * @property {Boolean} [globe.show=true] 是否显示地球
 * @property {String} [globe.baseColor='#546a53'] 地球背景色 ，css颜色值
 * @property {Boolean} [globe.depthTestAgainstTerrain=false] 是否启用深度监测,可以开启来测试矢量对象是否在地形下面或被遮挡。
 * @property {Boolean} [globe.showGroundAtmosphere=true] 是否在地球上绘制的地面大气
 * @property {Boolean} [globe.enableLighting=false] 是否显示昼夜区域
 * @property {Number} [globe.tileCacheSize=100] 地形图块缓存的大小，表示为图块数。任何其他只要不需要渲染，就会释放超出此数目的图块这个框架。较大的数字将消耗更多的内存，但显示细节更快例如，当缩小然后再放大时。
 *  //赵西洋 cesium1.85后取消terrainExaggeration变量
   @property {Number} [globe.terrainExaggeration=1.0]  地形夸张倍率，用于放大地形的标量。请注意，地形夸张不会修改其他相对于椭球的图元。
 * @property {Number} [globe.terrainExaggerationRelativeHeight = 0.0]  地形被夸大的高度。默认为0.0（相对于椭球表面缩放）。高于此高度的地形将向上缩放，低于此高度的地形将向下缩放。请注意，地形夸大不会修改任何其他图元，因为它们是相对于椭球体定位的。
 *
 * 以下是Cesium.ScreenSpaceCameraController对象相关参数
 * @property {Object} cameraController 相机操作相关参数
 * @property {Number} [cameraController.zoomFactor=3.0] 鼠标滚轮放大的步长参数
 * @property {Boolean} [cameraController.constrainedAxis=true] 为false时 解除在南北极区域鼠标操作限制
 * @property {Number} [cameraController.minimumZoomDistance=1.0] 变焦时相机位置的最小量级（以米为单位），默认为1。该值是相机与地表(含地形)的相对距离。
 * @property {Number} [cameraController.maximumZoomDistance=50000000.0] 变焦时相机位置的最大值（以米为单位）。该值是相机与地表(含地形)的相对距离。
 * @property {Number} [cameraController.minimumCollisionTerrainHeight=80000] 低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
 * @property {Boolean} [cameraController.enableRotate=true] 2D和3D视图下，是否允许用户旋转相机
 * @property {Boolean} [cameraController.enableTranslate=true] 2D和哥伦布视图下，是否允许用户平移地图
 * @property {Boolean} [cameraController.enableTilt=true] 3D和哥伦布视图下，是否允许用户倾斜相机
 * @property {Boolean} [cameraController.enableZoom=true] 是否允许 用户放大和缩小视图
 * @property {Boolean} [cameraController.enableCollisionDetection=true] 是否允许 地形相机的碰撞检测
 *
 * 以下是Cesium.Clock时钟相关参数
 * @property {Object} clock 时钟相关参数
 * @property {String|Cesium.JulianDate} [clock.currentTime=null] 当前的时间
 * @property {Number} [clock.multiplier=1.0] 当前的速度
 *
 */

/**
 * @typedef {Object} Map.controlOptions
 * 控件参数
 *
 * 以下是tudou3d.control定义的控件
 * @property {Boolean} [defaultContextMenu=true] 是否绑定默认的地图右键菜单
 * @property {Boolean} [mouseDownView=false] 鼠标滚轮缩放美化样式   {@link MouseDownView}
 * @property {Object} [locationBar] 鼠标提示控件,    {@link LocationBar}
 * @property {Boolean} [locationBar.fps] 是否显示实时FPS帧率
 * @property {String|Function} [locationBar.format] 显示内容的格式化html展示的内容格式化字符串。  支持以下模版配置：【鼠标所在位置】 经度:{lng}， 纬度:{lat}， 海拔：{alt}米， 【相机的】 方向角度：{heading}， 俯仰角度：{pitch}， 视高：{cameraHeight}米， 【地图的】 层级：{level}，
 * @property {Object} [compass] 导航球控件   {@link Compass}
 * @property {Object} [distanceLegend] 比例尺控件   {@link DistanceLegend}
 *
 * 以下是Cesium.Viewer所支持的控件相关的options
 * @property {Boolean} [infoBox=true]  是否显示 点击要素之后显示的信息
 * @property {Boolean} [selectionIndicator=true] 选择模型时，是否显示绿色框
 * @property {Boolean} [animation=true] 是否创建 左下角仪表动画面板
 * @property {Boolean} [timeline=true] 是否创建 下侧时间线控件面板
 * @property {Boolean} [baseLayerPicker=true] 是否显示 basemaps底图切换按钮
 * @property {Boolean} [fullscreenButton=true] 是否显示 全屏按钮
 * @property {Boolean} [vrButton=false] 是否显示 右下角vr虚拟现实按钮
 * @property {Boolean|GeocoderService[]} [geocoder=true] 是否显示 地名查找控件按钮
 * @property {Boolean} [homeButton=true] 是否显示  视角复位按钮
 * @property {Boolean} [sceneModePicker=true] 是否显示  二三维视图切换按钮
 * @property {Boolean} [projectionPicker=false] 是否显示  用于在透视和正投影之间进行切换按钮
 * @property {Boolean} [navigationHelpButton=true] 是否显示  帮助按钮
 * @property {Boolean} [navigationInstructionsInitiallyVisible=true] 在用户明确单击按钮之前是否自动显示navigationHelpButton
 * @property {Boolean} [showRenderLoopErrors=true] 如果为true，则在发生渲染循环错误时，此小部件将自动向包含错误的用户显示HTML面板。
 *
 */

/**
 * @typedef {Object} Map.terrainOptions
 *
 * 地形服务配置
 *
 * @property {TerrainType} type 地形类型
 * @property {String|Cesium.Resource} url 地形服务地址
 * @property {Boolean} [show=false] 是否启用显示地形
 * @property {Boolean} [requestVertexNormals=false] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
 * @property {Boolean} [requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
 * @property {Boolean} [requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
 *
 */

/**
 * @typedef {Object} Map.basemapOptions
 * 底图图层配置
 *
 * @property {String} type 图层类型
 * @property {BaseTileLayer.ConstructorOptions} [通用参数] 与BaseTileLayer类构造参数相同
 * @property {*} [其他参数]  每种不同type都有自己的不同属性，具体参考{@link LayerType}找到type对应的图层类,查看其构造参数
 */

/**
 * @typedef {Object} Map.layerOptions
 * 可以叠加显示的图层配置
 *
 * @property {String} type 图层类型
 * @property {String|Number} [id ] 图层id标识
 * @property {String|Number} [pid = -1] 图层父级的id，一般图层管理中使用
 * @property {String} [name = '未命名'] 图层名称
 * @property {Boolean} [show = true] 图层是否显示
 * @property {Object} [center=null] 图层自定义定位视角，默认根据数据情况自动定位。
 * @property {Object} [popup=null] 当图层支持popup弹窗时，绑定的值
 * @property {Object} [tooltip=null]  当图层支持tooltip弹窗时，绑定的值
 *
 * @property {*} [其他参数]  每种type都有自己的不同属性，具体参考{@link LayerType}找到type对应的图层类,查看其构造参数
 *
 */

/**
 * @typedef {Object} Map.EventType
 * Map支持的{@link EventType}事件类型
 *
 * @property {String} addLayer 添加图层
 * @property {String} removeLayer 移除图层
 *
 * @property {String} cameraMoveStart 相机开启移动前 场景事件
 * @property {String} cameraMoveEnd 相机移动完成后 场景事件
 * @property {String} cameraChanged 相机位置完成 场景事件
 * @property {String} preUpdate 场景更新前 场景事件
 * @property {String} postUpdate 场景更新后 场景事件
 * @property {String} preRender 场景渲染前 场景事件
 * @property {String} postRender 场景渲染后 场景事件
 * @property {String} morphStart 场景模式(2D/3D/哥伦布)变换前 场景事件
 * @property {String} morphComplete 完成场景模式(2D/3D/哥伦布)变换 场景事件
 * @property {String} clockTick 时钟跳动 场景事件
 *
 * @property {String} click 左键单击 鼠标事件
 * @property {String} clickGraphic 左键单击到矢量或模型数据时 鼠标事件
 * @property {String} clickTileGraphic 左键单击到wms或arcgis瓦片服务的对应矢量数据时
 * @property {String} clickMap 左键单击地图空白（未单击到矢量或模型数据）时 鼠标事件
 * @property {String} dblClick 左键双击 鼠标事件
 * @property {String} leftDown 左键鼠标按下 鼠标事件
 * @property {String} leftUp 左键鼠标按下后释放 鼠标事件
 * @property {String} mouseMove 鼠标移动 鼠标事件
 * @property {String} mouseMoveTarget 鼠标移动（拾取目标，并延迟处理） 鼠标事件
 * @property {String} wheel 鼠标滚轮滚动 鼠标事件
 * @property {String} rightClick 右键单击 鼠标事件
 * @property {String} rightDown 右键鼠标按下 鼠标事件
 * @property {String} rightUp 右键鼠标按下后释放 鼠标事件
 * @property {String} middleClick 中键单击 鼠标事件
 * @property {String} middleDown 中键鼠标按下 鼠标事件
 * @property {String} middleUp 中键鼠标按下后释放 鼠标事件
 * @property {String} pinchStart 在触摸屏上两指缩放开始 鼠标事件
 * @property {String} pinchEnd 在触摸屏上两指缩放结束 鼠标事件
 * @property {String} pinchMove 在触摸屏上两指移动 鼠标事件
 * @property {String} mouseDown 鼠标按下 [左中右3键都触发] 鼠标事件
 * @property {String} mouseUp 鼠标按下后释放 [左中右3键都触发] 鼠标事件
 * @property {String} mouseOver 鼠标移入 鼠标事件
 * @property {String} mouseOut 鼠标移出 鼠标事件
 * @property {String} keydown 按键按下 键盘事件
 * @property {String} keyup 按键按下后释放 键盘事件
 *
 * @example
 * //绑定监听事件
 * map.on(tudou3d.EventType.click, function (event) {
 *   console.log('单击了地图对象', event)
 * })
 * @see BaseClass#on
 * @see BaseClass#off
 */
// CONCATENATED MODULE: ./src/index.js
// index.js, 页面入口文件
// 整个语句都开启严格模式的语法
 //=========== css样式 ==========

 //=========== 框架基本信息 =========


var src_name = "Tudou3D平台";
var author = "土豆数据"; //============= 第3方常用类绑定到tudou3d库下面 =============


 //全部绑定




 //============= 基础类 =============

















 //============= util静态类 =============












































 //============= 二级包  =============


 //material材质


 //矢量对象






 //管理或分析


 //场景特效




 //服务查询
//============= 地图类 =============



/***/ })
/******/ ]);
});