/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.95
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-5744d52e","./Matrix2-73789715","./Color-62754929","./defaultValue-97284df2","./IndexDatatype-65271ba3","./ComponentDatatype-e7fbe225","./OrientedBoundingBox-5ee9ed67","./createTaskProcessorWorker","./RuntimeError-4f8ec8a2","./Transforms-d4da1631","./_commonjsHelpers-3aae1032-65601a27","./combine-d11b1f00","./WebGLConstants-6da700a2","./EllipsoidTangentPlane-9813dd6d","./AxisAlignedBoundingBox-546c299b","./IntersectionTests-a7d8bdc4","./Plane-e916220d"],(function(e,t,n,a,r,o,s,i,c,d,f,l,u,h,g,p,b){"use strict";const m=new t.Cartesian3,y=new t.Ellipsoid,C=new t.Rectangle,I={min:void 0,max:void 0,indexBytesPerElement:void 0};function x(e,t,a){const r=t.length,o=2+r*s.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}(a),i=new Float64Array(o);let c=0;i[c++]=e,i[c++]=r;for(let e=0;e<r;++e)s.OrientedBoundingBox.pack(t[e],i,c),c+=s.OrientedBoundingBox.packedLength;const d=a.length;i[c++]=d;for(let e=0;e<d;++e){const t=a[e];n.Color.pack(t.color,i,c),c+=n.Color.packedLength,i[c++]=t.offset,i[c++]=t.count;const r=t.batchIds,o=r.length;i[c++]=o;for(let e=0;e<o;++e)i[c++]=r[e]}return i}const w=32767,A=new t.Cartesian3,E=new t.Cartesian3,N=new t.Cartesian3,T=new t.Cartesian3,B=new t.Cartesian3,k=new t.Cartographic,L=new t.Rectangle;return i((function(i,c){let d;!function(e){const n=new Float64Array(e);let a=0;I.indexBytesPerElement=n[a++],I.min=n[a++],I.max=n[a++],t.Cartesian3.unpack(n,a,m),a+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,a,y),a+=t.Ellipsoid.packedLength,t.Rectangle.unpack(n,a,C)}(i.packedBuffer),d=2===I.indexBytesPerElement?new Uint16Array(i.indices):new Uint32Array(i.indices);const f=new Uint16Array(i.positions),l=new Uint32Array(i.counts),u=new Uint32Array(i.indexCounts),h=new Uint32Array(i.batchIds),g=new Uint32Array(i.batchTableColors),p=new Array(l.length),b=m,O=y;let U=C;const P=I.min,F=I.max;let S,D,R,_=i.minimumHeights,M=i.maximumHeights;a.defined(_)&&a.defined(M)&&(_=new Float32Array(_),M=new Float32Array(M));const G=f.length/2,V=f.subarray(0,G),Y=f.subarray(G,2*G);e.AttributeCompression.zigZagDeltaDecode(V,Y);const H=new Float64Array(3*G);for(S=0;S<G;++S){const e=V[S],n=Y[S],a=o.CesiumMath.lerp(U.west,U.east,e/w),r=o.CesiumMath.lerp(U.south,U.north,n/w),s=t.Cartographic.fromRadians(a,r,0,k),i=O.cartographicToCartesian(s,A);t.Cartesian3.pack(i,H,3*S)}const v=l.length,W=new Array(v),j=new Array(v);let z=0,Z=0;for(S=0;S<v;++S)W[S]=z,j[S]=Z,z+=l[S],Z+=u[S];const q=new Float32Array(3*G*2),J=new Uint16Array(2*G),K=new Uint32Array(j.length),Q=new Uint32Array(u.length);let X=[];const $={};for(S=0;S<v;++S)R=g[S],a.defined($[R])?($[R].positionLength+=l[S],$[R].indexLength+=u[S],$[R].batchIds.push(S)):$[R]={positionLength:l[S],indexLength:u[S],offset:0,indexOffset:0,batchIds:[S]};let ee,te=0,ne=0;for(R in $)if($.hasOwnProperty(R)){ee=$[R],ee.offset=te,ee.indexOffset=ne;const e=2*ee.positionLength,t=2*ee.indexLength+6*ee.positionLength;te+=e,ne+=t,ee.indexLength=t}const ae=[];for(R in $)$.hasOwnProperty(R)&&(ee=$[R],ae.push({color:n.Color.fromRgba(parseInt(R)),offset:ee.indexOffset,count:ee.indexLength,batchIds:ee.batchIds}));for(S=0;S<v;++S){R=g[S],ee=$[R];const e=ee.offset;let n=3*e,r=e;const o=W[S],i=l[S],c=h[S];let f=P,m=F;a.defined(_)&&a.defined(M)&&(f=_[S],m=M[S]);let y=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY,I=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY;for(D=0;D<i;++D){const e=t.Cartesian3.unpack(H,3*o+3*D,A);O.scaleToGeodeticSurface(e,e);const a=O.cartesianToCartographic(e,k),s=a.latitude,i=a.longitude;y=Math.min(s,y),C=Math.max(s,C),I=Math.min(i,I),x=Math.max(i,x);const d=O.geodeticSurfaceNormal(e,E);let l=t.Cartesian3.multiplyByScalar(d,f,N);const u=t.Cartesian3.add(e,l,T);l=t.Cartesian3.multiplyByScalar(d,m,l);const h=t.Cartesian3.add(e,l,B);t.Cartesian3.subtract(h,b,h),t.Cartesian3.subtract(u,b,u),t.Cartesian3.pack(h,q,n),t.Cartesian3.pack(u,q,n+3),J[r]=c,J[r+1]=c,n+=6,r+=2}U=L,U.west=I,U.east=x,U.south=y,U.north=C,p[S]=s.OrientedBoundingBox.fromRectangle(U,P,F,O);let w=ee.indexOffset;const G=j[S],V=u[S];for(K[S]=w,D=0;D<V;D+=3){const t=d[G+D]-o,n=d[G+D+1]-o,a=d[G+D+2]-o;X[w++]=2*t+e,X[w++]=2*n+e,X[w++]=2*a+e,X[w++]=2*a+1+e,X[w++]=2*n+1+e,X[w++]=2*t+1+e}for(D=0;D<i;++D){const t=D,n=(D+1)%i;X[w++]=2*t+1+e,X[w++]=2*n+e,X[w++]=2*t+e,X[w++]=2*t+1+e,X[w++]=2*n+1+e,X[w++]=2*n+e}ee.offset+=2*i,ee.indexOffset=w,Q[S]=w-K[S]}X=r.IndexDatatype.createTypedArray(q.length/3,X);const re=ae.length;for(let e=0;e<re;++e){const t=ae[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=Q[t[e]];ae[e].count=n}const oe=x(2===X.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,p,ae);return c.push(q.buffer,X.buffer,K.buffer,Q.buffer,J.buffer,oe.buffer),{positions:q.buffer,indices:X.buffer,indexOffsets:K.buffer,indexCounts:Q.buffer,batchIds:J.buffer,packedBuffer:oe.buffer}}))}));
